// Merged from C:\MyDartProjects\agg\agg-sharp\agg\agg_clip_liang_barsky.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Liang-Barsky clipping
//
//----------------------------------------------------------------------------
namespace MatterHackers.Agg
{
	public static class ClipLiangBarsky
	{
		//------------------------------------------------------------------------
		private enum clipping_flags_e
		{
			clipping_flags_x1_clipped = 4,
			clipping_flags_x2_clipped = 1,
			clipping_flags_y1_clipped = 8,
			clipping_flags_y2_clipped = 2,
			clipping_flags_x_clipped = clipping_flags_x1_clipped | clipping_flags_x2_clipped,
			clipping_flags_y_clipped = clipping_flags_y1_clipped | clipping_flags_y2_clipped
		};

		//----------------------------------------------------------clipping_flags
		// Determine the clipping code of the vertex according to the
		// Cyrus-Beck line clipping algorithm
		//
		//        |        |
		//  0110  |  0010  | 0011
		//        |        |
		// -------+--------+-------- clip_box.y2
		//        |        |
		//  0100  |  0000  | 0001
		//        |        |
		// -------+--------+-------- clip_box.y1
		//        |        |
		//  1100  |  1000  | 1001
		//        |        |
		//  clip_box.x1  clip_box.x2
		//
		//
		//template<class T>
		public static int clipping_flags(int x, int y, RectangleInt clip_box)
		{
			return ((x > clip_box.Right) ? 1 : 0)
				| ((y > clip_box.Top) ? 1 << 1 : 0)
				| ((x < clip_box.Left) ? 1 << 2 : 0)
				| ((y < clip_box.Bottom) ? 1 << 3 : 0);
		}

		public static int clipping_flags_x(int x, RectangleInt clip_box)
		{
			return ((x > clip_box.Right ? 1 : 0) | ((x < clip_box.Left ? 1 : 0) << 2));
		}

		public static int clipping_flags_y(int y, RectangleInt clip_box)
		{
			return (((y > clip_box.Top ? 1 : 0) << 1) | ((y < clip_box.Bottom ? 1 : 0) << 3));
		}

		public static int clip_liang_barsky(int x1, int y1, int x2, int y2,
										  RectangleInt clip_box,
										  int[] x, int[] y)
		{
			int XIndex = 0;
			int YIndex = 0;
			double nearzero = 1e-30;

			double deltax = x2 - x1;
			double deltay = y2 - y1;
			double xin;
			double xout;
			double yin;
			double yout;
			double tinx;
			double tiny;
			double toutx;
			double touty;
			double tin1;
			double tin2;
			double tout1;
			int np = 0;

			if (deltax == 0.0)
			{
				// bump off of the vertical
				deltax = (x1 > clip_box.Left) ? -nearzero : nearzero;
			}

			if (deltay == 0.0)
			{
				// bump off of the horizontal
				deltay = (y1 > clip_box.Bottom) ? -nearzero : nearzero;
			}

			if (deltax > 0.0)
			{
				// points to right
				xin = clip_box.Left;
				xout = clip_box.Right;
			}
			else
			{
				xin = clip_box.Right;
				xout = clip_box.Left;
			}

			if (deltay > 0.0)
			{
				// points up
				yin = clip_box.Bottom;
				yout = clip_box.Top;
			}
			else
			{
				yin = clip_box.Top;
				yout = clip_box.Bottom;
			}

			tinx = (xin - x1) / deltax;
			tiny = (yin - y1) / deltay;

			if (tinx < tiny)
			{
				// hits x first
				tin1 = tinx;
				tin2 = tiny;
			}
			else
			{
				// hits y first
				tin1 = tiny;
				tin2 = tinx;
			}

			if (tin1 <= 1.0)
			{
				if (0.0 < tin1)
				{
					x[XIndex++] = (int)xin;
					y[YIndex++] = (int)yin;
					++np;
				}

				if (tin2 <= 1.0)
				{
					toutx = (xout - x1) / deltax;
					touty = (yout - y1) / deltay;

					tout1 = (toutx < touty) ? toutx : touty;

					if (tin2 > 0.0 || tout1 > 0.0)
					{
						if (tin2 <= tout1)
						{
							if (tin2 > 0.0)
							{
								if (tinx > tiny)
								{
									x[XIndex++] = (int)xin;
									y[YIndex++] = (int)(y1 + tinx * deltay);
								}
								else
								{
									x[XIndex++] = (int)(x1 + tiny * deltax);
									y[YIndex++] = (int)yin;
								}
								++np;
							}

							if (tout1 < 1.0)
							{
								if (toutx < touty)
								{
									x[XIndex++] = (int)xout;
									y[YIndex++] = (int)(y1 + toutx * deltay);
								}
								else
								{
									x[XIndex++] = (int)(x1 + touty * deltax);
									y[YIndex++] = (int)yout;
								}
							}
							else
							{
								x[XIndex++] = x2;
								y[YIndex++] = y2;
							}
							++np;
						}
						else
						{
							if (tinx > tiny)
							{
								x[XIndex++] = (int)xin;
								y[YIndex++] = (int)yout;
							}
							else
							{
								x[XIndex++] = (int)xout;
								y[YIndex++] = (int)yin;
							}
							++np;
						}
					}
				}
			}
			return np;
		}

		public static bool clip_move_point(int x1, int y1, int x2, int y2,
							 RectangleInt clip_box,
							 ref int x, ref int y, int flags)
		{
			int bound;

			if ((flags & (int)clipping_flags_e.clipping_flags_x_clipped) != 0)
			{
				if (x1 == x2)
				{
					return false;
				}
				bound = ((flags & (int)clipping_flags_e.clipping_flags_x1_clipped) != 0) ? clip_box.Left : clip_box.Right;
				y = (int)((double)(bound - x1) * (y2 - y1) / (x2 - x1) + y1);
				x = bound;
			}

			flags = clipping_flags_y(y, clip_box);
			if ((flags & (int)clipping_flags_e.clipping_flags_y_clipped) != 0)
			{
				if (y1 == y2)
				{
					return false;
				}
				bound = ((flags & (int)clipping_flags_e.clipping_flags_y1_clipped) != 0) ? clip_box.Bottom : clip_box.Top;
				x = (int)((double)(bound - y1) * (x2 - x1) / (y2 - y1) + x1);
				y = bound;
			}
			return true;
		}

		//-------------------------------------------------------clip_line_segment
		// Returns: ret >= 4        - Fully clipped
		//          (ret & 1) != 0  - First point has been moved
		//          (ret & 2) != 0  - Second point has been moved
		//
		//template<class T>
		public static int clip_line_segment(ref int x1, ref int y1, ref int x2, ref int y2,
								   RectangleInt clip_box)
		{
			int f1 = clipping_flags(x1, y1, clip_box);
			int f2 = clipping_flags(x2, y2, clip_box);
			int ret = 0;

			if ((f2 | f1) == 0)
			{
				// Fully visible
				return 0;
			}

			if ((f1 & (int)clipping_flags_e.clipping_flags_x_clipped) != 0 &&
			   (f1 & (int)clipping_flags_e.clipping_flags_x_clipped) == (f2 & (int)clipping_flags_e.clipping_flags_x_clipped))
			{
				// Fully clipped
				return 4;
			}

			if ((f1 & (int)clipping_flags_e.clipping_flags_y_clipped) != 0 &&
			   (f1 & (int)clipping_flags_e.clipping_flags_y_clipped) == (f2 & (int)clipping_flags_e.clipping_flags_y_clipped))
			{
				// Fully clipped
				return 4;
			}

			int tx1 = x1;
			int ty1 = y1;
			int tx2 = x2;
			int ty2 = y2;
			if (f1 != 0)
			{
				if (!clip_move_point(tx1, ty1, tx2, ty2, clip_box, ref x1, ref y1, f1))
				{
					return 4;
				}
				if (x1 == x2 && y1 == y2)
				{
					return 4;
				}
				ret |= 1;
			}
			if (f2 != 0)
			{
				if (!clip_move_point(tx1, ty1, tx2, ty2, clip_box, ref x2, ref y2, f2))
				{
					return 4;
				}
				if (x1 == x2 && y1 == y2)
				{
					return 4;
				}
				ret |= 2;
			}
			return ret;
		}
	}
}

//#endif

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\agg_color_gray.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
//
// color types gray8, gray16
//
//----------------------------------------------------------------------------
namespace MatterHackers.Agg
{
	//===================================================================gray8
	public struct gray8
	{
		private const uint base_mask = base_scale - 1;
		private const uint base_scale = (uint)(1 << base_shift);
		private const int base_shift = 8;
		private byte a;
		private byte v;
		//--------------------------------------------------------------------
		public gray8(uint v_)
			: this(v_, (uint)base_mask)
		{
		}

		public gray8(uint v_, uint a_)
		{
			v = (byte)(v_);
			a = (byte)(a_);
		}

		//--------------------------------------------------------------------
		public gray8(ColorF c)
		{
			v = ((byte)Util.uround((0.299 * c.Red0To255 + 0.587 * c.Green0To255 + 0.114 * c.Blue0To255) * (double)(base_mask)));
			a = ((byte)Util.uround(c.Alpha0To255 * (double)(base_mask)));
		}

		//--------------------------------------------------------------------
		public gray8(ColorF c, double a_)
		{
			v = ((byte)Util.uround((0.299 * c.Red0To255 + 0.587 * c.Green0To255 + 0.114 * c.Blue0To255) * (double)(base_mask)));
			a = ((byte)Util.uround(a_ * (double)(base_mask)));
		}

		//--------------------------------------------------------------------
		public gray8(Color c)
		{
			v = (byte)((c.Red0To255 * 77 + c.Green0To255 * 150 + c.Blue0To255 * 29) >> 8);
			a = (byte)(c.Alpha0To255);
		}

		//--------------------------------------------------------------------
		public gray8(Color c, int a_)
		{
			v = (byte)((c.Red0To255 * 77 + c.Green0To255 * 150 + c.Blue0To255 * 29) >> 8);
			a = (byte)(a_);
		}

		//--------------------------------------------------------------------
		private gray8(gray8 c, uint a_)
		{
			v = (c.v);
			a = (byte)(a_);
		}
		//--------------------------------------------------------------------
		public void clear()
		{
			v = a = 0;
		}

		//--------------------------------------------------------------------
		public gray8 demultiply()
		{
			if (a == (int)base_mask) return this;
			if (a == 0)
			{
				v = 0;
				return this;
			}
			int v_ = ((int)(v) * (int)base_mask) / a;
			v = (byte)((v_ > (int)base_mask) ? (byte)base_mask : v_);
			return this;
		}

		//--------------------------------------------------------------------
		public gray8 gradient(gray8 c, double k)
		{
			gray8 ret;
			int ik = Util.uround(k * (int)base_scale);
			ret.v = (byte)((int)(v) + ((((int)(c.v) - v) * ik) >> base_shift));
			ret.a = (byte)((int)(a) + ((((int)(c.a) - a) * ik) >> base_shift));
			return ret;
		}

		//--------------------------------------------------------------------
		public void opacity(double a_)
		{
			if (a_ < 0.0) a_ = 0.0;
			if (a_ > 1.0) a_ = 1.0;
			a = (byte)Util.uround(a_ * (double)(base_mask));
		}

		//--------------------------------------------------------------------
		public double opacity()
		{
			return (double)(a) / (double)(base_mask);
		}

		//--------------------------------------------------------------------
		public gray8 premultiply()
		{
			if (a == (byte)base_mask) return this;
			if (a == 0)
			{
				v = 0;
				return this;
			}
			v = (byte)(((int)(v) * a) >> base_shift);
			return this;
		}

		//--------------------------------------------------------------------
		public gray8 premultiply(int a_)
		{
			if (a == (int)base_mask && a_ >= (int)base_mask) return this;
			if (a == 0 || a_ == 0)
			{
				v = a = 0;
				return this;
			}
			int v_ = ((int)(v) * a_) / a;
			v = (byte)((v_ > a_) ? a_ : v_);
			a = (byte)(a_);
			return this;
		}

		//--------------------------------------------------------------------
		public gray8 transparent()
		{
			a = 0;
			return this;
		}
		/*
		//--------------------------------------------------------------------
		void add(gray8 c, int cover)
		{
			int cv, ca;
			if(cover == cover_mask)
			{
				if (c.a == base_mask)
				{
					*this = c;
				}
				else
				{
					cv = v + c.v; v = (cv > (int)(base_mask)) ? (int)(base_mask) : cv;
					ca = a + c.a; a = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;
				}
			}
			else
			{
				cv = v + ((c.v * cover + cover_mask/2) >> cover_shift);
				ca = a + ((c.a * cover + cover_mask/2) >> cover_shift);
				v = (cv > (int)(base_mask)) ? (int)(base_mask) : cv;
				a = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;
			}
		}
		 */

		//--------------------------------------------------------------------
		//static gray8 no_color() { return gray8(0,0); }

		/*
		static gray8 gray8_pre(int v, int a = gray8.base_mask)
		{
			return gray8(v,a).premultiply();
		}

		static gray8 gray8_pre(gray8 c, uint a)
		{
			return gray8(c,a).premultiply();
		}

		static gray8 gray8_pre(rgba& c)
		{
			return gray8(c).premultiply();
		}

		static gray8 gray8_pre(rgba& c, double a)
		{
			return gray8(c,a).premultiply();
		}

		static gray8 gray8_pre(rgba8& c)
		{
			return gray8(c).premultiply();
		}

		static gray8 gray8_pre(rgba8& c, uint a)
		{
			return gray8(c,a).premultiply();
		}
		 */
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\agg_dda_line.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// classes dda_line_interpolator, dda2_line_interpolator
//
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg
{
	//===================================================dda_line_interpolator
	public sealed class dda_line_interpolator
	{
		private int m_y;
		private int m_inc;
		private int m_dy;

		//int m_YShift;
		private int m_FractionShift;

		//--------------------------------------------------------------------
		public dda_line_interpolator(int FractionShift)
		{
			m_FractionShift = FractionShift;
		}

		//--------------------------------------------------------------------
		public dda_line_interpolator(int y1, int y2, int count, int FractionShift)
		{
			m_FractionShift = FractionShift;
			m_y = (y1);
			m_inc = (((y2 - y1) << m_FractionShift) / (int)(count));
			m_dy = (0);
		}

		//--------------------------------------------------------------------
		//public void operator ++ ()
		public void Next()
		{
			m_dy += m_inc;
		}

		//--------------------------------------------------------------------
		//public void operator -- ()
		public void Prev()
		{
			m_dy -= m_inc;
		}

		//--------------------------------------------------------------------
		//public void operator += (int n)
		public void Next(int n)
		{
			m_dy += m_inc * (int)n;
		}

		//--------------------------------------------------------------------
		//public void operator -= (int n)
		public void Prev(int n)
		{
			m_dy -= m_inc * (int)n;
		}

		//--------------------------------------------------------------------
		public int y()
		{
			return m_y + (m_dy >> (m_FractionShift));
		} // - m_YShift)); }

		public int dy()
		{
			return m_dy;
		}
	}

	//=================================================dda2_line_interpolator
	public sealed class dda2_line_interpolator
	{
		private enum save_size_e { save_size = 2 };

		//--------------------------------------------------------------------
		public dda2_line_interpolator()
		{
		}

		//-------------------------------------------- Forward-adjusted line
		public dda2_line_interpolator(int y1, int y2, int count)
		{
			m_cnt = (count <= 0 ? 1 : count);
			m_lft = ((y2 - y1) / m_cnt);
			m_rem = ((y2 - y1) % m_cnt);
			m_mod = (m_rem);
			m_y = (y1);

			if (m_mod <= 0)
			{
				m_mod += count;
				m_rem += count;
				m_lft--;
			}
			m_mod -= count;
		}

		//-------------------------------------------- Backward-adjusted line
		public dda2_line_interpolator(int y1, int y2, int count, int unused)
		{
			m_cnt = (count <= 0 ? 1 : count);
			m_lft = ((y2 - y1) / m_cnt);
			m_rem = ((y2 - y1) % m_cnt);
			m_mod = (m_rem);
			m_y = (y1);

			if (m_mod <= 0)
			{
				m_mod += count;
				m_rem += count;
				m_lft--;
			}
		}

		//-------------------------------------------- Backward-adjusted line
		public dda2_line_interpolator(int y, int count)
		{
			m_cnt = (count <= 0 ? 1 : count);
			m_lft = ((y) / m_cnt);
			m_rem = ((y) % m_cnt);
			m_mod = (m_rem);
			m_y = (0);

			if (m_mod <= 0)
			{
				m_mod += count;
				m_rem += count;
				m_lft--;
			}
		}

		/*
		//--------------------------------------------------------------------
		public void save(save_data_type* data)
		{
			data[0] = m_mod;
			data[1] = m_y;
		}

		//--------------------------------------------------------------------
		public void load(save_data_type* data)
		{
			m_mod = data[0];
			m_y   = data[1];
		}
		 */

		//--------------------------------------------------------------------
		//public void operator++()
		public void Next()
		{
			m_mod += m_rem;
			m_y += m_lft;
			if (m_mod > 0)
			{
				m_mod -= m_cnt;
				m_y++;
			}
		}

		//--------------------------------------------------------------------
		//public void operator--()
		public void Prev()
		{
			if (m_mod <= m_rem)
			{
				m_mod += m_cnt;
				m_y--;
			}
			m_mod -= m_rem;
			m_y -= m_lft;
		}

		//--------------------------------------------------------------------
		public void adjust_forward()
		{
			m_mod -= m_cnt;
		}

		//--------------------------------------------------------------------
		public void adjust_backward()
		{
			m_mod += m_cnt;
		}

		//--------------------------------------------------------------------
		public int mod()
		{
			return m_mod;
		}

		public int rem()
		{
			return m_rem;
		}

		public int lft()
		{
			return m_lft;
		}

		//--------------------------------------------------------------------
		public int y()
		{
			return m_y;
		}

		private int m_cnt;
		private int m_lft;
		private int m_rem;
		private int m_mod;
		private int m_y;
	}

	//---------------------------------------------line_bresenham_interpolator
	public sealed class line_bresenham_interpolator
	{
		private int m_x1_lr;
		private int m_y1_lr;
		private int m_x2_lr;
		private int m_y2_lr;
		private bool m_ver;
		private int m_len;
		private int m_inc;
		private dda2_line_interpolator m_interpolator;

		public enum subpixel_scale_e
		{
			subpixel_shift = 8,
			subpixel_scale = 1 << subpixel_shift,
			subpixel_mask = subpixel_scale - 1
		}

		//--------------------------------------------------------------------
		public static int line_lr(int v)
		{
			return v >> (int)subpixel_scale_e.subpixel_shift;
		}

		//--------------------------------------------------------------------
		public line_bresenham_interpolator(int x1, int y1, int x2, int y2)
		{
			m_x1_lr = (line_lr(x1));
			m_y1_lr = (line_lr(y1));
			m_x2_lr = (line_lr(x2));
			m_y2_lr = (line_lr(y2));
			m_ver = (Math.Abs(m_x2_lr - m_x1_lr) < Math.Abs(m_y2_lr - m_y1_lr));
			if (m_ver)
			{
				m_len = (int)Math.Abs(m_y2_lr - m_y1_lr);
			}
			else
			{
				m_len = (int)Math.Abs(m_x2_lr - m_x1_lr);
			}

			m_inc = (m_ver ? ((y2 > y1) ? 1 : -1) : ((x2 > x1) ? 1 : -1));
			m_interpolator = new dda2_line_interpolator(m_ver ? x1 : y1,
						   m_ver ? x2 : y2,
						   (int)m_len);
		}

		//--------------------------------------------------------------------
		public bool is_ver()
		{
			return m_ver;
		}

		public int len()
		{
			return m_len;
		}

		public int inc()
		{
			return m_inc;
		}

		//--------------------------------------------------------------------
		public void hstep()
		{
			m_interpolator.Next();
			m_x1_lr += m_inc;
		}

		//--------------------------------------------------------------------
		public void vstep()
		{
			m_interpolator.Next();
			m_y1_lr += m_inc;
		}

		//--------------------------------------------------------------------
		public int x1()
		{
			return m_x1_lr;
		}

		public int y1()
		{
			return m_y1_lr;
		}

		public int x2()
		{
			return line_lr(m_interpolator.y());
		}

		public int y2()
		{
			return line_lr(m_interpolator.y());
		}

		public int x2_hr()
		{
			return m_interpolator.y();
		}

		public int y2_hr()
		{
			return m_interpolator.y();
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\agg_gamma_functions.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg
{
	public interface IGammaFunction
	{
		double GetGamma(double x);
	}

	public struct gamma_none : IGammaFunction
	{
		public double GetGamma(double x)
		{
			return x;
		}
	}

	//==============================================================gamma_power
	public class gamma_power : IGammaFunction
	{
		public gamma_power()
		{
			m_gamma = 1.0;
		}

		public gamma_power(double g)
		{
			m_gamma = g;
		}

		public void gamma(double g)
		{
			m_gamma = g;
		}

		public double gamma()
		{
			return m_gamma;
		}

		public double GetGamma(double x)
		{
			return Math.Pow(x, m_gamma);
		}

		private double m_gamma;
	}

	//==========================================================gamma_threshold
	public class gamma_threshold : IGammaFunction
	{
		public gamma_threshold()
		{
			m_threshold = 0.5;
		}

		public gamma_threshold(double t)
		{
			m_threshold = t;
		}

		public void threshold(double t)
		{
			m_threshold = t;
		}

		public double threshold()
		{
			return m_threshold;
		}

		public double GetGamma(double x)
		{
			return (x < m_threshold) ? 0.0 : 1.0;
		}

		private double m_threshold;
	}

	//============================================================gamma_linear
	public class gamma_linear : IGammaFunction
	{
		public gamma_linear()
		{
			m_start = (0.0);
			m_end = (1.0);
		}

		public gamma_linear(double s, double e)
		{
			m_start = (s);
			m_end = (e);
		}

		public void set(double s, double e)
		{
			m_start = s; m_end = e;
		}

		public void start(double s)
		{
			m_start = s;
		}

		public void end(double e)
		{
			m_end = e;
		}

		public double start()
		{
			return m_start;
		}

		public double end()
		{
			return m_end;
		}

		public double GetGamma(double x)
		{
			if (x < m_start) return 0.0;
			if (x > m_end) return 1.0;
			double EndMinusStart = m_end - m_start;
			if (EndMinusStart != 0)
				return (x - m_start) / EndMinusStart;
			else
				return 0.0;
		}

		private double m_start;
		private double m_end;
	}

	//==========================================================gamma_multiply
	public class gamma_multiply : IGammaFunction
	{
		public gamma_multiply()
		{
			m_mul = (1.0);
		}

		public gamma_multiply(double v)
		{
			m_mul = (v);
		}

		public void value(double v)
		{
			m_mul = v;
		}

		public double value()
		{
			return m_mul;
		}

		public double GetGamma(double x)
		{
			double y = x * m_mul;
			if (y > 1.0) y = 1.0;
			return y;
		}

		private double m_mul;
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\agg_image_filters.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Image transformation filters,
// Filtering classes (ImageFilterLookUpTable, image_filter),
// Basic filter shape classes
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg
{
	public interface IImageFilterFunction
	{
		double radius();

		double calc_weight(double x);
	}

	//-----------------------------------------------------ImageFilterLookUpTable
	public class ImageFilterLookUpTable
	{
		private double m_radius;
		private int m_diameter;
		private int m_start;
		private ArrayPOD<int> m_weight_array;

		public enum image_filter_scale_e
		{
			image_filter_shift = 14,                      //----image_filter_shift
			image_filter_scale = 1 << image_filter_shift, //----image_filter_scale
			image_filter_mask = image_filter_scale - 1   //----image_filter_mask
		}

		public enum image_subpixel_scale_e
		{
			image_subpixel_shift = 8,                         //----image_subpixel_shift
			image_subpixel_scale = 1 << image_subpixel_shift, //----image_subpixel_scale
			image_subpixel_mask = image_subpixel_scale - 1   //----image_subpixel_mask
		}

		public void calculate(IImageFilterFunction filter)
		{
			calculate(filter, true);
		}

		public void calculate(IImageFilterFunction filter, bool normalization)
		{
			double r = filter.radius();
			realloc_lut(r);
			int i;
			int pivot = diameter() << ((int)image_subpixel_scale_e.image_subpixel_shift - 1);
			for (i = 0; i < pivot; i++)
			{
				double x = (double)i / (double)image_subpixel_scale_e.image_subpixel_scale;
				double y = filter.calc_weight(x);
				m_weight_array.Array[pivot + i] =
				m_weight_array.Array[pivot - i] = Util.iround(y * (int)image_filter_scale_e.image_filter_scale);
			}
			int end = (diameter() << (int)image_subpixel_scale_e.image_subpixel_shift) - 1;
			m_weight_array.Array[0] = m_weight_array.Array[end];
			if (normalization)
			{
				normalize();
			}
		}

		public ImageFilterLookUpTable()
		{
			m_weight_array = new ArrayPOD<int>(256);
			m_radius = (0);
			m_diameter = (0);
			m_start = (0);
		}

		public ImageFilterLookUpTable(IImageFilterFunction filter)
			: this(filter, true)
		{
		}

		public ImageFilterLookUpTable(IImageFilterFunction filter, bool normalization)
		{
			m_weight_array = new ArrayPOD<int>(256);
			calculate(filter, normalization);
		}

		public double radius()
		{
			return m_radius;
		}

		public int diameter()
		{
			return m_diameter;
		}

		public int start()
		{
			return m_start;
		}

		public int[] weight_array()
		{
			return m_weight_array.Array;
		}

		//--------------------------------------------------------------------
		// This function normalizes integer values and corrects the rounding
		// errors. It doesn't do anything with the source floating point values
		// (m_weight_array_dbl), it corrects only integers according to the rule
		// of 1.0 which means that any sum of pixel weights must be equal to 1.0.
		// So, the filter function must produce a graph of the proper shape.
		//--------------------------------------------------------------------
		public void normalize()
		{
			int i;
			int flip = 1;

			for (i = 0; i < (int)image_subpixel_scale_e.image_subpixel_scale; i++)
			{
				for (; ; )
				{
					int sum = 0;
					int j;
					for (j = 0; j < m_diameter; j++)
					{
						sum += m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i];
					}

					if (sum == (int)image_filter_scale_e.image_filter_scale) break;

					double k = (double)((int)image_filter_scale_e.image_filter_scale) / (double)(sum);
					sum = 0;
					for (j = 0; j < m_diameter; j++)
					{
						sum += m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i] =
							(int)Util.iround(m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i] * k);
					}

					sum -= (int)image_filter_scale_e.image_filter_scale;
					int inc = (sum > 0) ? -1 : 1;

					for (j = 0; j < m_diameter && sum != 0; j++)
					{
						flip ^= 1;
						int idx = flip != 0 ? m_diameter / 2 + j / 2 : m_diameter / 2 - j / 2;
						int v = m_weight_array.Array[idx * (int)image_subpixel_scale_e.image_subpixel_scale + i];
						if (v < (int)image_filter_scale_e.image_filter_scale)
						{
							m_weight_array.Array[idx * (int)image_subpixel_scale_e.image_subpixel_scale + i] += (int)inc;
							sum += inc;
						}
					}
				}
			}

			int pivot = m_diameter << ((int)image_subpixel_scale_e.image_subpixel_shift - 1);

			for (i = 0; i < pivot; i++)
			{
				m_weight_array.Array[pivot + i] = m_weight_array.Array[pivot - i];
			}
			int end = (diameter() << (int)image_subpixel_scale_e.image_subpixel_shift) - 1;
			m_weight_array.Array[0] = m_weight_array.Array[end];
		}

		private void realloc_lut(double radius)
		{
			m_radius = radius;
			m_diameter = Util.uceil(radius) * 2;
			m_start = -(int)(m_diameter / 2 - 1);
			int size = (int)m_diameter << (int)image_subpixel_scale_e.image_subpixel_shift;
			if (size > m_weight_array.Size())
			{
				m_weight_array.Resize(size);
			}
		}
	}

	/*

	//--------------------------------------------------------image_filter
	public class image_filter : ImageFilterLookUpTable
	{
		public image_filter()
		{
			calculate(m_filter_function);
		}

		private IImageFilter m_filter_function;
	};
	 */

	//-----------------------------------------------image_filter_bilinear
	public struct image_filter_bilinear : IImageFilterFunction
	{
		public double radius()
		{
			return 1.0;
		}

		public double calc_weight(double x)
		{
			if (Math.Abs(x) < 1)
			{
				if (x < 0)
				{
					return 1.0 + x;
				}
				else
				{
					return 1.0 - x;
				}
			}

			return 0;
		}
	};

	//-----------------------------------------------image_filter_hanning
	public struct image_filter_hanning : IImageFilterFunction
	{
		public double radius()
		{
			return 1.0;
		}

		public double calc_weight(double x)
		{
			return 0.5 + 0.5 * Math.Cos(Math.PI * x);
		}
	};

	//-----------------------------------------------image_filter_hamming
	public struct image_filter_hamming : IImageFilterFunction
	{
		public double radius()
		{
			return 1.0;
		}

		public double calc_weight(double x)
		{
			return 0.54 + 0.46 * Math.Cos(Math.PI * x);
		}
	};

	//-----------------------------------------------image_filter_hermite
	public struct image_filter_hermite : IImageFilterFunction
	{
		public double radius()
		{
			return 1.0;
		}

		public double calc_weight(double x)
		{
			return (2.0 * x - 3.0) * x * x + 1.0;
		}
	};

	//------------------------------------------------image_filter_quadric
	public struct image_filter_quadric : IImageFilterFunction
	{
		public double radius()
		{
			return 1.5;
		}

		public double calc_weight(double x)
		{
			double t;
			if (x < 0.5) return 0.75 - x * x;
			if (x < 1.5) { t = x - 1.5; return 0.5 * t * t; }
			return 0.0;
		}
	};

	//------------------------------------------------image_filter_bicubic
	public class image_filter_bicubic : IImageFilterFunction
	{
		private static double pow3(double x)
		{
			return (x <= 0.0) ? 0.0 : x * x * x;
		}

		public double radius()
		{
			return 2.0;
		}

		public double calc_weight(double x)
		{
			return
				(1.0 / 6.0) *
				(pow3(x + 2) - 4 * pow3(x + 1) + 6 * pow3(x) - 4 * pow3(x - 1));
		}
	};

	//-------------------------------------------------image_filter_kaiser
	public class image_filter_kaiser : IImageFilterFunction
	{
		private double a;
		private double i0a;
		private double epsilon;

		public image_filter_kaiser()
			: this(6.33)
		{
		}

		public image_filter_kaiser(double b)
		{
			a = (b);
			epsilon = (1e-12);
			i0a = 1.0 / bessel_i0(b);
		}

		public double radius()
		{
			return 1.0;
		}

		public double calc_weight(double x)
		{
			return bessel_i0(a * Math.Sqrt(1.0 - x * x)) * i0a;
		}

		private double bessel_i0(double x)
		{
			int i;
			double sum, y, t;

			sum = 1.0;
			y = x * x / 4.0;
			t = y;

			for (i = 2; t > epsilon; i++)
			{
				sum += t;
				t *= (double)y / (i * i);
			}
			return sum;
		}
	};

	//----------------------------------------------image_filter_catrom
	public struct image_filter_catrom : IImageFilterFunction
	{
		public double radius()
		{
			return 2.0;
		}

		public double calc_weight(double x)
		{
			if (x < 1.0) return 0.5 * (2.0 + x * x * (-5.0 + x * 3.0));
			if (x < 2.0) return 0.5 * (4.0 + x * (-8.0 + x * (5.0 - x)));
			return 0.0;
		}
	};

	//---------------------------------------------image_filter_mitchell
	public class image_filter_mitchell : IImageFilterFunction
	{
		private double p0, p2, p3;
		private double q0, q1, q2, q3;

		public image_filter_mitchell()
			: this(1.0 / 3.0, 1.0 / 3.0)
		{
		}

		public image_filter_mitchell(double b, double c)
		{
			p0 = ((6.0 - 2.0 * b) / 6.0);
			p2 = ((-18.0 + 12.0 * b + 6.0 * c) / 6.0);
			p3 = ((12.0 - 9.0 * b - 6.0 * c) / 6.0);
			q0 = ((8.0 * b + 24.0 * c) / 6.0);
			q1 = ((-12.0 * b - 48.0 * c) / 6.0);
			q2 = ((6.0 * b + 30.0 * c) / 6.0);
			q3 = ((-b - 6.0 * c) / 6.0);
		}

		public double radius()
		{
			return 2.0;
		}

		public double calc_weight(double x)
		{
			if (x < 1.0) return p0 + x * x * (p2 + x * p3);
			if (x < 2.0) return q0 + x * (q1 + x * (q2 + x * q3));
			return 0.0;
		}
	};

	//----------------------------------------------image_filter_spline16
	public struct image_filter_spline16 : IImageFilterFunction
	{
		public double radius()
		{
			return 2.0;
		}

		public double calc_weight(double x)
		{
			if (x < 1.0)
			{
				return ((x - 9.0 / 5.0) * x - 1.0 / 5.0) * x + 1.0;
			}
			return ((-1.0 / 3.0 * (x - 1) + 4.0 / 5.0) * (x - 1) - 7.0 / 15.0) * (x - 1);
		}
	};

	//---------------------------------------------image_filter_spline36
	public struct image_filter_spline36 : IImageFilterFunction
	{
		public double radius()
		{
			return 3.0;
		}

		public double calc_weight(double x)
		{
			if (x < 1.0)
			{
				return ((13.0 / 11.0 * x - 453.0 / 209.0) * x - 3.0 / 209.0) * x + 1.0;
			}
			if (x < 2.0)
			{
				return ((-6.0 / 11.0 * (x - 1) + 270.0 / 209.0) * (x - 1) - 156.0 / 209.0) * (x - 1);
			}
			return ((1.0 / 11.0 * (x - 2) - 45.0 / 209.0) * (x - 2) + 26.0 / 209.0) * (x - 2);
		}
	};

	//----------------------------------------------image_filter_gaussian
	public struct image_filter_gaussian : IImageFilterFunction
	{
		public double radius()
		{
			return 2.0;
		}

		public double calc_weight(double x)
		{
			return Math.Exp(-2.0 * x * x) * Math.Sqrt(2.0 / Math.PI);
		}
	};

	//------------------------------------------------image_filter_bessel
	public struct image_filter_bessel : IImageFilterFunction
	{
		public double radius()
		{
			return 3.2383;
		}

		public double calc_weight(double x)
		{
			return (x == 0.0) ? Math.PI / 4.0 : agg_math.besj(Math.PI * x, 1) / (2.0 * x);
		}
	};

	//-------------------------------------------------image_filter_sinc
	public class image_filter_sinc : IImageFilterFunction
	{
		public image_filter_sinc(double r)
		{
			m_radius = (r < 2.0 ? 2.0 : r);
		}

		public double radius()
		{
			return m_radius;
		}

		public double calc_weight(double x)
		{
			if (x == 0.0) return 1.0;
			x *= Math.PI;
			return Math.Sin(x) / x;
		}

		private double m_radius;
	};

	//-----------------------------------------------image_filter_lanczos
	public class image_filter_lanczos : IImageFilterFunction
	{
		public image_filter_lanczos(double r)
		{
			m_radius = (r < 2.0 ? 2.0 : r);
		}

		public double radius()
		{
			return m_radius;
		}

		public double calc_weight(double x)
		{
			if (x == 0.0) return 1.0;
			if (x > m_radius) return 0.0;
			x *= Math.PI;
			double xr = x / m_radius;
			return (Math.Sin(x) / x) * (Math.Sin(xr) / xr);
		}

		private double m_radius;
	};

	//----------------------------------------------image_filter_blackman
	public class image_filter_blackman : IImageFilterFunction
	{
		public image_filter_blackman(double r)
		{
			m_radius = (r < 2.0 ? 2.0 : r);
		}

		public double radius()
		{
			return m_radius;
		}

		public double calc_weight(double x)
		{
			if (x == 0.0)
			{
				return 1.0;
			}

			if (x > m_radius)
			{
				return 0.0;
			}

			x *= Math.PI;
			double xr = x / m_radius;
			return (Math.Sin(x) / x) * (0.42 + 0.5 * Math.Cos(xr) + 0.08 * Math.Cos(2 * xr));
		}

		private double m_radius;
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\agg_line_aa_basics.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg
{
	//---------------------------------------------------------------line_coord
	public struct line_coord
	{
		public static int conv(double x)
		{
			return (int)Math.Round(x * LineAABasics.line_subpixel_scale);
		}
	};

	//-----------------------------------------------------------line_coord_sat
	public struct line_coord_sat
	{
		public static int conv(double x)
		{
			return Util.iround(x * LineAABasics.line_subpixel_scale, LineAABasics.line_max_coord);
		}
	};

	//==========================================================line_parameters
	public struct line_parameters
	{
		//---------------------------------------------------------------------
		public int x1, y1, x2, y2, dx, dy, sx, sy;

		public bool vertical;
		public int inc;
		public int len;
		public int octant;

		// The number of the octant is determined as a 3-bit value as follows:
		// bit 0 = vertical flag
		// bit 1 = sx < 0
		// bit 2 = sy < 0
		//
		// [N] shows the number of the orthogonal quadrant
		// <M> shows the number of the diagonal quadrant
		//               <1>
		//   [1]          |          [0]
		//       . (3)011 | 001(1) .
		//         .      |      .
		//           .    |    .
		//             .  |  .
		//    (2)010     .|.     000(0)
		// <2> ----------.+.----------- <0>
		//    (6)110   .  |  .   100(4)
		//           .    |    .
		//         .      |      .
		//       .        |        .
		//         (7)111 | 101(5)
		//   [2]          |          [3]
		//               <3>
		//                                                        0,1,2,3,4,5,6,7
		public static readonly byte[] s_orthogonal_quadrant = { 0, 0, 1, 1, 3, 3, 2, 2 };

		public static readonly byte[] s_diagonal_quadrant = { 0, 1, 2, 1, 0, 3, 2, 3 };

		//---------------------------------------------------------------------
		public line_parameters(int x1_, int y1_, int x2_, int y2_, int len_)
		{
			x1 = (x1_);
			y1 = (y1_);
			x2 = (x2_);
			y2 = (y2_);
			dx = (Math.Abs(x2_ - x1_));
			dy = (Math.Abs(y2_ - y1_));
			sx = ((x2_ > x1_) ? 1 : -1);
			sy = ((y2_ > y1_) ? 1 : -1);
			vertical = (dy >= dx);
			inc = (vertical ? sy : sx);
			len = (len_);
			octant = ((sy & 4) | (sx & 2) | (vertical ? 1 : 0));
		}

		//---------------------------------------------------------------------
		public uint orthogonal_quadrant()
		{
			return s_orthogonal_quadrant[octant];
		}

		public uint diagonal_quadrant()
		{
			return s_diagonal_quadrant[octant];
		}

		//---------------------------------------------------------------------
		public bool same_orthogonal_quadrant(line_parameters lp)
		{
			return s_orthogonal_quadrant[octant] == s_orthogonal_quadrant[lp.octant];
		}

		//---------------------------------------------------------------------
		public bool same_diagonal_quadrant(line_parameters lp)
		{
			return s_diagonal_quadrant[octant] == s_diagonal_quadrant[lp.octant];
		}

		//---------------------------------------------------------------------
		public void divide(out line_parameters lp1, out line_parameters lp2)
		{
			int xmid = (x1 + x2) >> 1;
			int ymid = (y1 + y2) >> 1;
			int len2 = len >> 1;

			lp1 = this; // it is a struct so this is a copy
			lp2 = this; // it is a struct so this is a copy

			lp1.x2 = xmid;
			lp1.y2 = ymid;
			lp1.len = len2;
			lp1.dx = Math.Abs(lp1.x2 - lp1.x1);
			lp1.dy = Math.Abs(lp1.y2 - lp1.y1);

			lp2.x1 = xmid;
			lp2.y1 = ymid;
			lp2.len = len2;
			lp2.dx = Math.Abs(lp2.x2 - lp2.x1);
			lp2.dy = Math.Abs(lp2.y2 - lp2.y1);
		}
	};

	public static class LineAABasics
	{
		public const int line_subpixel_shift = 8;                          //----line_subpixel_shift
		public const int line_subpixel_scale = 1 << line_subpixel_shift;  //----line_subpixel_scale
		public const int line_subpixel_mask = line_subpixel_scale - 1;    //----line_subpixel_mask
		public const int line_max_coord = (1 << 28) - 1;              //----line_max_coord
		public const int line_max_length = 1 << (line_subpixel_shift + 10); //----line_max_length

		public const int line_mr_subpixel_shift = 4;                           //----line_mr_subpixel_shift
		public const int line_mr_subpixel_scale = 1 << line_mr_subpixel_shift; //----line_mr_subpixel_scale
		public const int line_mr_subpixel_mask = line_mr_subpixel_scale - 1;   //----line_mr_subpixel_mask

		public static int line_mr(int x)
		{
			return x >> (line_subpixel_shift - line_mr_subpixel_shift);
		}

		public static int line_hr(int x)
		{
			return x << (line_subpixel_shift - line_mr_subpixel_shift);
		}

		public static int line_dbl_hr(int x)
		{
			return x << line_subpixel_shift;
		}

		public static void bisectrix(line_parameters l1,
				   line_parameters l2,
				   out int x, out int y)
		{
			double k = (double)(l2.len) / (double)(l1.len);
			double tx = l2.x2 - (l2.x1 - l1.x1) * k;
			double ty = l2.y2 - (l2.y1 - l1.y1) * k;

			//All bisectrices must be on the right of the line
			//If the next point is on the left (l1 => l2.2)
			//then the bisectix should be rotated by 180 degrees.
			if ((double)(l2.x2 - l2.x1) * (double)(l2.y1 - l1.y1) <
			   (double)(l2.y2 - l2.y1) * (double)(l2.x1 - l1.x1) + 100.0)
			{
				tx -= (tx - l2.x1) * 2.0;
				ty -= (ty - l2.y1) * 2.0;
			}

			// Check if the bisectrix is too short
			double dx = tx - l2.x1;
			double dy = ty - l2.y1;
			if ((int)Math.Sqrt(dx * dx + dy * dy) < line_subpixel_scale)
			{
				x = (l2.x1 + l2.x1 + (l2.y1 - l1.y1) + (l2.y2 - l2.y1)) >> 1;
				y = (l2.y1 + l2.y1 - (l2.x1 - l1.x1) - (l2.x2 - l2.x1)) >> 1;
				return;
			}

			x = Util.iround(tx);
			y = Util.iround(ty);
		}

		public static void fix_degenerate_bisectrix_start(line_parameters lp,
											   ref int x, ref int y)
		{
			int d = Util.iround(((double)(x - lp.x2) * (double)(lp.y2 - lp.y1) -
							(double)(y - lp.y2) * (double)(lp.x2 - lp.x1)) / lp.len);
			if (d < line_subpixel_scale / 2)
			{
				x = lp.x1 + (lp.y2 - lp.y1);
				y = lp.y1 - (lp.x2 - lp.x1);
			}
		}

		public static void fix_degenerate_bisectrix_end(line_parameters lp,
											 ref int x, ref int y)
		{
			int d = Util.iround(((double)(x - lp.x2) * (double)(lp.y2 - lp.y1) -
							(double)(y - lp.y2) * (double)(lp.x2 - lp.x1)) / lp.len);
			if (d < line_subpixel_scale / 2)
			{
				x = lp.x2 + (lp.y2 - lp.y1);
				y = lp.y2 - (lp.x2 - lp.x1);
			}
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\agg_math.cs
// <auto-generated>
// Hack to disable analyzers and their warnings - too many issues to address
// </auto-generated>
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
// Bessel function (besj) was adapted for use in AGG library by Andy Wilk
// Contact: castor.vulgaris@gmail.com
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg
{
	public static class agg_math
	{
		//------------------------------------------------------vertex_dist_epsilon
		// Coinciding points maximal distance (Epsilon)
		public const double vertex_dist_epsilon = 1e-14;

		//-----------------------------------------------------intersection_epsilon
		// See calc_intersection
		public const double intersection_epsilon = 1.0e-30;

		//------------------------------------------------------------cross_product
		public static double cross_product(double x1, double y1,
										double x2, double y2,
										double x, double y)
		{
			return (x - x2) * (y2 - y1) - (y - y2) * (x2 - x1);
		}

		//--------------------------------------------------------point_in_triangle
		public static bool point_in_triangle(double x1, double y1,
										  double x2, double y2,
										  double x3, double y3,
										  double x, double y)
		{
			bool cp1 = cross_product(x1, y1, x2, y2, x, y) < 0.0;
			bool cp2 = cross_product(x2, y2, x3, y3, x, y) < 0.0;
			bool cp3 = cross_product(x3, y3, x1, y1, x, y) < 0.0;
			return cp1 == cp2 && cp2 == cp3 && cp3 == cp1;
		}

		//-----------------------------------------------------------calc_distance
		public static double CalcDistance(double x1, double y1, double x2, double y2)
		{
			double dx = x2 - x1;
			double dy = y2 - y1;
			return Math.Sqrt(dx * dx + dy * dy);
		}

		//--------------------------------------------------------calc_sq_distance
		public static double calc_sq_distance(double x1, double y1, double x2, double y2)
		{
			double dx = x2 - x1;
			double dy = y2 - y1;
			return dx * dx + dy * dy;
		}

		//------------------------------------------------calc_line_point_distance
		public static double calc_line_point_distance(double x1, double y1,
												   double x2, double y2,
												   double x, double y)
		{
			double dx = x2 - x1;
			double dy = y2 - y1;
			double d = Math.Sqrt(dx * dx + dy * dy);
			if (d < vertex_dist_epsilon)
			{
				return CalcDistance(x1, y1, x, y);
			}
			return ((x - x2) * dy - (y - y2) * dx) / d;
		}

		//-------------------------------------------------------calc_line_point_u
		public static double calc_segment_point_u(double x1, double y1,
											   double x2, double y2,
											   double x, double y)
		{
			double dx = x2 - x1;
			double dy = y2 - y1;

			if (dx == 0 && dy == 0)
			{
				return 0;
			}

			double pdx = x - x1;
			double pdy = y - y1;

			return (pdx * dx + pdy * dy) / (dx * dx + dy * dy);
		}

		//---------------------------------------------calc_line_point_sq_distance
		public static double calc_segment_point_sq_distance(double x1, double y1,
														 double x2, double y2,
														 double x, double y,
														 double u)
		{
			if (u <= 0)
			{
				return calc_sq_distance(x, y, x1, y1);
			}
			else
				if (u >= 1)
				{
					return calc_sq_distance(x, y, x2, y2);
				}
			return calc_sq_distance(x, y, x1 + u * (x2 - x1), y1 + u * (y2 - y1));
		}

		//---------------------------------------------calc_line_point_sq_distance
		public static double calc_segment_point_sq_distance(double x1, double y1,
														 double x2, double y2,
														 double x, double y)
		{
			return
				calc_segment_point_sq_distance(
					x1, y1, x2, y2, x, y,
					calc_segment_point_u(x1, y1, x2, y2, x, y));
		}

		//-------------------------------------------------------calc_intersection
		public static bool calc_intersection(double aX1, double aY1, double aX2, double aY2,
										  double bX1, double bY1, double bX2, double bY2,
										  out double x, out double y)
		{
			double num = (aY1 - bY1) * (bX2 - bX1) - (aX1 - bX1) * (bY2 - bY1);
			double den = (aX2 - aX1) * (bY2 - bY1) - (aY2 - aY1) * (bX2 - bX1);
			if (Math.Abs(den) < intersection_epsilon)
			{
				x = 0;
				y = 0;
				return false;
			}
			double r = num / den;
			x = aX1 + r * (aX2 - aX1);
			y = aY1 + r * (aY2 - aY1);
			return true;
		}

		//-----------------------------------------------------intersection_exists
		public static bool intersection_exists(double x1, double y1, double x2, double y2,
											double x3, double y3, double x4, double y4)
		{
			// It's less expensive but you can't control the
			// boundary conditions: Less or LessEqual
			double dx1 = x2 - x1;
			double dy1 = y2 - y1;
			double dx2 = x4 - x3;
			double dy2 = y4 - y3;
			return ((x3 - x2) * dy1 - (y3 - y2) * dx1 < 0.0) !=
				   ((x4 - x2) * dy1 - (y4 - y2) * dx1 < 0.0) &&
				   ((x1 - x4) * dy2 - (y1 - y4) * dx2 < 0.0) !=
				   ((x2 - x4) * dy2 - (y2 - y4) * dx2 < 0.0);

			// It's is more expensive but more flexible
			// in terms of boundary conditions.
			//--------------------
			//double den  = (x2-x1) * (y4-y3) - (y2-y1) * (x4-x3);
			//if(Math.Abs(den) < intersection_epsilon) return false;
			//double nom1 = (x4-x3) * (y1-y3) - (y4-y3) * (x1-x3);
			//double nom2 = (x2-x1) * (y1-y3) - (y2-y1) * (x1-x3);
			//double ua = nom1 / den;
			//double ub = nom2 / den;
			//return ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0;
		}

		//--------------------------------------------------------calc_orthogonal
		public static void calc_orthogonal(double thickness,
										double x1, double y1,
										double x2, double y2,
										out double x, out double y)
		{
			double dx = x2 - x1;
			double dy = y2 - y1;
			double d = Math.Sqrt(dx * dx + dy * dy);
			x = thickness * dy / d;
			y = -thickness * dx / d;
		}

		//--------------------------------------------------------dilate_triangle
		public static void dilate_triangle(double x1, double y1,
										double x2, double y2,
										double x3, double y3,
										double[] x, double[] y,
										double d)
		{
			double dx1 = 0.0;
			double dy1 = 0.0;
			double dx2 = 0.0;
			double dy2 = 0.0;
			double dx3 = 0.0;
			double dy3 = 0.0;
			double loc = cross_product(x1, y1, x2, y2, x3, y3);
			if (Math.Abs(loc) > intersection_epsilon)
			{
				if (cross_product(x1, y1, x2, y2, x3, y3) > 0.0)
				{
					d = -d;
				}
				calc_orthogonal(d, x1, y1, x2, y2, out dx1, out dy1);
				calc_orthogonal(d, x2, y2, x3, y3, out dx2, out dy2);
				calc_orthogonal(d, x3, y3, x1, y1, out dx3, out dy3);
			}
			x[0] = x1 + dx1; y[0] = y1 + dy1;
			x[1] = x2 + dx1; y[1] = y2 + dy1;
			x[2] = x2 + dx2; y[2] = y2 + dy2;
			x[3] = x3 + dx2; y[3] = y3 + dy2;
			x[4] = x3 + dx3; y[4] = y3 + dy3;
			x[5] = x1 + dx3; y[5] = y1 + dy3;
		}

		//------------------------------------------------------calc_triangle_area
		public static double calc_triangle_area(double x1, double y1,
											 double x2, double y2,
											 double x3, double y3)
		{
			return (x1 * y2 - x2 * y1 + x2 * y3 - x3 * y2 + x3 * y1 - x1 * y3) * 0.5;
		}

		//-------------------------------------------------------calc_polygon_area
		public static double calc_polygon_area(VertexSequence st)
		{
			int i;
			double sum = 0.0;
			double x = st[0].x;
			double y = st[0].y;
			double xs = x;
			double ys = y;

			for (i = 1; i < st.Count; i++)
			{
				VertexDistance v = st[i];
				sum += x * v.y - y * v.x;
				x = v.x;
				y = v.y;
			}
			return (sum + x * ys - y * xs) * 0.5;
		}

		//------------------------------------------------------------------------
		// Tables for fast sqrt
		public static ushort[] g_sqrt_table =                       //----------g_sqrt_table
        {
            0,
            2048,2896,3547,4096,4579,5017,5418,5793,6144,6476,6792,7094,7384,7663,7932,8192,8444,
            8689,8927,9159,9385,9606,9822,10033,10240,10443,10642,10837,11029,11217,11403,11585,
            11765,11942,12116,12288,12457,12625,12790,12953,13114,13273,13430,13585,13738,13890,
            14040,14189,14336,14482,14626,14768,14910,15050,15188,15326,15462,15597,15731,15864,
            15995,16126,16255,16384,16512,16638,16764,16888,17012,17135,17257,17378,17498,17618,
            17736,17854,17971,18087,18203,18318,18432,18545,18658,18770,18882,18992,19102,19212,
            19321,19429,19537,19644,19750,19856,19961,20066,20170,20274,20377,20480,20582,20684,
            20785,20886,20986,21085,21185,21283,21382,21480,21577,21674,21771,21867,21962,22058,
            22153,22247,22341,22435,22528,22621,22713,22806,22897,22989,23080,23170,23261,23351,
            23440,23530,23619,23707,23796,23884,23971,24059,24146,24232,24319,24405,24491,24576,
            24661,24746,24831,24915,24999,25083,25166,25249,25332,25415,25497,25580,25661,25743,
            25824,25905,25986,26067,26147,26227,26307,26387,26466,26545,26624,26703,26781,26859,
            26937,27015,27092,27170,27247,27324,27400,27477,27553,27629,27705,27780,27856,27931,
            28006,28081,28155,28230,28304,28378,28452,28525,28599,28672,28745,28818,28891,28963,
            29035,29108,29180,29251,29323,29394,29466,29537,29608,29678,29749,29819,29890,29960,
            30030,30099,30169,30238,30308,30377,30446,30515,30583,30652,30720,30788,30856,30924,
            30992,31059,31127,31194,31261,31328,31395,31462,31529,31595,31661,31727,31794,31859,
            31925,31991,32056,32122,32187,32252,32317,32382,32446,32511,32575,32640,32704,32768,
            32832,32896,32959,33023,33086,33150,33213,33276,33339,33402,33465,33527,33590,33652,
            33714,33776,33839,33900,33962,34024,34086,34147,34208,34270,34331,34392,34453,34514,
            34574,34635,34695,34756,34816,34876,34936,34996,35056,35116,35176,35235,35295,35354,
            35413,35472,35531,35590,35649,35708,35767,35825,35884,35942,36001,36059,36117,36175,
            36233,36291,36348,36406,36464,36521,36578,36636,36693,36750,36807,36864,36921,36978,
            37034,37091,37147,37204,37260,37316,37372,37429,37485,37540,37596,37652,37708,37763,
            37819,37874,37929,37985,38040,38095,38150,38205,38260,38315,38369,38424,38478,38533,
            38587,38642,38696,38750,38804,38858,38912,38966,39020,39073,39127,39181,39234,39287,
            39341,39394,39447,39500,39553,39606,39659,39712,39765,39818,39870,39923,39975,40028,
            40080,40132,40185,40237,40289,40341,40393,40445,40497,40548,40600,40652,40703,40755,
            40806,40857,40909,40960,41011,41062,41113,41164,41215,41266,41317,41368,41418,41469,
            41519,41570,41620,41671,41721,41771,41821,41871,41922,41972,42021,42071,42121,42171,
            42221,42270,42320,42369,42419,42468,42518,42567,42616,42665,42714,42763,42813,42861,
            42910,42959,43008,43057,43105,43154,43203,43251,43300,43348,43396,43445,43493,43541,
            43589,43637,43685,43733,43781,43829,43877,43925,43972,44020,44068,44115,44163,44210,
            44258,44305,44352,44400,44447,44494,44541,44588,44635,44682,44729,44776,44823,44869,
            44916,44963,45009,45056,45103,45149,45195,45242,45288,45334,45381,45427,45473,45519,
            45565,45611,45657,45703,45749,45795,45840,45886,45932,45977,46023,46069,46114,46160,
            46205,46250,46296,46341,46386,46431,46477,46522,46567,46612,46657,46702,46746,46791,
            46836,46881,46926,46970,47015,47059,47104,47149,47193,47237,47282,47326,47370,47415,
            47459,47503,47547,47591,47635,47679,47723,47767,47811,47855,47899,47942,47986,48030,
            48074,48117,48161,48204,48248,48291,48335,48378,48421,48465,48508,48551,48594,48637,
            48680,48723,48766,48809,48852,48895,48938,48981,49024,49067,49109,49152,49195,49237,
            49280,49322,49365,49407,49450,49492,49535,49577,49619,49661,49704,49746,49788,49830,
            49872,49914,49956,49998,50040,50082,50124,50166,50207,50249,50291,50332,50374,50416,
            50457,50499,50540,50582,50623,50665,50706,50747,50789,50830,50871,50912,50954,50995,
            51036,51077,51118,51159,51200,51241,51282,51323,51364,51404,51445,51486,51527,51567,
            51608,51649,51689,51730,51770,51811,51851,51892,51932,51972,52013,52053,52093,52134,
            52174,52214,52254,52294,52334,52374,52414,52454,52494,52534,52574,52614,52654,52694,
            52734,52773,52813,52853,52892,52932,52972,53011,53051,53090,53130,53169,53209,53248,
            53287,53327,53366,53405,53445,53484,53523,53562,53601,53640,53679,53719,53758,53797,
            53836,53874,53913,53952,53991,54030,54069,54108,54146,54185,54224,54262,54301,54340,
            54378,54417,54455,54494,54532,54571,54609,54647,54686,54724,54762,54801,54839,54877,
            54915,54954,54992,55030,55068,55106,55144,55182,55220,55258,55296,55334,55372,55410,
            55447,55485,55523,55561,55599,55636,55674,55712,55749,55787,55824,55862,55900,55937,
            55975,56012,56049,56087,56124,56162,56199,56236,56273,56311,56348,56385,56422,56459,
            56497,56534,56571,56608,56645,56682,56719,56756,56793,56830,56867,56903,56940,56977,
            57014,57051,57087,57124,57161,57198,57234,57271,57307,57344,57381,57417,57454,57490,
            57527,57563,57599,57636,57672,57709,57745,57781,57817,57854,57890,57926,57962,57999,
            58035,58071,58107,58143,58179,58215,58251,58287,58323,58359,58395,58431,58467,58503,
            58538,58574,58610,58646,58682,58717,58753,58789,58824,58860,58896,58931,58967,59002,
            59038,59073,59109,59144,59180,59215,59251,59286,59321,59357,59392,59427,59463,59498,
            59533,59568,59603,59639,59674,59709,59744,59779,59814,59849,59884,59919,59954,59989,
            60024,60059,60094,60129,60164,60199,60233,60268,60303,60338,60373,60407,60442,60477,
            60511,60546,60581,60615,60650,60684,60719,60753,60788,60822,60857,60891,60926,60960,
            60995,61029,61063,61098,61132,61166,61201,61235,61269,61303,61338,61372,61406,61440,
            61474,61508,61542,61576,61610,61644,61678,61712,61746,61780,61814,61848,61882,61916,
            61950,61984,62018,62051,62085,62119,62153,62186,62220,62254,62287,62321,62355,62388,
            62422,62456,62489,62523,62556,62590,62623,62657,62690,62724,62757,62790,62824,62857,
            62891,62924,62957,62991,63024,63057,63090,63124,63157,63190,63223,63256,63289,63323,
            63356,63389,63422,63455,63488,63521,63554,63587,63620,63653,63686,63719,63752,63785,
            63817,63850,63883,63916,63949,63982,64014,64047,64080,64113,64145,64178,64211,64243,
            64276,64309,64341,64374,64406,64439,64471,64504,64536,64569,64601,64634,64666,64699,
            64731,64763,64796,64828,64861,64893,64925,64957,64990,65022,65054,65086,65119,65151,
            65183,65215,65247,65279,65312,65344,65376,65408,65440,65472,65504
        };

		public static byte[] g_elder_bit_table = //---------g_elder_bit_table
        {
            0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
            5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
            6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
            6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
            7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
            7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
            7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
            7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
        };

		//---------------------------------------------------------------fast_sqrt
		//Fast integer Sqrt - really fast: no cycles, divisions or multiplications
		public static int fast_sqrt(int val)
		{
			//This code is actually pure C and portable to most
			//architectures including 64bit ones.
			int t = val;
			int bit = 0;
			int shift = 11;

			//The following piece of code is just an emulation of the
			//Ix86 assembler command "bsr" (see above). However on old
			//Intels (like Intel MMX 233MHz) this code is about twice
			//as fast as just one "bsr". On PIII and PIV the
			//bsr is optimized quite well.
			bit = (int)t >> 24;
			if (bit != 0)
			{
				bit = g_elder_bit_table[bit] + 24;
			}
			else
			{
				bit = ((int)t >> 16) & 0xFF;
				if (bit != 0)
				{
					bit = g_elder_bit_table[bit] + 16;
				}
				else
				{
					bit = ((int)t >> 8) & 0xFF;
					if (bit != 0)
					{
						bit = g_elder_bit_table[bit] + 8;
					}
					else
					{
						bit = g_elder_bit_table[t];
					}
				}
			}

			//This code calculates the sqrt.
			bit -= 9;
			if (bit > 0)
			{
				bit = (bit >> 1) + (bit & 1);
				shift -= (int)bit;
				val >>= (bit << 1);
			}
			return (int)((int)g_sqrt_table[val] >> (int)shift);
		}

		//--------------------------------------------------------------------besj
		// Function BESJ calculates Bessel function of first kind of order n
		// Arguments:
		//     n - an integer (>=0), the order
		//     x - value at which the Bessel function is required
		//--------------------
		// C++ Mathematical Library
		// Converted from equivalent FORTRAN library
		// Converted by Gareth Walker for use by course 392 computational project
		// All functions tested and yield the same results as the corresponding
		// FORTRAN versions.
		//
		// If you have any problems using these functions please report them to
		// M.Muldoon@UMIST.ac.uk
		//
		// Documentation available on the web
		// http://www.ma.umist.ac.uk/mrm/Teaching/392/libs/392.html
		// Version 1.0   8/98
		// 29 October, 1999
		//--------------------
		// Adapted for use in AGG library by Andy Wilk (castor.vulgaris@gmail.com)
		//------------------------------------------------------------------------
		public static double besj(double x, int n)
		{
			if (n < 0)
			{
				return 0;
			}
			double d = 1E-6;
			double b = 0;
			if (Math.Abs(x) <= d)
			{
				if (n != 0) return 0;
				return 1;
			}
			double b1 = 0; // b1 is the value from the previous iteration
			// Set up a starting order for recurrence
			int m1 = (int)Math.Abs(x) + 6;
			if (Math.Abs(x) > 5)
			{
				m1 = (int)(Math.Abs(1.4 * x + 60 / x));
			}
			int m2 = (int)(n + 2 + Math.Abs(x) / 4);
			if (m1 > m2)
			{
				m2 = m1;
			}

			// Apply recurrence down from current max order
			for (; ; )
			{
				double c3 = 0;
				double c2 = 1E-30;
				double c4 = 0;
				int m8 = 1;
				if (m2 / 2 * 2 == m2)
				{
					m8 = -1;
				}
				int imax = m2 - 2;
				for (int i = 1; i <= imax; i++)
				{
					double c6t = 2 * (m2 - i) * c2 / x - c3;
					c3 = c2;
					c2 = c6t;
					if (m2 - i - 1 == n)
					{
						b = c6t;
					}
					m8 = -1 * m8;
					if (m8 > 0)
					{
						c4 = c4 + 2 * c6t;
					}
				}
				double c6 = 2 * c2 / x - c3;
				if (n == 0)
				{
					b = c6;
				}
				c4 += c6;
				b /= c4;
				if (Math.Abs(b - b1) < d)
				{
					return b;
				}
				b1 = b;
				m2 += 3;
			}
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\agg_pattern_filters_rgba.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using MatterHackers.Agg.Image;

namespace MatterHackers.Agg
{
	public interface IPatternFilter
	{
		int dilation();

		void pixel_high_res(ImageBuffer sourceImage, Color[] destBuffer, int destBufferOffset, int x, int y);
	}

	//=======================================================pattern_filter_nn
	//template<class ColorT>
	/*
	struct pattern_filter_nn
	{
		typedef ColorT Color;
		static uint dilation() { return 0; }

		static void pixel_low_res(Color** buf,
											 Color* p, int x, int y)
		{
			*p = buf[y][x];
		}

		static void pixel_high_res(Color** buf,
											  Color* p, int x, int y)
		{
			*p = buf[y >> line_subpixel_shift]
					[x >> line_subpixel_shift];
		}
	};
	 */

	public struct pattern_filter_bilinear_RGBA_Bytes : IPatternFilter
	{
		public int dilation()
		{
			return 1;
		}

		public void pixel_low_res(Color[][] buf, Color[] p, int offset, int x, int y)
		{
			p[offset] = buf[y][x];
		}

		public void pixel_high_res(ImageBuffer sourceImage, Color[] destBuffer, int destBufferOffset, int x, int y)
		{
			int r, g, b, a;
			r = g = b = a = LineAABasics.line_subpixel_scale * LineAABasics.line_subpixel_scale / 2;

			int weight;
			int x_lr = x >> LineAABasics.line_subpixel_shift;
			int y_lr = y >> LineAABasics.line_subpixel_shift;

			x &= LineAABasics.line_subpixel_mask;
			y &= LineAABasics.line_subpixel_mask;
			int sourceOffset;
			byte[] ptr = sourceImage.GetPixelPointerXY(x_lr, y_lr, out sourceOffset);

			weight = (LineAABasics.line_subpixel_scale - x) *
					 (LineAABasics.line_subpixel_scale - y);
			r += weight * ptr[sourceOffset + ImageBuffer.OrderR];
			g += weight * ptr[sourceOffset + ImageBuffer.OrderG];
			b += weight * ptr[sourceOffset + ImageBuffer.OrderB];
			a += weight * ptr[sourceOffset + ImageBuffer.OrderA];

			sourceOffset += sourceImage.GetBytesBetweenPixelsInclusive();

			weight = x * (LineAABasics.line_subpixel_scale - y);
			r += weight * ptr[sourceOffset + ImageBuffer.OrderR];
			g += weight * ptr[sourceOffset + ImageBuffer.OrderG];
			b += weight * ptr[sourceOffset + ImageBuffer.OrderB];
			a += weight * ptr[sourceOffset + ImageBuffer.OrderA];

			ptr = sourceImage.GetPixelPointerXY(x_lr, y_lr + 1, out sourceOffset);

			weight = (LineAABasics.line_subpixel_scale - x) * y;
			r += weight * ptr[sourceOffset + ImageBuffer.OrderR];
			g += weight * ptr[sourceOffset + ImageBuffer.OrderG];
			b += weight * ptr[sourceOffset + ImageBuffer.OrderB];
			a += weight * ptr[sourceOffset + ImageBuffer.OrderA];

			sourceOffset += sourceImage.GetBytesBetweenPixelsInclusive();

			weight = x * y;
			r += weight * ptr[sourceOffset + ImageBuffer.OrderR];
			g += weight * ptr[sourceOffset + ImageBuffer.OrderG];
			b += weight * ptr[sourceOffset + ImageBuffer.OrderB];
			a += weight * ptr[sourceOffset + ImageBuffer.OrderA];

			destBuffer[destBufferOffset].red = (byte)(r >> LineAABasics.line_subpixel_shift * 2);
			destBuffer[destBufferOffset].green = (byte)(g >> LineAABasics.line_subpixel_shift * 2);
			destBuffer[destBufferOffset].blue = (byte)(b >> LineAABasics.line_subpixel_shift * 2);
			destBuffer[destBufferOffset].alpha = (byte)(a >> LineAABasics.line_subpixel_shift * 2);
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\agg_rasterizer_cells_aa.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
//
// The author gratefully acknowledges the support of David Turner,
// Robert Wilhelm, and Werner Lemberg - the authors of the FreeType
// library - in producing this work. See http://www.freetype.org for details.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for 32-bit screen coordinates has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------

using poly_subpixel_scale_e = MatterHackers.Agg.Util.poly_subpixel_scale_e;

namespace MatterHackers.Agg
{
	//-----------------------------------------------------------------cell_aa
	// A pixel cell. There are no constructors defined and it was done
	// intentionally in order to avoid extra overhead when allocating an
	// array of cells.
	public struct PixelCellAa
	{
		public int x;
		public int y;
		public int cover;
		public int area;
		public int left, right;

		public void Initial()
		{
			x = 0x7FFFFFFF;
			y = 0x7FFFFFFF;
			cover = 0;
			area = 0;
			left = -1;
			right = -1;
		}

		public void Set(PixelCellAa cellB)
		{
			x = cellB.x;
			y = cellB.y;
			cover = cellB.cover;
			area = cellB.area;
			left = cellB.left;
			right = cellB.right;
		}

		public void Style(PixelCellAa cellB)
		{
			left = cellB.left;
			right = cellB.right;
		}

		public bool NotEqual(int ex, int ey, PixelCellAa cell)
		{
			unchecked
			{
				return ((ex - x) | (ey - y) | (left - cell.left) | (right - cell.right)) != 0;
			}
		}
	};

	//-----------------------------------------------------rasterizer_cells_aa
	// An internal class that implements the main rasterization algorithm.
	// Used in the rasterizer. Should not be used directly.
	public sealed class RasterizerCellsAa
	{
		private int m_num_used_cells;
		private VectorPOD<PixelCellAa> m_cells;
		private VectorPOD<PixelCellAa> m_sorted_cells;
		private VectorPOD<sorted_y> m_sorted_y;
		private QuickSortCellAa m_QSorter;

		private PixelCellAa m_curr_cell;
		private PixelCellAa m_style_cell;
		private int m_min_x;
		private int m_min_y;
		private int m_max_x;
		private int m_max_y;
		private bool m_sorted;

		private enum cell_block_scale_e
		{
			cell_block_shift = 12,
			cell_block_size = 1 << cell_block_shift,
			cell_block_mask = cell_block_size - 1,
			cell_block_pool = 256,
			cell_block_limit = 1024 * cell_block_size
		};

		private struct sorted_y
		{
			internal int start;
			internal int num;
		};

		public RasterizerCellsAa()
		{
			m_QSorter = new QuickSortCellAa();
			m_sorted_cells = new VectorPOD<PixelCellAa>();
			m_sorted_y = new VectorPOD<sorted_y>();
			m_min_x = (0x7FFFFFFF);
			m_min_y = (0x7FFFFFFF);
			m_max_x = (-0x7FFFFFFF);
			m_max_y = (-0x7FFFFFFF);
			m_sorted = (false);

			m_style_cell.Initial();
			m_curr_cell.Initial();
		}

		public void reset()
		{
			m_num_used_cells = 0;

			m_curr_cell.Initial();
			m_style_cell.Initial();
			m_sorted = false;
			m_min_x = 0x7FFFFFFF;
			m_min_y = 0x7FFFFFFF;
			m_max_x = -0x7FFFFFFF;
			m_max_y = -0x7FFFFFFF;
		}

		public void style(PixelCellAa style_cell)
		{
			m_style_cell.Style(style_cell);
		}

		private enum dx_limit_e { dx_limit = 16384 << Util.poly_subpixel_scale_e.poly_subpixel_shift };

		public void line(int x1, int y1, int x2, int y2)
		{
			int poly_subpixel_shift = (int)Util.poly_subpixel_scale_e.poly_subpixel_shift;
			int poly_subpixel_mask = (int)Util.poly_subpixel_scale_e.poly_subpixel_mask;
			int poly_subpixel_scale = (int)Util.poly_subpixel_scale_e.poly_subpixel_scale;
			int dx = x2 - x1;

			if (dx >= (int)dx_limit_e.dx_limit || dx <= -(int)dx_limit_e.dx_limit)
			{
				int cx = (x1 + x2) >> 1;
				int cy = (y1 + y2) >> 1;
				line(x1, y1, cx, cy);
				line(cx, cy, x2, y2);
			}

			int dy = y2 - y1;
			int ex1 = x1 >> poly_subpixel_shift;
			int ex2 = x2 >> poly_subpixel_shift;
			int ey1 = y1 >> poly_subpixel_shift;
			int ey2 = y2 >> poly_subpixel_shift;
			int fy1 = y1 & poly_subpixel_mask;
			int fy2 = y2 & poly_subpixel_mask;

			int x_from, x_to;
			int p, rem, mod, lift, delta, first, incr;

			if (ex1 < m_min_x) m_min_x = ex1;
			if (ex1 > m_max_x) m_max_x = ex1;
			if (ey1 < m_min_y) m_min_y = ey1;
			if (ey1 > m_max_y) m_max_y = ey1;
			if (ex2 < m_min_x) m_min_x = ex2;
			if (ex2 > m_max_x) m_max_x = ex2;
			if (ey2 < m_min_y) m_min_y = ey2;
			if (ey2 > m_max_y) m_max_y = ey2;

			set_curr_cell(ex1, ey1);

			//everything is on a single horizontal line
			if (ey1 == ey2)
			{
				render_hline(ey1, x1, fy1, x2, fy2);
				return;
			}

			//Vertical line - we have to calculate start and end cells,
			//and then - the common values of the area and coverage for
			//all cells of the line. We know exactly there's only one
			//cell, so, we don't have to call render_hline().
			incr = 1;
			if (dx == 0)
			{
				int ex = x1 >> poly_subpixel_shift;
				int two_fx = (x1 - (ex << poly_subpixel_shift)) << 1;
				int area;

				first = poly_subpixel_scale;
				if (dy < 0)
				{
					first = 0;
					incr = -1;
				}

				x_from = x1;

				delta = first - fy1;
				m_curr_cell.cover += delta;
				m_curr_cell.area += two_fx * delta;

				ey1 += incr;
				set_curr_cell(ex, ey1);

				delta = first + first - poly_subpixel_scale;
				area = two_fx * delta;
				while (ey1 != ey2)
				{
					m_curr_cell.cover = delta;
					m_curr_cell.area = area;
					ey1 += incr;
					set_curr_cell(ex, ey1);
				}
				delta = fy2 - poly_subpixel_scale + first;
				m_curr_cell.cover += delta;
				m_curr_cell.area += two_fx * delta;
				return;
			}

			//ok, we have to render several hlines
			p = (poly_subpixel_scale - fy1) * dx;
			first = poly_subpixel_scale;

			if (dy < 0)
			{
				p = fy1 * dx;
				first = 0;
				incr = -1;
				dy = -dy;
			}

			delta = p / dy;
			mod = p % dy;

			if (mod < 0)
			{
				delta--;
				mod += dy;
			}

			x_from = x1 + delta;
			render_hline(ey1, x1, fy1, x_from, first);

			ey1 += incr;
			set_curr_cell(x_from >> poly_subpixel_shift, ey1);

			if (ey1 != ey2)
			{
				p = poly_subpixel_scale * dx;
				lift = p / dy;
				rem = p % dy;

				if (rem < 0)
				{
					lift--;
					rem += dy;
				}
				mod -= dy;

				while (ey1 != ey2)
				{
					delta = lift;
					mod += rem;
					if (mod >= 0)
					{
						mod -= dy;
						delta++;
					}

					x_to = x_from + delta;
					render_hline(ey1, x_from, poly_subpixel_scale - first, x_to, first);
					x_from = x_to;

					ey1 += incr;
					set_curr_cell(x_from >> poly_subpixel_shift, ey1);
				}
			}
			render_hline(ey1, x_from, poly_subpixel_scale - first, x2, fy2);
		}

		public int min_x()
		{
			return m_min_x;
		}

		public int min_y()
		{
			return m_min_y;
		}

		public int max_x()
		{
			return m_max_x;
		}

		public int max_y()
		{
			return m_max_y;
		}

		public void sort_cells()
		{
			if (m_sorted) return; //Perform sort only the first time.

			add_curr_cell();
			m_curr_cell.x = 0x7FFFFFFF;
			m_curr_cell.y = 0x7FFFFFFF;
			m_curr_cell.cover = 0;
			m_curr_cell.area = 0;

			if (m_num_used_cells == 0) return;

			// Allocate the array of cell pointers
			m_sorted_cells.Allocate(m_num_used_cells);

			// Allocate and zero the Y array
			m_sorted_y.Allocate((int)(m_max_y - m_min_y + 1));
			m_sorted_y.zero();
			PixelCellAa[] cells = m_cells.Array;
			sorted_y[] sortedYData = m_sorted_y.Array;
			PixelCellAa[] sortedCellsData = m_sorted_cells.Array;

			// Create the Y-histogram (count the numbers of cells for each Y)
			for (int i = 0; i < m_num_used_cells; i++)
			{
				int Index = cells[i].y - m_min_y;
				sortedYData[Index].start++;
			}

			// Convert the Y-histogram into the array of starting indexes
			int start = 0;
			int SortedYSize = m_sorted_y.Count;
			for (int i = 0; i < SortedYSize; i++)
			{
				int v = sortedYData[i].start;
				sortedYData[i].start = start;
				start += v;
			}

			// Fill the cell pointer array sorted by Y
			for (int i = 0; i < m_num_used_cells; i++)
			{
				int SortedIndex = cells[i].y - m_min_y;
				int curr_y_start = sortedYData[SortedIndex].start;
				int curr_y_num = sortedYData[SortedIndex].num;
				sortedCellsData[curr_y_start + curr_y_num] = cells[i];
				++sortedYData[SortedIndex].num;
			}

			// Finally arrange the X-arrays
			for (int i = 0; i < SortedYSize; i++)
			{
				if (sortedYData[i].num != 0)
				{
					m_QSorter.Sort(sortedCellsData, sortedYData[i].start, sortedYData[i].start + sortedYData[i].num - 1);
				}
			}
			m_sorted = true;
		}

		public int total_cells()
		{
			return m_num_used_cells;
		}

		public int scanline_num_cells(int y)
		{
			return (int)m_sorted_y.data()[y - m_min_y].num;
		}

		public void scanline_cells(int y, out PixelCellAa[] CellData, out int Offset)
		{
			CellData = m_sorted_cells.data();
			Offset = m_sorted_y[y - m_min_y].start;
		}

		public bool sorted()
		{
			return m_sorted;
		}

		private void set_curr_cell(int x, int y)
		{
			if (m_curr_cell.NotEqual(x, y, m_style_cell))
			{
				add_curr_cell();
				m_curr_cell.Style(m_style_cell);
				m_curr_cell.x = x;
				m_curr_cell.y = y;
				m_curr_cell.cover = 0;
				m_curr_cell.area = 0;
			}
		}

		private void add_curr_cell()
		{
			if ((m_curr_cell.area | m_curr_cell.cover) != 0)
			{
				if (m_num_used_cells >= (int)cell_block_scale_e.cell_block_limit)
				{
					return;
				}

				allocate_cells_if_required();
				m_cells.data()[m_num_used_cells].Set(m_curr_cell);
				m_num_used_cells++;

#if false
                if(m_num_used_cells == 281)
                {
                    int a = 12;
                }

                DebugFile.Print(m_num_used_cells.ToString()
                    + ". x=" + m_curr_cell.m_x.ToString()
                    + " y=" + m_curr_cell.m_y.ToString()
                    + " area=" + m_curr_cell.m_area.ToString()
                    + " cover=" + m_curr_cell.m_cover.ToString()
                    + "\n");
#endif
			}
		}

		private void allocate_cells_if_required()
		{
			if (m_cells == null || (m_num_used_cells + 1) >= m_cells.Capacity())
			{
				if (m_num_used_cells >= (int)cell_block_scale_e.cell_block_limit)
				{
					return;
				}

				int new_num_allocated_cells = m_num_used_cells + (int)cell_block_scale_e.cell_block_size;
				VectorPOD<PixelCellAa> new_cells = new VectorPOD<PixelCellAa>(new_num_allocated_cells);
				if (m_cells != null)
				{
					new_cells.CopyFrom(m_cells);
				}
				m_cells = new_cells;
			}
		}

		private void render_hline(int ey, int x1, int y1, int x2, int y2)
		{
			int ex1 = x1 >> (int)poly_subpixel_scale_e.poly_subpixel_shift;
			int ex2 = x2 >> (int)poly_subpixel_scale_e.poly_subpixel_shift;
			int fx1 = x1 & (int)poly_subpixel_scale_e.poly_subpixel_mask;
			int fx2 = x2 & (int)poly_subpixel_scale_e.poly_subpixel_mask;

			int delta, p, first, dx;
			int incr, lift, mod, rem;

			//trivial case. Happens often
			if (y1 == y2)
			{
				set_curr_cell(ex2, ey);
				return;
			}

			//everything is located in a single cell.  That is easy!
			if (ex1 == ex2)
			{
				delta = y2 - y1;
				m_curr_cell.cover += delta;
				m_curr_cell.area += (fx1 + fx2) * delta;
				return;
			}

			//ok, we'll have to render a run of adjacent cells on the same hline...
			p = ((int)poly_subpixel_scale_e.poly_subpixel_scale - fx1) * (y2 - y1);
			first = (int)poly_subpixel_scale_e.poly_subpixel_scale;
			incr = 1;

			dx = x2 - x1;

			if (dx < 0)
			{
				p = fx1 * (y2 - y1);
				first = 0;
				incr = -1;
				dx = -dx;
			}

			delta = p / dx;
			mod = p % dx;

			if (mod < 0)
			{
				delta--;
				mod += dx;
			}

			m_curr_cell.cover += delta;
			m_curr_cell.area += (fx1 + first) * delta;

			ex1 += incr;
			set_curr_cell(ex1, ey);
			y1 += delta;

			if (ex1 != ex2)
			{
				p = (int)poly_subpixel_scale_e.poly_subpixel_scale * (y2 - y1 + delta);
				lift = p / dx;
				rem = p % dx;

				if (rem < 0)
				{
					lift--;
					rem += dx;
				}

				mod -= dx;

				while (ex1 != ex2)
				{
					delta = lift;
					mod += rem;
					if (mod >= 0)
					{
						mod -= dx;
						delta++;
					}

					m_curr_cell.cover += delta;
					m_curr_cell.area += (int)poly_subpixel_scale_e.poly_subpixel_scale * delta;
					y1 += delta;
					ex1 += incr;
					set_curr_cell(ex1, ey);
				}
			}
			delta = y2 - y1;
			m_curr_cell.cover += delta;
			m_curr_cell.area += (fx2 + (int)poly_subpixel_scale_e.poly_subpixel_scale - first) * delta;
		}

		private static void swap_cells(PixelCellAa a, PixelCellAa b)
		{
			PixelCellAa temp = a;
			a = b;
			b = temp;
		}

		private enum qsort { threshold = 9 };
	}

	//------------------------------------------------------scanline_hit_test
	public class scanline_hit_test : IScanlineCache
	{
		private int m_x;
		private bool m_hit;

		public scanline_hit_test(int x)
		{
			m_x = x;
			m_hit = false;
		}

		public void ResetSpans()
		{
		}

		public void finalize(int nothing)
		{
		}

		public void add_cell(int x, int nothing)
		{
			if (m_x == x) m_hit = true;
		}

		public void add_span(int x, int len, int nothing)
		{
			if (m_x >= x && m_x < x + len) m_hit = true;
		}

		public int num_spans()
		{
			return 1;
		}

		public bool hit()
		{
			return m_hit;
		}

		public void reset(int min_x, int max_x)
		{
			throw new System.NotImplementedException();
		}

		public ScanlineSpan begin()
		{
			throw new System.NotImplementedException();
		}

		public ScanlineSpan GetNextScanlineSpan()
		{
			throw new System.NotImplementedException();
		}

		public int y()
		{
			throw new System.NotImplementedException();
		}

		public byte[] GetCovers()
		{
			throw new System.NotImplementedException();
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\agg_rasterizer_compound_aa.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.3
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
//
// The author gratefully acknowledges the support of David Turner,
// Robert Wilhelm, and Werner Lemberg - the authors of the FreeType
// library - in producing this work. See http://www.freetype.org for details.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for 32-bit screen coordinates has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
using MatterHackers.Agg.VertexSource;

namespace MatterHackers.Agg
{
	//===========================================================layer_order_e
	public enum LayerOrder
	{
		Unsorted, //------layer_unsorted
		Direct,   //------layer_direct
		Inverse   //------layer_inverse
	};

	//==================================================rasterizer_compound_aa
	//template<class Clip=rasterizer_sl_clip_int>
	sealed public class rasterizer_compound_aa : IRasterizer
	{
		private RasterizerCellsAa rasterizerCellsAa;
		private VectorClipper vectorClipper;
		private Util.filling_rule_e fillingRule;
		private LayerOrder layerOrder;
		private VectorPOD<style_info> activeStyles;  // Active Styles
		private VectorPOD<int> activeStyleTable;     // Active Style Table (unique values)
		private VectorPOD<byte> activeStyleMask;     // Active Style Mask
		private VectorPOD<PixelCellAa> m_cells;
		private VectorPOD<byte> m_cover_buf;
		private VectorPOD<int> m_master_alpha;

		private int m_min_style;
		private int m_max_style;
		private int m_start_x;
		private int m_start_y;
		private int m_scan_y;
		private int m_sl_start;
		private int m_sl_len;

		private struct style_info
		{
			internal int start_cell;
			internal int num_cells;
			internal int last_x;
		};

		private const int aa_shift = 8;
		private const int aa_scale = 1 << aa_shift;
		private const int aa_mask = aa_scale - 1;
		private const int aa_scale2 = aa_scale * 2;
		private const int aa_mask2 = aa_scale2 - 1;

		private const int poly_subpixel_shift = (int)Util.poly_subpixel_scale_e.poly_subpixel_shift;

		public rasterizer_compound_aa()
		{
			rasterizerCellsAa = new RasterizerCellsAa();
			vectorClipper = new VectorClipper();
			fillingRule = Util.filling_rule_e.fill_non_zero;
			layerOrder = LayerOrder.Direct;
			activeStyles = new VectorPOD<style_info>();  // Active Styles
			activeStyleTable = new VectorPOD<int>();     // Active Style Table (unique values)
			activeStyleMask = new VectorPOD<byte>();     // Active Style Mask
			m_cells = new VectorPOD<PixelCellAa>();
			m_cover_buf = new VectorPOD<byte>();
			m_master_alpha = new VectorPOD<int>();
			m_min_style = (0x7FFFFFFF);
			m_max_style = (-0x7FFFFFFF);
			m_start_x = (0);
			m_start_y = (0);
			m_scan_y = (0x7FFFFFFF);
			m_sl_start = (0);
			m_sl_len = (0);
		}

		public void gamma(IGammaFunction gamma_function)
		{
			throw new System.NotImplementedException();
		}

		public void reset()
		{
			rasterizerCellsAa.reset();
			m_min_style = 0x7FFFFFFF;
			m_max_style = -0x7FFFFFFF;
			m_scan_y = 0x7FFFFFFF;
			m_sl_start = 0;
			m_sl_len = 0;
		}

		private void filling_rule(Util.filling_rule_e filling_rule)
		{
			fillingRule = filling_rule;
		}

		private void layer_order(LayerOrder order)
		{
			layerOrder = order;
		}

		private void clip_box(double x1, double y1,
													double x2, double y2)
		{
			reset();
			vectorClipper.clip_box(vectorClipper.upscale(x1), vectorClipper.upscale(y1),
							   vectorClipper.upscale(x2), vectorClipper.upscale(y2));
		}

		private void reset_clipping()
		{
			reset();
			vectorClipper.reset_clipping();
		}

		public void styles(int left, int right)
		{
			PixelCellAa cell = new PixelCellAa();
			cell.Initial();
			cell.left = (int)left;
			cell.right = (int)right;
			rasterizerCellsAa.style(cell);
			if (left >= 0 && left < m_min_style) m_min_style = left;
			if (left >= 0 && left > m_max_style) m_max_style = left;
			if (right >= 0 && right < m_min_style) m_min_style = right;
			if (right >= 0 && right > m_max_style) m_max_style = right;
		}

		public void move_to(int x, int y)
		{
			if (rasterizerCellsAa.sorted()) reset();
			vectorClipper.move_to(m_start_x = vectorClipper.downscale(x),
							  m_start_y = vectorClipper.downscale(y));
		}

		public void line_to(int x, int y)
		{
			vectorClipper.line_to(rasterizerCellsAa,
							  vectorClipper.downscale(x),
							  vectorClipper.downscale(y));
		}

		public void move_to_d(double x, double y)
		{
			if (rasterizerCellsAa.sorted()) reset();
			vectorClipper.move_to(m_start_x = vectorClipper.upscale(x),
							  m_start_y = vectorClipper.upscale(y));
		}

		public void line_to_d(double x, double y)
		{
			vectorClipper.line_to(rasterizerCellsAa,
							  vectorClipper.upscale(x),
							  vectorClipper.upscale(y));
		}

		private void add_vertex(double x, double y, FlagsAndCommand cmd)
		{
			if (ShapePath.IsMoveTo(cmd))
			{
				move_to_d(x, y);
			}
			else
				if (ShapePath.IsVertex(cmd))
				{
					line_to_d(x, y);
				}
				else
					if (ShapePath.IsClose(cmd))
					{
						vectorClipper.line_to(rasterizerCellsAa, m_start_x, m_start_y);
					}
		}

		private void edge(int x1, int y1, int x2, int y2)
		{
			if (rasterizerCellsAa.sorted()) reset();
			vectorClipper.move_to(vectorClipper.downscale(x1), vectorClipper.downscale(y1));
			vectorClipper.line_to(rasterizerCellsAa,
							  vectorClipper.downscale(x2),
							  vectorClipper.downscale(y2));
		}

		private void edge_d(double x1, double y1,
												  double x2, double y2)
		{
			if (rasterizerCellsAa.sorted()) reset();
			vectorClipper.move_to(vectorClipper.upscale(x1), vectorClipper.upscale(y1));
			vectorClipper.line_to(rasterizerCellsAa,
							  vectorClipper.upscale(x2),
							  vectorClipper.upscale(y2));
		}

		private void sort()
		{
			rasterizerCellsAa.sort_cells();
		}

		public bool rewind_scanlines()
		{
			rasterizerCellsAa.sort_cells();
			if (rasterizerCellsAa.total_cells() == 0)
			{
				return false;
			}
			if (m_max_style < m_min_style)
			{
				return false;
			}
			m_scan_y = rasterizerCellsAa.min_y();
			activeStyles.Allocate((int)(m_max_style - m_min_style + 2), 128);
			allocate_master_alpha();
			return true;
		}

		// Returns the number of styles
		public int sweep_styles()
		{
			for (; ; )
			{
				if (m_scan_y > rasterizerCellsAa.max_y()) return 0;
				int num_cells = (int)rasterizerCellsAa.scanline_num_cells(m_scan_y);
				PixelCellAa[] cells;
				int cellOffset = 0;
				int curCellOffset;
				rasterizerCellsAa.scanline_cells(m_scan_y, out cells, out cellOffset);
				int num_styles = (int)(m_max_style - m_min_style + 2);
				int style_id;
				int styleOffset = 0;

				m_cells.Allocate((int)num_cells * 2, 256); // Each cell can have two styles
				activeStyleTable.Capacity(num_styles, 64);
				activeStyleMask.Allocate((num_styles + 7) >> 3, 8);
				activeStyleMask.zero();

				if (num_cells > 0)
				{
					// Pre-add zero (for no-fill style, that is, -1).
					// We need that to ensure that the "-1 style" would go first.
					activeStyleMask.Array[0] |= 1;
					activeStyleTable.Add(0);
					activeStyles.Array[styleOffset].start_cell = 0;
					activeStyles.Array[styleOffset].num_cells = 0;
					activeStyles.Array[styleOffset].last_x = -0x7FFFFFFF;

					m_sl_start = cells[0].x;
					m_sl_len = (int)(cells[num_cells - 1].x - m_sl_start + 1);
					while (num_cells-- != 0)
					{
						curCellOffset = (int)cellOffset++;
						add_style(cells[curCellOffset].left);
						add_style(cells[curCellOffset].right);
					}

					// Convert the Y-histogram into the array of starting indexes
					int i;
					int start_cell = 0;
					style_info[] stylesArray = activeStyles.Array;
					for (i = 0; i < activeStyleTable.Count; i++)
					{
						int IndexToModify = (int)activeStyleTable[i];
						int v = stylesArray[IndexToModify].start_cell;
						stylesArray[IndexToModify].start_cell = start_cell;
						start_cell += v;
					}

					num_cells = (int)rasterizerCellsAa.scanline_num_cells(m_scan_y);
					rasterizerCellsAa.scanline_cells(m_scan_y, out cells, out cellOffset);

					while (num_cells-- > 0)
					{
						curCellOffset = (int)cellOffset++;
						style_id = (int)((cells[curCellOffset].left < 0) ? 0 :
									cells[curCellOffset].left - m_min_style + 1);

						styleOffset = (int)style_id;
						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)
						{
							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;
							unchecked
							{
								cells[cellOffset].area += cells[curCellOffset].area;
								cells[cellOffset].cover += cells[curCellOffset].cover;
							}
						}
						else
						{
							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;
							cells[cellOffset].x = cells[curCellOffset].x;
							cells[cellOffset].area = cells[curCellOffset].area;
							cells[cellOffset].cover = cells[curCellOffset].cover;
							stylesArray[styleOffset].last_x = cells[curCellOffset].x;
							stylesArray[styleOffset].num_cells++;
						}

						style_id = (int)((cells[curCellOffset].right < 0) ? 0 :
									cells[curCellOffset].right - m_min_style + 1);

						styleOffset = (int)style_id;
						if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)
						{
							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;
							unchecked
							{
								cells[cellOffset].area -= cells[curCellOffset].area;
								cells[cellOffset].cover -= cells[curCellOffset].cover;
							}
						}
						else
						{
							cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;
							cells[cellOffset].x = cells[curCellOffset].x;
							cells[cellOffset].area = -cells[curCellOffset].area;
							cells[cellOffset].cover = -cells[curCellOffset].cover;
							stylesArray[styleOffset].last_x = cells[curCellOffset].x;
							stylesArray[styleOffset].num_cells++;
						}
					}
				}
				if (activeStyleTable.Count > 1) break;
				++m_scan_y;
			}
			++m_scan_y;

			if (layerOrder != LayerOrder.Unsorted)
			{
				VectorPodRangeAdaptor ra = new VectorPodRangeAdaptor(activeStyleTable, 1, activeStyleTable.Count - 1);
				if (layerOrder == LayerOrder.Direct)
				{
					QuickSortRangeAdaptorUint m_QSorter = new QuickSortRangeAdaptorUint();
					m_QSorter.Sort(ra);
					//quick_sort(ra, uint_greater);
				}
				else
				{
					throw new System.NotImplementedException();
					//QuickSort_range_adaptor_uint m_QSorter = new QuickSort_range_adaptor_uint();
					//m_QSorter.Sort(ra);
					//quick_sort(ra, uint_less);
				}
			}

			return activeStyleTable.Count - 1;
		}

		// Returns style ID depending of the existing style index
		public int style(int style_idx)
		{
			return activeStyleTable[style_idx + 1] + (int)m_min_style - 1;
		}

		private bool navigate_scanline(int y)
		{
			rasterizerCellsAa.sort_cells();
			if (rasterizerCellsAa.total_cells() == 0)
			{
				return false;
			}
			if (m_max_style < m_min_style)
			{
				return false;
			}
			if (y < rasterizerCellsAa.min_y() || y > rasterizerCellsAa.max_y())
			{
				return false;
			}
			m_scan_y = y;
			activeStyles.Allocate((int)(m_max_style - m_min_style + 2), 128);
			allocate_master_alpha();
			return true;
		}

		private bool hit_test(int tx, int ty)
		{
			if (!navigate_scanline(ty))
			{
				return false;
			}

			int num_styles = sweep_styles();
			if (num_styles <= 0)
			{
				return false;
			}

			scanline_hit_test sl = new scanline_hit_test(tx);
			sweep_scanline(sl, -1);
			return sl.hit();
		}

		private byte[] allocate_cover_buffer(int len)
		{
			m_cover_buf.Allocate(len, 256);
			return m_cover_buf.Array;
		}

		private void master_alpha(int style, double alpha)
		{
			if (style >= 0)
			{
				while ((int)m_master_alpha.Count <= style)
				{
					m_master_alpha.Add(aa_mask);
				}
				m_master_alpha.Array[style] = Util.uround(alpha * aa_mask);
			}
		}

		public void add_path(IVertexSource vs)
		{
			add_path(vs, 0);
		}

		public void add_path(IVertexSource vs, int path_id)
		{
			double x;
			double y;

			FlagsAndCommand cmd;
			vs.Rewind(path_id);
			if (rasterizerCellsAa.sorted()) reset();
			while (!ShapePath.IsStop(cmd = vs.Vertex(out x, out y)))
			{
				add_vertex(x, y, cmd);
			}
		}

		public int min_x()
		{
			return rasterizerCellsAa.min_x();
		}

		public int min_y()
		{
			return rasterizerCellsAa.min_y();
		}

		public int max_x()
		{
			return rasterizerCellsAa.max_x();
		}

		public int max_y()
		{
			return rasterizerCellsAa.max_y();
		}

		public int min_style()
		{
			return m_min_style;
		}

		public int max_style()
		{
			return m_max_style;
		}

		public int scanline_start()
		{
			return m_sl_start;
		}

		public int scanline_length()
		{
			return m_sl_len;
		}

		public int calculate_alpha(int area, int master_alpha)
		{
			int cover = area >> (poly_subpixel_shift * 2 + 1 - aa_shift);
			if (cover < 0) cover = -cover;
			if (fillingRule == Util.filling_rule_e.fill_even_odd)
			{
				cover &= aa_mask2;
				if (cover > aa_scale)
				{
					cover = aa_scale2 - cover;
				}
			}
			if (cover > aa_mask) cover = aa_mask;
			return (int)((cover * master_alpha + aa_mask) >> aa_shift);
		}

		public bool sweep_scanline(IScanlineCache sl)
		{
			throw new System.NotImplementedException();
		}

		// Sweeps one scanline with one style index. The style ID can be
		// determined by calling style().
		//template<class Scanline>
		public bool sweep_scanline(IScanlineCache sl, int style_idx)
		{
			int scan_y = m_scan_y - 1;
			if (scan_y > rasterizerCellsAa.max_y()) return false;

			sl.ResetSpans();

			int master_alpha = aa_mask;

			if (style_idx < 0)
			{
				style_idx = 0;
			}
			else
			{
				style_idx++;
				master_alpha = m_master_alpha[(int)(activeStyleTable[(int)style_idx] + m_min_style - 1)];
			}

			style_info st = activeStyles[activeStyleTable[style_idx]];

			int num_cells = (int)st.num_cells;
			int CellOffset = st.start_cell;
			PixelCellAa cell = m_cells[CellOffset];

			int cover = 0;
			while (num_cells-- != 0)
			{
				int alpha;
				int x = cell.x;
				int area = cell.area;

				cover += cell.cover;

				cell = m_cells[++CellOffset];

				if (area != 0)
				{
					alpha = calculate_alpha((cover << (poly_subpixel_shift + 1)) - area,
											master_alpha);
					sl.add_cell(x, alpha);
					x++;
				}

				if (num_cells != 0 && cell.x > x)
				{
					alpha = calculate_alpha(cover << (poly_subpixel_shift + 1),
											master_alpha);
					if (alpha != 0)
					{
						sl.add_span(x, cell.x - x, alpha);
					}
				}
			}

			if (sl.num_spans() == 0) return false;
			sl.finalize(scan_y);
			return true;
		}

		private void add_style(int style_id)
		{
			if (style_id < 0) style_id = 0;
			else style_id -= m_min_style - 1;

			int nbyte = (int)((int)style_id >> 3);
			int mask = (int)(1 << (style_id & 7));

			style_info[] stylesArray = activeStyles.Array;
			if ((activeStyleMask[nbyte] & mask) == 0)
			{
				activeStyleTable.Add((int)style_id);
				activeStyleMask.Array[nbyte] |= (byte)mask;
				stylesArray[style_id].start_cell = 0;
				stylesArray[style_id].num_cells = 0;
				stylesArray[style_id].last_x = -0x7FFFFFFF;
			}
			++stylesArray[style_id].start_cell;
		}

		private void allocate_master_alpha()
		{
			while ((int)m_master_alpha.Count <= m_max_style)
			{
				m_master_alpha.Add(aa_mask);
			}
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\agg_rasterizer_outline_aa.cs
using MatterHackers.Agg.VertexSource;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg
{
	//-----------------------------------------------------------line_aa_vertex
	// Vertex (x, y) with the distance to the next one. The last vertex has
	// the distance between the last and the first points
	public struct line_aa_vertex
	{
		public int x;
		public int y;
		public int len;

		public line_aa_vertex(int x_, int y_)
		{
			x = (x_);
			y = (y_);
			len = (0);
		}

		public bool Compare(line_aa_vertex val)
		{
			double dx = val.x - x;
			double dy = val.y - y;
			return (len = Util.uround(Math.Sqrt(dx * dx + dy * dy))) >
				   (LineAABasics.line_subpixel_scale + LineAABasics.line_subpixel_scale / 2);
		}
	};

	public class line_aa_vertex_sequence : VectorPOD<line_aa_vertex>
	{
		public override void Add(line_aa_vertex val)
		{
			if (base.Count > 1)
			{
				if (!Array[base.Count - 2].Compare(Array[base.Count - 1]))
				{
					base.RemoveLast();
				}
			}
			base.Add(val);
		}

		public void modify_last(line_aa_vertex val)
		{
			base.RemoveLast();
			Add(val);
		}

		public void close(bool closed)
		{
			while (base.Count > 1)
			{
				if (Array[base.Count - 2].Compare(Array[base.Count - 1])) break;
				line_aa_vertex t = this[base.Count - 1];
				base.RemoveLast();
				modify_last(t);
			}

			if (closed)
			{
				while (base.Count > 1)
				{
					if (Array[base.Count - 1].Compare(Array[0])) break;
					base.RemoveLast();
				}
			}
		}

		internal line_aa_vertex prev(int idx)
		{
			return this[(idx + currentSize - 1) % currentSize];
		}

		internal line_aa_vertex curr(int idx)
		{
			return this[idx];
		}

		internal line_aa_vertex next(int idx)
		{
			return this[(idx + 1) % currentSize];
		}
	}

	//=======================================================rasterizer_outline_aa
	public class rasterizer_outline_aa
	{
		private LineRenderer m_ren;
		private line_aa_vertex_sequence m_src_vertices = new line_aa_vertex_sequence();
		private outline_aa_join_e m_line_join;
		private bool m_round_cap;
		private int m_start_x;
		private int m_start_y;

		public enum outline_aa_join_e
		{
			outline_no_join,             //-----outline_no_join
			outline_miter_join,          //-----outline_miter_join
			outline_round_join,          //-----outline_round_join
			outline_miter_accurate_join  //-----outline_accurate_join
		};

		public bool cmp_dist_start(int d)
		{
			return d > 0;
		}

		public bool cmp_dist_end(int d)
		{
			return d <= 0;
		}

		private struct draw_vars
		{
			public int idx;
			public int x1, y1, x2, y2;
			public line_parameters curr, next;
			public int lcurr, lnext;
			public int xb1, yb1, xb2, yb2;
			public int flags;
		};

		private void draw(ref draw_vars dv, int start, int end)
		{
			int i;

			for (i = start; i < end; i++)
			{
				if (m_line_join == outline_aa_join_e.outline_round_join)
				{
					dv.xb1 = dv.curr.x1 + (dv.curr.y2 - dv.curr.y1);
					dv.yb1 = dv.curr.y1 - (dv.curr.x2 - dv.curr.x1);
					dv.xb2 = dv.curr.x2 + (dv.curr.y2 - dv.curr.y1);
					dv.yb2 = dv.curr.y2 - (dv.curr.x2 - dv.curr.x1);
				}

				switch (dv.flags)
				{
					case 0: m_ren.line3(dv.curr, dv.xb1, dv.yb1, dv.xb2, dv.yb2); break;
					case 1: m_ren.line2(dv.curr, dv.xb2, dv.yb2); break;
					case 2: m_ren.line1(dv.curr, dv.xb1, dv.yb1); break;
					case 3: m_ren.line0(dv.curr); break;
				}

				if (m_line_join == outline_aa_join_e.outline_round_join && (dv.flags & 2) == 0)
				{
					m_ren.pie(dv.curr.x2, dv.curr.y2,
							   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1),
							   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1),
							   dv.curr.x2 + (dv.next.y2 - dv.next.y1),
							   dv.curr.y2 - (dv.next.x2 - dv.next.x1));
				}

				dv.x1 = dv.x2;
				dv.y1 = dv.y2;
				dv.lcurr = dv.lnext;
				dv.lnext = m_src_vertices[dv.idx].len;

				++dv.idx;
				if (dv.idx >= m_src_vertices.Count) dv.idx = 0;

				dv.x2 = m_src_vertices[dv.idx].x;
				dv.y2 = m_src_vertices[dv.idx].y;

				dv.curr = dv.next;
				dv.next = new line_parameters(dv.x1, dv.y1, dv.x2, dv.y2, dv.lnext);
				dv.xb1 = dv.xb2;
				dv.yb1 = dv.yb2;

				switch (m_line_join)
				{
					case outline_aa_join_e.outline_no_join:
						dv.flags = 3;
						break;

					case outline_aa_join_e.outline_miter_join:
						dv.flags >>= 1;
						dv.flags |= (dv.curr.diagonal_quadrant() ==
							dv.next.diagonal_quadrant() ? 1 : 0);
						if ((dv.flags & 2) == 0)
						{
							LineAABasics.bisectrix(dv.curr, dv.next, out dv.xb2, out dv.yb2);
						}
						break;

					case outline_aa_join_e.outline_round_join:
						dv.flags >>= 1;
						dv.flags |= (((dv.curr.diagonal_quadrant() ==
							dv.next.diagonal_quadrant()) ? 1 : 0) << 1);
						break;

					case outline_aa_join_e.outline_miter_accurate_join:
						dv.flags = 0;
						LineAABasics.bisectrix(dv.curr, dv.next, out dv.xb2, out dv.yb2);
						break;
				}
			}
		}

		public rasterizer_outline_aa(LineRenderer ren)
		{
			m_ren = ren;
			m_line_join = (OutlineRenderer.accurate_join_only() ?
							outline_aa_join_e.outline_miter_accurate_join :
							outline_aa_join_e.outline_round_join);
			m_round_cap = (false);
			m_start_x = (0);
			m_start_y = (0);
		}

		public void attach(LineRenderer ren)
		{
			m_ren = ren;
		}

		public void line_join(outline_aa_join_e join)
		{
			m_line_join = OutlineRenderer.accurate_join_only() ?
				outline_aa_join_e.outline_miter_accurate_join :
				join;
		}

		public outline_aa_join_e line_join()
		{
			return m_line_join;
		}

		public void round_cap(bool v)
		{
			m_round_cap = v;
		}

		public bool round_cap()
		{
			return m_round_cap;
		}

		public void move_to(int x, int y)
		{
			m_src_vertices.modify_last(new line_aa_vertex(m_start_x = x, m_start_y = y));
		}

		public void line_to(int x, int y)
		{
			m_src_vertices.Add(new line_aa_vertex(x, y));
		}

		public void move_to_d(double x, double y)
		{
			move_to(line_coord_sat.conv(x), line_coord_sat.conv(y));
		}

		public void line_to_d(double x, double y)
		{
			line_to(line_coord_sat.conv(x), line_coord_sat.conv(y));
		}

		public void render(bool close_polygon)
		{
			m_src_vertices.close(close_polygon);
			draw_vars dv = new draw_vars();
			line_aa_vertex v;
			int x1;
			int y1;
			int x2;
			int y2;
			int lprev;

			if (close_polygon)
			{
				if (m_src_vertices.Count >= 3)
				{
					dv.idx = 2;

					v = m_src_vertices[m_src_vertices.Count - 1];
					x1 = v.x;
					y1 = v.y;
					lprev = v.len;

					v = m_src_vertices[0];
					x2 = v.x;
					y2 = v.y;
					dv.lcurr = v.len;
					line_parameters prev = new line_parameters(x1, y1, x2, y2, lprev);

					v = m_src_vertices[1];
					dv.x1 = v.x;
					dv.y1 = v.y;
					dv.lnext = v.len;
					dv.curr = new line_parameters(x2, y2, dv.x1, dv.y1, dv.lcurr);

					v = m_src_vertices[dv.idx];
					dv.x2 = v.x;
					dv.y2 = v.y;
					dv.next = new line_parameters(dv.x1, dv.y1, dv.x2, dv.y2, dv.lnext);

					dv.xb1 = 0;
					dv.yb1 = 0;
					dv.xb2 = 0;
					dv.yb2 = 0;

					switch (m_line_join)
					{
						case outline_aa_join_e.outline_no_join:
							dv.flags = 3;
							break;

						case outline_aa_join_e.outline_miter_join:
						case outline_aa_join_e.outline_round_join:
							dv.flags =
								(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |
									((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);
							break;

						case outline_aa_join_e.outline_miter_accurate_join:
							dv.flags = 0;
							break;
					}

					if ((dv.flags & 1) == 0 && m_line_join != outline_aa_join_e.outline_round_join)
					{
						LineAABasics.bisectrix(prev, dv.curr, out dv.xb1, out dv.yb1);
					}

					if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)
					{
						LineAABasics.bisectrix(dv.curr, dv.next, out dv.xb2, out dv.yb2);
					}
					draw(ref dv, 0, m_src_vertices.Count);
				}
			}
			else
			{
				switch (m_src_vertices.Count)
				{
					case 0:
					case 1:
						break;

					case 2:
						{
							v = m_src_vertices[0];
							x1 = v.x;
							y1 = v.y;
							lprev = v.len;
							v = m_src_vertices[1];
							x2 = v.x;
							y2 = v.y;
							line_parameters lp = new line_parameters(x1, y1, x2, y2, lprev);
							if (m_round_cap)
							{
								m_ren.semidot(cmp_dist_start, x1, y1, x1 + (y2 - y1), y1 - (x2 - x1));
							}
							m_ren.line3(lp,
										 x1 + (y2 - y1),
										 y1 - (x2 - x1),
										 x2 + (y2 - y1),
										 y2 - (x2 - x1));
							if (m_round_cap)
							{
								m_ren.semidot(cmp_dist_end, x2, y2, x2 + (y2 - y1), y2 - (x2 - x1));
							}
						}
						break;

					case 3:
						{
							int x3, y3;
							int lnext;
							v = m_src_vertices[0];
							x1 = v.x;
							y1 = v.y;
							lprev = v.len;
							v = m_src_vertices[1];
							x2 = v.x;
							y2 = v.y;
							lnext = v.len;
							v = m_src_vertices[2];
							x3 = v.x;
							y3 = v.y;
							line_parameters lp1 = new line_parameters(x1, y1, x2, y2, lprev);
							line_parameters lp2 = new line_parameters(x2, y2, x3, y3, lnext);

							if (m_round_cap)
							{
								m_ren.semidot(cmp_dist_start, x1, y1, x1 + (y2 - y1), y1 - (x2 - x1));
							}

							if (m_line_join == outline_aa_join_e.outline_round_join)
							{
								m_ren.line3(lp1, x1 + (y2 - y1), y1 - (x2 - x1),
												  x2 + (y2 - y1), y2 - (x2 - x1));

								m_ren.pie(x2, y2, x2 + (y2 - y1), y2 - (x2 - x1),
												   x2 + (y3 - y2), y2 - (x3 - x2));

								m_ren.line3(lp2, x2 + (y3 - y2), y2 - (x3 - x2),
												  x3 + (y3 - y2), y3 - (x3 - x2));
							}
							else
							{
								LineAABasics.bisectrix(lp1, lp2, out dv.xb1, out dv.yb1);
								m_ren.line3(lp1, x1 + (y2 - y1), y1 - (x2 - x1),
												  dv.xb1, dv.yb1);

								m_ren.line3(lp2, dv.xb1, dv.yb1,
												  x3 + (y3 - y2), y3 - (x3 - x2));
							}
							if (m_round_cap)
							{
								m_ren.semidot(cmp_dist_end, x3, y3, x3 + (y3 - y2), y3 - (x3 - x2));
							}
						}
						break;

					default:
						{
							dv.idx = 3;

							v = m_src_vertices[0];
							x1 = v.x;
							y1 = v.y;
							lprev = v.len;

							v = m_src_vertices[1];
							x2 = v.x;
							y2 = v.y;
							dv.lcurr = v.len;
							line_parameters prev = new line_parameters(x1, y1, x2, y2, lprev);

							v = m_src_vertices[2];
							dv.x1 = v.x;
							dv.y1 = v.y;
							dv.lnext = v.len;
							dv.curr = new line_parameters(x2, y2, dv.x1, dv.y1, dv.lcurr);

							v = m_src_vertices[dv.idx];
							dv.x2 = v.x;
							dv.y2 = v.y;
							dv.next = new line_parameters(dv.x1, dv.y1, dv.x2, dv.y2, dv.lnext);

							dv.xb1 = 0;
							dv.yb1 = 0;
							dv.xb2 = 0;
							dv.yb2 = 0;

							switch (m_line_join)
							{
								case outline_aa_join_e.outline_no_join:
									dv.flags = 3;
									break;

								case outline_aa_join_e.outline_miter_join:
								case outline_aa_join_e.outline_round_join:
									dv.flags =
										(prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |
											((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);
									break;

								case outline_aa_join_e.outline_miter_accurate_join:
									dv.flags = 0;
									break;
							}

							if (m_round_cap)
							{
								m_ren.semidot(cmp_dist_start, x1, y1, x1 + (y2 - y1), y1 - (x2 - x1));
							}
							if ((dv.flags & 1) == 0)
							{
								if (m_line_join == outline_aa_join_e.outline_round_join)
								{
									m_ren.line3(prev, x1 + (y2 - y1), y1 - (x2 - x1),
													   x2 + (y2 - y1), y2 - (x2 - x1));
									m_ren.pie(prev.x2, prev.y2,
											   x2 + (y2 - y1), y2 - (x2 - x1),
											   dv.curr.x1 + (dv.curr.y2 - dv.curr.y1),
											   dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));
								}
								else
								{
									LineAABasics.bisectrix(prev, dv.curr, out dv.xb1, out dv.yb1);
									m_ren.line3(prev, x1 + (y2 - y1), y1 - (x2 - x1),
													   dv.xb1, dv.yb1);
								}
							}
							else
							{
								m_ren.line1(prev,
											 x1 + (y2 - y1),
											 y1 - (x2 - x1));
							}
							if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)
							{
								LineAABasics.bisectrix(dv.curr, dv.next, out dv.xb2, out dv.yb2);
							}

							draw(ref dv, 1, m_src_vertices.Count - 2);

							if ((dv.flags & 1) == 0)
							{
								if (m_line_join == outline_aa_join_e.outline_round_join)
								{
									m_ren.line3(dv.curr,
												 dv.curr.x1 + (dv.curr.y2 - dv.curr.y1),
												 dv.curr.y1 - (dv.curr.x2 - dv.curr.x1),
												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1),
												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
								}
								else
								{
									m_ren.line3(dv.curr, dv.xb1, dv.yb1,
												 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1),
												 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
								}
							}
							else
							{
								m_ren.line2(dv.curr,
											 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1),
											 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
							}
							if (m_round_cap)
							{
								m_ren.semidot(cmp_dist_end, dv.curr.x2, dv.curr.y2,
											   dv.curr.x2 + (dv.curr.y2 - dv.curr.y1),
											   dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
							}
						}
						break;
				}
			}
			m_src_vertices.Clear();
		}

		public void add_vertex(double x, double y, FlagsAndCommand cmd)
		{
			if (ShapePath.IsMoveTo(cmd))
			{
				render(false);
				move_to_d(x, y);
			}
			else
			{
				if (ShapePath.is_end_poly(cmd))
				{
					render(ShapePath.is_closed(cmd));
					if (ShapePath.is_closed(cmd))
					{
						move_to(m_start_x, m_start_y);
					}
				}
				else
				{
					line_to_d(x, y);
				}
			}
		}

		public void add_path(IVertexSource vs)
		{
			add_path(vs, 0);
		}

		public void add_path(IVertexSource vs, int path_id)
		{
			double x;
			double y;

			FlagsAndCommand cmd;
			vs.Rewind(path_id);

			//int index = 0;
			//int start = 851;
			//int num = 5;

			while (!ShapePath.IsStop(cmd = vs.Vertex(out x, out y)))
			{
				//index++;
				//if (index == 0
				//  || (index > start && index < start + num))
				add_vertex(x, y, cmd);
			}
			render(false);
		}

		public void RenderAllPaths(IVertexSource vs,
							  Color[] colors,
							  int[] path_id,
							  int num_paths)
		{
			for (int i = 0; i < num_paths; i++)
			{
				m_ren.color(colors[i]);
				add_path(vs, path_id[i]);
			}
		}

		/* // for debugging only
		public void render_path_index(IVertexSource vs,
							  RGBA_Bytes[] colors,
							  int[] path_id,
							  int pathIndex)
		{
			m_ren.color(colors[pathIndex]);
			add_path(vs, path_id[pathIndex]);
		}
		 */
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\agg_scanline_bin.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Class scanline_bin - binary scanline.
//
//----------------------------------------------------------------------------
//
// Adaptation for 32-bit screen coordinates (scanline32_bin) has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------

namespace MatterHackers.Agg
{
	//=============================================================scanline_bin
	//
	// This is binary scanline container which supports the interface
	// used in the rasterizer::render(). See description of agg_scanline_u8
	// for details.
	//
	//------------------------------------------------------------------------
	public sealed class scanline_bin : IScanlineCache
	{
		private int m_last_x;
		private int m_y;
		private ArrayPOD<ScanlineSpan> m_spans;
		private int m_span_index;
		private int m_interator_index;

		public ScanlineSpan GetNextScanlineSpan()
		{
			m_interator_index++;
			return m_spans.Array[m_interator_index - 1];
		}

		//--------------------------------------------------------------------
		public scanline_bin()
		{
			m_last_x = (0x7FFFFFF0);
			m_spans = new ArrayPOD<ScanlineSpan>(1000);
			m_span_index = 0;
		}

		//--------------------------------------------------------------------
		public void reset(int min_x, int max_x)
		{
			int max_len = max_x - min_x + 3;
			if (max_len > m_spans.Size())
			{
				m_spans.Resize(max_len);
			}
			m_last_x = 0x7FFFFFF0;
			m_span_index = 0;
		}

		//--------------------------------------------------------------------
		public void add_cell(int x, int cover)
		{
			if (x == m_last_x + 1)
			{
				m_spans.Array[m_span_index].len++;
			}
			else
			{
				m_span_index++;
				m_spans.Array[m_span_index].x = (int)x;
				m_spans.Array[m_span_index].len = 1;
			}
			m_last_x = x;
		}

		//--------------------------------------------------------------------
		public void add_span(int x, int len, int cover)
		{
			if (x == m_last_x + 1)
			{
				m_spans.Array[m_span_index].len += (int)len;
			}
			else
			{
				m_span_index++;
				m_spans.Array[m_span_index].x = x;
				m_spans.Array[m_span_index].len = (int)len;
			}
			m_last_x = x + len - 1;
		}

		/*
		//--------------------------------------------------------------------
		public void add_cells(int x, int len, void*)
		{
			add_span(x, len, 0);
		}
		 */

		//--------------------------------------------------------------------
		public void finalize(int y)
		{
			m_y = y;
		}

		//--------------------------------------------------------------------
		public void ResetSpans()
		{
			m_last_x = 0x7FFFFFF0;
			m_span_index = 0;
		}

		//--------------------------------------------------------------------
		public int y()
		{
			return m_y;
		}

		public int num_spans()
		{
			return (int)m_span_index;
		}

		public ScanlineSpan begin()
		{
			m_interator_index = 1;
			return GetNextScanlineSpan();
		}

		public byte[] GetCovers()
		{
			return null;
		}
	};

    /*
//===========================================================scanline32_bin
class scanline32_bin
{
public:
	typedef int32 coord_type;

	//--------------------------------------------------------------------
	struct span
	{
		span() {}
		span(coord_type x_, coord_type len_) : x(x_), len(len_) {}

		coord_type x;
		coord_type len;
	};
	typedef pod_bvector<span, 4> span_array_type;

	//--------------------------------------------------------------------
	class_iterator
	{
	public:
	   _iterator(span_array_type& spans) :
			m_spans(spans),
			m_span_idx(0)
		{}

		span& operator*()  { return m_spans[m_span_idx];  }
		span* operator->() { return &m_spans[m_span_idx]; }

		void operator ++ () { ++m_span_idx; }

	private:
		span_array_type& m_spans;
		int               m_span_idx;
	};

	//--------------------------------------------------------------------
	scanline32_bin() : m_max_len(0), m_last_x(0x7FFFFFF0) {}

	//--------------------------------------------------------------------
	void reset(int min_x, int max_x)
	{
		m_last_x = 0x7FFFFFF0;
		m_spans.Clear;
	}

	//--------------------------------------------------------------------
	void add_cell(int x, int)
	{
		if(x == m_last_x+1)
		{
			m_spans.last().len++;
		}
		else
		{
			m_spans.add(span(coord_type(x), 1));
		}
		m_last_x = x;
	}

	//--------------------------------------------------------------------
	void add_span(int x, int len, int)
	{
		if(x == m_last_x+1)
		{
			m_spans.last().len += coord_type(len);
		}
		else
		{
			m_spans.add(span(coord_type(x), coord_type(len)));
		}
		m_last_x = x + len - 1;
	}

	//--------------------------------------------------------------------
	void add_cells(int x, int len, void*)
	{
		add_span(x, len, 0);
	}

	//--------------------------------------------------------------------
	void finalize(int y)
	{
		m_y = y;
	}

	//--------------------------------------------------------------------
	void reset_spans()
	{
		m_last_x = 0x7FFFFFF0;
		m_spans.Clear;
	}

	//--------------------------------------------------------------------
	int            y()         { return m_y; }
	int       num_spans() { return m_spans.size(); }
   _iterator begin()     { return_iterator(m_spans); }

private:
	scanline32_bin(scanline32_bin&);
	scanline32_bin operator = (scanline32_bin&);

	int        m_max_len;
	int             m_last_x;
	int             m_y;
	span_array_type m_spans;
};
	 */
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\agg_simul_eq.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Solving simultaneous equations
//
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg
{
	//============================================================matrix_pivot
	//template<uint Rows, uint Cols>
	public static class matrix_pivot
	{
		private static void swap_arrays_index1(double[,] a1, uint a1Index0, double[,] a2, uint a2Index0)
		{
			int Cols = a1.GetLength(1);
			if (a2.GetLength(1) != Cols)
			{
				throw new System.FormatException("a1 and a2 must have the same second dimension.");
			}
			for (int i = 0; i < Cols; i++)
			{
				double tmp = a1[a1Index0, i];
				a1[a1Index0, i] = a2[a2Index0, i];
				a2[a2Index0, i] = tmp;
			}
		}

		public static int pivot(double[,] m, uint row)
		{
			int k = (int)(row);
			double max_val, tmp;

			max_val = -1.0;
			int i;
			int Rows = m.GetLength(0);
			for (i = (int)row; i < Rows; i++)
			{
				if ((tmp = Math.Abs(m[i, row])) > max_val && tmp != 0.0)
				{
					max_val = tmp;
					k = i;
				}
			}

			if (m[k, row] == 0.0)
			{
				return -1;
			}

			if (k != (int)(row))
			{
				swap_arrays_index1(m, (uint)k, m, row);
				return k;
			}
			return 0;
		}
	};

	//===============================================================simul_eq
	//template<uint Size, uint RightCols>
	internal struct simul_eq
	{
		public static bool solve(double[,] left,
						  double[,] right,
						  double[,] result)
		{
			if (left.GetLength(0) != 4
				|| right.GetLength(0) != 4
				|| left.GetLength(1) != 4
				|| result.GetLength(0) != 4
				|| right.GetLength(1) != 2
				|| result.GetLength(1) != 2)
			{
				throw new System.FormatException("left right and result must all be the same size.");
			}
			double a1;
			int Size = right.GetLength(0);
			int RightCols = right.GetLength(1);

			double[,] tmp = new double[Size, Size + RightCols];

			for (int i = 0; i < Size; i++)
			{
				for (int j = 0; j < Size; j++)
				{
					tmp[i, j] = left[i, j];
				}
				for (int j = 0; j < RightCols; j++)
				{
					tmp[i, Size + j] = right[i, j];
				}
			}

			for (int k = 0; k < Size; k++)
			{
				if (matrix_pivot.pivot(tmp, (uint)k) < 0)
				{
					return false; // Singularity....
				}

				a1 = tmp[k, k];

				for (int j = k; j < Size + RightCols; j++)
				{
					tmp[k, j] /= a1;
				}

				for (int i = k + 1; i < Size; i++)
				{
					a1 = tmp[i, k];
					for (int j = k; j < Size + RightCols; j++)
					{
						tmp[i, j] -= a1 * tmp[k, j];
					}
				}
			}

			for (int k = 0; k < RightCols; k++)
			{
				int m;
				for (m = (int)(Size - 1); m >= 0; m--)
				{
					result[m, k] = tmp[m, Size + k];
					for (int j = m + 1; j < Size; j++)
					{
						result[m, k] -= tmp[m, j] * result[j, k];
					}
				}
			}
			return true;
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\agg_VertexSequence.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// vertex_sequence container and vertex_dist struct
//
//----------------------------------------------------------------------------

namespace MatterHackers.Agg
{
	//----------------------------------------------------------vertex_sequence
	// Modified agg::pod_vector. The data is interpreted as a sequence
	// of vertices. It means that the type T must expose:
	//
	// bool T::operator() (const T& val)
	//
	// that is called every time a new vertex is being added. The main purpose
	// of this operator is the possibility to calculate some values during
	// adding and to return true if the vertex fits some criteria or false if
	// it doesn't. In the last case the new vertex is not added.
	//
	// The simple example is filtering coinciding vertices with calculation
	// of the distance between the current and previous ones:
	//
	//    struct vertex_dist
	//    {
	//        double   x;
	//        double   y;
	//        double   dist;
	//
	//        vertex_dist() {}
	//        vertex_dist(double x_, double y_) :
	//            x(x_),
	//            y(y_),
	//            dist(0.0)
	//        {
	//        }
	//
	//        bool operator () (const vertex_dist& val)
	//        {
	//            return (dist = calc_distance(x, y, val.x, val.y)) > EPSILON;
	//        }
	//    };
	//
	// Function close() calls this operator and removes the last vertex if
	// necessary.
	//------------------------------------------------------------------------
	public class VertexSequence : VectorPOD<VertexDistance>
	{
		public override void Add(VertexDistance val)
		{
			if (base.Count > 1)
			{
				if (!Array[base.Count - 2].IsEqual(Array[base.Count - 1]))
				{
					base.RemoveLast();
				}
			}
			base.Add(val);
		}

		public void modify_last(VertexDistance val)
		{
			base.RemoveLast();
			Add(val);
		}

		public void close(bool closed)
		{
			while (base.Count > 1)
			{
				if (Array[base.Count - 2].IsEqual(Array[base.Count - 1])) break;
				VertexDistance t = this[base.Count - 1];
				base.RemoveLast();
				modify_last(t);
			}

			if (closed)
			{
				while (base.Count > 1)
				{
					if (Array[base.Count - 1].IsEqual(Array[0])) break;
					base.RemoveLast();
				}
			}
		}

		internal VertexDistance prev(int idx)
		{
			return this[(idx + currentSize - 1) % currentSize];
		}

		internal VertexDistance curr(int idx)
		{
			return this[idx];
		}

		internal VertexDistance next(int idx)
		{
			return this[(idx + 1) % currentSize];
		}
	}

	//-------------------------------------------------------------vertex_dist
	// Vertex (x, y) with the distance to the next one. The last vertex has
	// distance between the last and the first points if the polygon is closed
	// and 0.0 if it's a polyline.
	public struct VertexDistance
	{
		public double x;
		public double y;
		public double dist;

		public VertexDistance(double x_, double y_)
		{
			x = x_;
			y = y_;
			dist = 0.0;
		}

		public bool IsEqual(VertexDistance val)
		{
			bool ret = (dist = agg_math.CalcDistance(x, y, val.x, val.y)) > agg_math.vertex_dist_epsilon;
			if (!ret) dist = 1.0 / agg_math.vertex_dist_epsilon;
			return ret;
		}
	}

	/*
	//--------------------------------------------------------vertex_dist_cmd
	// Save as the above but with additional "command" value
	struct vertex_dist_cmd : vertex_dist
	{
		unsigned cmd;

		vertex_dist_cmd() {}
		vertex_dist_cmd(double x_, double y_, unsigned cmd_) :
			base (x_, y_)

		{
			cmd = cmd;
		}
	};
	 */
}

//#endif

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\DebugLogger.cs
/*
Copyright (c) 2025, Lars Brubaker
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;

namespace Agg
{
    /// <summary>
    /// Debug logging levels from lowest to highest priority
    /// </summary>
    public enum DebugLevel
    {
        Message = 0,
        Warning = 1,
        Error = 2,
        Fatal = 3
    }

    /// <summary>
    /// Static class for handling debug logging with filter and level-based controls
    /// </summary>
    public static class DebugLogger
    {
        private static readonly HashSet<string> debugFilters = new HashSet<string>();
        private static readonly string debugLogPath = Path.Combine("C:", "Development", "MatterCAD", "debug_log.txt");
        private static readonly object debugLogLock = new object();
        private static DebugLevel minimumLevel = DebugLevel.Error; // Default to Error level and above

        /// <summary>
        /// Gets or sets the minimum debug level that will be logged
        /// </summary>
        public static DebugLevel MinimumLevel
        {
            get => minimumLevel;
            set => minimumLevel = value;
        }

        /// <summary>
        /// Enables debug logging for the specified filter category
        /// </summary>
        /// <param name="filter">Debug filter category to enable</param>
        public static void EnableFilter(string filter)
        {
            debugFilters.Add(filter);
        }

        /// <summary>
        /// Disables debug logging for the specified filter category
        /// </summary>
        /// <param name="filter">Debug filter category to disable</param>
        public static void DisableFilter(string filter)
        {
            debugFilters.Remove(filter);
        }

        /// <summary>
        /// Checks if a debug filter is enabled
        /// </summary>
        /// <param name="filter">Debug filter category to check</param>
        /// <returns>True if the filter is enabled</returns>
        public static bool IsFilterEnabled(string filter)
        {
            return debugFilters.Contains(filter);
        }

        /// <summary>
        /// Clears all debug filters
        /// </summary>
        public static void ClearFilters()
        {
            debugFilters.Clear();
        }

        /// <summary>
        /// Gets all currently enabled debug filters
        /// </summary>
        /// <returns>A copy of the enabled filters</returns>
        public static HashSet<string> GetEnabledFilters()
        {
            return new HashSet<string>(debugFilters);
        }

        /// <summary>
        /// Clears the debug log file
        /// </summary>
        public static void ClearLog()
        {
            try
            {
                if (File.Exists(debugLogPath))
                {
                    File.Delete(debugLogPath);
                }
            }
            catch
            {
                // Ignore file access errors
            }
        }

        /// <summary>
        /// Gets the current debug log file path
        /// </summary>
        /// <returns>The debug log file path</returns>
        public static string GetLogPath()
        {
            return debugLogPath;
        }

        /// <summary>
        /// Logs debug information if the specified filter is enabled OR if the level meets the minimum threshold
        /// </summary>
        /// <param name="filter">Debug filter category</param>
        /// <param name="message">Debug message</param>
        /// <param name="level">Debug level (defaults to Message)</param>
        [Conditional("DEBUG")]
        public static void Log(string filter, string message, DebugLevel level = DebugLevel.Message)
        {
#if !DEBUG
            // In release builds, only log errors and failures
            if (level < DebugLevel.Error)
            {
                return;
            }
#endif

            // Log if either:
            // 1. The filter is specifically enabled, OR
            // 2. The level meets or exceeds the minimum level threshold
            bool shouldLog = debugFilters.Contains(filter) || level >= minimumLevel;

            if (shouldLog)
            {
                var levelString = level switch
                {
                    DebugLevel.Message => "MSG",
                    DebugLevel.Warning => "WARN",
                    DebugLevel.Error => "ERROR",
                    DebugLevel.Fatal => "FAIL",
                    _ => "UNKNOWN"
                };

                var logMessage = $"[{levelString}] [{filter}] {message}";
                Debug.WriteLine(logMessage);

                // Also write to file with thread synchronization
                lock (debugLogLock)
                {
                    try
                    {
                        var timestamp = DateTime.Now.ToString("HH:mm:ss.fff");
                        File.AppendAllText(debugLogPath, $"{timestamp} {logMessage}\n");
                    }
                    catch
                    {
                        // Ignore file access errors
                    }
                }
            }
        }

        /// <summary>
        /// Logs a message-level debug entry
        /// This is typically used for tracing execution flow
        /// </summary>
        /// <param name="filter">Debug filter category</param>
        /// <param name="message">Debug message</param>
        [Conditional("DEBUG")]
        public static void LogMessage(string filter, string message)
        {
            Log(filter, message, DebugLevel.Message);
        }

        /// <summary>
        /// Logs a warning-level debug entry
        /// This is typically used for recoverable errors
        /// </summary>
        /// <param name="filter">Debug filter category</param>
        /// <param name="message">Debug message</param>
        [Conditional("DEBUG")]
        public static void LogWarning(string filter, string message)
        {
            Log(filter, message, DebugLevel.Warning);
        }

        /// <summary>
        /// Logs an error-level debug entry
        /// This is typically used for recoverable errors
        /// </summary>
        /// <param name="filter">Debug filter category</param>
        /// <param name="message">Debug message</param>
        [Conditional("DEBUG")]
        public static void LogError(string filter, string message)
        {
            Log(filter, message, DebugLevel.Error);
        }

        /// <summary>
        /// Logs a fatal-level debug entry
        /// This level indicates a critical failure that will likely cause the application to terminate.
        /// </summary>
        /// <param name="filter">Debug filter category</param>
        /// <param name="message">Debug message</param>
        [Conditional("DEBUG")]
        public static void LogFatal(string filter, string message)
        {
            Log(filter, message, DebugLevel.Fatal);
        }
    }
} 

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\FloodFiller.cs
/*
Copyright (c) 2014, Lars Brubaker, Kevin Pope
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using MatterHackers.Agg.Image;

namespace MatterHackers.Agg
{
	public class FloodFill
	{
		protected byte[] destBuffer = null;

		protected int imageStride = 0;

		protected bool[] pixelsChecked;

		private ImageBuffer destImage;

		private FillingRule fillRule;

		private FirstInFirstOutQueue<Range> ranges = new FirstInFirstOutQueue<Range>(9);

		public FloodFill(Color fillColor)
		{
			fillRule = new ExactMatch(fillColor);
		}

		public FloodFill(Color fillColor, int tolerance0To255)
		{
			if (tolerance0To255 > 0)
			{
				fillRule = new ToleranceMatch(fillColor, tolerance0To255);
			}
			else
			{
				fillRule = new ExactMatch(fillColor);
			}
		}

		public FloodFill(FillingRule fillRule)
		{
			this.fillRule = fillRule;
		}

		public void Fill(ImageBuffer bufferToFillOn, int x, int y)
		{
			unchecked // this way we can overflow the uint on negative and get a big number
			{
				if ((uint)x > bufferToFillOn.Width || (uint)y > bufferToFillOn.Height)
				{
					return;
				}
			}

			destImage = bufferToFillOn;
			imageStride = destImage.StrideInBytes();
			destBuffer = destImage.GetBuffer();
			int imageWidth = destImage.Width;
			int imageHeight = destImage.Height;

			pixelsChecked = new bool[destImage.Width * destImage.Height];

			int startColorBufferOffset = destImage.GetBufferOffsetXY(x, y);

			fillRule.SetStartColor(new Color(destImage.GetBuffer()[startColorBufferOffset + 2], destImage.GetBuffer()[startColorBufferOffset + 1], destImage.GetBuffer()[startColorBufferOffset]));

			LinearFill(x, y);

			while (ranges.Count > 0)
			{
				Range range = ranges.Dequeue();

				int downY = range.y - 1;
				int upY = range.y + 1;
				int downPixelOffset = (imageWidth * (range.y - 1)) + range.startX;
				int upPixelOffset = (imageWidth * (range.y + 1)) + range.startX;
				for (int rangeX = range.startX; rangeX <= range.endX; rangeX++)
				{
					if (range.y > 0)
					{
						if (!pixelsChecked[downPixelOffset])
						{
							int bufferOffset = destImage.GetBufferOffsetXY(rangeX, downY);
							if (fillRule.CheckPixel(destBuffer, bufferOffset))
							{
								LinearFill(rangeX, downY);
							}
						}
					}

					if (range.y < (imageHeight - 1))
					{
						if (!pixelsChecked[upPixelOffset])
						{
							int bufferOffset = destImage.GetBufferOffsetXY(rangeX, upY);
							if (fillRule.CheckPixel(destBuffer, bufferOffset))
							{
								LinearFill(rangeX, upY);
							}
						}
					}
					upPixelOffset++;
					downPixelOffset++;
				}
			}
		}

		private void LinearFill(int x, int y)
		{
			int bytesPerPixel = destImage.GetBytesBetweenPixelsInclusive();
			int imageWidth = destImage.Width;

			int leftFillX = x;
			int bufferOffset = destImage.GetBufferOffsetXY(x, y);
			int pixelOffset = (imageWidth * y) + x;
			while (true)
			{
				fillRule.SetPixel(destBuffer, bufferOffset);
				pixelsChecked[pixelOffset] = true;
				leftFillX--;
				pixelOffset--;
				bufferOffset -= bytesPerPixel;
				if (leftFillX <= 0 || (pixelsChecked[pixelOffset]) || !fillRule.CheckPixel(destBuffer, bufferOffset))
				{
					break;
				}
			}
			leftFillX++;

			int rightFillX = x;
			bufferOffset = destImage.GetBufferOffsetXY(x, y);
			pixelOffset = (imageWidth * y) + x;
			while (true)
			{
				fillRule.SetPixel(destBuffer, bufferOffset);
				pixelsChecked[pixelOffset] = true;
				rightFillX++;
				pixelOffset++;
				bufferOffset += bytesPerPixel;
				if (rightFillX >= imageWidth || pixelsChecked[pixelOffset] || !fillRule.CheckPixel(destBuffer, bufferOffset))
				{
					break;
				}
			}
			rightFillX--;

			ranges.Enqueue(new Range(leftFillX, rightFillX, y));
		}

		private struct Range
		{
			public int endX;
			public int startX;
			public int y;

			public Range(int startX, int endX, int y)
			{
				this.startX = startX;
				this.endX = endX;
				this.y = y;
			}
		}

		public class ExactMatch : FillingRule
		{
			public ExactMatch(Color fillColor)
				: base(fillColor)
			{
			}

			public override bool CheckPixel(byte[] destBuffer, int bufferOffset)
			{
				return (destBuffer[bufferOffset] == startColor.red) &&
					(destBuffer[bufferOffset + 1] == startColor.green) &&
					(destBuffer[bufferOffset + 2] == startColor.blue);
			}
		}

		public abstract class FillingRule
		{
			protected Color fillColor;
			protected Color startColor;

			protected FillingRule(Color fillColor)
			{
				this.fillColor = fillColor;
			}

			public abstract bool CheckPixel(byte[] destBuffer, int bufferOffset);

			public virtual void SetPixel(byte[] destBuffer, int bufferOffset)
			{
				destBuffer[bufferOffset] = fillColor.blue;
				destBuffer[bufferOffset + 1] = fillColor.green;
				destBuffer[bufferOffset + 2] = fillColor.red;
			}

			public void SetStartColor(Color startColor)
			{
				this.startColor = startColor;
			}
		}

		public class ToleranceMatch : FillingRule
		{
			private int tolerance0To255;

			public ToleranceMatch(Color fillColor, int tolerance0To255)
				: base(fillColor)
			{
				this.tolerance0To255 = tolerance0To255;
			}

			public override bool CheckPixel(byte[] destBuffer, int bufferOffset)
			{
				return (destBuffer[bufferOffset] >= (startColor.red - tolerance0To255)) && destBuffer[bufferOffset] <= (startColor.red + tolerance0To255) &&
					(destBuffer[bufferOffset + 1] >= (startColor.green - tolerance0To255)) && destBuffer[bufferOffset + 1] <= (startColor.green + tolerance0To255) &&
					(destBuffer[bufferOffset + 2] >= (startColor.blue - tolerance0To255)) && destBuffer[bufferOffset + 2] <= (startColor.blue + tolerance0To255);
			}
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Font\LiberationSansBoldFont.cs
using System;

namespace MatterHackers.Agg.Font
{
	public class LiberationSansBoldFont
	{
		private static TypeFace instance;

		public static TypeFace Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new TypeFace();
					instance.ReadSVG(FontData());
				}

				return instance;
			}
		}

		private static String FontData()
		{
			return @"<?xml version=""1.0"" standalone=""no""?>
<!DOCTYPE svg PUBLIC ""-//W3C//DTD SVG 1.1//EN"" ""http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"" >
<svg>
<metadata>
Created by FontForge 20110222 at Mon Jun 27 20:33:49 2011
 By Application Server
Copyright (c) 2007 Red Hat, Inc. All rights reserved. LIBERATION is a trademark of Red Hat, Inc.
</metadata>
<defs>
<font id=""LiberationSans-Bold"" horiz-adv-x=""1139"" >
  <font-face 
    font-family=""Liberation Sans""
    font-weight=""700""
    font-stretch=""normal""
    units-per-em=""2048""
    panose-1=""2 11 7 4 2 2 2 2 2 4""
    ascent=""1638""
    descent=""-410""
    x-height=""1082""
    cap-height=""1409""
    bbox=""-377 -621 2175 2116""
    underline-thickness=""215""
    underline-position=""-110""
    unicode-range=""U+0020-F005""
  />
<missing-glyph horiz-adv-x=""748"" 
d=""M68 0v1365h544v-1365h-544zM136 68h408v1229h-408v-1229z"" />
    <glyph glyph-name="".notdef"" horiz-adv-x=""748"" 
d=""M68 0v1365h544v-1365h-544zM136 68h408v1229h-408v-1229z"" />
    <glyph glyph-name="".null"" horiz-adv-x=""0"" 
 />
    <glyph glyph-name=""nonmarkingreturn"" horiz-adv-x=""682"" 
 />
    <glyph glyph-name=""uni00A0"" unicode="" "" horiz-adv-x=""569"" 
 />
    <glyph glyph-name=""uni00A0"" unicode=""&#xa0;"" horiz-adv-x=""569"" 
 />
    <glyph glyph-name=""exclam"" unicode=""!"" horiz-adv-x=""682"" 
d=""M455 426h-230l-32 983h294zM193 0v270h288v-270h-288z"" />
    <glyph glyph-name=""quotedbl"" unicode=""&#x22;"" horiz-adv-x=""971"" 
d=""M807 898h-219l-27 511h275zM381 898h-219l-27 511h273z"" />
    <glyph glyph-name=""numbersign"" unicode=""#"" 
d=""M909 862l-69 -332h215v-149h-246l-82 -381h-156l80 381h-307l-80 -381h-153l79 381h-155v149h188l70 332h-207v148h238l84 385h153l-82 -385h307l84 385h156l-84 -385h164v-148h-197zM449 862l-72 -332h309l70 332h-307z"" />
    <glyph glyph-name=""dollar"" unicode=""$"" 
d=""M1110 412q0 -85 -28 -154.5t-86.5 -120t-149.5 -80t-217 -34.5v-175h-109v172q-114 4 -198.5 31t-144 76t-96 119.5t-54.5 161.5l256 47q8 -48 23.5 -87.5t42.5 -68.5t68.5 -47.5t102.5 -24.5v391q-3 2 -15 4.5t-16 2.5q-78 18 -153 44.5t-133.5 72t-94.5 115t-36 173.5
q0 91 33 156.5t92.5 108.5t142 65t180.5 26v134h109v-134q107 -4 182 -28t127 -67.5t84 -107t53 -147.5l-264 -39q-15 87 -58.5 134.5t-123.5 58.5v-352q5 -2 10.5 -2t11.5 -2q86 -20 168.5 -47t147 -73t104 -118.5t39.5 -183.5zM520 1194q-53 -4 -88.5 -18t-57.5 -35.5
t-31 -49t-9 -57.5q0 -43 14 -70.5t39 -45.5t59 -30.5t74 -25.5v332zM850 408q0 49 -17 79.5t-47 49.5t-70.5 31.5t-86.5 25.5v-367q106 7 163.5 50t57.5 131z"" />
    <glyph glyph-name=""percent"" unicode=""%"" horiz-adv-x=""1821"" 
d=""M1767 432q0 -125 -28 -211t-76 -138.5t-112.5 -75.5t-137.5 -23q-75 0 -139.5 23t-112 75.5t-75 138.5t-27.5 211q0 132 27.5 218.5t75.5 138t113.5 72t141.5 20.5q72 0 136 -20.5t111.5 -72t75 -138t27.5 -218.5zM552 0h-206l920 1409h209zM408 1425q72 0 136 -20.5
t112 -71.5t76 -137.5t28 -218.5q0 -125 -28 -211t-76.5 -139t-113.5 -76t-139 -23q-73 0 -137.5 23t-112 75.5t-75 138.5t-27.5 212q0 132 27 218.5t75 137.5t113.5 71.5t141.5 20.5zM1552 432q0 87 -8.5 144t-25.5 90.5t-42 47t-59 13.5q-37 0 -63.5 -13.5t-43.5 -47.5
t-25.5 -91t-8.5 -143q0 -84 8 -139.5t25.5 -89.5t43.5 -48t62 -14q33 0 58.5 14t43 47.5t26.5 89.5t9 140zM543 977q0 86 -8.5 142.5t-25.5 90t-42 47t-59 13.5q-37 0 -64 -14t-44 -47.5t-25.5 -90t-8.5 -141.5q0 -84 8.5 -140t26 -90t43.5 -48.5t62 -14.5q34 0 59.5 14
t43 48t26 90.5t8.5 140.5z"" />
    <glyph glyph-name=""ampersand"" unicode=""&#x26;"" horiz-adv-x=""1479"" 
d=""M90 385q0 79 25.5 143t70.5 116t107 93.5t135 75.5q-32 65 -53 139t-21 140t20 125t65 103.5t117 70.5t175 26q81 0 147.5 -19.5t114.5 -57.5t74.5 -93t26.5 -127q0 -73 -33 -129.5t-87.5 -102t-125.5 -83t-146 -72.5q51 -90 112 -173.5t132 -162.5q56 85 94 174.5
t64 188.5l209 -70q-34 -117 -81 -220t-112 -200q45 -38 90 -55.5t88 -17.5q32 0 61.5 4t55.5 12v-203q-55 -22 -131 -22q-51 0 -98 10t-89 26.5t-78 38.5t-65 46q-33 -25 -73.5 -48.5t-88 -41.5t-102 -28.5t-115.5 -10.5q-126 0 -218 31t-151 85t-87.5 128t-28.5 161z
M870 1118q0 57 -38 93t-103 36q-77 0 -117.5 -43t-40.5 -114q0 -48 15.5 -98t38.5 -95q51 22 96 44.5t78 49t52 57.5t19 70zM788 246q-77 86 -146 180t-126 197q-83 -39 -127.5 -96t-44.5 -138q0 -46 15.5 -86t45.5 -69.5t75.5 -46.5t105.5 -17q65 0 117.5 24t84.5 52z"" />
    <glyph glyph-name=""quotesingle"" unicode=""'"" horiz-adv-x=""487"" 
d=""M354 898h-219l-26 511h272z"" />
    <glyph glyph-name=""parenleft"" unicode=""("" horiz-adv-x=""682"" 
d=""M399 -425q-77 111 -133 221t-92.5 226t-54 241.5t-17.5 267.5q0 143 17.5 267.5t54 240t92.5 225t133 220.5h281q-80 -116 -137 -229t-93.5 -229t-53.5 -238.5t-17 -257.5q0 -136 17 -258.5t53.5 -238.5t93.5 -228.5t137 -229.5h-281z"" />
    <glyph glyph-name=""parenright"" unicode="")"" horiz-adv-x=""682"" 
d=""M2 -425q80 117 137 229.5t93.5 228.5t53.5 238.5t17 258.5q0 135 -17 257.5t-53.5 238.5t-93.5 229t-137 229h281q77 -111 133 -220.5t92.5 -225t54 -240t17.5 -267.5q0 -142 -17.5 -267.5t-54 -241.5t-92.5 -226t-133 -221h-281z"" />
    <glyph glyph-name=""asterisk"" unicode=""*"" horiz-adv-x=""797"" 
d=""M492 1135l235 104l68 -197l-250 -61l186 -213l-184 -121l-146 252l-149 -252l-186 123l190 211l-250 61l68 197l239 -104l-18 274h215z"" />
    <glyph glyph-name=""plus"" unicode=""+"" horiz-adv-x=""1196"" 
d=""M711 569v-408h-226v408h-399v224h399v408h226v-408h402v-224h-402z"" />
    <glyph glyph-name=""comma"" unicode="","" horiz-adv-x=""569"" 
d=""M432 66q0 -67 -7.5 -122t-21.5 -101.5t-34 -85.5t-45 -74h-185q29 35 53 74t42 80t28 82t10 81h-129v305h289v-239z"" />
    <glyph glyph-name=""uni00AD"" unicode=""-"" horiz-adv-x=""682"" 
d=""M80 409v244h520v-244h-520z"" />
    <glyph glyph-name=""uni00AD"" unicode=""&#xad;"" horiz-adv-x=""682"" 
d=""M80 409v244h520v-244h-520z"" />
    <glyph glyph-name=""period"" unicode=""."" horiz-adv-x=""569"" 
d=""M139 0v305h289v-305h-289z"" />
    <glyph glyph-name=""slash"" unicode=""/"" horiz-adv-x=""569"" 
d=""M20 -41l291 1525h238l-286 -1525h-243z"" />
    <glyph glyph-name=""zero"" unicode=""0"" 
d=""M1055 705q0 -202 -37 -340.5t-102.5 -224t-155 -123t-195.5 -37.5t-195 37t-153 122.5t-100 224t-36 341.5q0 213 35.5 352.5t100.5 222.5t155.5 116.5t200.5 33.5q103 0 191.5 -33.5t153 -116.5t101 -222.5t36.5 -352.5zM773 705q0 149 -11 246.5t-35 155t-62.5 80.5
t-93.5 23q-59 0 -99 -23.5t-64.5 -81.5t-35 -155.5t-10.5 -244.5q0 -145 11 -242t35 -155.5t63 -82.5t96 -24q55 0 94 24t64 82.5t36.5 155.5t11.5 242z"" />
    <glyph glyph-name=""one"" unicode=""1"" 
d=""M129 0v209h349v961l-338 -211v221l353 229h266v-1200h323v-209h-953z"" />
    <glyph glyph-name=""two"" unicode=""2"" 
d=""M71 0v195q48 105 117 189.5t144.5 155t150 131t134 117t96.5 113.5t37 121q0 94 -47 139t-138 45q-90 0 -137.5 -48.5t-61.5 -145.5l-283 16q10 83 41 156t88.5 128t144 86.5t206.5 31.5q114 0 202 -26.5t148 -77.5t91 -124.5t31 -167.5q0 -99 -39 -179t-100 -147.5
t-135.5 -126.5t-144.5 -115t-127.5 -113t-85.5 -122h654v-231h-986z"" />
    <glyph glyph-name=""three"" unicode=""3"" 
d=""M1065 391q0 -96 -31.5 -172.5t-94.5 -130.5t-156.5 -82.5t-217.5 -28.5q-138 0 -232.5 35t-155 92.5t-91 130.5t-39.5 148l286 25q6 -45 22.5 -82.5t44.5 -64.5t68.5 -41.5t95.5 -14.5q101 0 157 50t56 153q0 63 -26.5 101t-67 58.5t-87.5 27.5t-89 7h-98v227h92
q42 0 85.5 8t78.5 29t57 58.5t22 95.5q0 87 -48.5 136.5t-141.5 49.5q-87 0 -140.5 -48t-61.5 -136l-281 20q12 99 54.5 172t107 121t148.5 71.5t178 23.5q124 0 213 -30t146 -81t84 -119t27 -145q0 -62 -18 -115.5t-54.5 -96t-93.5 -73t-135 -45.5v-4q87 -10 151 -39.5
t105 -73.5t61 -99.5t20 -117.5z"" />
    <glyph glyph-name=""four"" unicode=""4"" 
d=""M940 287v-287h-268v287h-641v211l595 911h314v-913h188v-209h-188zM672 957q0 17 0.5 44.5t2 56.5t3 55.5t3.5 41.5q-5 -11 -16 -31.5t-24.5 -44t-28 -46.5t-25.5 -40l-327 -497h412v461z"" />
    <glyph glyph-name=""five"" unicode=""5"" 
d=""M1082 469q0 -106 -33.5 -195.5t-99.5 -155t-163.5 -102t-225.5 -36.5q-118 0 -206 28.5t-148.5 79t-95 118.5t-47.5 146l281 23q8 -33 22.5 -64t40.5 -55t64 -38.5t92 -14.5q105 0 167.5 67t62.5 193q0 56 -15.5 101t-44 77t-70 49t-94.5 17q-70 0 -115 -26.5t-76 -64.5
h-274l49 793h847v-209h-592l-23 -356q42 37 106 63.5t149 26.5q104 0 186 -34t139 -95t87 -146.5t30 -189.5z"" />
    <glyph glyph-name=""six"" unicode=""6"" 
d=""M1065 461q0 -106 -30 -194.5t-89.5 -152t-148.5 -99t-206 -35.5q-249 0 -382.5 174.5t-133.5 517.5q0 377 135.5 567.5t387.5 190.5q84 0 153 -17.5t123 -56.5t92 -100.5t61 -149.5l-265 -37q-20 74 -65 106.5t-105 32.5q-113 0 -177.5 -113t-64.5 -343q45 75 125 115
t181 40q93 0 168.5 -30.5t129 -88t82.5 -140.5t29 -187zM783 453q0 57 -13 102.5t-39.5 77.5t-65.5 49.5t-90 17.5q-37 0 -74 -12t-66 -38.5t-47 -67.5t-18 -99q0 -60 15 -112t42.5 -90.5t66.5 -60t88 -21.5q95 0 148 67.5t53 186.5z"" />
    <glyph glyph-name=""seven"" unicode=""7"" 
d=""M1049 1186q-95 -150 -179.5 -291t-147.5 -283.5t-99.5 -293t-36.5 -318.5h-293q0 167 39.5 317.5t107.5 293.5t158 282.5t190 284.5h-700v231h961v-223z"" />
    <glyph glyph-name=""eight"" unicode=""8"" 
d=""M1076 397q0 -91 -30 -167.5t-92 -132t-157 -86.5t-226 -31q-130 0 -225.5 31t-158 86.5t-92.5 131.5t-30 166q0 77 24 136.5t64 102.5t92 68.5t107 34.5v4q-59 13 -106 43t-80 72t-50.5 93.5t-17.5 107.5q0 84 30.5 153t89.5 118t146.5 75.5t202.5 26.5
q123 0 212.5 -27.5t147.5 -77t86 -118.5t28 -152q0 -55 -17.5 -106.5t-50.5 -93.5t-80.5 -71t-107.5 -41v-4q62 -10 115.5 -36.5t92.5 -69t61 -102t22 -134.5zM752 1040q0 42 -9 77.5t-30 61t-56.5 40t-89.5 14.5q-52 0 -87 -14.5t-56 -40t-30 -61t-9 -77.5q0 -37 7.5 -73
t27.5 -64.5t56 -46.5t93 -18q60 0 96.5 18t55.5 47t25 65t6 72zM785 420q0 43 -9.5 83t-34 70.5t-67.5 49t-109 18.5q-60 0 -100.5 -18.5t-65 -49.5t-35 -71.5t-10.5 -85.5q0 -53 10.5 -97t36 -75.5t67.5 -48.5t105 -17t104 17.5t65 49.5t33.5 76.5t9.5 98.5z"" />
    <glyph glyph-name=""nine"" unicode=""9"" 
d=""M1063 727q0 -375 -137 -561t-389 -186q-91 0 -163.5 19t-126.5 59t-91.5 103t-59.5 150l264 37q20 -75 65.5 -111t114.5 -36q57 0 102 27t77 82t49.5 139.5t18.5 199.5q-20 -39 -53 -69t-74.5 -50t-88.5 -30.5t-95 -10.5q-92 0 -167 32.5t-128 93.5t-81.5 147.5
t-28.5 195.5q0 112 33.5 200t96.5 148.5t154.5 92t207.5 31.5q122 0 215.5 -41.5t156.5 -128t95.5 -219t32.5 -314.5zM766 924q0 60 -13.5 112.5t-40.5 91t-66 60.5t-90 22q-47 0 -84 -17.5t-63 -50.5t-39.5 -80t-13.5 -106q0 -55 13 -102.5t38 -82t63 -54t87 -19.5
q39 0 76.5 14t67 42t47.5 70.5t18 99.5z"" />
    <glyph glyph-name=""colon"" unicode="":"" horiz-adv-x=""682"" 
d=""M197 752v282h288v-282h-288zM197 0v281h288v-281h-288z"" />
    <glyph glyph-name=""uni037E"" unicode="";"" horiz-adv-x=""682"" 
d=""M199 752v282h288v-282h-288zM487 66q0 -67 -7.5 -122t-21.5 -101.5t-34 -85.5t-45 -74h-184q28 35 52.5 74t42.5 80t28 82t10 81h-129v281h288v-215z"" />
    <glyph glyph-name=""uni037E"" unicode=""&#x37e;"" horiz-adv-x=""682"" 
d=""M199 752v282h288v-282h-288zM487 66q0 -67 -7.5 -122t-21.5 -101.5t-34 -85.5t-45 -74h-184q28 35 52.5 74t42.5 80t28 82t10 81h-129v281h288v-215z"" />
    <glyph glyph-name=""less"" unicode=""&#x3c;"" horiz-adv-x=""1196"" 
d=""M86 516v322l1027 391v-228l-833 -325l833 -324v-227z"" />
    <glyph glyph-name=""equal"" unicode=""="" horiz-adv-x=""1196"" 
d=""M85 842v223h1027v-223h-1027zM85 291v221h1027v-221h-1027z"" />
    <glyph glyph-name=""greater"" unicode=""&#x3e;"" horiz-adv-x=""1196"" 
d=""M86 125v227l832 324l-832 325v228l1027 -391v-322z"" />
    <glyph glyph-name=""question"" unicode=""?"" horiz-adv-x=""1251"" 
d=""M1133 1026q0 -66 -17.5 -116t-46.5 -89.5t-66 -71t-76 -59.5t-76.5 -55t-67.5 -57.5t-49 -67t-21 -84.5h-267q5 85 36.5 145.5t76.5 105.5t96 80.5t94.5 72.5t72 80.5t28.5 103.5q0 88 -57.5 139t-163.5 51q-51 0 -94 -15.5t-75.5 -43.5t-53.5 -68t-27 -88l-285 12
q12 89 49.5 167t102.5 136t159.5 92t219.5 34q120 0 214 -28t159.5 -80.5t100 -127.5t34.5 -168zM438 0v270h289v-270h-289z"" />
    <glyph glyph-name=""at"" unicode=""@"" horiz-adv-x=""1997"" 
d=""M1878 725q0 -144 -38 -263.5t-103.5 -205.5t-153 -134t-186.5 -48q-42 0 -77.5 10.5t-60.5 32t-39 54t-14 75.5q0 14 1.5 33t4.5 34h-6q-21 -44 -56 -87t-80.5 -76.5t-100 -54.5t-113.5 -21q-95 0 -158.5 34t-101.5 89t-54 124t-16 138q0 115 34 225t98 196t157 138.5
t211 52.5q102 0 167 -46.5t97 -127.5h6l39 152h156l-117 -506q-17 -79 -27 -141t-10 -99q0 -50 23.5 -71t54.5 -21q59 0 114.5 38t99.5 106t70.5 162t26.5 206q0 126 -41 234t-121 187t-198 124t-272 45q-133 0 -245 -31.5t-202.5 -88.5t-159 -136t-115 -173.5t-70 -201.5
t-23.5 -221q0 -87 17 -168.5t51.5 -152.5t87 -130t123.5 -101t161.5 -65.5t200.5 -23.5q86 0 166 12t153.5 33t141 49.5t128.5 60.5l62 -122q-60 -34 -129 -66t-150 -56.5t-175 -39.5t-204 -15q-130 0 -240 28.5t-198.5 80t-155.5 123.5t-112 159t-67.5 187t-22.5 207
q0 139 31.5 267t91 238t145 200t194 154t238 99t275.5 35q203 0 351.5 -59t245 -159t143 -232t46.5 -279zM1231 721q0 47 -15.5 86.5t-43.5 68t-67 44.5t-87 16q-55 0 -101 -20.5t-82 -55.5t-63 -81.5t-44.5 -99.5t-26.5 -109t-9 -109q0 -114 48.5 -180t148.5 -66
q48 0 95.5 23t89.5 67.5t76.5 110t55.5 149.5q5 18 9.5 39.5t8 42.5t5.5 40t2 34z"" />
    <glyph glyph-name=""A"" unicode=""A"" horiz-adv-x=""1479"" 
d=""M1133 0l-125 360h-537l-125 -360h-295l514 1409h348l512 -1409h-292zM803 987q-12 35 -23.5 70.5t-20 65t-14 48.5t-6.5 21q-1 -3 -6 -22t-13.5 -48t-20 -64.5t-23.5 -70.5l-139 -405h405z"" />
    <glyph glyph-name=""B"" unicode=""B"" horiz-adv-x=""1479"" 
d=""M1386 402q0 -107 -43 -183.5t-117.5 -125t-173.5 -71t-210 -22.5h-705v1409h645q125 0 222.5 -21.5t164.5 -65.5t101.5 -110.5t34.5 -156.5q0 -120 -66.5 -202.5t-202.5 -111.5q171 -20 260.5 -107.5t89.5 -231.5zM1008 1015q0 95 -60.5 135t-179.5 40h-336v-349h338
q125 0 181.5 43.5t56.5 130.5zM1090 425q0 56 -22 94t-60.5 61t-90 33t-111.5 10h-374v-404h385q58 0 108 9.5t86.5 33t57.5 63.5t21 100z"" />
    <glyph glyph-name=""C"" unicode=""C"" horiz-adv-x=""1479"" 
d=""M795 212q83 0 143.5 23.5t105 61.5t74 86t48.5 97l257 -97q-31 -76 -81 -149t-125 -129t-178.5 -90.5t-243.5 -34.5q-183 0 -317 54.5t-221.5 152t-130 231.5t-42.5 293q0 165 42.5 298t128.5 226.5t217.5 144t309.5 50.5q138 0 241.5 -29t179 -81.5t125 -124
t77.5 -157.5l-260 -71q-14 45 -43 86.5t-73.5 73.5t-104.5 51.5t-136 19.5q-107 0 -184 -34.5t-126.5 -98.5t-73 -153.5t-23.5 -200.5q0 -110 23.5 -201.5t73.5 -157.5t128.5 -103t188.5 -37z"" />
    <glyph glyph-name=""D"" unicode=""D"" horiz-adv-x=""1479"" 
d=""M1393 715q0 -176 -53 -309.5t-145 -223.5t-217.5 -136t-270.5 -46h-570v1409h510q164 0 301 -41t236 -126t154 -216t55 -311zM1096 715q0 123 -33.5 211t-93.5 144.5t-143.5 83.5t-184.5 27h-209v-953h250q89 0 164.5 31t131 92.5t87 152.5t31.5 211z"" />
    <glyph glyph-name=""E"" unicode=""E"" horiz-adv-x=""1366"" 
d=""M137 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149z"" />
    <glyph glyph-name=""F"" unicode=""F"" horiz-adv-x=""1251"" 
d=""M432 1181v-436h721v-228h-721v-517h-295v1409h1039v-228h-744z"" />
    <glyph glyph-name=""G"" unicode=""G"" horiz-adv-x=""1593"" 
d=""M806 211q64 0 123 10t109.5 26.5t91 38t66.5 44.5v195h-344v218h614v-518q-48 -49 -116 -93.5t-153 -78t-185.5 -53.5t-213.5 -20q-187 0 -322 54.5t-222 152t-128.5 231.5t-41.5 293q0 165 44 298t133.5 226.5t225 144t318.5 50.5q133 0 236.5 -26t181 -74t130 -115.5
t83.5 -151.5l-272 -82q-18 44 -48 83.5t-74.5 69t-103 47t-133.5 17.5q-110 0 -190 -34.5t-132 -98.5t-77 -153.5t-25 -200.5q0 -110 25.5 -202t78 -158t132.5 -103t189 -37z"" />
    <glyph glyph-name=""H"" unicode=""H"" horiz-adv-x=""1479"" 
d=""M1046 0v604h-614v-604h-295v1409h295v-561h614v561h295v-1409h-295z"" />
    <glyph glyph-name=""I"" unicode=""I"" horiz-adv-x=""569"" 
d=""M137 0v1409h295v-1409h-295z"" />
    <glyph glyph-name=""J"" unicode=""J"" 
d=""M524 -20q-106 0 -189 22t-144 70t-100.5 124.5t-59.5 185.5l293 43q10 -59 28 -99.5t43.5 -66t58.5 -37t72 -11.5q88 0 133.5 59t45.5 169v739h-281v231h575v-963q0 -107 -31 -193.5t-91.5 -147t-149 -93t-203.5 -32.5z"" />
    <glyph glyph-name=""K"" unicode=""K"" horiz-adv-x=""1479"" 
d=""M1112 0l-506 647l-174 -133v-514h-295v1409h295v-639l635 639h344l-602 -596l651 -813h-348z"" />
    <glyph glyph-name=""L"" unicode=""L"" horiz-adv-x=""1251"" 
d=""M137 0v1409h295v-1181h756v-228h-1051z"" />
    <glyph glyph-name=""M"" unicode=""M"" horiz-adv-x=""1706"" 
d=""M1307 0v854q0 51 1.5 105t3.5 99q3 53 5 103q-21 -79 -40 -150q-8 -30 -17 -62t-17.5 -62t-16.5 -56t-14 -45l-254 -786h-210l-254 786q-6 19 -13.5 45t-16 56t-17.5 62t-18 62q-20 71 -42 150q3 -58 6 -114q2 -48 4 -101t2 -92v-854h-262v1409h395l252 -788
q10 -31 21.5 -76t22.5 -87q12 -49 26 -102q14 52 27 100q6 21 12 43t12 43t12 40t11 34l248 793h393v-1409h-262z"" />
    <glyph glyph-name=""N"" unicode=""N"" horiz-adv-x=""1479"" 
d=""M995 0l-614 1085q5 -44 9 -88q4 -38 6.5 -82t2.5 -84v-831h-262v1409h337l623 -1094q-5 42 -9 88q-4 39 -6.5 88t-2.5 99v819h262v-1409h-346z"" />
    <glyph glyph-name=""O"" unicode=""O"" horiz-adv-x=""1593"" 
d=""M1507 711q0 -165 -49 -300t-141 -231t-224.5 -148t-299.5 -52q-177 0 -309.5 54.5t-221.5 152t-133.5 231.5t-44.5 293q0 165 46.5 298t137 226.5t223 144t304.5 50.5t304.5 -51t223 -145t137.5 -226.5t47 -296.5zM1206 711q0 111 -26.5 200.5t-78.5 153.5t-128.5 98.5
t-177.5 34.5q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5q0 -110 26.5 -201.5t78.5 -157.5t129 -103t178 -37q108 0 186 37.5t128.5 104t74.5 158t24 199.5z"" />
    <glyph glyph-name=""P"" unicode=""P"" horiz-adv-x=""1366"" 
d=""M1296 963q0 -91 -30.5 -175.5t-93.5 -149.5t-160 -103.5t-230 -38.5h-350v-496h-295v1409h633q135 0 234 -32.5t164 -91.5t96.5 -141t31.5 -181zM999 958q0 109 -65.5 165.5t-196.5 56.5h-305v-457h313q66 0 113.5 17t79 48t46.5 74.5t15 95.5z"" />
    <glyph glyph-name=""Q"" unicode=""Q"" horiz-adv-x=""1593"" 
d=""M1507 711q0 -141 -35.5 -259.5t-103 -210t-164.5 -152t-221 -85.5q20 -58 47 -94.5t61 -57t74 -28t86 -7.5q29 0 59 2.5t60 7.5l-2 -202q-54 -12 -113 -20t-129 -8q-95 0 -166 28.5t-123.5 80t-89 124t-63.5 160.5q-150 14 -262.5 73t-187.5 154t-112.5 221t-37.5 273
q0 165 46.5 298t137 226.5t223 144t304.5 50.5t304.5 -51t223 -145t137.5 -226.5t47 -296.5zM1206 711q0 111 -26.5 200.5t-78.5 153.5t-128.5 98.5t-177.5 34.5q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5q0 -110 26.5 -202t78.5 -158t129 -103t178 -37
q108 0 186 37.5t128.5 104t74.5 158.5t24 200z"" />
    <glyph glyph-name=""R"" unicode=""R"" horiz-adv-x=""1479"" 
d=""M1105 0l-327 535h-346v-535h-295v1409h704q132 0 230.5 -29.5t164.5 -84t98.5 -132t32.5 -174.5q0 -79 -23.5 -144.5t-65 -116.5t-98.5 -85.5t-124 -50.5l381 -592h-332zM1070 977q0 103 -67.5 153t-192.5 50h-378v-416h386q66 0 113.5 15.5t78 44t45.5 67.5t15 86z"" />
    <glyph glyph-name=""S"" unicode=""S"" horiz-adv-x=""1366"" 
d=""M1286 406q0 -96 -35 -174.5t-108.5 -134.5t-188 -86.5t-272.5 -30.5q-140 0 -247 25t-183.5 74t-124 121.5t-68.5 166.5l285 47q12 -47 35 -86t63.5 -67.5t101 -44t146.5 -15.5q150 0 229.5 45.5t79.5 142.5q0 58 -32 95t-85 61t-122 40t-144 31q-60 14 -120 29
t-114.5 36t-101.5 50t-81.5 71.5t-54 99.5t-19.5 134q0 105 42 180t116.5 122.5t177.5 69.5t225 22q138 0 236.5 -21.5t165 -65.5t105 -110.5t56.5 -155.5l-286 -39q-22 91 -89.5 137t-193.5 46q-78 0 -129.5 -13.5t-82 -36.5t-43.5 -53.5t-13 -64.5q0 -52 25 -85.5t70 -56
t107.5 -38t137.5 -31.5q66 -14 131 -29.5t124 -36.5t110 -51t88.5 -73.5t59 -103.5t21.5 -142z"" />
    <glyph glyph-name=""T"" unicode=""T"" horiz-adv-x=""1251"" 
d=""M773 1181v-1181h-295v1181h-455v228h1206v-228h-456z"" />
    <glyph glyph-name=""U"" unicode=""U"" horiz-adv-x=""1479"" 
d=""M723 -20q-132 0 -242 31.5t-189.5 98t-124 170.5t-44.5 248v881h295v-858q0 -89 22 -153.5t63 -106t99 -61t129 -19.5q72 0 132.5 20.5t104 63.5t67.5 109t24 157v848h295v-866q0 -145 -47 -251t-131 -175.5t-199.5 -103t-253.5 -33.5z"" />
    <glyph glyph-name=""V"" unicode=""V"" horiz-adv-x=""1366"" 
d=""M834 0h-299l-521 1409h308l290 -905q14 -45 27 -92t24 -86q12 -46 23 -88q10 41 21 86q10 38 23.5 85.5t27.5 94.5l289 905h305z"" />
    <glyph glyph-name=""W"" unicode=""W"" horiz-adv-x=""1933"" 
d=""M1567 0h-350l-191 815q-9 37 -19.5 88t-19.5 99q-11 55 -20 114q-11 -59 -22 -115q-5 -24 -10 -49.5t-10.5 -50t-10 -46.5t-9.5 -40l-190 -815h-350l-363 1409h299l176 -784q15 -64 28 -126t24 -111q12 -57 22 -109q15 74 29 144q6 30 13 62t13.5 63t13 59.5t11.5 51.5
l174 750h330l178 -750q6 -24 12 -53.5t12 -61l12 -63t11 -61.5q12 -70 24 -141q12 56 25 116q11 51 25 112t28 118l170 784h299z"" />
    <glyph glyph-name=""X"" unicode=""X"" horiz-adv-x=""1366"" 
d=""M1038 0l-354 561l-354 -561h-312l488 741l-447 668h312l313 -498l313 498h310l-428 -668l469 -741h-310z"" />
    <glyph glyph-name=""Y"" unicode=""Y"" horiz-adv-x=""1366"" 
d=""M831 578v-578h-294v578l-502 831h309l338 -596l342 596h309z"" />
    <glyph glyph-name=""Z"" unicode=""Z"" horiz-adv-x=""1251"" 
d=""M1192 0h-1131v209l762 969h-686v231h1014v-205l-762 -973h803v-231z"" />
    <glyph glyph-name=""bracketleft"" unicode=""["" horiz-adv-x=""682"" 
d=""M115 -425v1909h542v-190h-276v-1528h276v-191h-542z"" />
    <glyph glyph-name=""backslash"" unicode=""\"" horiz-adv-x=""569"" 
d=""M307 -41l-286 1526h238l291 -1526h-243z"" />
    <glyph glyph-name=""bracketright"" unicode=""]"" horiz-adv-x=""682"" 
d=""M25 -425v191h278v1528h-278v190h542v-1909h-542z"" />
    <glyph glyph-name=""asciicircum"" unicode=""^"" horiz-adv-x=""1196"" 
d=""M922 514l-326 752l-324 -752h-227l391 895h322l393 -895h-229z"" />
    <glyph glyph-name=""underscore"" unicode=""_"" 
d=""M-20 -250v78h1177v-78h-1177z"" />
    <glyph glyph-name=""grave"" unicode=""`"" horiz-adv-x=""682"" 
d=""M406 1183l-340 276v43h258l251 -288v-31h-169z"" />
    <glyph glyph-name=""a"" unicode=""a"" 
d=""M393 -20q-78 0 -139.5 21.5t-104.5 63t-66 102.5t-23 139q0 96 33.5 161.5t91.5 106t136 59t166 19.5l233 4v55q0 59 -10.5 98.5t-30.5 64.5t-49.5 35.5t-67.5 10.5q-35 0 -62.5 -7t-47.5 -24.5t-32.5 -47t-17.5 -74.5l-293 14q12 71 44 129.5t88.5 101.5t139 66.5
t193.5 23.5q101 0 180 -25t134 -74.5t84 -121.5t29 -167v-394q0 -38 3.5 -68t13 -50.5t27 -31t45.5 -10.5q32 0 62 6v-152q-25 -6 -45 -11t-40 -8t-42.5 -5t-52.5 -2q-106 0 -156.5 52t-60.5 153h-6q-56 -101 -143.5 -157t-212.5 -56zM720 501l-144 -2q-45 -2 -85.5 -7.5
t-71 -23t-48.5 -50.5t-18 -90q0 -77 35.5 -114.5t94.5 -37.5q54 0 98 23t74.5 60.5t47.5 86.5t17 100v55z"" />
    <glyph glyph-name=""b"" unicode=""b"" horiz-adv-x=""1251"" 
d=""M1167 545q0 -123 -24.5 -226.5t-75.5 -179t-129.5 -117.5t-185.5 -42q-48 0 -96 10t-91 33t-79 60t-62 91h-2q0 -21 -1.5 -48t-3.5 -52.5t-4.5 -45.5t-4.5 -28h-273q3 35 5.5 99.5t2.5 147.5v1237h281v-414q0 -32 -0.5 -62.5t-1.5 -56.5q-1 -30 -2 -57h4q51 112 140 160
t206 48q104 0 179 -41.5t123.5 -116t71.5 -176.5t23 -223zM874 545q0 184 -54 273t-167 89q-43 0 -85 -17t-75 -59.5t-53 -114t-20 -180.5q0 -106 20 -176t52 -112t74 -59t85 -17q107 0 165 88.5t58 284.5z"" />
    <glyph glyph-name=""c"" unicode=""c"" 
d=""M594 -20q-129 0 -225.5 40t-160.5 113t-96 175.5t-32 226.5q0 135 35 240.5t101 178t162.5 110.5t219.5 38q105 0 186.5 -28t140.5 -76.5t95.5 -114.5t50.5 -142l-283 -14q-12 83 -60 132.5t-136 49.5q-113 0 -165 -93t-52 -270q0 -374 221 -374q80 0 134 50.5t67 150.5
l282 -13q-10 -75 -45.5 -143.5t-96 -121t-146.5 -84t-197 -31.5z"" />
    <glyph glyph-name=""d"" unicode=""d"" horiz-adv-x=""1251"" 
d=""M844 0q-2 8 -4.5 28.5t-5 46.5t-4 53t-1.5 48h-4q-49 -105 -136.5 -150.5t-209.5 -45.5q-102 0 -176.5 42t-123 117t-72 177.5t-23.5 223.5q0 123 24.5 226t75.5 177.5t129.5 116.5t186.5 42q53 0 102 -11t91 -34t76 -59t58 -87h2q0 10 -0.5 29.5t-0.5 44.5t-0.5 52
t-0.5 52v395h281v-1248q0 -79 3 -140.5t5 -95.5h-272zM831 547q0 107 -20 177.5t-52.5 112t-74 58t-84.5 16.5q-54 0 -95.5 -21t-70 -66t-43 -115t-14.5 -169q0 -368 221 -368q42 0 84 18t75 61t53.5 115.5t20.5 180.5z"" />
    <glyph glyph-name=""e"" unicode=""e"" 
d=""M586 -20q-117 0 -210.5 34.5t-159.5 105t-101 177t-35 249.5q0 155 41.5 261t112 171.5t162.5 94.5t194 29q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-8h-694q0 -68 12 -126.5t39 -101t70 -67t104 -24.5q74 0 121 31.5t67 97.5l265 -23q-18 -46 -50.5 -98
t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM586 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420q-8 131 -63 196.5t-148 65.5z"" />
    <glyph glyph-name=""f"" unicode=""f"" horiz-adv-x=""682"" 
d=""M473 892v-892h-280v892h-158v190h158v113q0 62 15 114.5t51 91.5t97 61t152 22q48 0 94.5 -5t83.5 -11v-181q-18 4 -40.5 6.5t-41.5 2.5q-39 0 -64.5 -8t-40 -24t-20.5 -40.5t-6 -56.5v-85h213v-190h-213z"" />
    <glyph glyph-name=""g"" unicode=""g"" horiz-adv-x=""1251"" 
d=""M596 -434q-107 0 -188.5 21.5t-139 60t-92 92t-47.5 117.5l281 33q15 -65 64.5 -102t129.5 -37q50 0 91.5 14t71 47.5t46 88.5t16.5 136v57t1 53q1 28 1 54h-2q-49 -105 -137.5 -152t-210.5 -47q-103 0 -177.5 40.5t-123.5 113t-72.5 173t-23.5 221.5q0 125 25 226.5
t76.5 174.5t130 112.5t186.5 39.5t193.5 -46t133.5 -149h5q0 21 1.5 48.5t3.5 53t4.5 45.5t4.5 27h266q-2 -36 -4 -101t-2 -149v-799q0 -118 -34 -205.5t-99.5 -145.5t-161 -87t-217.5 -29zM831 556q0 102 -20 170t-52 109t-73.5 58t-83.5 17q-54 0 -95.5 -21t-70.5 -65
t-44 -112t-15 -162q0 -175 56 -264t167 -89q42 0 83.5 16.5t74.5 58t53 110.5t20 174z"" />
    <glyph glyph-name=""h"" unicode=""h"" horiz-adv-x=""1251"" 
d=""M420 866q57 124 143 180t205 56q98 0 165.5 -32t110 -88t61.5 -132t19 -164v-686h-280v606q0 63 -10 115.5t-33 90t-60 58.5t-90 21q-51 0 -92.5 -22.5t-71.5 -64t-46.5 -99t-16.5 -126.5v-579h-281v1484h281v-405q0 -32 -1 -64.5t-2.5 -61t-2.5 -51.5t-2 -36h4z"" />
    <glyph glyph-name=""i"" unicode=""i"" horiz-adv-x=""569"" 
d=""M143 1277v207h281v-207h-281zM143 0v1082h281v-1082h-281z"" />
    <glyph glyph-name=""j"" unicode=""j"" horiz-adv-x=""569"" 
d=""M144 1277v207h281v-207h-281zM138 -425q-56 0 -97.5 2.5t-72.5 6.5v198q13 -2 26 -3t25 -1q39 0 63 8t38 27t19 50t5 77v1142h281v-1210q0 -65 -16 -119t-50.5 -94t-89 -62t-131.5 -22z"" />
    <glyph glyph-name=""k"" unicode=""k"" 
d=""M834 0l-289 490l-121 -84v-406h-281v1484h281v-850l386 448h302l-380 -422l409 -660h-307z"" />
    <glyph glyph-name=""l"" unicode=""l"" horiz-adv-x=""569"" 
d=""M143 0v1484h281v-1484h-281z"" />
    <glyph glyph-name=""m"" unicode=""m"" horiz-adv-x=""1821"" 
d=""M780 0v607q0 63 -8.5 115.5t-28 90t-51 58.5t-76.5 21q-43 0 -78 -22.5t-60.5 -64t-39.5 -99t-14 -126.5v-580h-281v840q0 35 -0.5 72t-2 70.5t-2.5 60t-3 39.5h268q2 -12 4 -38.5t4 -58.5t3.5 -64t1.5 -54h4q52 124 129.5 180t185.5 56q124 0 199.5 -60.5t101.5 -175.5
h6q29 67 62.5 112t74 72.5t88 39.5t103.5 12q89 0 150.5 -32t100 -88t56 -132t17.5 -164v-687h-279v607q0 63 -8.5 115.5t-28 90t-51 58.5t-76.5 21q-42 0 -76.5 -21.5t-60 -61t-39.5 -94.5t-16 -122v-593h-279z"" />
    <glyph glyph-name=""n"" unicode=""n"" horiz-adv-x=""1251"" 
d=""M844 0v607q0 63 -10 115.5t-33 90t-60 58.5t-90 21q-51 0 -92.5 -22.5t-71.5 -64t-46.5 -99t-16.5 -126.5v-580h-281v840q0 35 -0.5 72t-2 70.5t-2.5 60t-3 39.5h268q2 -12 4 -38.5t4 -58.5t3.5 -64t1.5 -54h4q57 124 143 180t205 56q98 0 165.5 -32t110 -88t61.5 -132
t19 -164v-687h-280z"" />
    <glyph glyph-name=""o"" unicode=""o"" horiz-adv-x=""1251"" 
d=""M1171 542q0 -124 -34.5 -227t-103.5 -177.5t-172 -116t-240 -41.5q-132 0 -233 41t-169.5 115t-103.5 177.5t-35 228.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q146 0 249 -42t168.5 -116.5t96 -177t30.5 -224.5zM877 542q0 193 -63 280t-183 87q-124 0 -190 -88
t-66 -279q0 -97 17.5 -167t49.5 -115t77 -66.5t99 -21.5q62 0 110.5 21.5t81.5 66.5t50 115t17 167z"" />
    <glyph glyph-name=""p"" unicode=""p"" horiz-adv-x=""1251"" 
d=""M1167 546q0 -123 -24.5 -227t-75.5 -179t-129.5 -117.5t-185.5 -42.5q-48 0 -95.5 10t-90.5 32.5t-79.5 59t-62.5 90.5h-6q1 -5 2 -25t2 -46.5t1.5 -56t0.5 -54.5v-415h-281v1258q0 83 -2.5 148t-5.5 101h273q2 -7 4.5 -27t4 -46t2.5 -54t1 -49h4q51 107 140 153t206 46
q103 0 178 -42t123.5 -116t72 -176.5t23.5 -224.5zM874 546q0 185 -56 274.5t-167 89.5q-42 0 -83.5 -17.5t-74 -60t-53 -114t-20.5 -180.5q0 -106 20 -176.5t52.5 -112.5t73.5 -59.5t83 -17.5q54 0 96 21.5t70.5 67t43.5 116.5t15 169z"" />
    <glyph glyph-name=""q"" unicode=""q"" horiz-adv-x=""1251"" 
d=""M84 540q0 123 25 226.5t76.5 178t130 116.5t186.5 42t193.5 -46t133.5 -149q0 21 1.5 48.5t4 53t5 45.5t4.5 27h270q-2 -36 -4 -101t-2 -148v-1258h-279v450q0 28 1 55t2 50q1 26 2 50h-2q-49 -105 -140 -152.5t-213 -47.5q-102 0 -176.5 42t-123 117t-72 177.5
t-23.5 223.5zM831 546q0 108 -20 178t-52 111.5t-73.5 58t-83.5 16.5q-54 0 -95.5 -21t-70.5 -66t-44 -115t-15 -168q0 -368 223 -368q42 0 83.5 18t74.5 61t53 115t20 180z"" />
    <glyph glyph-name=""r"" unicode=""r"" horiz-adv-x=""797"" 
d=""M143 0v828q0 35 -0.5 74t-2 74.5t-2.5 64t-3 41.5h268q2 -12 4 -41.5t4 -64.5t3.5 -69.5t1.5 -55.5h4q21 59 42 105.5t49.5 79t68.5 50t99 17.5q25 0 49.5 -4.5t37.5 -10.5v-235q-27 6 -54.5 10.5t-65.5 4.5q-105 0 -163.5 -85t-58.5 -252v-531h-281z"" />
    <glyph glyph-name=""s"" unicode=""s"" 
d=""M1055 316q0 -78 -32.5 -140t-94.5 -105.5t-152 -67t-205 -23.5q-103 0 -186 15t-145.5 49.5t-104.5 89.5t-63 136l247 37q12 -45 33 -73t52 -43t72.5 -20t94.5 -5q48 0 89.5 5.5t72 19t47.5 38t17 61.5q0 42 -24.5 66.5t-67 40t-100 27t-122.5 26.5q-68 15 -134 36
t-118 57t-84 91.5t-32 140.5q0 77 30 137.5t88 103t143.5 65t196.5 22.5q88 0 164 -16.5t136 -52t100.5 -90.5t56.5 -133l-249 -26q-7 39 -25 64.5t-44.5 40.5t-61.5 20.5t-77 5.5q-100 0 -150 -25.5t-50 -85.5q0 -37 20.5 -59t58 -36.5t89 -25t112.5 -25.5
q75 -16 147.5 -37.5t129 -59t91 -96.5t34.5 -150z"" />
    <glyph glyph-name=""t"" unicode=""t"" horiz-adv-x=""682"" 
d=""M420 -18q-124 0 -191 67.5t-67 204.5v638h-137v190h151l88 254h176v-254h205v-190h-205v-562q0 -79 30 -116.5t93 -37.5q26 0 47 4t47 10v-174q-52 -17 -110 -25.5t-127 -8.5z"" />
    <glyph glyph-name=""u"" unicode=""u"" horiz-adv-x=""1251"" 
d=""M831 215q-107 -235 -348 -235q-184 0 -275 120q-81 105 -81 295v687h281v-607q0 -285 192 -285q101 0 164 86q63 88 63 226v580h281v-840q0 -138 8 -242h-268q-1 12 -3.5 38.5t-4.5 58.5l-2 64q-2 32 -2 54h-5z"" />
    <glyph glyph-name=""v"" unicode=""v"" 
d=""M565 227l271 855h294l-399 -1082h-336l-387 1082h297z"" />
    <glyph glyph-name=""w"" unicode=""w"" horiz-adv-x=""1593"" 
d=""M436 255l209 827h301l207 -827l184 827h260l-284 -1082h-297l-219 882l-226 -882h-297l-280 1082h264z"" />
    <glyph glyph-name=""x"" unicode=""x"" 
d=""M819 0l-252 392l-254 -392h-299l396 559l-377 523h303l231 -354l230 354h305l-377 -520l399 -562h-305z"" />
    <glyph glyph-name=""y"" unicode=""y"" 
d=""M584 241l250 841h294l-428 -1139q-81 -197 -168 -279q-95 -89 -249 -89q-101 0 -177 13v200q53 -8 95.5 -8t74.5 9t58 30q51 42 92 144l18 48l-428 1071h297z"" />
    <glyph glyph-name=""z"" unicode=""z"" horiz-adv-x=""1024"" 
d=""M68 0v199l540 680h-499v203h809v-201l-537 -676h586v-205h-899z"" />
    <glyph glyph-name=""braceleft"" unicode=""{"" horiz-adv-x=""797"" 
d=""M557 -425q-69 0 -123.5 21t-93 59.5t-58.5 94t-20 124.5v328q0 63 -16 106.5t-46 70.5t-72.5 39t-94.5 13v195q53 2 95.5 14.5t72 39.5t45.5 70.5t16 106.5v328q0 146 78.5 222.5t216.5 76.5h197v-190h-58q-91 0 -131.5 -52t-40.5 -157v-301q0 -51 -16.5 -93.5
t-44.5 -74.5t-66 -53.5t-80 -30.5v-4q43 -10 81 -31.5t66 -54t44 -74t16 -92.5v-301q0 -106 40.5 -157.5t131.5 -51.5h58v-191h-197z"" />
    <glyph glyph-name=""bar"" unicode=""|"" horiz-adv-x=""573"" 
d=""M156 -455v1939h262v-1939h-262z"" />
    <glyph glyph-name=""braceright"" unicode=""}"" horiz-adv-x=""797"" 
d=""M43 -234h57q93 0 132.5 51.5t39.5 157.5v301q0 51 16.5 92.5t44.5 74t65.5 54t80.5 31.5v4q-42 9 -79.5 30.5t-66 53.5t-45 74.5t-16.5 93.5v301q0 105 -39.5 157t-132.5 52h-57v190h197q138 0 216.5 -76.5t78.5 -222.5v-328q0 -63 16.5 -106.5t46.5 -70.5t72.5 -39.5
t95.5 -14.5v-195q-53 -1 -95.5 -13t-72.5 -39t-46.5 -70.5t-16.5 -106.5v-328q0 -69 -20 -124.5t-58.5 -94t-93 -59.5t-123.5 -21h-197v191z"" />
    <glyph glyph-name=""asciitilde"" unicode=""~"" horiz-adv-x=""1196"" 
d=""M852 516q-75 0 -147.5 21t-147.5 47q-66 23 -120.5 35t-100.5 12q-39 0 -72.5 -6t-64 -17.5t-59.5 -27.5t-59 -37v213q51 38 119 61t152 23q41 0 82 -6.5t81 -17t79 -24t77 -26.5q45 -16 98.5 -29.5t101.5 -13.5q68 0 132 25t116 67v-219q-32 -22 -62.5 -37.5t-62 -25
t-66.5 -13.5t-76 -4z"" />
    <glyph glyph-name=""exclamdown"" unicode=""&#xa1;"" horiz-adv-x=""682"" 
d=""M200 812v270h288v-270h-288zM194 -327l32 981h230l32 -981h-294z"" />
    <glyph glyph-name=""cent"" unicode=""&#xa2;"" 
d=""M506 352v681q-67 -21 -108 -81q-64 -92 -64 -261t66 -260q42 -57 106 -79zM668 353q120 44 141 196l283 -12q-21 -146 -126 -247q-113 -109 -298 -130v-191h-162v189q-222 21 -342 166q-113 135 -113 362q0 233 119 375q117 140 336 164v184h162v-184q175 -19 285 -119
q103 -93 130 -238l-282 -14q-23 136 -133 177v-678z"" />
    <glyph glyph-name=""sterling"" unicode=""&#xa3;"" 
d=""M1118 363q-13 -73 -43 -139t-79 -115.5t-116 -79t-154 -29.5h-694v205q39 22 72 48t56 61.5t36 83.5t13 114v92h-188v170h178v248q0 92 24 167.5t75.5 129t132 82.5t194.5 29q96 0 164 -20.5t115.5 -58.5t78 -91.5t49.5 -120.5l-233 -47q-21 77 -62 112t-107 35
q-91 0 -131 -57.5t-40 -182.5v-225h286v-170h-286v-90q0 -59 -12.5 -105.5t-35.5 -83t-57 -64.5t-77 -52h380q104 0 157.5 49.5t70.5 143.5z"" />
    <glyph glyph-name=""currency"" unicode=""&#xa4;"" 
d=""M134 684q0 60 15.5 116t44.5 105l-133 133l157 156l131 -133q48 28 104 43.5t116 15.5t115.5 -15t103.5 -44l135 135l158 -158l-136 -135q29 -48 44.5 -103.5t15.5 -115.5t-15 -114.5t-43 -102.5l134 -133l-158 -160l-133 135q-100 -59 -221 -59q-60 0 -116 14.5
t-104 42.5l-135 -137l-157 158l135 137q-28 48 -43 103.5t-15 115.5zM360 686q0 -43 16.5 -81t45 -66.5t66.5 -45t81 -16.5t80.5 16.5t66 45t45 66.5t16.5 81t-16.5 81t-45 66.5t-66 45t-80.5 16.5t-81 -16.5t-66.5 -45t-45 -66.5t-16.5 -81z"" />
    <glyph glyph-name=""yen"" unicode=""&#xa5;"" 
d=""M766 691h276v-146h-338v-162h338v-147h-338v-236h-272v236h-336v147h336l2 162h-338v146h276l-364 718h289l270 -596l274 596h289z"" />
    <glyph glyph-name=""brokenbar"" unicode=""&#xa6;"" horiz-adv-x=""573"" 
d=""M156 676v778h262v-778h-262zM156 -455v779h262v-779h-262z"" />
    <glyph glyph-name=""section"" unicode=""&#xa7;"" 
d=""M575 1427q87 0 163.5 -15.5t136.5 -48.5t100.5 -85t55.5 -125l-239 -25q-7 34 -26.5 58.5t-48 40t-65 23t-77.5 7.5q-112 0 -164.5 -29.5t-52.5 -94.5q0 -39 23 -65.5t62 -45.5t90.5 -32.5t108.5 -26.5q85 -19 160.5 -43t131.5 -61t89 -91t33 -134q0 -44 -13 -84.5
t-38.5 -75t-62 -61.5t-83.5 -42q41 -18 74.5 -42t57 -54.5t36.5 -70t13 -89.5q0 -78 -29 -141.5t-89 -108.5t-151 -69.5t-215 -24.5q-103 0 -186.5 15t-147 49t-106 89t-63.5 135l237 37q11 -45 34 -75t57 -48t78 -25t97 -7q122 0 185 32.5t63 112.5q0 45 -21 74t-63 49.5
t-105 37t-147 36.5q-63 15 -130 37.5t-121.5 58.5t-90 89.5t-35.5 131.5q0 49 15 89t43 71.5t67.5 55.5t87.5 40q-38 16 -72.5 40.5t-60 57t-40.5 72.5t-15 88q0 149 117.5 231t341.5 82zM818 600q0 39 -16 66t-51.5 47.5t-91 36t-133.5 30.5q-93 -11 -143 -47.5t-50 -105.5
q0 -39 24 -65.5t64.5 -45t93 -32t108.5 -26.5q41 2 77 10.5t62 25.5t41 43t15 63z"" />
    <glyph glyph-name=""dieresis"" unicode=""&#xa8;"" horiz-adv-x=""682"" 
d=""M450 1199v219h217v-219h-217zM16 1199v219h214v-219h-214z"" />
    <glyph glyph-name=""copyright"" unicode=""&#xa9;"" horiz-adv-x=""1509"" 
d=""M1478 707q0 -100 -26 -192.5t-73 -173t-112.5 -146t-146 -112.5t-173 -73t-192.5 -26q-99 0 -191.5 26t-172.5 73t-146.5 112.5t-113.5 146t-73 173t-26 192.5t26 192t73 172.5t113 146.5t146.5 113t172.5 73t192 26q150 0 281.5 -57t230 -155t155 -229.5t56.5 -281.5z
M1366 707q0 126 -48 236.5t-131 193t-194 130.5t-238 48q-84 0 -161.5 -22t-145.5 -61.5t-123 -95t-95 -123t-61.5 -145t-21.5 -161.5q0 -127 48 -238t130.5 -194t193 -131t236.5 -48q127 0 238 48t194 131t131 194t48 238zM544 709q0 -62 13.5 -114t41.5 -89.5t70 -58.5
t99 -21q41 0 73 13t56 34t40.5 46.5t26.5 49.5l160 -47q-20 -43 -48.5 -85.5t-70.5 -76.5t-100 -54.5t-137 -20.5q-104 0 -180 31.5t-126 88t-74 134.5t-24 170q0 96 24 173t73 130.5t123.5 82.5t174.5 29q78 0 136 -18.5t99.5 -50t70 -73t47.5 -87.5l-156 -41
q-10 24 -26 47t-39.5 41.5t-54.5 29.5t-72 11q-58 0 -100 -19.5t-68.5 -55.5t-39 -86.5t-12.5 -112.5z"" />
    <glyph glyph-name=""ordfeminine"" unicode=""&#xaa;"" horiz-adv-x=""758"" 
d=""M257 725q-97 0 -154.5 52.5t-57.5 149.5q0 60 23 100t62 64.5t90.5 35t108.5 11.5l147 2v42q0 35 -8 58t-22 36.5t-33 19t-41 5.5q-21 0 -39.5 -4t-33.5 -14.5t-25.5 -28.5t-13.5 -47l-190 9q8 43 29.5 80t59 64.5t90.5 43t122 15.5q65 0 117.5 -14t90.5 -43.5
t58.5 -73.5t20.5 -104v-237q0 -48 9 -72.5t42 -24.5q4 0 11 0.5t14 1.5t13.5 1.5t10.5 1.5v-109q-29 -8 -60.5 -13t-58.5 -5q-71 0 -111.5 36.5t-45.5 97.5h-3q-34 -65 -89.5 -101t-132.5 -36zM328 856q35 0 62.5 15t46.5 38t29 51.5t10 56.5v27l-92 -2q-31 -1 -58 -4.5
t-47.5 -14t-32.5 -30t-12 -52.5q0 -41 23 -63t71 -22z"" />
    <glyph glyph-name=""guillemotleft"" unicode=""&#xab;"" 
d=""M807 141l-256 361v71l256 367h238v-37l-254 -366l256 -361v-35h-240zM350 141l-258 361v71l258 367h236v-37l-254 -366l256 -361v-35h-238z"" />
    <glyph glyph-name=""logicalnot"" unicode=""&#xac;"" horiz-adv-x=""1196"" 
d=""M887 141v428h-803v224h1027v-652h-224z"" />
    <glyph glyph-name=""registered"" unicode=""&#xae;"" horiz-adv-x=""1509"" 
d=""M1478 707q0 -100 -26 -192.5t-73 -173t-112.5 -146t-146 -112.5t-173 -73t-192.5 -26q-99 0 -191.5 26t-172.5 73t-146.5 112.5t-113.5 146t-73 173t-26 192.5t26 192t73 172.5t113 146.5t146.5 113t172.5 73t192 26q150 0 281.5 -57t230 -155t155 -229.5t56.5 -281.5z
M1366 707q0 126 -48 236.5t-131 193t-194 130.5t-238 48q-84 0 -161.5 -22t-145.5 -61.5t-123 -95t-95 -123t-61.5 -145t-21.5 -161.5q0 -127 48 -238t130.5 -194t193 -131t236.5 -48q127 0 238 48t194 131t131 194t48 238zM923 297l-178 313h-117v-313h-178v815h330
q153 0 229 -64.5t76 -177.5q0 -94 -48 -153t-126 -84l213 -336h-201zM905 868q0 57 -37.5 87t-106.5 30h-133v-246h144q66 0 99.5 35.5t33.5 93.5z"" />
    <glyph glyph-name=""macron"" unicode=""&#xaf;"" horiz-adv-x=""1131"" 
d=""M1148 1452h-1165v94h1165v-94z"" />
    <glyph glyph-name=""degree"" unicode=""&#xb0;"" horiz-adv-x=""819"" 
d=""M731 1110q0 -66 -25.5 -123.5t-69 -100t-102 -67t-124.5 -24.5t-124.5 24.5t-102 67t-68.5 100t-25 123.5q0 67 25 124.5t68.5 100t102 66.5t124.5 24t124.5 -24t102 -66.5t69 -100t25.5 -124.5zM573 1110q0 35 -12.5 65.5t-34.5 53t-51.5 35t-64.5 12.5t-65 -12.5
t-52.5 -35t-35.5 -53t-13 -65.5q0 -34 13 -64.5t35.5 -53.5t52.5 -36.5t65 -13.5t64.5 13.5t51.5 36.5t34.5 53.5t12.5 64.5z"" />
    <glyph glyph-name=""plusminus"" unicode=""&#xb1;"" horiz-adv-x=""1124"" 
d=""M674 707v-341h-224v341h-401v223h401v340h224v-340h402v-223h-402zM49 0v223h1027v-223h-1027z"" />
    <glyph glyph-name=""uni00B2"" unicode=""&#xb2;"" horiz-adv-x=""682"" 
d=""M53 694l-2 121q25 53 62.5 93.5t79.5 72.5t84 59t75.5 52.5t54.5 53.5t21 62q0 42 -19.5 66.5t-61.5 24.5q-85 0 -95 -98l-194 5q6 46 27.5 86t57.5 70t87 47t117 17q71 0 123.5 -16t87 -44t51.5 -66.5t17 -83.5q0 -53 -22 -93t-56 -72t-75.5 -58.5t-80 -52t-70 -51.5
t-45.5 -57h362v-138h-586z"" />
    <glyph glyph-name=""uni00B3"" unicode=""&#xb3;"" horiz-adv-x=""682"" 
d=""M638 895q0 -99 -75 -155t-213 -56q-84 0 -140.5 18t-92 47.5t-52 66.5t-21.5 76l189 12q5 -45 32.5 -69t81.5 -24q49 0 75.5 23.5t26.5 72.5q0 31 -13.5 49.5t-34 28t-45 12.5t-46.5 3h-56v126h51q23 0 45.5 4t40.5 14t29.5 27.5t11.5 44.5q0 39 -23 61t-66 22
q-42 0 -67.5 -22t-30.5 -67l-186 12q6 51 31 89.5t63.5 64t88 38t106.5 12.5q68 0 119 -14.5t84.5 -40t50.5 -60t17 -73.5q0 -64 -36.5 -109.5t-115.5 -61.5v-2q45 -5 77.5 -20.5t53 -38.5t30.5 -51.5t10 -59.5z"" />
    <glyph glyph-name=""acute"" unicode=""&#xb4;"" horiz-adv-x=""682"" 
d=""M87 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""uni00B5"" unicode=""&#xb5;"" horiz-adv-x=""1180"" 
d=""M789 0q-3 23 -8 62t-5 82h-3q-19 -49 -40.5 -81t-46 -50.5t-53.5 -25.5t-62 -7q-52 0 -92.5 24t-63.5 66h-4q3 -32 3.5 -59.5t0.5 -55.5v-381h-281v1508h281v-605q0 -64 8 -116t28 -89.5t53.5 -58t85.5 -20.5q50 0 84 22.5t55 63t30 98t9 127.5v578h281v-840
q0 -34 0.5 -70.5t2 -70t3 -60.5t2.5 -41h-268z"" />
    <glyph glyph-name=""paragraph"" unicode=""&#xb6;"" 
d=""M940 1266v-1530h-156v1530h-195v-1530h-155v958q-81 0 -147.5 22.5t-114.5 66.5t-74.5 111t-26.5 155q0 84 25 150.5t72.5 113t116.5 71.5t157 25h629v-143h-131z"" />
    <glyph glyph-name=""uni2219"" unicode=""&#xb7;"" horiz-adv-x=""569"" 
d=""M141 531v305h288v-305h-288z"" />
    <glyph glyph-name=""uni2219"" unicode=""&#x2219;"" horiz-adv-x=""569"" 
d=""M141 531v305h288v-305h-288z"" />
    <glyph glyph-name=""cedilla"" unicode=""&#xb8;"" horiz-adv-x=""682"" 
d=""M500 -235q0 -39 -15.5 -74t-51 -60.5t-93.5 -40.5t-143 -15q-45 0 -101 6v118q25 -5 46 -6t38 -1q75 0 106 18.5t31 50.5q0 35 -28 52t-94 17h-25.5t-26.5 -2l62 172h143l-33 -82q94 -5 139.5 -46t45.5 -107z"" />
    <glyph glyph-name=""uni00B9"" unicode=""&#xb9;"" horiz-adv-x=""682"" 
d=""M82 694v121h184v468l-173 -108v122l180 117h175v-599h170v-121h-536z"" />
    <glyph glyph-name=""ordmasculine"" unicode=""&#xba;"" horiz-adv-x=""748"" 
d=""M713 1073q0 -77 -21.5 -141t-64 -110t-105.5 -71.5t-147 -25.5q-80 0 -141.5 25.5t-103.5 71t-63.5 109.5t-21.5 142q0 75 20.5 138.5t62 109.5t104.5 72t147 26q88 0 151.5 -26t104 -72t59.5 -109.5t19 -138.5zM513 1073q0 59 -8.5 98t-25 62.5t-41 33t-57.5 9.5
t-58.5 -10t-43 -33.5t-27 -62.5t-9.5 -97q0 -60 9.5 -100t27 -64t41.5 -34t53 -10q33 0 59 10t43.5 34t27 64t9.5 100z"" />
    <glyph glyph-name=""guillemotright"" unicode=""&#xbb;"" 
d=""M93 141v35l256 361l-254 366v37h238l256 -367v-71l-256 -361h-240zM552 141v35l256 361l-254 366v37h236l258 -367v-71l-258 -361h-238z"" />
    <glyph glyph-name=""onequarter"" unicode=""&#xbc;"" horiz-adv-x=""1708"" 
d=""M94 694v121h184v468l-173 -108v122l180 117h175v-599h170v-121h-536zM544 0h-201l895 1409h201zM1508 141v-140h-183v140h-344v148l316 432h211v-440h103v-140h-103zM1329 583q-3 -4 -11.5 -19.5t-19 -33.5t-20.5 -33.5t-14 -21.5l-141 -194h202v194q0 8 0.5 22t1 30
t1.5 31t1 25z"" />
    <glyph glyph-name=""onehalf"" unicode=""&#xbd;"" horiz-adv-x=""1708"" 
d=""M94 694v121h184v468l-173 -108v122l180 117h175v-599h170v-121h-536zM524 0h-201l895 1409h201zM1026 -1l-2 121q25 53 62.5 93.5t79.5 72.5t84 59t75.5 52.5t54.5 53.5t21 62q0 42 -19.5 66.5t-61.5 24.5q-85 0 -95 -98l-194 5q6 46 27.5 86t57.5 70t87 47t117 17
q71 0 123.5 -16t87 -44t51.5 -66.5t17 -83.5q0 -53 -22 -93t-56 -72t-75.5 -58.5t-80 -52t-70 -51.5t-45.5 -57h362v-138h-586z"" />
    <glyph glyph-name=""threequarters"" unicode=""&#xbe;"" horiz-adv-x=""1708"" 
d=""M544 0h-201l895 1409h201zM1508 141v-140h-183v140h-344v148l316 432h211v-440h103v-140h-103zM1329 583q-3 -4 -11.5 -19.5t-19 -33.5t-20.5 -33.5t-14 -21.5l-141 -194h202v194q0 8 0.5 22t1 30t1.5 31t1 25zM697 895q0 -99 -75 -155t-213 -56q-84 0 -140.5 18
t-92 47.5t-52 66.5t-21.5 76l189 12q5 -45 32.5 -69t81.5 -24q49 0 75.5 23.5t26.5 72.5q0 31 -13.5 49.5t-34 28t-45 12.5t-46.5 3h-56v126h51q23 0 45.5 4t40.5 14t29.5 27.5t11.5 44.5q0 39 -23 61t-66 22q-42 0 -67.5 -22t-30.5 -67l-186 12q6 51 31 89.5t63.5 64t88 38
t106.5 12.5q68 0 119 -14.5t84.5 -40t50.5 -60t17 -73.5q0 -64 -36.5 -109.5t-115.5 -61.5v-2q45 -5 77.5 -20.5t53 -38.5t30.5 -51.5t10 -59.5z"" />
    <glyph glyph-name=""questiondown"" unicode=""&#xbf;"" horiz-adv-x=""1251"" 
d=""M114 56q0 66 17.5 116t46.5 89.5t66 71t76 59.5t76.5 55t67.5 57.5t49 67t21 84.5h267q-5 -85 -36.5 -145t-76.5 -105.5t-96 -81t-94.5 -72.5t-72 -80t-28.5 -104q0 -88 57.5 -139t163.5 -51q51 0 94 15.5t75.5 43.5t53.5 68t27 88l285 -12q-12 -89 -49.5 -167
t-102.5 -136t-159.5 -92t-219.5 -34q-120 0 -214 28t-159.5 80.5t-100 127.5t-34.5 168zM809 1082v-270h-289v270h289z"" />
    <glyph glyph-name=""Agrave"" unicode=""&#xc0;"" horiz-adv-x=""1479"" 
d=""M1133 0l-125 360h-537l-125 -360h-295l514 1409h348l512 -1409h-292zM803 987q-12 35 -23.5 70.5t-20 65t-14 48.5t-6.5 21q-1 -3 -6 -22t-13.5 -48t-20 -64.5t-23.5 -70.5l-139 -405h405zM769 1530l-340 242v43h258l251 -254v-31h-169z"" />
    <glyph glyph-name=""Aacute"" unicode=""&#xc1;"" horiz-adv-x=""1479"" 
d=""M1133 0l-125 360h-537l-125 -360h-295l514 1409h348l512 -1409h-292zM803 987q-12 35 -23.5 70.5t-20 65t-14 48.5t-6.5 21q-1 -3 -6 -22t-13.5 -48t-20 -64.5t-23.5 -70.5l-139 -405h405zM573 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""Acircumflex"" unicode=""&#xc2;"" horiz-adv-x=""1479"" 
d=""M1133 0l-125 360h-537l-125 -360h-295l514 1409h348l512 -1409h-292zM803 987q-12 35 -23.5 70.5t-20 65t-14 48.5t-6.5 21q-1 -3 -6 -22t-13.5 -48t-20 -64.5t-23.5 -70.5l-139 -405h405zM1107 1559v-29h-159l-203 151h-4l-211 -151h-160v29l258 276h229z"" />
    <glyph glyph-name=""Atilde"" unicode=""&#xc3;"" horiz-adv-x=""1479"" 
d=""M1133 0l-125 360h-537l-125 -360h-295l514 1409h348l512 -1409h-292zM803 987q-12 35 -23.5 70.5t-20 65t-14 48.5t-6.5 21q-1 -3 -6 -22t-13.5 -48t-20 -64.5t-23.5 -70.5l-139 -405h405zM905 1530q-44 0 -88.5 19t-86.5 42.5t-79.5 42.5t-67.5 19q-26 0 -43 -8.5
t-27.5 -24.5t-16.5 -38.5t-11 -51.5h-137q3 45 11 96t31.5 95t66.5 73t116 29q45 0 90 -19t87 -42.5t78.5 -42.5t65.5 -19q25 0 41.5 8.5t28 24.5t18 39t11.5 51h135q-2 -45 -10 -96t-31 -95t-66 -73t-116 -29z"" />
    <glyph glyph-name=""Adieresis"" unicode=""&#xc4;"" horiz-adv-x=""1479"" 
d=""M1133 0l-125 360h-537l-125 -360h-295l514 1409h348l512 -1409h-292zM803 987q-12 35 -23.5 70.5t-20 65t-14 48.5t-6.5 21q-1 -3 -6 -22t-13.5 -48t-20 -64.5t-23.5 -70.5l-139 -405h405zM868 1530v219h197v-219h-197zM414 1530v219h194v-219h-194z"" />
    <glyph glyph-name=""Aring"" unicode=""&#xc5;"" horiz-adv-x=""1479"" 
d=""M1133 0l-125 360h-537l-125 -360h-295l514 1409h348l512 -1409h-292zM803 987q-12 35 -23.5 70.5t-20 65t-14 48.5t-6.5 21q-1 -3 -6 -22t-13.5 -48t-20 -64.5t-23.5 -70.5l-139 -405h405zM993 1552q0 -53 -20 -99.5t-54.5 -81t-81 -54t-98.5 -19.5t-98.5 19.5t-81 54
t-54.5 81t-20 99.5q0 52 20 98.5t54.5 81t81 54.5t98.5 20t98.5 -20t81 -54.5t54.5 -81t20 -98.5zM866 1552q0 26 -10 48.5t-27 39.5t-40.5 27t-49.5 10t-49 -10t-40 -27t-26.5 -39.5t-9.5 -48.5q0 -27 9.5 -50.5t26.5 -40.5t40 -27t49 -10t49.5 10t40.5 27t27 40.5t10 50.5
z"" />
    <glyph glyph-name=""AE"" unicode=""&#xc6;"" horiz-adv-x=""2048"" 
d=""M931 0v360h-450l-172 -360h-305l700 1409h1223v-227h-701v-355h639v-221h-639v-379h742v-227h-1037zM931 1192h-61q-4 -9 -17 -37t-28 -61.5t-29.5 -64.5t-21.5 -46l-191 -401h348v610z"" />
    <glyph glyph-name=""Ccedilla"" unicode=""&#xc7;"" horiz-adv-x=""1479"" 
d=""M795 212q83 0 143.5 23.5t105 61.5t74 86t48.5 97l257 -97q-31 -76 -81 -149t-125 -129t-178.5 -90.5t-243.5 -34.5q-183 0 -317 54.5t-221.5 152t-130 231.5t-42.5 293q0 165 42.5 298t128.5 226.5t217.5 144t309.5 50.5q138 0 241.5 -29t179 -81.5t125 -124
t77.5 -157.5l-260 -71q-14 45 -43 86.5t-73.5 73.5t-104.5 51.5t-136 19.5q-107 0 -184 -34.5t-126.5 -98.5t-73 -153.5t-23.5 -200.5q0 -110 23.5 -201.5t73.5 -157.5t128.5 -103t188.5 -37zM989 -235q0 -39 -15.5 -74t-51 -60.5t-93.5 -40.5t-143 -15q-45 0 -101 6v118
q25 -5 46 -6t38 -1q75 0 106 18.5t31 50.5q0 35 -28 52t-94 17h-25.5t-26.5 -2l62 172h143l-33 -82q94 -5 139.5 -46t45.5 -107z"" />
    <glyph glyph-name=""Egrave"" unicode=""&#xc8;"" horiz-adv-x=""1366"" 
d=""M137 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149zM736 1530l-340 242v43h258l251 -254v-31h-169z"" />
    <glyph glyph-name=""Eacute"" unicode=""&#xc9;"" horiz-adv-x=""1366"" 
d=""M137 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149zM517 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""Ecircumflex"" unicode=""&#xca;"" horiz-adv-x=""1366"" 
d=""M137 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149zM1081 1559v-29h-159l-203 151h-4l-211 -151h-160v29l258 276h229z"" />
    <glyph glyph-name=""Edieresis"" unicode=""&#xcb;"" horiz-adv-x=""1366"" 
d=""M137 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149zM840 1530v219h197v-219h-197zM386 1530v219h194v-219h-194z"" />
    <glyph glyph-name=""Igrave"" unicode=""&#xcc;"" horiz-adv-x=""569"" 
d=""M137 0v1409h295v-1409h-295zM300 1530l-340 242v43h258l251 -254v-31h-169z"" />
    <glyph glyph-name=""Iacute"" unicode=""&#xcd;"" horiz-adv-x=""569"" 
d=""M137 0v1409h295v-1409h-295zM104 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""Icircumflex"" unicode=""&#xce;"" horiz-adv-x=""569"" 
d=""M137 0v1409h295v-1409h-295zM652 1559v-29h-159l-203 151h-4l-211 -151h-160v29l258 276h229z"" />
    <glyph glyph-name=""Idieresis"" unicode=""&#xcf;"" horiz-adv-x=""569"" 
d=""M137 0v1409h295v-1409h-295zM413 1530v219h197v-219h-197zM-41 1530v219h194v-219h-194z"" />
    <glyph glyph-name=""Eth"" unicode=""&#xd0;"" horiz-adv-x=""1479"" 
d=""M1393 715q0 -176 -53 -309.5t-145 -223.5t-217.5 -136t-270.5 -46h-570v594h-129v219h129v596h510q164 0 301 -41t236 -126t154 -216t55 -311zM1096 715q0 123 -33.5 210.5t-93.5 143.5t-143.5 82.5t-184.5 26.5h-209v-365h356v-219h-356v-363h250q89 0 164.5 30.5
t131 91.5t87 151.5t31.5 210.5z"" />
    <glyph glyph-name=""Ntilde"" unicode=""&#xd1;"" horiz-adv-x=""1479"" 
d=""M995 0l-614 1085q5 -44 9 -88q4 -38 6.5 -82t2.5 -84v-831h-262v1409h337l623 -1094q-5 42 -9 88q-4 39 -6.5 88t-2.5 99v819h262v-1409h-346zM906 1530q-44 0 -88.5 19t-86.5 42.5t-79.5 42.5t-67.5 19q-26 0 -43 -8.5t-27.5 -24.5t-16.5 -38.5t-11 -51.5h-137
q3 45 11 96t31.5 95t66.5 73t116 29q45 0 90 -19t87 -42.5t78.5 -42.5t65.5 -19q25 0 41.5 8.5t28 24.5t18 39t11.5 51h135q-2 -45 -10 -96t-31 -95t-66 -73t-116 -29z"" />
    <glyph glyph-name=""Ograve"" unicode=""&#xd2;"" horiz-adv-x=""1593"" 
d=""M1507 711q0 -165 -49 -300t-141 -231t-224.5 -148t-299.5 -52q-177 0 -309.5 54.5t-221.5 152t-133.5 231.5t-44.5 293q0 165 46.5 298t137 226.5t223 144t304.5 50.5t304.5 -51t223 -145t137.5 -226.5t47 -296.5zM1206 711q0 111 -26.5 200.5t-78.5 153.5t-128.5 98.5
t-177.5 34.5q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5q0 -110 26.5 -201.5t78.5 -157.5t129 -103t178 -37q108 0 186 37.5t128.5 104t74.5 158t24 199.5zM887 1530l-340 242v43h258l251 -254v-31h-169z"" />
    <glyph glyph-name=""Oacute"" unicode=""&#xd3;"" horiz-adv-x=""1593"" 
d=""M1507 711q0 -165 -49 -300t-141 -231t-224.5 -148t-299.5 -52q-177 0 -309.5 54.5t-221.5 152t-133.5 231.5t-44.5 293q0 165 46.5 298t137 226.5t223 144t304.5 50.5t304.5 -51t223 -145t137.5 -226.5t47 -296.5zM1206 711q0 111 -26.5 200.5t-78.5 153.5t-128.5 98.5
t-177.5 34.5q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5q0 -110 26.5 -201.5t78.5 -157.5t129 -103t178 -37q108 0 186 37.5t128.5 104t74.5 158t24 199.5zM625 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""Ocircumflex"" unicode=""&#xd4;"" horiz-adv-x=""1593"" 
d=""M1507 711q0 -165 -49 -300t-141 -231t-224.5 -148t-299.5 -52q-177 0 -309.5 54.5t-221.5 152t-133.5 231.5t-44.5 293q0 165 46.5 298t137 226.5t223 144t304.5 50.5t304.5 -51t223 -145t137.5 -226.5t47 -296.5zM1206 711q0 111 -26.5 200.5t-78.5 153.5t-128.5 98.5
t-177.5 34.5q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5q0 -110 26.5 -201.5t78.5 -157.5t129 -103t178 -37q108 0 186 37.5t128.5 104t74.5 158t24 199.5zM1163 1559v-29h-159l-203 151h-4l-211 -151h-160v29l258 276h229z"" />
    <glyph glyph-name=""Otilde"" unicode=""&#xd5;"" horiz-adv-x=""1593"" 
d=""M1507 711q0 -165 -49 -300t-141 -231t-224.5 -148t-299.5 -52q-177 0 -309.5 54.5t-221.5 152t-133.5 231.5t-44.5 293q0 165 46.5 298t137 226.5t223 144t304.5 50.5t304.5 -51t223 -145t137.5 -226.5t47 -296.5zM1206 711q0 111 -26.5 200.5t-78.5 153.5t-128.5 98.5
t-177.5 34.5q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5q0 -110 26.5 -201.5t78.5 -157.5t129 -103t178 -37q108 0 186 37.5t128.5 104t74.5 158t24 199.5zM954 1530q-44 0 -88.5 19t-86.5 42.5t-79.5 42.5t-67.5 19q-26 0 -43 -8.5t-27.5 -24.5t-16.5 -38.5
t-11 -51.5h-137q3 45 11 96t31.5 95t66.5 73t116 29q45 0 90 -19t87 -42.5t78.5 -42.5t65.5 -19q25 0 41.5 8.5t28 24.5t18 39t11.5 51h135q-2 -45 -10 -96t-31 -95t-66 -73t-116 -29z"" />
    <glyph glyph-name=""Odieresis"" unicode=""&#xd6;"" horiz-adv-x=""1593"" 
d=""M1507 711q0 -165 -49 -300t-141 -231t-224.5 -148t-299.5 -52q-177 0 -309.5 54.5t-221.5 152t-133.5 231.5t-44.5 293q0 165 46.5 298t137 226.5t223 144t304.5 50.5t304.5 -51t223 -145t137.5 -226.5t47 -296.5zM1206 711q0 111 -26.5 200.5t-78.5 153.5t-128.5 98.5
t-177.5 34.5q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5q0 -110 26.5 -201.5t78.5 -157.5t129 -103t178 -37q108 0 186 37.5t128.5 104t74.5 158t24 199.5zM923 1530v219h197v-219h-197zM469 1530v219h194v-219h-194z"" />
    <glyph glyph-name=""multiply"" unicode=""&#xd7;"" horiz-adv-x=""1196"" 
d=""M86 326l356 358l-352 352l158 156l352 -350l352 352l158 -158l-352 -354l352 -350l-158 -160l-352 354l-356 -358z"" />
    <glyph glyph-name=""Oslash"" unicode=""&#xd8;"" horiz-adv-x=""1593"" 
d=""M147 -73l154 218q-109 99 -163 243.5t-54 322.5q0 165 46.5 298t137 226.5t223 144t304.5 50.5q103 0 191.5 -19.5t162.5 -54.5l82 117h193l-142 -203q112 -94 169 -236.5t57 -322.5q0 -165 -49 -300t-141 -231t-225 -148t-300 -52q-212 0 -360 77l-91 -129zM1207 711
q0 100 -21.5 182.5t-64.5 144.5l-541 -772q43 -26 96.5 -40.5t116.5 -14.5q108 0 186.5 37.5t129 104t74.5 158.5t24 200zM381 711q0 -99 20.5 -183t63.5 -149l539 768q-45 25 -96 38t-113 13q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5z"" />
    <glyph glyph-name=""Ugrave"" unicode=""&#xd9;"" horiz-adv-x=""1479"" 
d=""M723 -20q-132 0 -242 31.5t-189.5 98t-124 170.5t-44.5 248v881h295v-858q0 -89 22 -153.5t63 -106t99 -61t129 -19.5q72 0 132.5 20.5t104 63.5t67.5 109t24 157v848h295v-866q0 -145 -47 -251t-131 -175.5t-199.5 -103t-253.5 -33.5zM756 1530l-340 242v43h258
l251 -254v-31h-169z"" />
    <glyph glyph-name=""Uacute"" unicode=""&#xda;"" horiz-adv-x=""1479"" 
d=""M723 -20q-132 0 -242 31.5t-189.5 98t-124 170.5t-44.5 248v881h295v-858q0 -89 22 -153.5t63 -106t99 -61t129 -19.5q72 0 132.5 20.5t104 63.5t67.5 109t24 157v848h295v-866q0 -145 -47 -251t-131 -175.5t-199.5 -103t-253.5 -33.5zM592 1530v31l252 254h258v-43
l-340 -242h-170z"" />
    <glyph glyph-name=""Ucircumflex"" unicode=""&#xdb;"" horiz-adv-x=""1479"" 
d=""M723 -20q-132 0 -242 31.5t-189.5 98t-124 170.5t-44.5 248v881h295v-858q0 -89 22 -153.5t63 -106t99 -61t129 -19.5q72 0 132.5 20.5t104 63.5t67.5 109t24 157v848h295v-866q0 -145 -47 -251t-131 -175.5t-199.5 -103t-253.5 -33.5zM1105 1559v-29h-159l-203 151h-4
l-211 -151h-160v29l258 276h229z"" />
    <glyph glyph-name=""Udieresis"" unicode=""&#xdc;"" horiz-adv-x=""1479"" 
d=""M723 -20q-132 0 -242 31.5t-189.5 98t-124 170.5t-44.5 248v881h295v-858q0 -89 22 -153.5t63 -106t99 -61t129 -19.5q72 0 132.5 20.5t104 63.5t67.5 109t24 157v848h295v-866q0 -145 -47 -251t-131 -175.5t-199.5 -103t-253.5 -33.5zM867 1530v219h197v-219h-197z
M413 1530v219h194v-219h-194z"" />
    <glyph glyph-name=""Yacute"" unicode=""&#xdd;"" horiz-adv-x=""1366"" 
d=""M831 578v-578h-294v578l-502 831h309l338 -596l342 596h309zM524 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""Thorn"" unicode=""&#xde;"" horiz-adv-x=""1366"" 
d=""M1296 737q0 -91 -30.5 -173.5t-93.5 -144.5t-160 -99t-230 -37h-350v-283h-295v1409h295v-233h338q135 0 234 -31.5t164 -89t96.5 -138.5t31.5 -180zM999 733q0 110 -65.5 172t-196.5 62h-305v-475h313q66 0 113.5 18t79 50.5t46.5 76.5t15 96z"" />
    <glyph glyph-name=""germandbls"" unicode=""&#xdf;"" horiz-adv-x=""1251"" 
d=""M1193 312q0 -73 -22 -134t-69.5 -105t-120.5 -68.5t-175 -24.5q-71 0 -135.5 10t-126.5 33v206q24 -11 54 -21.5t61 -19t61.5 -13.5t55.5 -5q81 0 118 34.5t37 91.5q0 46 -25 80t-62.5 63.5t-81.5 58t-81.5 65t-62.5 84t-25 113.5q0 46 16.5 80.5t41.5 63.5t53.5 54
t53.5 51.5t41.5 57.5t16.5 71q0 65 -46.5 104t-134.5 39q-103 0 -157 -63.5t-54 -204.5v-1013h-281v1007q0 111 30 199.5t91.5 150t154.5 94.5t219 33q114 0 198 -27t138.5 -72.5t81 -106.5t26.5 -129q0 -54 -16.5 -96.5t-41.5 -76.5t-54.5 -61t-54.5 -49.5t-41.5 -43
t-16.5 -40.5q0 -28 25 -52.5t62 -52t81 -60t81 -75t62 -99t25 -131.5z"" />
    <glyph glyph-name=""agrave"" unicode=""&#xe0;"" 
d=""M385 -20q-78 0 -139.5 21.5t-104.5 63t-66 102.5t-23 139q0 96 33.5 161.5t91.5 106t136 59t166 19.5l233 4v55q0 59 -10.5 98.5t-30.5 64.5t-49.5 35.5t-67.5 10.5q-35 0 -62.5 -7t-47.5 -24.5t-32.5 -47t-17.5 -74.5l-293 14q12 71 44 129.5t88.5 101.5t139 66.5
t193.5 23.5q101 0 180 -25t134 -74.5t84 -121.5t29 -167v-394q0 -38 3.5 -68t13 -50.5t27 -31t45.5 -10.5q32 0 62 6v-152q-25 -6 -45 -11t-40 -8t-42.5 -5t-52.5 -2q-106 0 -156.5 52t-60.5 153h-6q-56 -101 -143.5 -157t-212.5 -56zM712 501l-144 -2q-45 -2 -85.5 -7.5
t-71 -23t-48.5 -50.5t-18 -90q0 -77 35.5 -114.5t94.5 -37.5q54 0 98 23t74.5 60.5t47.5 86.5t17 100v55zM580 1183l-340 276v43h258l251 -288v-31h-169z"" />
    <glyph glyph-name=""aacute"" unicode=""&#xe1;"" 
d=""M385 -20q-78 0 -139.5 21.5t-104.5 63t-66 102.5t-23 139q0 96 33.5 161.5t91.5 106t136 59t166 19.5l233 4v55q0 59 -10.5 98.5t-30.5 64.5t-49.5 35.5t-67.5 10.5q-35 0 -62.5 -7t-47.5 -24.5t-32.5 -47t-17.5 -74.5l-293 14q12 71 44 129.5t88.5 101.5t139 66.5
t193.5 23.5q101 0 180 -25t134 -74.5t84 -121.5t29 -167v-394q0 -38 3.5 -68t13 -50.5t27 -31t45.5 -10.5q32 0 62 6v-152q-25 -6 -45 -11t-40 -8t-42.5 -5t-52.5 -2q-106 0 -156.5 52t-60.5 153h-6q-56 -101 -143.5 -157t-212.5 -56zM712 501l-144 -2q-45 -2 -85.5 -7.5
t-71 -23t-48.5 -50.5t-18 -90q0 -77 35.5 -114.5t94.5 -37.5q54 0 98 23t74.5 60.5t47.5 86.5t17 100v55zM375 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""acircumflex"" unicode=""&#xe2;"" 
d=""M385 -20q-78 0 -139.5 21.5t-104.5 63t-66 102.5t-23 139q0 96 33.5 161.5t91.5 106t136 59t166 19.5l233 4v55q0 59 -10.5 98.5t-30.5 64.5t-49.5 35.5t-67.5 10.5q-35 0 -62.5 -7t-47.5 -24.5t-32.5 -47t-17.5 -74.5l-293 14q12 71 44 129.5t88.5 101.5t139 66.5
t193.5 23.5q101 0 180 -25t134 -74.5t84 -121.5t29 -167v-394q0 -38 3.5 -68t13 -50.5t27 -31t45.5 -10.5q32 0 62 6v-152q-25 -6 -45 -11t-40 -8t-42.5 -5t-52.5 -2q-106 0 -156.5 52t-60.5 153h-6q-56 -101 -143.5 -157t-212.5 -56zM712 501l-144 -2q-45 -2 -85.5 -7.5
t-71 -23t-48.5 -50.5t-18 -90q0 -77 35.5 -114.5t94.5 -37.5q54 0 98 23t74.5 60.5t47.5 86.5t17 100v55zM936 1211v-28h-159l-203 192h-4l-211 -192h-160v28l258 318h229z"" />
    <glyph glyph-name=""atilde"" unicode=""&#xe3;"" 
d=""M385 -20q-78 0 -139.5 21.5t-104.5 63t-66 102.5t-23 139q0 96 33.5 161.5t91.5 106t136 59t166 19.5l233 4v55q0 59 -10.5 98.5t-30.5 64.5t-49.5 35.5t-67.5 10.5q-35 0 -62.5 -7t-47.5 -24.5t-32.5 -47t-17.5 -74.5l-293 14q12 71 44 129.5t88.5 101.5t139 66.5
t193.5 23.5q101 0 180 -25t134 -74.5t84 -121.5t29 -167v-394q0 -38 3.5 -68t13 -50.5t27 -31t45.5 -10.5q32 0 62 6v-152q-25 -6 -45 -11t-40 -8t-42.5 -5t-52.5 -2q-106 0 -156.5 52t-60.5 153h-6q-56 -101 -143.5 -157t-212.5 -56zM712 501l-144 -2q-45 -2 -85.5 -7.5
t-71 -23t-48.5 -50.5t-18 -90q0 -77 35.5 -114.5t94.5 -37.5q54 0 98 23t74.5 60.5t47.5 86.5t17 100v55zM719 1183q-44 0 -88.5 19t-86.5 42.5t-79.5 42.5t-67.5 19q-26 0 -43 -8.5t-27.5 -24.5t-16.5 -38.5t-11 -51.5h-137q3 45 11 96t31.5 95t66.5 73t116 29q45 0 90 -19
t87 -42.5t78.5 -42.5t65.5 -19q25 0 41.5 8.5t28 24.5t18 39t11.5 51h135q-2 -45 -10 -96t-31 -95t-66 -73t-116 -29z"" />
    <glyph glyph-name=""adieresis"" unicode=""&#xe4;"" 
d=""M385 -20q-78 0 -139.5 21.5t-104.5 63t-66 102.5t-23 139q0 96 33.5 161.5t91.5 106t136 59t166 19.5l233 4v55q0 59 -10.5 98.5t-30.5 64.5t-49.5 35.5t-67.5 10.5q-35 0 -62.5 -7t-47.5 -24.5t-32.5 -47t-17.5 -74.5l-293 14q12 71 44 129.5t88.5 101.5t139 66.5
t193.5 23.5q101 0 180 -25t134 -74.5t84 -121.5t29 -167v-394q0 -38 3.5 -68t13 -50.5t27 -31t45.5 -10.5q32 0 62 6v-152q-25 -6 -45 -11t-40 -8t-42.5 -5t-52.5 -2q-106 0 -156.5 52t-60.5 153h-6q-56 -101 -143.5 -157t-212.5 -56zM712 501l-144 -2q-45 -2 -85.5 -7.5
t-71 -23t-48.5 -50.5t-18 -90q0 -77 35.5 -114.5t94.5 -37.5q54 0 98 23t74.5 60.5t47.5 86.5t17 100v55zM665 1199v219h217v-219h-217zM231 1199v219h214v-219h-214z"" />
    <glyph glyph-name=""aring"" unicode=""&#xe5;"" 
d=""M385 -20q-78 0 -139.5 21.5t-104.5 63t-66 102.5t-23 139q0 96 33.5 161.5t91.5 106t136 59t166 19.5l233 4v55q0 59 -10.5 98.5t-30.5 64.5t-49.5 35.5t-67.5 10.5q-35 0 -62.5 -7t-47.5 -24.5t-32.5 -47t-17.5 -74.5l-293 14q12 71 44 129.5t88.5 101.5t139 66.5
t193.5 23.5q101 0 180 -25t134 -74.5t84 -121.5t29 -167v-394q0 -38 3.5 -68t13 -50.5t27 -31t45.5 -10.5q32 0 62 6v-152q-25 -6 -45 -11t-40 -8t-42.5 -5t-52.5 -2q-106 0 -156.5 52t-60.5 153h-6q-56 -101 -143.5 -157t-212.5 -56zM712 501l-144 -2q-45 -2 -85.5 -7.5
t-71 -23t-48.5 -50.5t-18 -90q0 -77 35.5 -114.5t94.5 -37.5q54 0 98 23t74.5 60.5t47.5 86.5t17 100v55zM813 1431q0 -53 -20 -99.5t-54.5 -81t-81 -54t-98.5 -19.5t-98.5 19.5t-81 54t-54.5 81t-20 99.5q0 52 20 98.5t54.5 81t81 54.5t98.5 20t98.5 -20t81 -54.5t54.5 -81
t20 -98.5zM686 1431q0 26 -10 48.5t-27 39.5t-40.5 27t-49.5 10t-49 -10t-40 -27t-26.5 -39.5t-9.5 -48.5q0 -27 9.5 -50.5t26.5 -40.5t40 -27t49 -10t49.5 10t40.5 27t27 40.5t10 50.5z"" />
    <glyph glyph-name=""ae"" unicode=""&#xe6;"" horiz-adv-x=""1821"" 
d=""M1253 -20q-151 0 -261 56.5t-173 172.5q-29 -50 -67.5 -92t-89 -72.5t-114 -47.5t-142.5 -17t-142 21.5t-107 63t-67.5 102.5t-23.5 139q0 96 34.5 161t94.5 105.5t140 59t171 20.5l240 4v55q0 59 -11 98.5t-32.5 64.5t-53 35.5t-71.5 10.5q-37 0 -66.5 -7t-50.5 -24.5
t-34.5 -47t-18.5 -74.5l-293 14q12 71 44.5 129.5t89.5 101.5t140 66.5t197 23.5q217 0 333 -107q69 57 155.5 82t182.5 25q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-19h-694q0 -65 13 -121.5t40.5 -98t70 -65t101.5 -23.5q74 0 121 31.5t67 97.5l265 -23
q-18 -46 -50.5 -98t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM496 176q57 0 103 24.5t79 64t50.5 90t17.5 101.5v45l-152 -2q-48 -2 -90.5 -7.5t-74.5 -23t-51 -50.5t-19 -90q0 -77 37.5 -114.5t99.5 -37.5zM1253 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420
q-8 131 -63 196.5t-148 65.5z"" />
    <glyph glyph-name=""ccedilla"" unicode=""&#xe7;"" 
d=""M594 -20q-129 0 -225.5 40t-160.5 113t-96 175.5t-32 226.5q0 135 35 240.5t101 178t162.5 110.5t219.5 38q105 0 186.5 -28t140.5 -76.5t95.5 -114.5t50.5 -142l-283 -14q-12 83 -60 132.5t-136 49.5q-113 0 -165 -93t-52 -270q0 -374 221 -374q80 0 134 50.5t67 150.5
l282 -13q-10 -75 -45.5 -143.5t-96 -121t-146.5 -84t-197 -31.5zM791 -235q0 -39 -15.5 -74t-51 -60.5t-93.5 -40.5t-143 -15q-45 0 -101 6v118q25 -5 46 -6t38 -1q75 0 106 18.5t31 50.5q0 35 -28 52t-94 17h-25.5t-26.5 -2l62 172h143l-33 -82q94 -5 139.5 -46t45.5 -107z
"" />
    <glyph glyph-name=""egrave"" unicode=""&#xe8;"" 
d=""M586 -20q-117 0 -210.5 34.5t-159.5 105t-101 177t-35 249.5q0 155 41.5 261t112 171.5t162.5 94.5t194 29q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-8h-694q0 -68 12 -126.5t39 -101t70 -67t104 -24.5q74 0 121 31.5t67 97.5l265 -23q-18 -46 -50.5 -98
t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM586 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420q-8 131 -63 196.5t-148 65.5zM627 1183l-340 276v43h258l251 -288v-31h-169z"" />
    <glyph glyph-name=""eacute"" unicode=""&#xe9;"" 
d=""M586 -20q-117 0 -210.5 34.5t-159.5 105t-101 177t-35 249.5q0 155 41.5 261t112 171.5t162.5 94.5t194 29q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-8h-694q0 -68 12 -126.5t39 -101t70 -67t104 -24.5q74 0 121 31.5t67 97.5l265 -23q-18 -46 -50.5 -98
t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM586 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420q-8 131 -63 196.5t-148 65.5zM418 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""ecircumflex"" unicode=""&#xea;"" 
d=""M586 -20q-117 0 -210.5 34.5t-159.5 105t-101 177t-35 249.5q0 155 41.5 261t112 171.5t162.5 94.5t194 29q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-8h-694q0 -68 12 -126.5t39 -101t70 -67t104 -24.5q74 0 121 31.5t67 97.5l265 -23q-18 -46 -50.5 -98
t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM586 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420q-8 131 -63 196.5t-148 65.5zM960 1211v-28h-159l-203 192h-4l-211 -192h-160v28l258 318h229z"" />
    <glyph glyph-name=""edieresis"" unicode=""&#xeb;"" 
d=""M586 -20q-117 0 -210.5 34.5t-159.5 105t-101 177t-35 249.5q0 155 41.5 261t112 171.5t162.5 94.5t194 29q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-8h-694q0 -68 12 -126.5t39 -101t70 -67t104 -24.5q74 0 121 31.5t67 97.5l265 -23q-18 -46 -50.5 -98
t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM586 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420q-8 131 -63 196.5t-148 65.5zM694 1199v219h217v-219h-217zM260 1199v219h214v-219h-214z"" />
    <glyph glyph-name=""igrave"" unicode=""&#xec;"" horiz-adv-x=""569"" 
d=""M145 0v1082h281v-1082h-281zM276 1183l-340 276v43h258l251 -288v-31h-169z"" />
    <glyph glyph-name=""iacute"" unicode=""&#xed;"" horiz-adv-x=""569"" 
d=""M145 0v1082h281v-1082h-281zM114 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""icircumflex"" unicode=""&#xee;"" horiz-adv-x=""569"" 
d=""M145 0v1082h281v-1082h-281zM654 1211v-28h-159l-203 192h-4l-211 -192h-160v28l258 318h229z"" />
    <glyph glyph-name=""idieresis"" unicode=""&#xef;"" horiz-adv-x=""569"" 
d=""M145 0v1082h281v-1082h-281zM394 1199v219h217v-219h-217zM-40 1199v219h214v-219h-214z"" />
    <glyph glyph-name=""eth"" unicode=""&#xf0;"" horiz-adv-x=""1251"" 
d=""M856 1266q69 -70 127 -150.5t100 -171t65 -191.5t23 -212v-4q0 -122 -34 -224t-102.5 -175.5t-171.5 -114.5t-240 -41q-132 0 -233 36.5t-170 102t-104.5 157t-35.5 201.5q0 107 33.5 197.5t101.5 156.5t171 103t241 37q46 0 91 -8.5t72 -23.5q-34 72 -69 127t-81 108
l-292 -122v184l166 70q-57 46 -123.5 90t-134.5 86h293q40 -20 80.5 -43t79.5 -51l268 113v-188zM877 477q0 160 -63 231.5t-183 71.5q-124 0 -190 -73t-66 -230q0 -80 17.5 -137.5t49.5 -95t77 -55t99 -17.5q125 0 192 72t67 233z"" />
    <glyph glyph-name=""ntilde"" unicode=""&#xf1;"" horiz-adv-x=""1251"" 
d=""M844 0v607q0 63 -10 115.5t-33 90t-60 58.5t-90 21q-51 0 -92.5 -22.5t-71.5 -64t-46.5 -99t-16.5 -126.5v-580h-281v840q0 35 -0.5 72t-2 70.5t-2.5 60t-3 39.5h268q2 -12 4 -38.5t4 -58.5t3.5 -64t1.5 -54h4q57 124 143 180t205 56q98 0 165.5 -32t110 -88t61.5 -132
t19 -164v-687h-280zM809 1183q-44 0 -88.5 19t-86.5 42.5t-79.5 42.5t-67.5 19q-26 0 -43 -8.5t-27.5 -24.5t-16.5 -38.5t-11 -51.5h-137q3 45 11 96t31.5 95t66.5 73t116 29q45 0 90 -19t87 -42.5t78.5 -42.5t65.5 -19q25 0 41.5 8.5t28 24.5t18 39t11.5 51h135
q-2 -45 -10 -96t-31 -95t-66 -73t-116 -29z"" />
    <glyph glyph-name=""ograve"" unicode=""&#xf2;"" horiz-adv-x=""1251"" 
d=""M1171 542q0 -124 -34.5 -227t-103.5 -177.5t-172 -116t-240 -41.5q-132 0 -233 41t-169.5 115t-103.5 177.5t-35 228.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q146 0 249 -42t168.5 -116.5t96 -177t30.5 -224.5zM877 542q0 193 -63 280t-183 87q-124 0 -190 -88
t-66 -279q0 -97 17.5 -167t49.5 -115t77 -66.5t99 -21.5q62 0 110.5 21.5t81.5 66.5t50 115t17 167zM668 1183l-340 276v43h258l251 -288v-31h-169z"" />
    <glyph glyph-name=""oacute"" unicode=""&#xf3;"" horiz-adv-x=""1251"" 
d=""M1171 542q0 -124 -34.5 -227t-103.5 -177.5t-172 -116t-240 -41.5q-132 0 -233 41t-169.5 115t-103.5 177.5t-35 228.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q146 0 249 -42t168.5 -116.5t96 -177t30.5 -224.5zM877 542q0 193 -63 280t-183 87q-124 0 -190 -88
t-66 -279q0 -97 17.5 -167t49.5 -115t77 -66.5t99 -21.5q62 0 110.5 21.5t81.5 66.5t50 115t17 167zM465 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""ocircumflex"" unicode=""&#xf4;"" horiz-adv-x=""1251"" 
d=""M1171 542q0 -124 -34.5 -227t-103.5 -177.5t-172 -116t-240 -41.5q-132 0 -233 41t-169.5 115t-103.5 177.5t-35 228.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q146 0 249 -42t168.5 -116.5t96 -177t30.5 -224.5zM877 542q0 193 -63 280t-183 87q-124 0 -190 -88
t-66 -279q0 -97 17.5 -167t49.5 -115t77 -66.5t99 -21.5q62 0 110.5 21.5t81.5 66.5t50 115t17 167zM993 1211v-28h-159l-203 192h-4l-211 -192h-160v28l258 318h229z"" />
    <glyph glyph-name=""otilde"" unicode=""&#xf5;"" horiz-adv-x=""1251"" 
d=""M1171 542q0 -124 -34.5 -227t-103.5 -177.5t-172 -116t-240 -41.5q-132 0 -233 41t-169.5 115t-103.5 177.5t-35 228.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q146 0 249 -42t168.5 -116.5t96 -177t30.5 -224.5zM877 542q0 193 -63 280t-183 87q-124 0 -190 -88
t-66 -279q0 -97 17.5 -167t49.5 -115t77 -66.5t99 -21.5q62 0 110.5 21.5t81.5 66.5t50 115t17 167zM791 1183q-44 0 -88.5 19t-86.5 42.5t-79.5 42.5t-67.5 19q-26 0 -43 -8.5t-27.5 -24.5t-16.5 -38.5t-11 -51.5h-137q3 45 11 96t31.5 95t66.5 73t116 29q45 0 90 -19
t87 -42.5t78.5 -42.5t65.5 -19q25 0 41.5 8.5t28 24.5t18 39t11.5 51h135q-2 -45 -10 -96t-31 -95t-66 -73t-116 -29z"" />
    <glyph glyph-name=""odieresis"" unicode=""&#xf6;"" horiz-adv-x=""1251"" 
d=""M1171 542q0 -124 -34.5 -227t-103.5 -177.5t-172 -116t-240 -41.5q-132 0 -233 41t-169.5 115t-103.5 177.5t-35 228.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q146 0 249 -42t168.5 -116.5t96 -177t30.5 -224.5zM877 542q0 193 -63 280t-183 87q-124 0 -190 -88
t-66 -279q0 -97 17.5 -167t49.5 -115t77 -66.5t99 -21.5q62 0 110.5 21.5t81.5 66.5t50 115t17 167zM734 1199v219h217v-219h-217zM300 1199v219h214v-219h-214z"" />
    <glyph glyph-name=""divide"" unicode=""&#xf7;"" horiz-adv-x=""1124"" 
d=""M442 961v233h238v-233h-238zM49 569v224h1027v-224h-1027zM442 170v233h238v-233h-238z"" />
    <glyph glyph-name=""oslash"" unicode=""&#xf8;"" horiz-adv-x=""1251"" 
d=""M1171 542q0 -124 -34.5 -227t-103.5 -177.5t-172 -116t-240 -41.5q-99 0 -179.5 23t-144.5 66l-113 -124h-183l197 215q-59 73 -88.5 169.5t-29.5 212.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q104 0 185.5 -21.5t144.5 -61.5l101 114h184l-184 -206
q59 -74 86 -172t27 -213zM375 542q0 -92 17 -163l407 461q-60 69 -168 69q-124 0 -190 -88t-66 -279zM877 542q0 47 -4 87.5t-12 74.5l-407 -460q32 -37 73 -54.5t91 -17.5q62 0 110.5 21.5t81.5 66.5t50 115t17 167z"" />
    <glyph glyph-name=""ugrave"" unicode=""&#xf9;"" horiz-adv-x=""1251"" 
d=""M831 215q-107 -235 -348 -235q-184 0 -275 120q-81 105 -81 295v687h281v-607q0 -285 192 -285q101 0 164 86q63 88 63 226v580h281v-840q0 -138 8 -242h-268q-1 12 -3.5 38.5t-4.5 58.5l-2 64q-2 32 -2 54h-5zM623 1183l-340 276v43h258l251 -288v-31h-169z"" />
    <glyph glyph-name=""uacute"" unicode=""&#xfa;"" horiz-adv-x=""1251"" 
d=""M831 215q-107 -235 -348 -235q-184 0 -275 120q-81 105 -81 295v687h281v-607q0 -285 192 -285q101 0 164 86q63 88 63 226v580h281v-840q0 -138 8 -242h-268q-1 12 -3.5 38.5t-4.5 58.5l-2 64q-2 32 -2 54h-5zM463 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""ucircumflex"" unicode=""&#xfb;"" horiz-adv-x=""1251"" 
d=""M831 215q-107 -235 -348 -235q-184 0 -275 120q-81 105 -81 295v687h281v-607q0 -285 192 -285q101 0 164 86q63 88 63 226v580h281v-840q0 -138 8 -242h-268q-1 12 -3.5 38.5t-4.5 58.5l-2 64q-2 32 -2 54h-5zM989 1211v-28h-159l-203 192h-4l-211 -192h-160v28l258 318
h229z"" />
    <glyph glyph-name=""udieresis"" unicode=""&#xfc;"" horiz-adv-x=""1251"" 
d=""M831 215q-107 -235 -348 -235q-184 0 -275 120q-81 105 -81 295v687h281v-607q0 -285 192 -285q101 0 164 86q63 88 63 226v580h281v-840q0 -138 8 -242h-268q-1 12 -3.5 38.5t-4.5 58.5l-2 64q-2 32 -2 54h-5zM732 1199v219h217v-219h-217zM298 1199v219h214v-219h-214z
"" />
    <glyph glyph-name=""yacute"" unicode=""&#xfd;"" 
d=""M584 241l250 841h294l-428 -1139q-81 -197 -168 -279q-95 -89 -249 -89q-101 0 -177 13v200q53 -8 95.5 -8t74.5 9t58 30q51 42 92 144l18 48l-428 1071h297zM413 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""thorn"" unicode=""&#xfe;"" horiz-adv-x=""1251"" 
d=""M143 1484h281v-462q0 -30 -0.5 -60t-1.5 -54q-1 -28 -2 -54h4q51 107 140 153t206 46q103 0 178 -40t123.5 -111t72 -168.5t23.5 -213.5q0 -117 -24.5 -216t-75.5 -171t-129.5 -112.5t-185.5 -40.5q-48 0 -95.5 10t-90.5 32.5t-79.5 59t-62.5 90.5h-6q1 -5 2 -25t2 -46.5
t1.5 -56t0.5 -54.5v-415h-281v1909zM874 520q0 172 -55.5 255t-167.5 83q-42 0 -83.5 -16t-74 -55.5t-53 -106.5t-20.5 -168q0 -99 20 -164.5t52.5 -104.5t73.5 -55t83 -16q108 0 166.5 82.5t58.5 265.5z"" />
    <glyph glyph-name=""ydieresis"" unicode=""&#xff;"" 
d=""M584 241l250 841h294l-428 -1139q-81 -197 -168 -279q-95 -89 -249 -89q-101 0 -177 13v200q53 -8 95.5 -8t74.5 9t58 30q51 42 92 144l18 48l-428 1071h297zM691 1199v219h217v-219h-217zM257 1199v219h214v-219h-214z"" />
    <glyph glyph-name=""Amacron"" unicode=""&#x100;"" horiz-adv-x=""1479"" 
d=""M1133 0l-125 360h-537l-125 -360h-295l514 1409h348l512 -1409h-292zM803 987q-12 35 -23.5 70.5t-20 65t-14 48.5t-6.5 21q-1 -3 -6 -22t-13.5 -48t-20 -64.5t-23.5 -70.5l-139 -405h405zM432 1705h612v-168h-612v168z"" />
    <glyph glyph-name=""amacron"" unicode=""&#x101;"" 
d=""M393 -20q-78 0 -139.5 21.5t-104.5 63t-66 102.5t-23 139q0 96 33.5 161.5t91.5 106t136 59t166 19.5l233 4v55q0 59 -10.5 98.5t-30.5 64.5t-49.5 35.5t-67.5 10.5q-35 0 -62.5 -7t-47.5 -24.5t-32.5 -47t-17.5 -74.5l-293 14q12 71 44 129.5t88.5 101.5t139 66.5
t193.5 23.5q101 0 180 -25t134 -74.5t84 -121.5t29 -167v-394q0 -38 3.5 -68t13 -50.5t27 -31t45.5 -10.5q32 0 62 6v-152q-25 -6 -45 -11t-40 -8t-42.5 -5t-52.5 -2q-106 0 -156.5 52t-60.5 153h-6q-56 -101 -143.5 -157t-212.5 -56zM720 501l-144 -2q-45 -2 -85.5 -7.5
t-71 -23t-48.5 -50.5t-18 -90q0 -77 35.5 -114.5t94.5 -37.5q54 0 98 23t74.5 60.5t47.5 86.5t17 100v55zM279 1371h612v-168h-612v168z"" />
    <glyph glyph-name=""Abreve"" unicode=""&#x102;"" horiz-adv-x=""1479"" 
d=""M1133 0l-125 360h-537l-125 -360h-295l514 1409h348l512 -1409h-292zM803 987q-12 35 -23.5 70.5t-20 65t-14 48.5t-6.5 21q-1 -3 -6 -22t-13.5 -48t-20 -64.5t-23.5 -70.5l-139 -405h405zM737 1520q-80 0 -143 24t-107.5 63.5t-70.5 91.5t-31 109h163q8 -32 26 -57
t43 -42.5t56.5 -27t65.5 -9.5q36 0 67.5 9.5t56.5 27t42 42.5t24 57h164q-8 -57 -33.5 -109t-69 -91.5t-106.5 -63.5t-147 -24z"" />
    <glyph glyph-name=""abreve"" unicode=""&#x103;"" 
d=""M393 -20q-78 0 -139.5 21.5t-104.5 63t-66 102.5t-23 139q0 96 33.5 161.5t91.5 106t136 59t166 19.5l233 4v55q0 59 -10.5 98.5t-30.5 64.5t-49.5 35.5t-67.5 10.5q-35 0 -62.5 -7t-47.5 -24.5t-32.5 -47t-17.5 -74.5l-293 14q12 71 44 129.5t88.5 101.5t139 66.5
t193.5 23.5q101 0 180 -25t134 -74.5t84 -121.5t29 -167v-394q0 -38 3.5 -68t13 -50.5t27 -31t45.5 -10.5q32 0 62 6v-152q-25 -6 -45 -11t-40 -8t-42.5 -5t-52.5 -2q-106 0 -156.5 52t-60.5 153h-6q-56 -101 -143.5 -157t-212.5 -56zM720 501l-144 -2q-45 -2 -85.5 -7.5
t-71 -23t-48.5 -50.5t-18 -90q0 -77 35.5 -114.5t94.5 -37.5q54 0 98 23t74.5 60.5t47.5 86.5t17 100v55zM578 1183q-80 0 -143 25.5t-107.5 70t-70.5 103t-31 124.5h163q8 -39 26 -70t43 -52t56.5 -32.5t65.5 -11.5q36 0 67.5 11.5t56.5 32.5t42 52t24 70h164
q-8 -66 -33.5 -124.5t-69 -103t-106.5 -70t-147 -25.5z"" />
    <glyph glyph-name=""Aogonek"" unicode=""&#x104;"" horiz-adv-x=""1479"" 
d=""M1133 0l-125 360h-537l-125 -360h-295l514 1409h348l512 -1409h-292zM803 987q-12 35 -23.5 70.5t-20 65t-14 48.5t-6.5 21q-1 -3 -6 -22t-13.5 -48t-20 -64.5t-23.5 -70.5l-139 -405h405zM1262 -414q-51 0 -94.5 12.5t-75 38t-49.5 62.5t-18 87q0 48 16 88.5t40 71.5
t51.5 52.5t50.5 33.5h153q-63 -42 -96 -99.5t-33 -110.5q0 -42 24.5 -67.5t69.5 -25.5q31 0 57.5 7t54.5 20v-137q-63 -33 -151 -33z"" />
    <glyph glyph-name=""aogonek"" unicode=""&#x105;"" 
d=""M393 -20q-78 0 -139.5 21.5t-104.5 63t-66 102.5t-23 139q0 96 33.5 161.5t91.5 106t136 59t166 19.5l233 4v55q0 59 -10.5 98.5t-30.5 64.5t-49.5 35.5t-67.5 10.5q-35 0 -62.5 -7t-47.5 -24.5t-32.5 -47t-17.5 -74.5l-293 14q12 71 44 129.5t88.5 101.5t139 66.5
t193.5 23.5q101 0 180 -25t134 -74.5t84 -121.5t29 -167v-394q0 -38 3.5 -68t13 -50.5t27 -31t45.5 -10.5q32 0 62 6v-152q-25 -6 -45 -11t-40 -8t-42.5 -5t-52.5 -2q-106 0 -156.5 52t-60.5 153h-6q-56 -101 -143.5 -157t-212.5 -56zM720 501l-144 -2q-45 -2 -85.5 -7.5
t-71 -23t-48.5 -50.5t-18 -90q0 -77 35.5 -114.5t94.5 -37.5q54 0 98 23t74.5 60.5t47.5 86.5t17 100v55zM922 -425q-51 0 -94.5 12.5t-75 38t-49.5 62.5t-18 87q0 48 16 88.5t40 71.5t51.5 52.5t50.5 33.5h153q-63 -42 -96 -99.5t-33 -110.5q0 -42 24.5 -67.5t69.5 -25.5
q31 0 57.5 7t54.5 20v-137q-63 -33 -151 -33z"" />
    <glyph glyph-name=""Cacute"" unicode=""&#x106;"" horiz-adv-x=""1479"" 
d=""M795 212q83 0 143.5 23.5t105 61.5t74 86t48.5 97l257 -97q-31 -76 -81 -149t-125 -129t-178.5 -90.5t-243.5 -34.5q-183 0 -317 54.5t-221.5 152t-130 231.5t-42.5 293q0 165 42.5 298t128.5 226.5t217.5 144t309.5 50.5q138 0 241.5 -29t179 -81.5t125 -124
t77.5 -157.5l-260 -71q-14 45 -43 86.5t-73.5 73.5t-104.5 51.5t-136 19.5q-107 0 -184 -34.5t-126.5 -98.5t-73 -153.5t-23.5 -200.5q0 -110 23.5 -201.5t73.5 -157.5t128.5 -103t188.5 -37zM652 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""cacute"" unicode=""&#x107;"" 
d=""M594 -20q-129 0 -225.5 40t-160.5 113t-96 175.5t-32 226.5q0 135 35 240.5t101 178t162.5 110.5t219.5 38q105 0 186.5 -28t140.5 -76.5t95.5 -114.5t50.5 -142l-283 -14q-12 83 -60 132.5t-136 49.5q-113 0 -165 -93t-52 -270q0 -374 221 -374q80 0 134 50.5t67 150.5
l282 -13q-10 -75 -45.5 -143.5t-96 -121t-146.5 -84t-197 -31.5zM446 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""Ccircumflex"" unicode=""&#x108;"" horiz-adv-x=""1479"" 
d=""M795 212q83 0 143.5 23.5t105 61.5t74 86t48.5 97l257 -97q-31 -76 -81 -149t-125 -129t-178.5 -90.5t-243.5 -34.5q-183 0 -317 54.5t-221.5 152t-130 231.5t-42.5 293q0 165 42.5 298t128.5 226.5t217.5 144t309.5 50.5q138 0 241.5 -29t179 -81.5t125 -124
t77.5 -157.5l-260 -71q-14 45 -43 86.5t-73.5 73.5t-104.5 51.5t-136 19.5q-107 0 -184 -34.5t-126.5 -98.5t-73 -153.5t-23.5 -200.5q0 -110 23.5 -201.5t73.5 -157.5t128.5 -103t188.5 -37zM1170 1559v-29h-159l-203 151h-4l-211 -151h-160v29l258 276h229z"" />
    <glyph glyph-name=""ccircumflex"" unicode=""&#x109;"" 
d=""M594 -20q-129 0 -225.5 40t-160.5 113t-96 175.5t-32 226.5q0 135 35 240.5t101 178t162.5 110.5t219.5 38q105 0 186.5 -28t140.5 -76.5t95.5 -114.5t50.5 -142l-283 -14q-12 83 -60 132.5t-136 49.5q-113 0 -165 -93t-52 -270q0 -374 221 -374q80 0 134 50.5t67 150.5
l282 -13q-10 -75 -45.5 -143.5t-96 -121t-146.5 -84t-197 -31.5zM967 1211v-28h-159l-203 192h-4l-211 -192h-160v28l258 318h229z"" />
    <glyph glyph-name=""Cdotaccent"" unicode=""&#x10a;"" horiz-adv-x=""1479"" 
d=""M795 212q83 0 143.5 23.5t105 61.5t74 86t48.5 97l257 -97q-31 -76 -81 -149t-125 -129t-178.5 -90.5t-243.5 -34.5q-183 0 -317 54.5t-221.5 152t-130 231.5t-42.5 293q0 165 42.5 298t128.5 226.5t217.5 144t309.5 50.5q138 0 241.5 -29t179 -81.5t125 -124
t77.5 -157.5l-260 -71q-14 45 -43 86.5t-73.5 73.5t-104.5 51.5t-136 19.5q-107 0 -184 -34.5t-126.5 -98.5t-73 -153.5t-23.5 -200.5q0 -110 23.5 -201.5t73.5 -157.5t128.5 -103t188.5 -37zM646 1547v207h281v-207h-281z"" />
    <glyph glyph-name=""cdotaccent"" unicode=""&#x10b;"" 
d=""M594 -20q-129 0 -225.5 40t-160.5 113t-96 175.5t-32 226.5q0 135 35 240.5t101 178t162.5 110.5t219.5 38q105 0 186.5 -28t140.5 -76.5t95.5 -114.5t50.5 -142l-283 -14q-12 83 -60 132.5t-136 49.5q-113 0 -165 -93t-52 -270q0 -374 221 -374q80 0 134 50.5t67 150.5
l282 -13q-10 -75 -45.5 -143.5t-96 -121t-146.5 -84t-197 -31.5zM460 1277v207h281v-207h-281z"" />
    <glyph glyph-name=""Ccaron"" unicode=""&#x10c;"" horiz-adv-x=""1479"" 
d=""M795 212q83 0 143.5 23.5t105 61.5t74 86t48.5 97l257 -97q-31 -76 -81 -149t-125 -129t-178.5 -90.5t-243.5 -34.5q-183 0 -317 54.5t-221.5 152t-130 231.5t-42.5 293q0 165 42.5 298t128.5 226.5t217.5 144t309.5 50.5q138 0 241.5 -29t179 -81.5t125 -124
t77.5 -157.5l-260 -71q-14 45 -43 86.5t-73.5 73.5t-104.5 51.5t-136 19.5q-107 0 -184 -34.5t-126.5 -98.5t-73 -153.5t-23.5 -200.5q0 -110 23.5 -201.5t73.5 -157.5t128.5 -103t188.5 -37zM900 1530h-229l-258 276v29h160l211 -152h4l203 152h159v-29z"" />
    <glyph glyph-name=""ccaron"" unicode=""&#x10d;"" 
d=""M594 -20q-129 0 -225.5 40t-160.5 113t-96 175.5t-32 226.5q0 135 35 240.5t101 178t162.5 110.5t219.5 38q105 0 186.5 -28t140.5 -76.5t95.5 -114.5t50.5 -142l-283 -14q-12 83 -60 132.5t-136 49.5q-113 0 -165 -93t-52 -270q0 -374 221 -374q80 0 134 50.5t67 150.5
l282 -13q-10 -75 -45.5 -143.5t-96 -121t-146.5 -84t-197 -31.5zM701 1183h-229l-258 317v29h160l211 -193h4l203 193h159v-29z"" />
    <glyph glyph-name=""Dcaron"" unicode=""&#x10e;"" horiz-adv-x=""1479"" 
d=""M1393 715q0 -176 -53 -309.5t-145 -223.5t-217.5 -136t-270.5 -46h-570v1409h510q164 0 301 -41t236 -126t154 -216t55 -311zM1096 715q0 123 -33.5 211t-93.5 144.5t-143.5 83.5t-184.5 27h-209v-953h250q89 0 164.5 31t131 92.5t87 152.5t31.5 211zM818 1530h-229
l-258 276v29h160l211 -152h4l203 152h159v-29z"" />
    <glyph glyph-name=""dcaron"" unicode=""&#x10f;"" horiz-adv-x=""1472"" 
d=""M844 0q-2 8 -4.5 28.5t-5 46.5t-4 53t-1.5 48h-4q-49 -105 -136.5 -150.5t-209.5 -45.5q-102 0 -176.5 42t-123 117t-72 177.5t-23.5 223.5q0 123 24.5 226t75.5 177.5t129.5 116.5t186.5 42q53 0 102 -11t91 -34t76 -59t58 -87h2q0 10 -0.5 29.5t-0.5 44.5t-0.5 52
t-0.5 52v395h281v-1248q0 -79 3 -140.5t5 -95.5h-272zM831 547q0 107 -20 177.5t-52.5 112t-74 58t-84.5 16.5q-54 0 -95.5 -21t-70 -66t-43 -115t-14.5 -169q0 -368 221 -368q42 0 84 18t75 61t53.5 115.5t20.5 180.5zM1473 1338q0 -43 -7 -79t-20 -66.5t-30 -56t-37 -49.5
h-137q45 48 69.5 96t24.5 94h-108v207h245v-146z"" />
    <glyph glyph-name=""Dcroat"" unicode=""&#x110;"" horiz-adv-x=""1479"" 
d=""M1393 715q0 -176 -53 -309.5t-145 -223.5t-217.5 -136t-270.5 -46h-570v594h-129v219h129v596h510q164 0 301 -41t236 -126t154 -216t55 -311zM1096 715q0 123 -33.5 210.5t-93.5 143.5t-143.5 82.5t-184.5 26.5h-209v-365h356v-219h-356v-363h250q89 0 164.5 30.5
t131 91.5t87 151.5t31.5 210.5z"" />
    <glyph glyph-name=""dcroat"" unicode=""&#x111;"" horiz-adv-x=""1251"" 
d=""M827 1345v139h282v-139h132v-170h-132v-939q0 -79 3 -140.5t5 -95.5h-272q-2 8 -4.5 28.5t-5 46.5t-4 53t-1.5 48h-4q-49 -105 -137 -150.5t-210 -45.5q-102 0 -176.5 40.5t-123 112.5t-72 171t-23.5 217q0 119 24.5 218.5t75.5 171t129.5 111.5t186.5 40q53 0 102 -11
t91 -34t76 -59t58 -87h2q0 10 -0.5 29.5t-0.5 44.5t-0.5 52t-0.5 52v126h-286v170h286zM831 529q0 104 -20 170.5t-52.5 105.5t-74 54t-84.5 15q-54 0 -95.5 -19.5t-70 -61.5t-43 -109t-14.5 -162q0 -350 221 -350q42 0 84 16.5t75 57.5t53.5 109.5t20.5 173.5z"" />
    <glyph glyph-name=""Emacron"" unicode=""&#x112;"" horiz-adv-x=""1366"" 
d=""M137 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149zM386 1705h612v-168h-612v168z"" />
    <glyph glyph-name=""emacron"" unicode=""&#x113;"" 
d=""M586 -20q-117 0 -210.5 34.5t-159.5 105t-101 177t-35 249.5q0 155 41.5 261t112 171.5t162.5 94.5t194 29q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-8h-694q0 -68 12 -126.5t39 -101t70 -67t104 -24.5q74 0 121 31.5t67 97.5l265 -23q-18 -46 -50.5 -98
t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM586 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420q-8 131 -63 196.5t-148 65.5zM281 1371h612v-168h-612v168z"" />
    <glyph glyph-name=""Ebreve"" unicode=""&#x114;"" horiz-adv-x=""1366"" 
d=""M137 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149zM700 1520q-80 0 -143 24t-107.5 63.5t-70.5 91.5t-31 109h163q8 -32 26 -57t43 -42.5t56.5 -27t65.5 -9.5q36 0 67.5 9.5t56.5 27t42 42.5t24 57h164q-8 -57 -33.5 -109t-69 -91.5t-106.5 -63.5
t-147 -24z"" />
    <glyph glyph-name=""ebreve"" unicode=""&#x115;"" 
d=""M586 -20q-117 0 -210.5 34.5t-159.5 105t-101 177t-35 249.5q0 155 41.5 261t112 171.5t162.5 94.5t194 29q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-8h-694q0 -68 12 -126.5t39 -101t70 -67t104 -24.5q74 0 121 31.5t67 97.5l265 -23q-18 -46 -50.5 -98
t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM586 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420q-8 131 -63 196.5t-148 65.5zM567 1183q-80 0 -143 25.5t-107.5 70t-70.5 103t-31 124.5h163q8 -39 26 -70t43 -52t56.5 -32.5t65.5 -11.5q36 0 67.5 11.5t56.5 32.5
t42 52t24 70h164q-8 -66 -33.5 -124.5t-69 -103t-106.5 -70t-147 -25.5z"" />
    <glyph glyph-name=""Edotaccent"" unicode=""&#x116;"" horiz-adv-x=""1366"" 
d=""M137 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149zM565 1547v207h281v-207h-281z"" />
    <glyph glyph-name=""edotaccent"" unicode=""&#x117;"" 
d=""M586 -20q-117 0 -210.5 34.5t-159.5 105t-101 177t-35 249.5q0 155 41.5 261t112 171.5t162.5 94.5t194 29q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-8h-694q0 -68 12 -126.5t39 -101t70 -67t104 -24.5q74 0 121 31.5t67 97.5l265 -23q-18 -46 -50.5 -98
t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM586 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420q-8 131 -63 196.5t-148 65.5zM441 1277v207h281v-207h-281z"" />
    <glyph glyph-name=""Eogonek"" unicode=""&#x118;"" horiz-adv-x=""1366"" 
d=""M137 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149zM1062 -425q-51 0 -94.5 12.5t-75 38t-49.5 62.5t-18 87q0 48 16 88.5t40 71.5t51.5 52.5t50.5 33.5h153q-63 -42 -96 -99.5t-33 -110.5q0 -42 24.5 -67.5t69.5 -25.5q31 0 57.5 7t54.5 20v-137
q-63 -33 -151 -33z"" />
    <glyph glyph-name=""eogonek"" unicode=""&#x119;"" 
d=""M586 -20q-117 0 -210.5 34.5t-159.5 105t-101 177t-35 249.5q0 155 41.5 261t112 171.5t162.5 94.5t194 29q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-8h-694q0 -68 12 -126.5t39 -101t70 -67t104 -24.5q74 0 121 31.5t67 97.5l265 -23q-18 -46 -50.5 -98
t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM586 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420q-8 131 -63 196.5t-148 65.5zM776 -408q-51 0 -94.5 12.5t-75 38t-49.5 62.5t-18 87q0 48 16 88.5t40 71.5t51.5 52.5t50.5 33.5h153q-63 -42 -96 -99.5t-33 -110.5
q0 -42 24.5 -67.5t69.5 -25.5q31 0 57.5 7t54.5 20v-137q-63 -33 -151 -33z"" />
    <glyph glyph-name=""Ecaron"" unicode=""&#x11a;"" horiz-adv-x=""1366"" 
d=""M137 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149zM827 1530h-229l-258 276v29h160l211 -152h4l203 152h159v-29z"" />
    <glyph glyph-name=""ecaron"" unicode=""&#x11b;"" 
d=""M586 -20q-117 0 -210.5 34.5t-159.5 105t-101 177t-35 249.5q0 155 41.5 261t112 171.5t162.5 94.5t194 29q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-8h-694q0 -68 12 -126.5t39 -101t70 -67t104 -24.5q74 0 121 31.5t67 97.5l265 -23q-18 -46 -50.5 -98
t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM586 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420q-8 131 -63 196.5t-148 65.5zM703 1183h-229l-258 317v29h160l211 -193h4l203 193h159v-29z"" />
    <glyph glyph-name=""Gcircumflex"" unicode=""&#x11c;"" horiz-adv-x=""1593"" 
d=""M806 211q64 0 123 10t109.5 26.5t91 38t66.5 44.5v195h-344v218h614v-518q-48 -49 -116 -93.5t-153 -78t-185.5 -53.5t-213.5 -20q-187 0 -322 54.5t-222 152t-128.5 231.5t-41.5 293q0 165 44 298t133.5 226.5t225 144t318.5 50.5q133 0 236.5 -26t181 -74t130 -115.5
t83.5 -151.5l-272 -82q-18 44 -48 83.5t-74.5 69t-103 47t-133.5 17.5q-110 0 -190 -34.5t-132 -98.5t-77 -153.5t-25 -200.5q0 -110 25.5 -202t78 -158t132.5 -103t189 -37zM1165 1559v-29h-159l-203 151h-4l-211 -151h-160v29l258 276h229z"" />
    <glyph glyph-name=""gcircumflex"" unicode=""&#x11d;"" horiz-adv-x=""1251"" 
d=""M596 -434q-107 0 -188.5 21.5t-139 60t-92 92t-47.5 117.5l281 33q15 -65 64.5 -102t129.5 -37q50 0 91.5 14t71 47.5t46 88.5t16.5 136v57t1 53q1 28 1 54h-2q-49 -105 -137.5 -152t-210.5 -47q-103 0 -177.5 40.5t-123.5 113t-72.5 173t-23.5 221.5q0 125 25 226.5
t76.5 174.5t130 112.5t186.5 39.5t193.5 -46t133.5 -149h5q0 21 1.5 48.5t3.5 53t4.5 45.5t4.5 27h266q-2 -36 -4 -101t-2 -149v-799q0 -118 -34 -205.5t-99.5 -145.5t-161 -87t-217.5 -29zM831 556q0 102 -20 170t-52 109t-73.5 58t-83.5 17q-54 0 -95.5 -21t-70.5 -65
t-44 -112t-15 -162q0 -175 56 -264t167 -89q42 0 83.5 16.5t74.5 58t53 110.5t20 174zM970 1211v-28h-159l-203 192h-4l-211 -192h-160v28l258 318h229z"" />
    <glyph glyph-name=""Gbreve"" unicode=""&#x11e;"" horiz-adv-x=""1593"" 
d=""M806 211q64 0 123 10t109.5 26.5t91 38t66.5 44.5v195h-344v218h614v-518q-48 -49 -116 -93.5t-153 -78t-185.5 -53.5t-213.5 -20q-187 0 -322 54.5t-222 152t-128.5 231.5t-41.5 293q0 165 44 298t133.5 226.5t225 144t318.5 50.5q133 0 236.5 -26t181 -74t130 -115.5
t83.5 -151.5l-272 -82q-18 44 -48 83.5t-74.5 69t-103 47t-133.5 17.5q-110 0 -190 -34.5t-132 -98.5t-77 -153.5t-25 -200.5q0 -110 25.5 -202t78 -158t132.5 -103t189 -37zM808 1520q-80 0 -143 24t-107.5 63.5t-70.5 91.5t-31 109h163q8 -32 26 -57t43 -42.5t56.5 -27
t65.5 -9.5q36 0 67.5 9.5t56.5 27t42 42.5t24 57h164q-8 -57 -33.5 -109t-69 -91.5t-106.5 -63.5t-147 -24z"" />
    <glyph glyph-name=""gbreve"" unicode=""&#x11f;"" horiz-adv-x=""1251"" 
d=""M596 -434q-107 0 -188.5 21.5t-139 60t-92 92t-47.5 117.5l281 33q15 -65 64.5 -102t129.5 -37q50 0 91.5 14t71 47.5t46 88.5t16.5 136v57t1 53q1 28 1 54h-2q-49 -105 -137.5 -152t-210.5 -47q-103 0 -177.5 40.5t-123.5 113t-72.5 173t-23.5 221.5q0 125 25 226.5
t76.5 174.5t130 112.5t186.5 39.5t193.5 -46t133.5 -149h5q0 21 1.5 48.5t3.5 53t4.5 45.5t4.5 27h266q-2 -36 -4 -101t-2 -149v-799q0 -118 -34 -205.5t-99.5 -145.5t-161 -87t-217.5 -29zM831 556q0 102 -20 170t-52 109t-73.5 58t-83.5 17q-54 0 -95.5 -21t-70.5 -65
t-44 -112t-15 -162q0 -175 56 -264t167 -89q42 0 83.5 16.5t74.5 58t53 110.5t20 174zM605 1183q-80 0 -143 25.5t-107.5 70t-70.5 103t-31 124.5h163q8 -39 26 -70t43 -52t56.5 -32.5t65.5 -11.5q36 0 67.5 11.5t56.5 32.5t42 52t24 70h164q-8 -66 -33.5 -124.5t-69 -103
t-106.5 -70t-147 -25.5z"" />
    <glyph glyph-name=""Gdotaccent"" unicode=""&#x120;"" horiz-adv-x=""1593"" 
d=""M806 211q64 0 123 10t109.5 26.5t91 38t66.5 44.5v195h-344v218h614v-518q-48 -49 -116 -93.5t-153 -78t-185.5 -53.5t-213.5 -20q-187 0 -322 54.5t-222 152t-128.5 231.5t-41.5 293q0 165 44 298t133.5 226.5t225 144t318.5 50.5q133 0 236.5 -26t181 -74t130 -115.5
t83.5 -151.5l-272 -82q-18 44 -48 83.5t-74.5 69t-103 47t-133.5 17.5q-110 0 -190 -34.5t-132 -98.5t-77 -153.5t-25 -200.5q0 -110 25.5 -202t78 -158t132.5 -103t189 -37zM667 1547v207h281v-207h-281z"" />
    <glyph glyph-name=""gdotaccent"" unicode=""&#x121;"" horiz-adv-x=""1251"" 
d=""M596 -434q-107 0 -188.5 21.5t-139 60t-92 92t-47.5 117.5l281 33q15 -65 64.5 -102t129.5 -37q50 0 91.5 14t71 47.5t46 88.5t16.5 136v57t1 53q1 28 1 54h-2q-49 -105 -137.5 -152t-210.5 -47q-103 0 -177.5 40.5t-123.5 113t-72.5 173t-23.5 221.5q0 125 25 226.5
t76.5 174.5t130 112.5t186.5 39.5t193.5 -46t133.5 -149h5q0 21 1.5 48.5t3.5 53t4.5 45.5t4.5 27h266q-2 -36 -4 -101t-2 -149v-799q0 -118 -34 -205.5t-99.5 -145.5t-161 -87t-217.5 -29zM831 556q0 102 -20 170t-52 109t-73.5 58t-83.5 17q-54 0 -95.5 -21t-70.5 -65
t-44 -112t-15 -162q0 -175 56 -264t167 -89q42 0 83.5 16.5t74.5 58t53 110.5t20 174zM485 1277v207h281v-207h-281z"" />
    <glyph glyph-name=""Gcommaaccent"" unicode=""&#x122;"" horiz-adv-x=""1593"" 
d=""M806 211q64 0 123 10t109.5 26.5t91 38t66.5 44.5v195h-344v218h614v-518q-48 -49 -116 -93.5t-153 -78t-185.5 -53.5t-213.5 -20q-187 0 -322 54.5t-222 152t-128.5 231.5t-41.5 293q0 165 44 298t133.5 226.5t225 144t318.5 50.5q133 0 236.5 -26t181 -74t130 -115.5
t83.5 -151.5l-272 -82q-18 44 -48 83.5t-74.5 69t-103 47t-133.5 17.5q-110 0 -190 -34.5t-132 -98.5t-77 -153.5t-25 -200.5q0 -110 25.5 -202t78 -158t132.5 -103t189 -37zM938 -204q0 -44 -7 -79.5t-20 -66t-30 -56t-37 -49.5h-137q45 48 69.5 90t24.5 80h-108v207h245
v-126z"" />
    <glyph glyph-name=""gcommaaccent"" unicode=""&#x123;"" horiz-adv-x=""1251"" 
d=""M596 -434q-107 0 -188.5 21.5t-139 60t-92 92t-47.5 117.5l281 33q15 -65 64.5 -102t129.5 -37q50 0 91.5 14t71 47.5t46 88.5t16.5 136v57t1 53q1 28 1 54h-2q-49 -105 -137.5 -152t-210.5 -47q-103 0 -177.5 40.5t-123.5 113t-72.5 173t-23.5 221.5q0 125 25 226.5
t76.5 174.5t130 112.5t186.5 39.5t193.5 -46t133.5 -149h5q0 21 1.5 48.5t3.5 53t4.5 45.5t4.5 27h266q-2 -36 -4 -101t-2 -149v-799q0 -118 -34 -205.5t-99.5 -145.5t-161 -87t-217.5 -29zM831 556q0 102 -20 170t-52 109t-73.5 58t-83.5 17q-54 0 -95.5 -21t-70.5 -65
t-44 -112t-15 -162q0 -175 56 -264t167 -89q42 0 83.5 16.5t74.5 58t53 110.5t20 174zM496 1358q0 87 22 145.5t62 105.5h147q-45 -48 -69.5 -96t-24.5 -94h108v-207h-245v146z"" />
    <glyph glyph-name=""Hcircumflex"" unicode=""&#x124;"" horiz-adv-x=""1479"" 
d=""M1046 0v604h-614v-604h-295v1409h295v-561h614v561h295v-1409h-295zM1113 1559v-29h-159l-203 151h-4l-211 -151h-160v29l258 276h229z"" />
    <glyph glyph-name=""hcircumflex"" unicode=""&#x125;"" horiz-adv-x=""1251"" 
d=""M420 866q57 124 143 180t205 56q98 0 165.5 -32t110 -88t61.5 -132t19 -164v-686h-280v606q0 63 -10 115.5t-33 90t-60 58.5t-90 21q-51 0 -92.5 -22.5t-71.5 -64t-46.5 -99t-16.5 -126.5v-579h-281v1484h281v-405q0 -32 -1 -64.5t-2.5 -61t-2.5 -51.5t-2 -36h4z
M1012 1638v-29h-159l-203 151h-4l-211 -151h-160v29l258 276h229z"" />
    <glyph glyph-name=""Hbar"" unicode=""&#x126;"" horiz-adv-x=""1479"" 
d=""M1057 0v604h-625v-604h-295v1045h-123v170h123v194h295v-194h625v194h284v-194h124v-170h-124v-1045h-284zM1057 848v197h-625v-197h625z"" />
    <glyph glyph-name=""hbar"" unicode=""&#x127;"" horiz-adv-x=""1251"" 
d=""M420 826q57 124 143 180t205 56q98 0 165.5 -32t110 -88t61.5 -132t19 -164v-646h-280v566q0 63 -10 115.5t-33 90t-60 58.5t-90 21q-51 0 -92.5 -22.5t-71.5 -64t-46.5 -99t-16.5 -126.5v-539h-281v1175h-133v170h133v139h281v-139h306v-170h-306v-136q0 -32 -1 -64.5
t-2.5 -61t-2.5 -51.5t-2 -36h4z"" />
    <glyph glyph-name=""Itilde"" unicode=""&#x128;"" horiz-adv-x=""569"" 
d=""M137 0v1409h295v-1409h-295zM454 1530q-44 0 -88.5 19t-86.5 42.5t-79.5 42.5t-67.5 19q-26 0 -43 -8.5t-27.5 -24.5t-16.5 -38.5t-11 -51.5h-137q3 45 11 96t31.5 95t66.5 73t116 29q45 0 90 -19t87 -42.5t78.5 -42.5t65.5 -19q25 0 41.5 8.5t28 24.5t18 39t11.5 51h135
q-2 -45 -10 -96t-31 -95t-66 -73t-116 -29z"" />
    <glyph glyph-name=""itilde"" unicode=""&#x129;"" horiz-adv-x=""569"" 
d=""M145 0v1082h281v-1082h-281zM454 1183q-44 0 -88.5 19t-86.5 42.5t-79.5 42.5t-67.5 19q-26 0 -43 -8.5t-27.5 -24.5t-16.5 -38.5t-11 -51.5h-137q3 45 11 96t31.5 95t66.5 73t116 29q45 0 90 -19t87 -42.5t78.5 -42.5t65.5 -19q25 0 41.5 8.5t28 24.5t18 39t11.5 51h135
q-2 -45 -10 -96t-31 -95t-66 -73t-116 -29z"" />
    <glyph glyph-name=""Imacron"" unicode=""&#x12a;"" horiz-adv-x=""569"" 
d=""M137 0v1409h295v-1409h-295zM-20 1705h612v-168h-612v168z"" />
    <glyph glyph-name=""imacron"" unicode=""&#x12b;"" horiz-adv-x=""569"" 
d=""M145 0v1082h281v-1082h-281zM-20 1371h612v-168h-612v168z"" />
    <glyph glyph-name=""Ibreve"" unicode=""&#x12c;"" horiz-adv-x=""569"" 
d=""M137 0v1409h295v-1409h-295zM284 1520q-80 0 -143 24t-107.5 63.5t-70.5 91.5t-31 109h163q8 -32 26 -57t43 -42.5t56.5 -27t65.5 -9.5q36 0 67.5 9.5t56.5 27t42 42.5t24 57h164q-8 -57 -33.5 -109t-69 -91.5t-106.5 -63.5t-147 -24z"" />
    <glyph glyph-name=""ibreve"" unicode=""&#x12d;"" horiz-adv-x=""569"" 
d=""M145 0v1082h281v-1082h-281zM285 1183q-80 0 -143 25.5t-107.5 70t-70.5 103t-31 124.5h163q8 -39 26 -70t43 -52t56.5 -32.5t65.5 -11.5q36 0 67.5 11.5t56.5 32.5t42 52t24 70h164q-8 -66 -33.5 -124.5t-69 -103t-106.5 -70t-147 -25.5z"" />
    <glyph glyph-name=""Iogonek"" unicode=""&#x12e;"" horiz-adv-x=""569"" 
d=""M137 0v1409h295v-1409h-295zM325 -425q-51 0 -94.5 12.5t-75 38t-49.5 62.5t-18 87q0 48 16 88.5t40 71.5t51.5 52.5t50.5 33.5h153q-63 -42 -96 -99.5t-33 -110.5q0 -42 24.5 -67.5t69.5 -25.5q31 0 57.5 7t54.5 20v-137q-63 -33 -151 -33z"" />
    <glyph glyph-name=""iogonek"" unicode=""&#x12f;"" horiz-adv-x=""569"" 
d=""M143 1277v207h281v-207h-281zM143 0v1082h281v-1082h-281zM306 -425q-51 0 -94.5 12.5t-75 38t-49.5 62.5t-18 87q0 48 16 88.5t40 71.5t51.5 52.5t50.5 33.5h153q-63 -42 -96 -99.5t-33 -110.5q0 -42 24.5 -67.5t69.5 -25.5q31 0 57.5 7t54.5 20v-137q-63 -33 -151 -33z
"" />
    <glyph glyph-name=""Idotaccent"" unicode=""&#x130;"" horiz-adv-x=""569"" 
d=""M137 0v1409h295v-1409h-295zM146 1547v207h281v-207h-281z"" />
    <glyph glyph-name=""dotlessi"" unicode=""&#x131;"" horiz-adv-x=""569"" 
d=""M145 0v1082h281v-1082h-281z"" />
    <glyph glyph-name=""IJ"" unicode=""&#x132;"" horiz-adv-x=""1607"" 
d=""M137 0v1409h295v-1409h-295zM992 -20q-106 0 -189 22t-144 70t-100.5 124.5t-59.5 185.5l293 43q10 -59 28 -99.5t43.5 -66t58.5 -37t72 -11.5q88 0 133.5 59t45.5 169v739h-281v231h575v-963q0 -107 -31 -193.5t-91.5 -147t-149 -93t-203.5 -32.5z"" />
    <glyph glyph-name=""ij"" unicode=""&#x133;"" 
d=""M143 1277v207h281v-207h-281zM143 0v1082h281v-1082h-281zM713 1277v207h281v-207h-281zM707 -425q-56 0 -97.5 2.5t-72.5 6.5v198q13 -2 26 -3t25 -1q39 0 63 8t38 27t19 50t5 77v1142h281v-1210q0 -65 -16 -119t-50.5 -94t-89 -62t-131.5 -22z"" />
    <glyph glyph-name=""Jcircumflex"" unicode=""&#x134;"" 
d=""M524 -20q-106 0 -189 22t-144 70t-100.5 124.5t-59.5 185.5l293 43q10 -59 28 -99.5t43.5 -66t58.5 -37t72 -11.5q88 0 133.5 59t45.5 169v739h-281v231h575v-963q0 -107 -31 -193.5t-91.5 -147t-149 -93t-203.5 -32.5zM1058 1559v-29h-159l-203 151h-4l-211 -151h-160
v29l258 276h229z"" />
    <glyph glyph-name=""jcircumflex"" unicode=""&#x135;"" horiz-adv-x=""569"" 
d=""M647 1211v-28h-159l-203 192h-4l-211 -192h-160v28l258 318h229zM138 -425q-56 0 -97.5 2.5t-72.5 6.5v198q13 -2 26 -3t25 -1q39 0 63 8t38 27t19 50t5 77v1142h281v-1210q0 -65 -16 -119t-50.5 -94t-89 -62t-131.5 -22z"" />
    <glyph glyph-name=""Kcommaaccent"" unicode=""&#x136;"" horiz-adv-x=""1479"" 
d=""M1112 0l-506 647l-174 -133v-514h-295v1409h295v-639l635 639h344l-602 -596l651 -813h-348zM875 -204q0 -44 -7 -79.5t-20 -66t-30 -56t-37 -49.5h-137q45 48 69.5 90t24.5 80h-108v207h245v-126z"" />
    <glyph glyph-name=""kcommaaccent"" unicode=""&#x137;"" 
d=""M834 0l-289 490l-121 -84v-406h-281v1484h281v-850l386 448h302l-380 -422l409 -660h-307zM725 -204q0 -44 -7 -79.5t-20 -66t-30 -56t-37 -49.5h-137q45 48 69.5 90t24.5 80h-108v207h245v-126z"" />
    <glyph glyph-name=""kgreenlandic"" unicode=""&#x138;"" 
d=""M834 0l-289 490l-121 -84v-406h-281v1082h281v-448l386 448h302l-380 -422l409 -660h-307z"" />
    <glyph glyph-name=""Lacute"" unicode=""&#x139;"" horiz-adv-x=""1251"" 
d=""M137 0v1409h295v-1181h756v-228h-1051zM260 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""lacute"" unicode=""&#x13a;"" horiz-adv-x=""569"" 
d=""M143 0v1484h281v-1484h-281zM106 1609v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""Lcommaaccent"" unicode=""&#x13b;"" horiz-adv-x=""1251"" 
d=""M137 0v1409h295v-1181h756v-228h-1051zM757 -204q0 -44 -7 -79.5t-20 -66t-30 -56t-37 -49.5h-137q45 48 69.5 90t24.5 80h-108v207h245v-126z"" />
    <glyph glyph-name=""lcommaaccent"" unicode=""&#x13c;"" horiz-adv-x=""569"" 
d=""M143 0v1484h281v-1484h-281zM406 -204q0 -44 -7 -79.5t-20 -66t-30 -56t-37 -49.5h-137q45 48 69.5 90t24.5 80h-108v207h245v-126z"" />
    <glyph glyph-name=""Lcaron"" unicode=""&#x13d;"" horiz-adv-x=""1251"" 
d=""M137 0v1409h295v-1181h756v-228h-1051zM984 1263q0 -43 -7 -79t-20 -66.5t-30 -56t-37 -49.5h-137q45 48 69.5 96t24.5 94h-108v207h245v-146z"" />
    <glyph glyph-name=""lcaron"" unicode=""&#x13e;"" horiz-adv-x=""789"" 
d=""M143 0v1484h281v-1484h-281zM790 1338q0 -43 -7 -79t-20 -66.5t-30 -56t-37 -49.5h-137q45 48 69.5 96t24.5 94h-108v207h245v-146z"" />
    <glyph glyph-name=""Ldot"" unicode=""&#x13f;"" horiz-adv-x=""1251"" 
d=""M137 0v1409h295v-1181h756v-228h-1051zM669 651v207h281v-207h-281z"" />
    <glyph glyph-name=""ldot"" unicode=""&#x140;"" horiz-adv-x=""981"" 
d=""M143 0v1484h281v-1484h-281zM600 651v207h281v-207h-281z"" />
    <glyph glyph-name=""Lslash"" unicode=""&#x141;"" horiz-adv-x=""1251"" 
d=""M137 0v483l-137 -65v225l137 66v700h295v-559l307 147v-223l-307 -147v-396h756v-231h-1051z"" />
    <glyph glyph-name=""lslash"" unicode=""&#x142;"" horiz-adv-x=""569"" 
d=""M424 717v-717h-281v561l-125 -69v215l125 69v708h281v-552l129 74v-213z"" />
    <glyph glyph-name=""Nacute"" unicode=""&#x143;"" horiz-adv-x=""1479"" 
d=""M995 0l-614 1085q5 -44 9 -88q4 -38 6.5 -82t2.5 -84v-831h-262v1409h337l623 -1094q-5 42 -9 88q-4 39 -6.5 88t-2.5 99v819h262v-1409h-346zM574 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""nacute"" unicode=""&#x144;"" horiz-adv-x=""1251"" 
d=""M844 0v607q0 63 -10 115.5t-33 90t-60 58.5t-90 21q-51 0 -92.5 -22.5t-71.5 -64t-46.5 -99t-16.5 -126.5v-580h-281v840q0 35 -0.5 72t-2 70.5t-2.5 60t-3 39.5h268q2 -12 4 -38.5t4 -58.5t3.5 -64t1.5 -54h4q57 124 143 180t205 56q98 0 165.5 -32t110 -88t61.5 -132
t19 -164v-687h-280zM475 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""Ncommaaccent"" unicode=""&#x145;"" horiz-adv-x=""1479"" 
d=""M995 0l-614 1085q5 -44 9 -88q4 -38 6.5 -82t2.5 -84v-831h-262v1409h337l623 -1094q-5 42 -9 88q-4 39 -6.5 88t-2.5 99v819h262v-1409h-346zM856 -204q0 -44 -7 -79.5t-20 -66t-30 -56t-37 -49.5h-137q45 48 69.5 90t24.5 80h-108v207h245v-126z"" />
    <glyph glyph-name=""ncommaaccent"" unicode=""&#x146;"" horiz-adv-x=""1251"" 
d=""M844 0v607q0 63 -10 115.5t-33 90t-60 58.5t-90 21q-51 0 -92.5 -22.5t-71.5 -64t-46.5 -99t-16.5 -126.5v-580h-281v840q0 35 -0.5 72t-2 70.5t-2.5 60t-3 39.5h268q2 -12 4 -38.5t4 -58.5t3.5 -64t1.5 -54h4q57 124 143 180t205 56q98 0 165.5 -32t110 -88t61.5 -132
t19 -164v-687h-280zM759 -204q0 -44 -7 -79.5t-20 -66t-30 -56t-37 -49.5h-137q45 48 69.5 90t24.5 80h-108v207h245v-126z"" />
    <glyph glyph-name=""Ncaron"" unicode=""&#x147;"" horiz-adv-x=""1479"" 
d=""M995 0l-614 1085q5 -44 9 -88q4 -38 6.5 -82t2.5 -84v-831h-262v1409h337l623 -1094q-5 42 -9 88q-4 39 -6.5 88t-2.5 99v819h262v-1409h-346zM852 1530h-229l-258 276v29h160l211 -152h4l203 152h159v-29z"" />
    <glyph glyph-name=""ncaron"" unicode=""&#x148;"" horiz-adv-x=""1251"" 
d=""M844 0v607q0 63 -10 115.5t-33 90t-60 58.5t-90 21q-51 0 -92.5 -22.5t-71.5 -64t-46.5 -99t-16.5 -126.5v-580h-281v840q0 35 -0.5 72t-2 70.5t-2.5 60t-3 39.5h268q2 -12 4 -38.5t4 -58.5t3.5 -64t1.5 -54h4q57 124 143 180t205 56q98 0 165.5 -32t110 -88t61.5 -132
t19 -164v-687h-280zM729 1183h-229l-258 317v29h160l211 -193h4l203 193h159v-29z"" />
    <glyph glyph-name=""napostrophe"" unicode=""&#x149;"" horiz-adv-x=""1451"" 
d=""M1044 0v607q0 63 -10 115.5t-33 90t-60 58.5t-90 21q-51 0 -92.5 -22.5t-71.5 -64t-46.5 -99t-16.5 -126.5v-580h-281v840q0 35 -0.5 72t-2 70.5t-2.5 60t-3 39.5h268q2 -12 4 -38.5t4 -58.5t3.5 -64t1.5 -54h4q57 124 143 180t205 56q98 0 165.5 -32t110 -88t61.5 -132
t19 -164v-687h-280zM269 1214q0 -67 -7 -121.5t-21 -101t-34.5 -85.5t-46.5 -75h-182q28 36 52 75t41.5 79.5t27.5 82t10 81.5h-127v260h287v-195z"" />
    <glyph glyph-name=""Eng"" unicode=""&#x14a;"" horiz-adv-x=""1481"" 
d=""M904 -20q-74 0 -131.5 11.5t-103.5 34t-82 56t-68 76.5l202 171q17 -22 35.5 -43t40.5 -37.5t48 -26.5t57 -10q54 0 87.5 22.5t51.5 65.5t24 107t6 146v295q0 94 -16 161t-49.5 109.5t-85 62t-122.5 19.5q-76 0 -143 -29.5t-116.5 -79t-78 -115t-28.5 -137.5v-839h-295
v1092q0 37 -0.5 83t-1 91t-1 83t-1.5 60h288q2 -22 4 -53.5t3.5 -66t2.5 -69t1 -62.5h4q32 62 80.5 112t110 85t134 54.5t153.5 19.5q117 0 201 -32t137 -98.5t78 -168.5t25 -241v-347q0 -130 -21 -234t-72.5 -177t-138.5 -112t-219 -39z"" />
    <glyph glyph-name=""eng"" unicode=""&#x14b;"" horiz-adv-x=""1251"" 
d=""M837 -425q-56 0 -97.5 2.5t-72.5 6.5v198q13 -2 26 -3t25 -1q39 0 63.5 8t38.5 27t19 50t5 77v667q0 63 -10 115.5t-33 90t-60 58.5t-90 21q-51 0 -92.5 -22.5t-71.5 -64t-46.5 -99t-16.5 -126.5v-580h-281v840q0 35 -0.5 72t-2 70.5t-2.5 60t-3 39.5h268q2 -12 4 -38.5
t4 -58.5t3.5 -64t1.5 -54h4q57 124 143 180t205 56q98 0 165.5 -32t110 -88t61.5 -132t19 -164v-815q0 -65 -16 -119t-50.5 -94t-89 -62t-131.5 -22z"" />
    <glyph glyph-name=""Omacron"" unicode=""&#x14c;"" horiz-adv-x=""1593"" 
d=""M1507 711q0 -165 -49 -300t-141 -231t-224.5 -148t-299.5 -52q-177 0 -309.5 54.5t-221.5 152t-133.5 231.5t-44.5 293q0 165 46.5 298t137 226.5t223 144t304.5 50.5t304.5 -51t223 -145t137.5 -226.5t47 -296.5zM1206 711q0 111 -26.5 200.5t-78.5 153.5t-128.5 98.5
t-177.5 34.5q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5q0 -110 26.5 -201.5t78.5 -157.5t129 -103t178 -37q108 0 186 37.5t128.5 104t74.5 158t24 199.5zM490 1705h612v-168h-612v168z"" />
    <glyph glyph-name=""omacron"" unicode=""&#x14d;"" horiz-adv-x=""1251"" 
d=""M1171 542q0 -124 -34.5 -227t-103.5 -177.5t-172 -116t-240 -41.5q-132 0 -233 41t-169.5 115t-103.5 177.5t-35 228.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q146 0 249 -42t168.5 -116.5t96 -177t30.5 -224.5zM877 542q0 193 -63 280t-183 87q-124 0 -190 -88
t-66 -279q0 -97 17.5 -167t49.5 -115t77 -66.5t99 -21.5q62 0 110.5 21.5t81.5 66.5t50 115t17 167zM324 1371h612v-168h-612v168z"" />
    <glyph glyph-name=""Obreve"" unicode=""&#x14e;"" horiz-adv-x=""1593"" 
d=""M1507 711q0 -165 -49 -300t-141 -231t-224.5 -148t-299.5 -52q-177 0 -309.5 54.5t-221.5 152t-133.5 231.5t-44.5 293q0 165 46.5 298t137 226.5t223 144t304.5 50.5t304.5 -51t223 -145t137.5 -226.5t47 -296.5zM1206 711q0 111 -26.5 200.5t-78.5 153.5t-128.5 98.5
t-177.5 34.5q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5q0 -110 26.5 -201.5t78.5 -157.5t129 -103t178 -37q108 0 186 37.5t128.5 104t74.5 158t24 199.5zM784 1520q-80 0 -143 24t-107.5 63.5t-70.5 91.5t-31 109h163q8 -32 26 -57t43 -42.5t56.5 -27
t65.5 -9.5q36 0 67.5 9.5t56.5 27t42 42.5t24 57h164q-8 -57 -33.5 -109t-69 -91.5t-106.5 -63.5t-147 -24z"" />
    <glyph glyph-name=""obreve"" unicode=""&#x14f;"" horiz-adv-x=""1251"" 
d=""M1171 542q0 -124 -34.5 -227t-103.5 -177.5t-172 -116t-240 -41.5q-132 0 -233 41t-169.5 115t-103.5 177.5t-35 228.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q146 0 249 -42t168.5 -116.5t96 -177t30.5 -224.5zM877 542q0 193 -63 280t-183 87q-124 0 -190 -88
t-66 -279q0 -97 17.5 -167t49.5 -115t77 -66.5t99 -21.5q62 0 110.5 21.5t81.5 66.5t50 115t17 167zM631 1183q-80 0 -143 25.5t-107.5 70t-70.5 103t-31 124.5h163q8 -39 26 -70t43 -52t56.5 -32.5t65.5 -11.5q36 0 67.5 11.5t56.5 32.5t42 52t24 70h164
q-8 -66 -33.5 -124.5t-69 -103t-106.5 -70t-147 -25.5z"" />
    <glyph glyph-name=""Ohungarumlaut"" unicode=""&#x150;"" horiz-adv-x=""1593"" 
d=""M1507 711q0 -165 -49 -300t-141 -231t-224.5 -148t-299.5 -52q-177 0 -309.5 54.5t-221.5 152t-133.5 231.5t-44.5 293q0 165 46.5 298t137 226.5t223 144t304.5 50.5t304.5 -51t223 -145t137.5 -226.5t47 -296.5zM1206 711q0 111 -26.5 200.5t-78.5 153.5t-128.5 98.5
t-177.5 34.5q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5q0 -110 26.5 -201.5t78.5 -157.5t129 -103t178 -37q108 0 186 37.5t128.5 104t74.5 158t24 199.5zM611 1530h-132v34l215 252h235v-43zM1017 1530h-132v34l215 252h235v-43z"" />
    <glyph glyph-name=""ohungarumlaut"" unicode=""&#x151;"" horiz-adv-x=""1251"" 
d=""M1171 542q0 -124 -34.5 -227t-103.5 -177.5t-172 -116t-240 -41.5q-132 0 -233 41t-169.5 115t-103.5 177.5t-35 228.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q146 0 249 -42t168.5 -116.5t96 -177t30.5 -224.5zM877 542q0 193 -63 280t-183 87q-124 0 -190 -88
t-66 -279q0 -97 17.5 -167t49.5 -115t77 -66.5t99 -21.5q62 0 110.5 21.5t81.5 66.5t50 115t17 167zM435 1184h-142v34l225 266h235v-43zM841 1184h-142v34l225 266h235v-43z"" />
    <glyph glyph-name=""OE"" unicode=""&#x152;"" horiz-adv-x=""2048"" 
d=""M992 0q-38 -2 -91.5 -6t-107.5 -4q-177 0 -309.5 53t-221.5 148.5t-133.5 228t-44.5 291.5q0 165 46.5 296.5t137 223t223 140.5t304.5 49q56 0 105.5 -3.5t97.5 -7.5h929v-227h-667v-355h606v-221h-606v-379h708v-227h-976zM963 1169q-30 8 -77 13.5t-91 5.5
q-103 0 -180.5 -33t-129.5 -95t-78 -150t-26 -199q0 -110 26.5 -200t79 -154.5t129.5 -99.5t177 -35q46 0 89 3t81 17v927z"" />
    <glyph glyph-name=""oe"" unicode=""&#x153;"" horiz-adv-x=""1933"" 
d=""M1384 -20q-118 0 -210.5 39.5t-158.5 119.5q-69 -76 -167 -117.5t-227 -41.5q-132 0 -233 41t-169.5 115t-103.5 177.5t-35 228.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q134 0 231 -40t163 -113q71 81 166 117t201 36q128 0 218.5 -44.5t148.5 -124.5t85 -191.5
t27 -246.5v-19h-694q0 -65 13 -121.5t40.5 -98t70 -65t101.5 -23.5q74 0 121 31.5t67 97.5l265 -23q-18 -46 -50.5 -98t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM877 542q0 193 -63 280t-183 87q-124 0 -190 -88t-66 -279q0 -97 17.5 -167t49.5 -115t77 -66.5t99 -21.5
q62 0 110.5 21.5t81.5 66.5t50 115t17 167zM1384 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420q-8 131 -63 196.5t-148 65.5z"" />
    <glyph glyph-name=""Racute"" unicode=""&#x154;"" horiz-adv-x=""1479"" 
d=""M1105 0l-327 535h-346v-535h-295v1409h704q132 0 230.5 -29.5t164.5 -84t98.5 -132t32.5 -174.5q0 -79 -23.5 -144.5t-65 -116.5t-98.5 -85.5t-124 -50.5l381 -592h-332zM1070 977q0 103 -67.5 153t-192.5 50h-378v-416h386q66 0 113.5 15.5t78 44t45.5 67.5t15 86z
M548 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""racute"" unicode=""&#x155;"" horiz-adv-x=""797"" 
d=""M143 0v828q0 35 -0.5 74t-2 74.5t-2.5 64t-3 41.5h268q2 -12 4 -41.5t4 -64.5t3.5 -69.5t1.5 -55.5h4q21 59 42 105.5t49.5 79t68.5 50t99 17.5q25 0 49.5 -4.5t37.5 -10.5v-235q-27 6 -54.5 10.5t-65.5 4.5q-105 0 -163.5 -85t-58.5 -252v-531h-281zM269 1183v31
l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""Rcommaaccent"" unicode=""&#x156;"" horiz-adv-x=""1479"" 
d=""M1105 0l-327 535h-346v-535h-295v1409h704q132 0 230.5 -29.5t164.5 -84t98.5 -132t32.5 -174.5q0 -79 -23.5 -144.5t-65 -116.5t-98.5 -85.5t-124 -50.5l381 -592h-332zM1070 977q0 103 -67.5 153t-192.5 50h-378v-416h386q66 0 113.5 15.5t78 44t45.5 67.5t15 86z
M865 -204q0 -44 -7 -79.5t-20 -66t-30 -56t-37 -49.5h-137q45 48 69.5 90t24.5 80h-108v207h245v-126z"" />
    <glyph glyph-name=""rcommaaccent"" unicode=""&#x157;"" horiz-adv-x=""797"" 
d=""M143 0v828q0 35 -0.5 74t-2 74.5t-2.5 64t-3 41.5h268q2 -12 4 -41.5t4 -64.5t3.5 -69.5t1.5 -55.5h4q21 59 42 105.5t49.5 79t68.5 50t99 17.5q25 0 49.5 -4.5t37.5 -10.5v-235q-27 6 -54.5 10.5t-65.5 4.5q-105 0 -163.5 -85t-58.5 -252v-531h-281zM405 -204
q0 -44 -7 -79.5t-20 -66t-30 -56t-37 -49.5h-137q45 48 69.5 90t24.5 80h-108v207h245v-126z"" />
    <glyph glyph-name=""Rcaron"" unicode=""&#x158;"" horiz-adv-x=""1479"" 
d=""M1105 0l-327 535h-346v-535h-295v1409h704q132 0 230.5 -29.5t164.5 -84t98.5 -132t32.5 -174.5q0 -79 -23.5 -144.5t-65 -116.5t-98.5 -85.5t-124 -50.5l381 -592h-332zM1070 977q0 103 -67.5 153t-192.5 50h-378v-416h386q66 0 113.5 15.5t78 44t45.5 67.5t15 86z
M818 1530h-229l-258 276v29h160l211 -152h4l203 152h159v-29z"" />
    <glyph glyph-name=""rcaron"" unicode=""&#x159;"" horiz-adv-x=""797"" 
d=""M143 0v828q0 35 -0.5 74t-2 74.5t-2.5 64t-3 41.5h268q2 -12 4 -41.5t4 -64.5t3.5 -69.5t1.5 -55.5h4q21 59 42 105.5t49.5 79t68.5 50t99 17.5q25 0 49.5 -4.5t37.5 -10.5v-235q-27 6 -54.5 10.5t-65.5 4.5q-105 0 -163.5 -85t-58.5 -252v-531h-281zM543 1183h-229
l-258 317v29h160l211 -193h4l203 193h159v-29z"" />
    <glyph glyph-name=""Sacute"" unicode=""&#x15a;"" horiz-adv-x=""1366"" 
d=""M1286 406q0 -96 -35 -174.5t-108.5 -134.5t-188 -86.5t-272.5 -30.5q-140 0 -247 25t-183.5 74t-124 121.5t-68.5 166.5l285 47q12 -47 35 -86t63.5 -67.5t101 -44t146.5 -15.5q150 0 229.5 45.5t79.5 142.5q0 58 -32 95t-85 61t-122 40t-144 31q-60 14 -120 29
t-114.5 36t-101.5 50t-81.5 71.5t-54 99.5t-19.5 134q0 105 42 180t116.5 122.5t177.5 69.5t225 22q138 0 236.5 -21.5t165 -65.5t105 -110.5t56.5 -155.5l-286 -39q-22 91 -89.5 137t-193.5 46q-78 0 -129.5 -13.5t-82 -36.5t-43.5 -53.5t-13 -64.5q0 -52 25 -85.5t70 -56
t107.5 -38t137.5 -31.5q66 -14 131 -29.5t124 -36.5t110 -51t88.5 -73.5t59 -103.5t21.5 -142zM555 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""sacute"" unicode=""&#x15b;"" 
d=""M1055 316q0 -78 -32.5 -140t-94.5 -105.5t-152 -67t-205 -23.5q-103 0 -186 15t-145.5 49.5t-104.5 89.5t-63 136l247 37q12 -45 33 -73t52 -43t72.5 -20t94.5 -5q48 0 89.5 5.5t72 19t47.5 38t17 61.5q0 42 -24.5 66.5t-67 40t-100 27t-122.5 26.5q-68 15 -134 36
t-118 57t-84 91.5t-32 140.5q0 77 30 137.5t88 103t143.5 65t196.5 22.5q88 0 164 -16.5t136 -52t100.5 -90.5t56.5 -133l-249 -26q-7 39 -25 64.5t-44.5 40.5t-61.5 20.5t-77 5.5q-100 0 -150 -25.5t-50 -85.5q0 -37 20.5 -59t58 -36.5t89 -25t112.5 -25.5
q75 -16 147.5 -37.5t129 -59t91 -96.5t34.5 -150zM400 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""Scircumflex"" unicode=""&#x15c;"" horiz-adv-x=""1366"" 
d=""M1286 406q0 -96 -35 -174.5t-108.5 -134.5t-188 -86.5t-272.5 -30.5q-140 0 -247 25t-183.5 74t-124 121.5t-68.5 166.5l285 47q12 -47 35 -86t63.5 -67.5t101 -44t146.5 -15.5q150 0 229.5 45.5t79.5 142.5q0 58 -32 95t-85 61t-122 40t-144 31q-60 14 -120 29
t-114.5 36t-101.5 50t-81.5 71.5t-54 99.5t-19.5 134q0 105 42 180t116.5 122.5t177.5 69.5t225 22q138 0 236.5 -21.5t165 -65.5t105 -110.5t56.5 -155.5l-286 -39q-22 91 -89.5 137t-193.5 46q-78 0 -129.5 -13.5t-82 -36.5t-43.5 -53.5t-13 -64.5q0 -52 25 -85.5t70 -56
t107.5 -38t137.5 -31.5q66 -14 131 -29.5t124 -36.5t110 -51t88.5 -73.5t59 -103.5t21.5 -142zM1079 1559v-29h-159l-203 151h-4l-211 -151h-160v29l258 276h229z"" />
    <glyph glyph-name=""scircumflex"" unicode=""&#x15d;"" 
d=""M1055 316q0 -78 -32.5 -140t-94.5 -105.5t-152 -67t-205 -23.5q-103 0 -186 15t-145.5 49.5t-104.5 89.5t-63 136l247 37q12 -45 33 -73t52 -43t72.5 -20t94.5 -5q48 0 89.5 5.5t72 19t47.5 38t17 61.5q0 42 -24.5 66.5t-67 40t-100 27t-122.5 26.5q-68 15 -134 36
t-118 57t-84 91.5t-32 140.5q0 77 30 137.5t88 103t143.5 65t196.5 22.5q88 0 164 -16.5t136 -52t100.5 -90.5t56.5 -133l-249 -26q-7 39 -25 64.5t-44.5 40.5t-61.5 20.5t-77 5.5q-100 0 -150 -25.5t-50 -85.5q0 -37 20.5 -59t58 -36.5t89 -25t112.5 -25.5
q75 -16 147.5 -37.5t129 -59t91 -96.5t34.5 -150zM935 1211v-28h-159l-203 192h-4l-211 -192h-160v28l258 318h229z"" />
    <glyph glyph-name=""Scedilla"" unicode=""&#x15e;"" horiz-adv-x=""1366"" 
d=""M1286 406q0 -96 -35 -174.5t-108.5 -134.5t-188 -86.5t-272.5 -30.5q-140 0 -247 25t-183.5 74t-124 121.5t-68.5 166.5l285 47q12 -47 35 -86t63.5 -67.5t101 -44t146.5 -15.5q150 0 229.5 45.5t79.5 142.5q0 58 -32 95t-85 61t-122 40t-144 31q-60 14 -120 29
t-114.5 36t-101.5 50t-81.5 71.5t-54 99.5t-19.5 134q0 105 42 180t116.5 122.5t177.5 69.5t225 22q138 0 236.5 -21.5t165 -65.5t105 -110.5t56.5 -155.5l-286 -39q-22 91 -89.5 137t-193.5 46q-78 0 -129.5 -13.5t-82 -36.5t-43.5 -53.5t-13 -64.5q0 -52 25 -85.5t70 -56
t107.5 -38t137.5 -31.5q66 -14 131 -29.5t124 -36.5t110 -51t88.5 -73.5t59 -103.5t21.5 -142zM922 -235q0 -39 -15.5 -74t-51 -60.5t-93.5 -40.5t-143 -15q-45 0 -101 6v118q25 -5 46 -6t38 -1q75 0 106 18.5t31 50.5q0 35 -28 52t-94 17h-25.5t-26.5 -2l62 172h143
l-33 -82q94 -5 139.5 -46t45.5 -107z"" />
    <glyph glyph-name=""scedilla"" unicode=""&#x15f;"" 
d=""M1055 316q0 -78 -32.5 -140t-94.5 -105.5t-152 -67t-205 -23.5q-103 0 -186 15t-145.5 49.5t-104.5 89.5t-63 136l247 37q12 -45 33 -73t52 -43t72.5 -20t94.5 -5q48 0 89.5 5.5t72 19t47.5 38t17 61.5q0 42 -24.5 66.5t-67 40t-100 27t-122.5 26.5q-68 15 -134 36
t-118 57t-84 91.5t-32 140.5q0 77 30 137.5t88 103t143.5 65t196.5 22.5q88 0 164 -16.5t136 -52t100.5 -90.5t56.5 -133l-249 -26q-7 39 -25 64.5t-44.5 40.5t-61.5 20.5t-77 5.5q-100 0 -150 -25.5t-50 -85.5q0 -37 20.5 -59t58 -36.5t89 -25t112.5 -25.5
q75 -16 147.5 -37.5t129 -59t91 -96.5t34.5 -150zM786 -235q0 -39 -15.5 -74t-51 -60.5t-93.5 -40.5t-143 -15q-45 0 -101 6v118q25 -5 46 -6t38 -1q75 0 106 18.5t31 50.5q0 35 -28 52t-94 17h-25.5t-26.5 -2l62 172h143l-33 -82q94 -5 139.5 -46t45.5 -107z"" />
    <glyph glyph-name=""Scaron"" unicode=""&#x160;"" horiz-adv-x=""1366"" 
d=""M1286 406q0 -96 -35 -174.5t-108.5 -134.5t-188 -86.5t-272.5 -30.5q-140 0 -247 25t-183.5 74t-124 121.5t-68.5 166.5l285 47q12 -47 35 -86t63.5 -67.5t101 -44t146.5 -15.5q150 0 229.5 45.5t79.5 142.5q0 58 -32 95t-85 61t-122 40t-144 31q-60 14 -120 29
t-114.5 36t-101.5 50t-81.5 71.5t-54 99.5t-19.5 134q0 105 42 180t116.5 122.5t177.5 69.5t225 22q138 0 236.5 -21.5t165 -65.5t105 -110.5t56.5 -155.5l-286 -39q-22 91 -89.5 137t-193.5 46q-78 0 -129.5 -13.5t-82 -36.5t-43.5 -53.5t-13 -64.5q0 -52 25 -85.5t70 -56
t107.5 -38t137.5 -31.5q66 -14 131 -29.5t124 -36.5t110 -51t88.5 -73.5t59 -103.5t21.5 -142zM806 1530h-229l-258 276v29h160l211 -152h4l203 152h159v-29z"" />
    <glyph glyph-name=""scaron"" unicode=""&#x161;"" 
d=""M1055 316q0 -78 -32.5 -140t-94.5 -105.5t-152 -67t-205 -23.5q-103 0 -186 15t-145.5 49.5t-104.5 89.5t-63 136l247 37q12 -45 33 -73t52 -43t72.5 -20t94.5 -5q48 0 89.5 5.5t72 19t47.5 38t17 61.5q0 42 -24.5 66.5t-67 40t-100 27t-122.5 26.5q-68 15 -134 36
t-118 57t-84 91.5t-32 140.5q0 77 30 137.5t88 103t143.5 65t196.5 22.5q88 0 164 -16.5t136 -52t100.5 -90.5t56.5 -133l-249 -26q-7 39 -25 64.5t-44.5 40.5t-61.5 20.5t-77 5.5q-100 0 -150 -25.5t-50 -85.5q0 -37 20.5 -59t58 -36.5t89 -25t112.5 -25.5
q75 -16 147.5 -37.5t129 -59t91 -96.5t34.5 -150zM692 1183h-229l-258 317v29h160l211 -193h4l203 193h159v-29z"" />
    <glyph glyph-name=""Tcommaaccent"" unicode=""&#x162;"" horiz-adv-x=""1251"" 
d=""M823 -235q0 -39 -15.5 -74t-51 -60.5t-93.5 -40.5t-143 -15q-45 0 -101 6v118q25 -5 46 -6t38 -1q75 0 106 18.5t31 50.5q0 35 -28 52t-94 17h-25.5t-26.5 -2l62 172h143l-33 -82q94 -5 139.5 -46t45.5 -107zM773 1181v-1181h-295v1181h-455v228h1206v-228h-456z"" />
    <glyph glyph-name=""tcommaaccent"" unicode=""&#x163;"" horiz-adv-x=""682"" 
d=""M656 -235q0 -39 -15.5 -74t-51 -60.5t-93.5 -40.5t-143 -15q-45 0 -101 6v118q25 -5 46 -6t38 -1q75 0 106 18.5t31 50.5q0 35 -28 52t-94 17h-25.5t-26.5 -2l62 172h143l-33 -82q94 -5 139.5 -46t45.5 -107zM420 -18q-124 0 -191 67.5t-67 204.5v638h-137v190h151
l88 254h176v-254h205v-190h-205v-562q0 -79 30 -116.5t93 -37.5q26 0 47 4t47 10v-174q-52 -17 -110 -25.5t-127 -8.5z"" />
    <glyph glyph-name=""Tcaron"" unicode=""&#x164;"" horiz-adv-x=""1251"" 
d=""M773 1181v-1181h-295v1181h-455v228h1206v-228h-456zM749 1530h-229l-258 276v29h160l211 -152h4l203 152h159v-29z"" />
    <glyph glyph-name=""tcaron"" unicode=""&#x165;"" horiz-adv-x=""981"" 
d=""M420 -18q-124 0 -191 67.5t-67 204.5v638h-137v190h151l88 254h176v-254h205v-190h-205v-562q0 -79 30 -116.5t93 -37.5q26 0 47 4t47 10v-174q-52 -17 -110 -25.5t-127 -8.5zM981 1338q0 -43 -7 -79t-20 -66.5t-30 -56t-37 -49.5h-137q45 48 69.5 96t24.5 94h-108v207
h245v-146z"" />
    <glyph glyph-name=""Tbar"" unicode=""&#x166;"" horiz-adv-x=""1251"" 
d=""M773 1181v-365h228v-190h-228v-626h-295v626h-227v190h227v365h-455v228h1206v-228h-456z"" />
    <glyph glyph-name=""tbar"" unicode=""&#x167;"" horiz-adv-x=""682"" 
d=""M420 -18q-124 0 -191 67.5t-67 204.5v219h-127v190h127v229h-137v190h151l88 254h176v-254h205v-190h-205v-229h185v-190h-185v-143q0 -79 30 -116.5t93 -37.5q26 0 47 4t47 10v-174q-52 -17 -110 -25.5t-127 -8.5z"" />
    <glyph glyph-name=""Utilde"" unicode=""&#x168;"" horiz-adv-x=""1479"" 
d=""M723 -20q-132 0 -242 31.5t-189.5 98t-124 170.5t-44.5 248v881h295v-858q0 -89 22 -153.5t63 -106t99 -61t129 -19.5q72 0 132.5 20.5t104 63.5t67.5 109t24 157v848h295v-866q0 -145 -47 -251t-131 -175.5t-199.5 -103t-253.5 -33.5zM905 1530q-44 0 -88.5 19
t-86.5 42.5t-79.5 42.5t-67.5 19q-26 0 -43 -8.5t-27.5 -24.5t-16.5 -38.5t-11 -51.5h-137q3 45 11 96t31.5 95t66.5 73t116 29q45 0 90 -19t87 -42.5t78.5 -42.5t65.5 -19q25 0 41.5 8.5t28 24.5t18 39t11.5 51h135q-2 -45 -10 -96t-31 -95t-66 -73t-116 -29z"" />
    <glyph glyph-name=""utilde"" unicode=""&#x169;"" horiz-adv-x=""1251"" 
d=""M831 215q-107 -235 -348 -235q-184 0 -275 120q-81 105 -81 295v687h281v-607q0 -285 192 -285q101 0 164 86q63 88 63 226v580h281v-840q0 -138 8 -242h-268q-1 12 -3.5 38.5t-4.5 58.5l-2 64q-2 32 -2 54h-5zM786 1183q-44 0 -88.5 19t-86.5 42.5t-79.5 42.5t-67.5 19
q-26 0 -43 -8.5t-27.5 -24.5t-16.5 -38.5t-11 -51.5h-137q3 45 11 96t31.5 95t66.5 73t116 29q45 0 90 -19t87 -42.5t78.5 -42.5t65.5 -19q25 0 41.5 8.5t28 24.5t18 39t11.5 51h135q-2 -45 -10 -96t-31 -95t-66 -73t-116 -29z"" />
    <glyph glyph-name=""Umacron"" unicode=""&#x16a;"" horiz-adv-x=""1479"" 
d=""M723 -20q-132 0 -242 31.5t-189.5 98t-124 170.5t-44.5 248v881h295v-858q0 -89 22 -153.5t63 -106t99 -61t129 -19.5q72 0 132.5 20.5t104 63.5t67.5 109t24 157v848h295v-866q0 -145 -47 -251t-131 -175.5t-199.5 -103t-253.5 -33.5zM433 1700h612v-168h-612v168z"" />
    <glyph glyph-name=""umacron"" unicode=""&#x16b;"" horiz-adv-x=""1251"" 
d=""M831 215q-107 -235 -348 -235q-184 0 -275 120q-81 105 -81 295v687h281v-607q0 -285 192 -285q101 0 164 86q63 88 63 226v580h281v-840q0 -138 8 -242h-268q-1 12 -3.5 38.5t-4.5 58.5l-2 64q-2 32 -2 54h-5zM312 1371h612v-168h-612v168z"" />
    <glyph glyph-name=""Ubreve"" unicode=""&#x16c;"" horiz-adv-x=""1479"" 
d=""M723 -20q-132 0 -242 31.5t-189.5 98t-124 170.5t-44.5 248v881h295v-858q0 -89 22 -153.5t63 -106t99 -61t129 -19.5q72 0 132.5 20.5t104 63.5t67.5 109t24 157v848h295v-866q0 -145 -47 -251t-131 -175.5t-199.5 -103t-253.5 -33.5zM737 1520q-80 0 -143 24
t-107.5 63.5t-70.5 91.5t-31 109h163q8 -32 26 -57t43 -42.5t56.5 -27t65.5 -9.5q36 0 67.5 9.5t56.5 27t42 42.5t24 57h164q-8 -57 -33.5 -109t-69 -91.5t-106.5 -63.5t-147 -24z"" />
    <glyph glyph-name=""ubreve"" unicode=""&#x16d;"" horiz-adv-x=""1251"" 
d=""M831 215q-107 -235 -348 -235q-184 0 -275 120q-81 105 -81 295v687h281v-607q0 -285 192 -285q101 0 164 86q63 88 63 226v580h281v-840q0 -138 8 -242h-268q-1 12 -3.5 38.5t-4.5 58.5l-2 64q-2 32 -2 54h-5zM622 1183q-80 0 -143 25.5t-107.5 70t-70.5 103t-31 124.5
h163q8 -39 26 -70t43 -52t56.5 -32.5t65.5 -11.5q36 0 67.5 11.5t56.5 32.5t42 52t24 70h164q-8 -66 -33.5 -124.5t-69 -103t-106.5 -70t-147 -25.5z"" />
    <glyph glyph-name=""Uring"" unicode=""&#x16e;"" horiz-adv-x=""1479"" 
d=""M723 -20q-132 0 -242 31.5t-189.5 98t-124 170.5t-44.5 248v881h295v-858q0 -89 22 -153.5t63 -106t99 -61t129 -19.5q72 0 132.5 20.5t104 63.5t67.5 109t24 157v848h295v-866q0 -145 -47 -251t-131 -175.5t-199.5 -103t-253.5 -33.5zM994 1724q0 -53 -20 -99.5
t-54.5 -81t-81 -54t-98.5 -19.5t-98.5 19.5t-81 54t-54.5 81t-20 99.5q0 52 20 98.5t54.5 81t81 54.5t98.5 20t98.5 -20t81 -54.5t54.5 -81t20 -98.5zM867 1724q0 26 -10 48.5t-27 39.5t-40.5 27t-49.5 10t-49 -10t-40 -27t-26.5 -39.5t-9.5 -48.5q0 -27 9.5 -50.5
t26.5 -40.5t40 -27t49 -10t49.5 10t40.5 27t27 40.5t10 50.5z"" />
    <glyph glyph-name=""uring"" unicode=""&#x16f;"" horiz-adv-x=""1251"" 
d=""M831 215q-107 -235 -348 -235q-184 0 -275 120q-81 105 -81 295v687h281v-607q0 -285 192 -285q101 0 164 86q63 88 63 226v580h281v-840q0 -138 8 -242h-268q-1 12 -3.5 38.5t-4.5 58.5l-2 64q-2 32 -2 54h-5zM875 1390q0 -53 -20 -99.5t-54.5 -81t-81 -54t-98.5 -19.5
t-98.5 19.5t-81 54t-54.5 81t-20 99.5q0 52 20 98.5t54.5 81t81 54.5t98.5 20t98.5 -20t81 -54.5t54.5 -81t20 -98.5zM748 1390q0 26 -10 48.5t-27 39.5t-40.5 27t-49.5 10t-49 -10t-40 -27t-26.5 -39.5t-9.5 -48.5q0 -27 9.5 -50.5t26.5 -40.5t40 -27t49 -10t49.5 10
t40.5 27t27 40.5t10 50.5z"" />
    <glyph glyph-name=""Uhungarumlaut"" unicode=""&#x170;"" horiz-adv-x=""1479"" 
d=""M723 -20q-132 0 -242 31.5t-189.5 98t-124 170.5t-44.5 248v881h295v-858q0 -89 22 -153.5t63 -106t99 -61t129 -19.5q72 0 132.5 20.5t104 63.5t67.5 109t24 157v848h295v-866q0 -145 -47 -251t-131 -175.5t-199.5 -103t-253.5 -33.5zM525 1530h-132v34l215 252h235v-43
zM931 1530h-132v34l215 252h235v-43z"" />
    <glyph glyph-name=""uhungarumlaut"" unicode=""&#x171;"" horiz-adv-x=""1251"" 
d=""M831 215q-107 -235 -348 -235q-184 0 -275 120q-81 105 -81 295v687h281v-607q0 -285 192 -285q101 0 164 86q63 88 63 226v580h281v-840q0 -138 8 -242h-268q-1 12 -3.5 38.5t-4.5 58.5l-2 64q-2 32 -2 54h-5zM399 1184h-142v34l225 266h235v-43zM805 1184h-142v34
l225 266h235v-43z"" />
    <glyph glyph-name=""Uogonek"" unicode=""&#x172;"" horiz-adv-x=""1479"" 
d=""M723 -20q-132 0 -242 31.5t-189.5 98t-124 170.5t-44.5 248v881h295v-858q0 -89 22 -153.5t63 -106t99 -61t129 -19.5q72 0 132.5 20.5t104 63.5t67.5 109t24 157v848h295v-866q0 -145 -47 -251t-131 -175.5t-199.5 -103t-253.5 -33.5zM857 -425q-51 0 -94.5 12.5t-75 38
t-49.5 62.5t-18 87q0 48 16 88.5t40 71.5t51.5 52.5t50.5 33.5h153q-63 -42 -96 -99.5t-33 -110.5q0 -42 24.5 -67.5t69.5 -25.5q31 0 57.5 7t54.5 20v-137q-63 -33 -151 -33z"" />
    <glyph glyph-name=""uogonek"" unicode=""&#x173;"" horiz-adv-x=""1251"" 
d=""M831 215q-107 -235 -348 -235q-184 0 -275 120q-81 105 -81 295v687h281v-607q0 -285 192 -285q101 0 164 86q63 88 63 226v580h281v-840q0 -138 8 -242h-268q-1 12 -3.5 38.5t-4.5 58.5l-2 64q-2 32 -2 54h-5zM958 -425q-51 0 -94.5 12.5t-75 38t-49.5 62.5t-18 87
q0 48 16 88.5t40 71.5t51.5 52.5t50.5 33.5h153q-63 -42 -96 -99.5t-33 -110.5q0 -42 24.5 -67.5t69.5 -25.5q31 0 57.5 7t54.5 20v-137q-63 -33 -151 -33z"" />
    <glyph glyph-name=""Wcircumflex"" unicode=""&#x174;"" horiz-adv-x=""1933"" 
d=""M1567 0h-350l-191 815q-9 37 -19.5 88t-19.5 99q-11 55 -20 114q-11 -59 -22 -115q-5 -24 -10 -49.5t-10.5 -50t-10 -46.5t-9.5 -40l-190 -815h-350l-363 1409h299l176 -784q15 -64 28 -126t24 -111q12 -57 22 -109q15 74 29 144q6 30 13 62t13.5 63t13 59.5t11.5 51.5
l174 750h330l178 -750q6 -24 12 -53.5t12 -61l12 -63t11 -61.5q12 -70 24 -141q12 56 25 116q11 51 25 112t28 118l170 784h299zM1337 1559v-29h-159l-203 151h-4l-211 -151h-160v29l258 276h229z"" />
    <glyph glyph-name=""wcircumflex"" unicode=""&#x175;"" horiz-adv-x=""1593"" 
d=""M436 255l209 827h301l207 -827l184 827h260l-284 -1082h-297l-219 882l-226 -882h-297l-280 1082h264zM1166 1211v-28h-159l-203 192h-4l-211 -192h-160v28l258 318h229z"" />
    <glyph glyph-name=""Ycircumflex"" unicode=""&#x176;"" horiz-adv-x=""1366"" 
d=""M831 578v-578h-294v578l-502 831h309l338 -596l342 596h309zM1053 1559v-29h-159l-203 151h-4l-211 -151h-160v29l258 276h229z"" />
    <glyph glyph-name=""ycircumflex"" unicode=""&#x177;"" 
d=""M584 241l250 841h294l-428 -1139q-81 -197 -168 -279q-95 -89 -249 -89q-101 0 -177 13v200q53 -8 95.5 -8t74.5 9t58 30q51 42 92 144l18 48l-428 1071h297zM949 1211v-28h-159l-203 192h-4l-211 -192h-160v28l258 318h229z"" />
    <glyph glyph-name=""Ydieresis"" unicode=""&#x178;"" horiz-adv-x=""1366"" 
d=""M831 578v-578h-294v578l-502 831h309l338 -596l342 596h309zM807 1530v219h197v-219h-197zM353 1530v219h194v-219h-194z"" />
    <glyph glyph-name=""Zacute"" unicode=""&#x179;"" horiz-adv-x=""1251"" 
d=""M1192 0h-1131v209l762 969h-686v231h1014v-205l-762 -973h803v-231zM473 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""zacute"" unicode=""&#x17a;"" horiz-adv-x=""1024"" 
d=""M68 0v199l540 680h-499v203h809v-201l-537 -676h586v-205h-899zM336 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""Zdotaccent"" unicode=""&#x17b;"" horiz-adv-x=""1251"" 
d=""M1192 0h-1131v209l762 969h-686v231h1014v-205l-762 -973h803v-231zM496 1547v207h281v-207h-281z"" />
    <glyph glyph-name=""zdotaccent"" unicode=""&#x17c;"" horiz-adv-x=""1024"" 
d=""M68 0v199l540 680h-499v203h809v-201l-537 -676h586v-205h-899zM389 1277v207h281v-207h-281z"" />
    <glyph glyph-name=""Zcaron"" unicode=""&#x17d;"" horiz-adv-x=""1251"" 
d=""M1192 0h-1131v209l762 969h-686v231h1014v-205l-762 -973h803v-231zM761 1530h-229l-258 276v29h160l211 -152h4l203 152h159v-29z"" />
    <glyph glyph-name=""zcaron"" unicode=""&#x17e;"" horiz-adv-x=""1024"" 
d=""M68 0v199l540 680h-499v203h809v-201l-537 -676h586v-205h-899zM630 1183h-229l-258 317v29h160l211 -193h4l203 193h159v-29z"" />
    <glyph glyph-name=""longs"" unicode=""&#x17f;"" horiz-adv-x=""569"" 
d=""M142 1195q0 62 15 114.5t51 91.5t97 61t152 22q48 0 94.5 -5t83.5 -11v-181q-18 4 -40.5 6.5t-41.5 2.5q-39 0 -64.5 -8t-40 -24t-20.5 -40.5t-6 -56.5v-1167h-280v1195z"" />
    <glyph glyph-name=""florin"" unicode=""&#x192;"" 
d=""M993 1247q-9 3 -22.5 6t-27.5 5.5t-27.5 4t-24.5 1.5q-65 0 -93.5 -33t-40.5 -94l-20 -107h212l-36 -190h-213l-251 -1265h-281l251 1265h-158l37 190h158l27 135q11 62 35.5 114.5t67.5 91.5t108 61t157 22q23 0 48.5 -2.5t50 -6.5t46.5 -9.5t37 -11.5z"" />
    <glyph glyph-name=""Aringacute"" unicode=""&#x1fa;"" horiz-adv-x=""1479"" 
d=""M1133 0l-125 360h-537l-125 -360h-295l514 1409h348l512 -1409h-292zM803 987q-12 35 -23.5 70.5t-20 65t-14 48.5t-6.5 21q-1 -3 -6 -22t-13.5 -48t-20 -64.5t-23.5 -70.5l-139 -405h405zM993 1537q0 -53 -20 -99.5t-54.5 -81t-81 -54t-98.5 -19.5t-98.5 19.5t-81 54
t-54.5 81t-20 99.5q0 52 20 98.5t54.5 81t81 54.5t98.5 20t98.5 -20t81 -54.5t54.5 -81t20 -98.5zM866 1537q0 26 -10 48.5t-27 39.5t-40.5 27t-49.5 10t-49 -10t-40 -27t-26.5 -39.5t-9.5 -48.5q0 -27 9.5 -50.5t26.5 -40.5t40 -27t49 -10t49.5 10t40.5 27t27 40.5t10 50.5
zM586 1831v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""aringacute"" unicode=""&#x1fb;"" 
d=""M393 -20q-78 0 -139.5 21.5t-104.5 63t-66 102.5t-23 139q0 96 33.5 161.5t91.5 106t136 59t166 19.5l233 4v55q0 59 -10.5 98.5t-30.5 64.5t-49.5 35.5t-67.5 10.5q-35 0 -62.5 -7t-47.5 -24.5t-32.5 -47t-17.5 -74.5l-293 14q12 71 44 129.5t88.5 101.5t139 66.5
t193.5 23.5q101 0 180 -25t134 -74.5t84 -121.5t29 -167v-394q0 -38 3.5 -68t13 -50.5t27 -31t45.5 -10.5q32 0 62 6v-152q-25 -6 -45 -11t-40 -8t-42.5 -5t-52.5 -2q-106 0 -156.5 52t-60.5 153h-6q-56 -101 -143.5 -157t-212.5 -56zM720 501l-144 -2q-45 -2 -85.5 -7.5
t-71 -23t-48.5 -50.5t-18 -90q0 -77 35.5 -114.5t94.5 -37.5q54 0 98 23t74.5 60.5t47.5 86.5t17 100v55zM823 1390q0 -53 -20 -99.5t-54.5 -81t-81 -54t-98.5 -19.5t-98.5 19.5t-81 54t-54.5 81t-20 99.5q0 52 20 98.5t54.5 81t81 54.5t98.5 20t98.5 -20t81 -54.5t54.5 -81
t20 -98.5zM696 1390q0 26 -10 48.5t-27 39.5t-40.5 27t-49.5 10t-49 -10t-40 -27t-26.5 -39.5t-9.5 -48.5q0 -27 9.5 -50.5t26.5 -40.5t40 -27t49 -10t49.5 10t40.5 27t27 40.5t10 50.5zM442 1693v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""AEacute"" unicode=""&#x1fc;"" horiz-adv-x=""2048"" 
d=""M931 0v360h-450l-172 -360h-305l700 1409h1223v-227h-701v-355h639v-221h-639v-379h742v-227h-1037zM931 1192h-61q-4 -9 -17 -37t-28 -61.5t-29.5 -64.5t-21.5 -46l-191 -401h348v610zM1083 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""aeacute"" unicode=""&#x1fd;"" horiz-adv-x=""1821"" 
d=""M1253 -20q-151 0 -261 56.5t-173 172.5q-29 -50 -67.5 -92t-89 -72.5t-114 -47.5t-142.5 -17t-142 21.5t-107 63t-67.5 102.5t-23.5 139q0 96 34.5 161t94.5 105.5t140 59t171 20.5l240 4v55q0 59 -11 98.5t-32.5 64.5t-53 35.5t-71.5 10.5q-37 0 -66.5 -7t-50.5 -24.5
t-34.5 -47t-18.5 -74.5l-293 14q12 71 44.5 129.5t89.5 101.5t140 66.5t197 23.5q217 0 333 -107q69 57 155.5 82t182.5 25q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-19h-694q0 -65 13 -121.5t40.5 -98t70 -65t101.5 -23.5q74 0 121 31.5t67 97.5l265 -23
q-18 -46 -50.5 -98t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM496 176q57 0 103 24.5t79 64t50.5 90t17.5 101.5v45l-152 -2q-48 -2 -90.5 -7.5t-74.5 -23t-51 -50.5t-19 -90q0 -77 37.5 -114.5t99.5 -37.5zM1253 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420
q-8 131 -63 196.5t-148 65.5zM774 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""Oslashacute"" unicode=""&#x1fe;"" horiz-adv-x=""1593"" 
d=""M147 -73l154 218q-109 99 -163 243.5t-54 322.5q0 165 46.5 298t137 226.5t223 144t304.5 50.5q103 0 191.5 -19.5t162.5 -54.5l82 117h193l-142 -203q112 -94 169 -236.5t57 -322.5q0 -165 -49 -300t-141 -231t-225 -148t-300 -52q-212 0 -360 77l-91 -129zM1207 711
q0 100 -21.5 182.5t-64.5 144.5l-541 -772q43 -26 96.5 -40.5t116.5 -14.5q108 0 186.5 37.5t129 104t74.5 158.5t24 200zM381 711q0 -99 20.5 -183t63.5 -149l539 768q-45 25 -96 38t-113 13q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5zM625 1530v31l252 254
h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""oslashacute"" unicode=""&#x1ff;"" horiz-adv-x=""1251"" 
d=""M1171 542q0 -124 -34.5 -227t-103.5 -177.5t-172 -116t-240 -41.5q-99 0 -179.5 23t-144.5 66l-113 -124h-183l197 215q-59 73 -88.5 169.5t-29.5 212.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q104 0 185.5 -21.5t144.5 -61.5l101 114h184l-184 -206
q59 -74 86 -172t27 -213zM375 542q0 -92 17 -163l407 461q-60 69 -168 69q-124 0 -190 -88t-66 -279zM877 542q0 47 -4 87.5t-12 74.5l-407 -460q32 -37 73 -54.5t91 -17.5q62 0 110.5 21.5t81.5 66.5t50 115t17 167zM465 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""Scommaaccent"" unicode=""&#x218;"" horiz-adv-x=""1366"" 
d=""M827 -204q0 -44 -7 -79.5t-20 -66t-30 -56t-37 -49.5h-137q45 48 69.5 90t24.5 80h-108v207h245v-126zM1286 406q0 -96 -35 -174.5t-108.5 -134.5t-188 -86.5t-272.5 -30.5q-140 0 -247 25t-183.5 74t-124 121.5t-68.5 166.5l285 47q12 -47 35 -86t63.5 -67.5t101 -44
t146.5 -15.5q150 0 229.5 45.5t79.5 142.5q0 58 -32 95t-85 61t-122 40t-144 31q-60 14 -120 29t-114.5 36t-101.5 50t-81.5 71.5t-54 99.5t-19.5 134q0 105 42 180t116.5 122.5t177.5 69.5t225 22q138 0 236.5 -21.5t165 -65.5t105 -110.5t56.5 -155.5l-286 -39
q-22 91 -89.5 137t-193.5 46q-78 0 -129.5 -13.5t-82 -36.5t-43.5 -53.5t-13 -64.5q0 -52 25 -85.5t70 -56t107.5 -38t137.5 -31.5q66 -14 131 -29.5t124 -36.5t110 -51t88.5 -73.5t59 -103.5t21.5 -142z"" />
    <glyph glyph-name=""scommaaccent"" unicode=""&#x219;"" 
d=""M711 -204q0 -44 -7 -79.5t-20 -66t-30 -56t-37 -49.5h-137q45 48 69.5 90t24.5 80h-108v207h245v-126zM1055 316q0 -78 -32.5 -140t-94.5 -105.5t-152 -67t-205 -23.5q-103 0 -186 15t-145.5 49.5t-104.5 89.5t-63 136l247 37q12 -45 33 -73t52 -43t72.5 -20t94.5 -5
q48 0 89.5 5.5t72 19t47.5 38t17 61.5q0 42 -24.5 66.5t-67 40t-100 27t-122.5 26.5q-68 15 -134 36t-118 57t-84 91.5t-32 140.5q0 77 30 137.5t88 103t143.5 65t196.5 22.5q88 0 164 -16.5t136 -52t100.5 -90.5t56.5 -133l-249 -26q-7 39 -25 64.5t-44.5 40.5t-61.5 20.5
t-77 5.5q-100 0 -150 -25.5t-50 -85.5q0 -37 20.5 -59t58 -36.5t89 -25t112.5 -25.5q75 -16 147.5 -37.5t129 -59t91 -96.5t34.5 -150z"" />
    <glyph glyph-name=""uni021A"" unicode=""&#x21a;"" horiz-adv-x=""1251"" 
d=""M754 -204q0 -44 -7 -79.5t-20 -66t-30 -56t-37 -49.5h-137q45 48 69.5 90t24.5 80h-108v207h245v-126zM773 1181v-1181h-295v1181h-455v228h1206v-228h-456z"" />
    <glyph glyph-name=""uni021B"" unicode=""&#x21b;"" horiz-adv-x=""682"" 
d=""M486 -204q0 -44 -7 -79.5t-20 -66t-30 -56t-37 -49.5h-137q45 48 69.5 90t24.5 80h-108v207h245v-126zM420 -18q-124 0 -191 67.5t-67 204.5v638h-137v190h151l88 254h176v-254h205v-190h-205v-562q0 -79 30 -116.5t93 -37.5q26 0 47 4t47 10v-174q-52 -17 -110 -25.5
t-127 -8.5z"" />
    <glyph glyph-name=""circumflex"" unicode=""&#x2c6;"" horiz-adv-x=""682"" 
d=""M737 1211v-28h-159l-203 192h-4l-211 -192h-160v28l258 318h229z"" />
    <glyph glyph-name=""caron"" unicode=""&#x2c7;"" horiz-adv-x=""682"" 
d=""M487 1183h-229l-258 317v29h160l211 -193h4l203 193h159v-29z"" />
    <glyph glyph-name=""uni02C9"" unicode=""&#x2c9;"" horiz-adv-x=""682"" 
d=""M36 1371h612v-168h-612v168z"" />
    <glyph glyph-name=""breve"" unicode=""&#x2d8;"" horiz-adv-x=""682"" 
d=""M295 1183q-80 0 -143 25.5t-107.5 70t-70.5 103t-31 124.5h163q8 -39 26 -70t43 -52t56.5 -32.5t65.5 -11.5q36 0 67.5 11.5t56.5 32.5t42 52t24 70h164q-8 -66 -33.5 -124.5t-69 -103t-106.5 -70t-147 -25.5z"" />
    <glyph glyph-name=""dotaccent"" unicode=""&#x2d9;"" horiz-adv-x=""682"" 
d=""M200 1277v207h281v-207h-281z"" />
    <glyph glyph-name=""ring"" unicode=""&#x2da;"" horiz-adv-x=""682"" 
d=""M547 1390q0 -53 -20 -99.5t-54.5 -81t-81 -54t-98.5 -19.5t-98.5 19.5t-81 54t-54.5 81t-20 99.5q0 52 20 98.5t54.5 81t81 54.5t98.5 20t98.5 -20t81 -54.5t54.5 -81t20 -98.5zM420 1390q0 26 -10 48.5t-27 39.5t-40.5 27t-49.5 10t-49 -10t-40 -27t-26.5 -39.5
t-9.5 -48.5q0 -27 9.5 -50.5t26.5 -40.5t40 -27t49 -10t49.5 10t40.5 27t27 40.5t10 50.5z"" />
    <glyph glyph-name=""ogonek"" unicode=""&#x2db;"" horiz-adv-x=""682"" 
d=""M313 -425q-51 0 -94.5 12.5t-75 38t-49.5 62.5t-18 87q0 48 16 88.5t40 71.5t51.5 52.5t50.5 33.5h153q-63 -42 -96 -99.5t-33 -110.5q0 -42 24.5 -67.5t69.5 -25.5q31 0 57.5 7t54.5 20v-137q-63 -33 -151 -33z"" />
    <glyph glyph-name=""tilde"" unicode=""&#x2dc;"" horiz-adv-x=""682"" 
d=""M543 1183q-44 0 -88.5 19t-86.5 42.5t-79.5 42.5t-67.5 19q-26 0 -43 -8.5t-27.5 -24.5t-16.5 -38.5t-11 -51.5h-137q3 45 11 96t31.5 95t66.5 73t116 29q45 0 90 -19t87 -42.5t78.5 -42.5t65.5 -19q25 0 41.5 8.5t28 24.5t18 39t11.5 51h135q-2 -45 -10 -96t-31 -95
t-66 -73t-116 -29z"" />
    <glyph glyph-name=""hungarumlaut"" unicode=""&#x2dd;"" horiz-adv-x=""682"" 
d=""M50 1184h-142v34l225 266h235v-43zM456 1184h-142v34l225 266h235v-43z"" />
    <glyph glyph-name=""tonos"" unicode=""&#x384;"" horiz-adv-x=""682"" 
d=""M185 1183v33l69 292h257v-37l-221 -288h-105z"" />
    <glyph glyph-name=""dieresistonos"" unicode=""&#x385;"" horiz-adv-x=""952"" 
d=""M361 1190v33l59 398h237v-37l-181 -394h-115zM110 1231v222h200v-222h-200zM642 1231v222h200v-222h-200z"" />
    <glyph glyph-name=""Alphatonos"" unicode=""&#x386;"" horiz-adv-x=""1479"" 
d=""M1133 0l-125 360h-537l-125 -360h-295l514 1409h348l512 -1409h-292zM803 987q-12 35 -23.5 70.5t-20 65t-14 48.5t-6.5 21q-1 -3 -6 -22t-13.5 -48t-20 -64.5t-23.5 -70.5l-139 -405h405zM36 1085v33l69 292h257v-37l-221 -288h-105z"" />
    <glyph glyph-name=""anoteleia"" unicode=""&#x387;"" horiz-adv-x=""682"" 
d=""M197 531v305h288v-305h-288z"" />
    <glyph glyph-name=""Epsilontonos"" unicode=""&#x388;"" horiz-adv-x=""1747"" 
d=""M518 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149zM46 1085v33l69 292h257v-37l-221 -288h-105z"" />
    <glyph glyph-name=""Etatonos"" unicode=""&#x389;"" horiz-adv-x=""1855"" 
d=""M1422 0v604h-614v-604h-295v1409h295v-561h614v561h295v-1409h-295zM36 1085v33l69 292h257v-37l-221 -288h-105z"" />
    <glyph glyph-name=""Iotatonos"" unicode=""&#x38a;"" horiz-adv-x=""970"" 
d=""M538 0v1409h295v-1409h-295zM36 1085v33l69 292h257v-37l-221 -288h-105z"" />
    <glyph glyph-name=""Omicrontonos"" unicode=""&#x38c;"" horiz-adv-x=""1689"" 
d=""M1603 711q0 -165 -49 -300t-141 -231t-224.5 -148t-299.5 -52q-177 0 -309.5 54.5t-221.5 152t-133.5 231.5t-44.5 293q0 165 46.5 298t137 226.5t223 144t304.5 50.5t304.5 -51t223 -145t137.5 -226.5t47 -296.5zM1302 711q0 111 -26.5 200.5t-78.5 153.5t-128.5 98.5
t-177.5 34.5q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5q0 -110 26.5 -201.5t78.5 -157.5t129 -103t178 -37q108 0 186 37.5t128.5 104t74.5 158t24 199.5zM-26 1085v33l69 292h257v-37l-221 -288h-105z"" />
    <glyph glyph-name=""Upsilontonos"" unicode=""&#x38e;"" horiz-adv-x=""1899"" 
d=""M1363 578v-578h-294v578l-502 831h309l338 -596l342 596h309zM128 1085v33l69 292h257v-37l-221 -288h-105z"" />
    <glyph glyph-name=""Omegatonos"" unicode=""&#x38f;"" horiz-adv-x=""1716"" 
d=""M895 1430q165 0 296.5 -41t223.5 -119t141 -189.5t49 -252.5q0 -102 -24 -190.5t-76 -165t-132.5 -140.5t-193.5 -115q31 3 63 6q27 2 58 3.5t57 1.5h276v-228h-671v309q181 86 262 201.5t81 263.5q0 101 -27.5 180t-80 133t-129.5 82.5t-175 28.5q-99 0 -175.5 -28.5
t-129.5 -82.5t-80.5 -133t-27.5 -180q0 -148 81.5 -263.5t262.5 -201.5v-309h-667v228h274q26 0 57 -1.5t58 -3.5q32 -3 62 -6q-112 51 -192.5 115t-131.5 140.5t-75 165.5t-24 191q0 141 49 252.5t141 189t223.5 118.5t296.5 41zM-48 1085v33l69 292h257v-37l-221 -288
h-105z"" />
    <glyph glyph-name=""iotadieresistonos"" unicode=""&#x390;"" horiz-adv-x=""569"" 
d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h282v-855q0 -32 6 -64t16.5 -62t25 -55.5t32.5 -45.5h-300zM164 1190v33l59 398h237v-37l-181 -394h-115zM-87 1231v222h200v-222h-200zM445 1231v222h200v-222h-200z"" />
    <glyph glyph-name=""Alpha"" unicode=""&#x391;"" horiz-adv-x=""1479"" 
d=""M1133 0l-125 360h-537l-125 -360h-295l514 1409h348l512 -1409h-292zM803 987q-12 35 -23.5 70.5t-20 65t-14 48.5t-6.5 21q-1 -3 -6 -22t-13.5 -48t-20 -64.5t-23.5 -70.5l-139 -405h405z"" />
    <glyph glyph-name=""Beta"" unicode=""&#x392;"" horiz-adv-x=""1479"" 
d=""M1386 402q0 -107 -43 -183.5t-117.5 -125t-173.5 -71t-210 -22.5h-705v1409h645q125 0 222.5 -21.5t164.5 -65.5t101.5 -110.5t34.5 -156.5q0 -120 -66.5 -202.5t-202.5 -111.5q171 -20 260.5 -107.5t89.5 -231.5zM1008 1015q0 95 -60.5 135t-179.5 40h-336v-349h338
q125 0 181.5 43.5t56.5 130.5zM1090 425q0 56 -22 94t-60.5 61t-90 33t-111.5 10h-374v-404h385q58 0 108 9.5t86.5 33t57.5 63.5t21 100z"" />
    <glyph glyph-name=""Gamma"" unicode=""&#x393;"" horiz-adv-x=""1231"" 
d=""M1198 1409v-228h-766v-1180h-295v1408h1061z"" />
    <glyph glyph-name=""Delta"" unicode=""&#x394;"" horiz-adv-x=""1472"" 
d=""M84 226l483 1183l345 -1l476 -1182v-226h-1305zM1086 244l-266 698q-15 41 -29.5 81.5t-26 75t-18.5 59l-9 31.5q-1 -7 -9 -32t-19 -60t-25.5 -76t-29.5 -81l-263 -696h695z"" />
    <glyph glyph-name=""Epsilon"" unicode=""&#x395;"" horiz-adv-x=""1366"" 
d=""M137 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149z"" />
    <glyph glyph-name=""Zeta"" unicode=""&#x396;"" horiz-adv-x=""1251"" 
d=""M1192 0h-1131v209l762 969h-686v231h1014v-205l-762 -973h803v-231z"" />
    <glyph glyph-name=""Eta"" unicode=""&#x397;"" horiz-adv-x=""1479"" 
d=""M1046 0v604h-614v-604h-295v1409h295v-561h614v561h295v-1409h-295z"" />
    <glyph glyph-name=""Theta"" unicode=""&#x398;"" horiz-adv-x=""1593"" 
d=""M502 827h587v-228h-587v228zM1507 711q0 -165 -49 -300t-141 -231t-224.5 -148t-299.5 -52q-177 0 -309.5 54.5t-221.5 152t-133.5 231.5t-44.5 293q0 165 46.5 298t137 226.5t223 144t304.5 50.5t304.5 -51t223 -145t137.5 -226.5t47 -296.5zM1206 711
q0 111 -26.5 200.5t-78.5 153.5t-128.5 98.5t-177.5 34.5q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5q0 -110 26.5 -201.5t78.5 -157.5t129 -103t178 -37q108 0 186 37.5t128.5 104t74.5 158t24 199.5z"" />
    <glyph glyph-name=""Iota"" unicode=""&#x399;"" horiz-adv-x=""569"" 
d=""M137 0v1409h295v-1409h-295z"" />
    <glyph glyph-name=""Kappa"" unicode=""&#x39a;"" horiz-adv-x=""1479"" 
d=""M1112 0l-506 647l-174 -133v-514h-295v1409h295v-639l635 639h344l-602 -596l651 -813h-348z"" />
    <glyph glyph-name=""Lambda"" unicode=""&#x39b;"" horiz-adv-x=""1366"" 
d=""M1352 1h-305l-289 885q-14 48 -27.5 95t-23.5 85q-11 45 -21 86q-11 -42 -23 -88q-11 -39 -24 -86t-27 -92l-290 -885h-308l521 1409h299z"" />
    <glyph glyph-name=""Mu"" unicode=""&#x39c;"" horiz-adv-x=""1706"" 
d=""M1307 0v854q0 51 1.5 105t3.5 99q3 53 5 103q-21 -79 -40 -150q-8 -30 -17 -62t-17.5 -62t-16.5 -56t-14 -45l-254 -786h-210l-254 786q-6 19 -13.5 45t-16 56t-17.5 62t-18 62q-20 71 -42 150q3 -58 6 -114q2 -48 4 -101t2 -92v-854h-262v1409h395l252 -788
q10 -31 21.5 -76t22.5 -87q12 -49 26 -102q14 52 27 100q6 21 12 43t12 43t12 40t11 34l248 793h393v-1409h-262z"" />
    <glyph glyph-name=""Nu"" unicode=""&#x39d;"" horiz-adv-x=""1479"" 
d=""M995 0l-614 1085q5 -44 9 -88q4 -38 6.5 -82t2.5 -84v-831h-262v1409h337l623 -1094q-5 42 -9 88q-4 39 -6.5 88t-2.5 99v819h262v-1409h-346z"" />
    <glyph glyph-name=""Xi"" unicode=""&#x39e;"" horiz-adv-x=""1318"" 
d=""M119 1409h1081v-228h-1081v228zM1235 228v-228h-1151v228h1151zM1080 827v-228h-841v228h841z"" />
    <glyph glyph-name=""Omicron"" unicode=""&#x39f;"" horiz-adv-x=""1593"" 
d=""M1507 711q0 -165 -49 -300t-141 -231t-224.5 -148t-299.5 -52q-177 0 -309.5 54.5t-221.5 152t-133.5 231.5t-44.5 293q0 165 46.5 298t137 226.5t223 144t304.5 50.5t304.5 -51t223 -145t137.5 -226.5t47 -296.5zM1206 711q0 111 -26.5 200.5t-78.5 153.5t-128.5 98.5
t-177.5 34.5q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5q0 -110 26.5 -201.5t78.5 -157.5t129 -103t178 -37q108 0 186 37.5t128.5 104t74.5 158t24 199.5z"" />
    <glyph glyph-name=""Pi"" unicode=""&#x3a0;"" horiz-adv-x=""1479"" 
d=""M1056 0v1165h-625v-1165h-294v1409h1204v-1409h-285z"" />
    <glyph glyph-name=""Rho"" unicode=""&#x3a1;"" horiz-adv-x=""1366"" 
d=""M1296 963q0 -91 -30.5 -175.5t-93.5 -149.5t-160 -103.5t-230 -38.5h-350v-496h-295v1409h633q135 0 234 -32.5t164 -91.5t96.5 -141t31.5 -181zM999 958q0 109 -65.5 165.5t-196.5 56.5h-305v-457h313q66 0 113.5 17t79 48t46.5 74.5t15 95.5z"" />
    <glyph glyph-name=""Sigma"" unicode=""&#x3a3;"" horiz-adv-x=""1229"" 
d=""M90 0v234l448 507l-431 435v233h999v-228h-697l371 -373v-134l-394 -446h781v-228h-1077z"" />
    <glyph glyph-name=""Tau"" unicode=""&#x3a4;"" horiz-adv-x=""1251"" 
d=""M773 1181v-1181h-295v1181h-455v228h1206v-228h-456z"" />
    <glyph glyph-name=""Upsilon"" unicode=""&#x3a5;"" horiz-adv-x=""1366"" 
d=""M831 578v-578h-294v578l-502 831h309l338 -596l342 596h309z"" />
    <glyph glyph-name=""Phi"" unicode=""&#x3a6;"" horiz-adv-x=""1681"" 
d=""M1322 730q0 152 -79 237t-244 85h-19v-655h26q84 0 143.5 25t98 69.5t56.5 105.5t18 133zM702 -11v199h-54q-148 0 -258 44t-183 119t-108.5 174t-35.5 209q0 119 37 216.5t111.5 166.5t186.5 106.5t262 37.5h42v158h278v-158h42q150 0 262 -37.5t186.5 -106.5
t111.5 -166.5t37 -216.5q0 -110 -35.5 -209t-108.5 -174t-182.5 -119t-258.5 -44h-54v-199h-278zM360 730q0 -72 18 -133t56.5 -105.5t98 -69.5t143.5 -25h26v655h-19q-165 0 -244 -85t-79 -237z"" />
    <glyph glyph-name=""Chi"" unicode=""&#x3a7;"" horiz-adv-x=""1366"" 
d=""M1038 0l-354 561l-354 -561h-312l488 741l-447 668h312l313 -498l313 498h310l-428 -668l469 -741h-310z"" />
    <glyph glyph-name=""Psi"" unicode=""&#x3a8;"" horiz-adv-x=""1657"" 
d=""M968 427v-427h-279v427h-40q-144 0 -248.5 33.5t-172 99t-100 162.5t-32.5 224v463h279v-467q0 -80 17.5 -136t54.5 -91t94.5 -51t138.5 -16h9v761h279v-761h9q81 0 138.5 16t94.5 51t54.5 91t17.5 136v467h279v-463q0 -127 -32.5 -224t-100 -162.5t-172 -99
t-248.5 -33.5h-40z"" />
    <glyph glyph-name=""Omega"" unicode=""&#x3a9;"" horiz-adv-x=""1642"" 
d=""M821 1430q165 0 296.5 -41t223.5 -119t141 -189.5t49 -252.5q0 -102 -24 -190.5t-76 -165t-132.5 -140.5t-193.5 -115q31 3 63 6q27 2 58 3.5t57 1.5h276v-228h-671v309q181 86 262 201.5t81 263.5q0 101 -27.5 180t-80 133t-129.5 82.5t-175 28.5q-99 0 -175.5 -28.5
t-129.5 -82.5t-80.5 -133t-27.5 -180q0 -148 81.5 -263.5t262.5 -201.5v-309h-667v228h274q26 0 57 -1.5t58 -3.5q32 -3 62 -6q-112 51 -192.5 115t-131.5 140.5t-75 165.5t-24 191q0 141 49 252.5t141 189t223.5 118.5t296.5 41z"" />
    <glyph glyph-name=""Iotadieresis"" unicode=""&#x3aa;"" horiz-adv-x=""569"" 
d=""M137 0v1409h295v-1409h-295zM413 1530v219h197v-219h-197zM-41 1530v219h194v-219h-194z"" />
    <glyph glyph-name=""Upsilondieresis"" unicode=""&#x3ab;"" horiz-adv-x=""1366"" 
d=""M831 578v-578h-294v578l-502 831h309l338 -596l342 596h309zM807 1530v219h197v-219h-197zM353 1530v219h194v-219h-194z"" />
    <glyph glyph-name=""alphatonos"" unicode=""&#x3ac;"" horiz-adv-x=""1259"" 
d=""M860 237q-26 -56 -58.5 -103t-75 -81.5t-98 -53.5t-127.5 -19q-212 0 -316.5 137.5t-104.5 418.5q0 284 113.5 425t333.5 141q73 0 131.5 -19.5t104 -54t78.5 -81t54 -100.5h3q11 55 31 118.5t44 116.5h265q-26 -47 -53 -113.5t-51 -138.5t-41.5 -144t-23.5 -130
q8 -77 21 -152.5t31 -146t39 -135.5t45 -122h-270q-13 32 -24.5 65t-20.5 64.5t-15.5 59t-10.5 48.5h-4zM375 539q0 -97 10 -166t32 -113.5t56.5 -65.5t82.5 -21q39 0 77 22.5t69.5 68.5t55 115.5t33.5 162.5q-9 74 -26.5 140.5t-45 116.5t-66 79.5t-89.5 29.5
q-48 0 -84 -20t-59 -64t-34.5 -114t-11.5 -171zM519 1183v33l69 292h257v-37l-221 -288h-105z"" />
    <glyph glyph-name=""epsilontonos"" unicode=""&#x3ad;"" horiz-adv-x=""924"" 
d=""M526 168q75 0 143.5 38.5t126.5 98.5l143 -140q-33 -34 -71.5 -67t-90 -59t-120 -42.5t-160.5 -16.5q-107 0 -186 23.5t-131 65.5t-77.5 100t-25.5 128q0 57 21 103.5t59.5 79.5t91.5 53t116 25v2q-61 6 -108.5 27t-80 54t-49.5 76.5t-17 94.5q0 63 28 116t82 91.5
t132.5 60.5t180.5 22q70 0 127 -9.5t104 -29.5t86 -52.5t73 -77.5l-162 -123q-42 57 -92.5 85t-119.5 28q-84 0 -128 -32.5t-44 -89.5q0 -48 25.5 -77.5t69.5 -45.5t104 -21t129 -5v-177q-66 0 -127.5 -3.5t-108.5 -19t-75 -48t-28 -90.5q0 -72 42.5 -109t117.5 -37z
M423 1183v33l69 292h257v-37l-221 -288h-105z"" />
    <glyph glyph-name=""etatonos"" unicode=""&#x3ae;"" horiz-adv-x=""1251"" 
d=""M845 -424v1053q0 75 -9.5 125.5t-31.5 81t-57.5 43.5t-87.5 13q-53 0 -96.5 -20.5t-74 -60.5t-47 -97.5t-16.5 -132.5v-581h-282v851q0 68 -11 128.5t-25 102.5h269q9 -21 16 -45t12 -48.5t7.5 -48t2.5 -43.5h3q27 47 59 85t74 64.5t96 41t126 14.5q93 0 159.5 -22
t109 -68t63 -118t20.5 -173v-1145h-279zM568 1183v33l69 292h257v-37l-221 -288h-105z"" />
    <glyph glyph-name=""iotatonos"" unicode=""&#x3af;"" horiz-adv-x=""569"" 
d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h282v-855q0 -32 6 -64t16.5 -62t25 -55.5t32.5 -45.5h-300zM176 1183v33l69 292h257v-37l-221 -288h-105z"" />
    <glyph glyph-name=""upsilondieresistonos"" unicode=""&#x3b0;"" horiz-adv-x=""1192"" 
d=""M1108 571q0 -136 -29.5 -245.5t-92 -186.5t-159.5 -118t-233 -41q-240 0 -353.5 110.5t-113.5 342.5v649h281v-622q0 -136 47.5 -204.5t155.5 -68.5q59 0 100 23t67 73.5t37.5 129.5t11.5 190q0 63 -11.5 132t-29.5 133.5t-40 120.5t-43 93h286q20 -40 41 -96.5
t38.5 -123.5t28.5 -141.5t11 -149.5zM489 1190v33l59 398h237v-37l-181 -394h-115zM238 1231v222h200v-222h-200zM770 1231v222h200v-222h-200z"" />
    <glyph glyph-name=""alpha"" unicode=""&#x3b1;"" horiz-adv-x=""1259"" 
d=""M860 237q-26 -56 -58.5 -103t-75 -81.5t-98 -53.5t-127.5 -19q-212 0 -316.5 137.5t-104.5 418.5q0 284 113.5 425t333.5 141q73 0 131.5 -19.5t104 -54t78.5 -81t54 -100.5h3q11 55 31 118.5t44 116.5h265q-26 -47 -53 -113.5t-51 -138.5t-41.5 -144t-23.5 -130
q8 -77 21 -152.5t31 -146t39 -135.5t45 -122h-270q-13 32 -24.5 65t-20.5 64.5t-15.5 59t-10.5 48.5h-4zM375 539q0 -97 10 -166t32 -113.5t56.5 -65.5t82.5 -21q39 0 77 22.5t69.5 68.5t55 115.5t33.5 162.5q-9 74 -26.5 140.5t-45 116.5t-66 79.5t-89.5 29.5
q-48 0 -84 -20t-59 -64t-34.5 -114t-11.5 -171z"" />
    <glyph glyph-name=""beta"" unicode=""&#x3b2;"" horiz-adv-x=""1250"" 
d=""M1181 405q0 -88 -26 -165.5t-81.5 -135.5t-141 -91t-204.5 -33q-101 0 -174.5 27.5t-128.5 66.5h-9q5 -57 6.5 -103t1.5 -99v-297h-282v1452q0 237 124.5 347t371.5 110q108 0 191 -23.5t139.5 -68.5t85 -110t28.5 -147q0 -73 -17.5 -128.5t-48 -96.5t-71 -69t-86.5 -46
q57 -11 114.5 -38.5t103.5 -74t75 -115t29 -162.5zM424 255q22 -17 50.5 -32t61 -26.5t67.5 -18t69 -6.5q58 0 102 17.5t73.5 50t44.5 78t15 101.5t-18 103t-58 81t-103 53.5t-152 19.5v198q127 22 183.5 79t56.5 156q0 36 -10.5 67.5t-32.5 55t-55.5 36.5t-80.5 13
q-54 0 -94 -15.5t-66.5 -50t-39.5 -90t-13 -134.5v-736z"" />
    <glyph glyph-name=""gamma"" unicode=""&#x3b3;"" 
d=""M8 1082h298l212 -640q3 -9 11.5 -40t17.5 -69.5t16.5 -78t8.5 -66.5q4 31 12 67.5t17 72t18 67t16 52.5l201 635h295l-395 -1028q-21 -55 -39.5 -110t-34 -113.5t-28 -121.5t-21.5 -133h-290q20 134 46.5 240.5t54.5 194.5z"" />
    <glyph glyph-name=""delta"" unicode=""&#x3b4;"" horiz-adv-x=""1242"" 
d=""M866 487q0 69 -16 127.5t-43.5 109.5t-63.5 95t-76 84q-67 -24 -120.5 -62t-91.5 -90.5t-58.5 -119.5t-20.5 -150q0 -66 14 -122t43 -96.5t73.5 -63.5t105.5 -23q70 0 118.5 23.5t78.5 64.5t43.5 98.5t13.5 124.5zM734 1294q-13 0 -32.5 1t-41 2t-41 2t-32.5 2l323 -293
q58 -53 104 -110t77.5 -121t48 -137t16.5 -157q0 -108 -35.5 -200.5t-104.5 -159.5t-169.5 -105t-229.5 -38q-127 0 -226 34.5t-166.5 99t-103 157.5t-35.5 210q0 110 36.5 196t100 152t148 113.5t180.5 80.5l-312 314v147h853v-190h-358z"" />
    <glyph glyph-name=""epsilon"" unicode=""&#x3b5;"" horiz-adv-x=""972"" 
d=""M526 168q75 0 143.5 38.5t126.5 98.5l143 -140q-33 -34 -71.5 -67t-90 -59t-120 -42.5t-160.5 -16.5q-107 0 -186 23.5t-131 65.5t-77.5 100t-25.5 128q0 57 21 103.5t59.5 79.5t91.5 53t116 25v2q-61 6 -108.5 27t-80 54t-49.5 76.5t-17 94.5q0 63 28 116t82 91.5
t132.5 60.5t180.5 22q70 0 127 -9.5t104 -29.5t86 -52.5t73 -77.5l-162 -123q-42 57 -92.5 85t-119.5 28q-84 0 -128 -32.5t-44 -89.5q0 -48 25.5 -77.5t69.5 -45.5t104 -21t129 -5v-177q-66 0 -127.5 -3.5t-108.5 -19t-75 -48t-28 -90.5q0 -72 42.5 -109t117.5 -37z"" />
    <glyph glyph-name=""zeta"" unicode=""&#x3b6;"" horiz-adv-x=""943"" 
d=""M324 422q0 -56 20 -90.5t55.5 -56t84 -36t104.5 -30.5q54 -15 111.5 -34t104.5 -52.5t77 -87t30 -137.5q0 -42 -10 -85.5t-24.5 -84t-30.5 -74.5t-29 -55l-183 74q9 15 18.5 33.5t17.5 38.5t13.5 41t5.5 42q0 37 -17.5 62.5t-50 43.5t-78.5 31.5t-104 28.5
q-64 14 -130.5 33.5t-120.5 56.5t-88 98t-34 157q0 80 23 163.5t63 168t93.5 168t115 163.5t127 154t129.5 139v4q-12 -1 -29 -1.5t-35 -1t-35 -1t-28 -0.5h-315v189h701v-190q-62 -61 -127.5 -131t-127 -144.5t-115.5 -152t-94.5 -153.5t-64 -150t-23.5 -141z"" />
    <glyph glyph-name=""eta"" unicode=""&#x3b7;"" horiz-adv-x=""1251"" 
d=""M845 -424v1053q0 75 -9.5 125.5t-31.5 81t-57.5 43.5t-87.5 13q-53 0 -96.5 -20.5t-74 -60.5t-47 -97.5t-16.5 -132.5v-581h-282v851q0 68 -11 128.5t-25 102.5h269q9 -21 16 -45t12 -48.5t7.5 -48t2.5 -43.5h3q27 47 59 85t74 64.5t96 41t126 14.5q93 0 159.5 -22
t109 -68t63 -118t20.5 -173v-1145h-279z"" />
    <glyph glyph-name=""theta"" unicode=""&#x3b8;"" horiz-adv-x=""1107"" 
d=""M1017 733q0 -381 -120 -567t-348 -186q-108 0 -193.5 46t-144.5 139t-90 234.5t-31 333.5q0 374 116.5 562t348.5 188q121 0 208.5 -46.5t143.5 -140.5t83 -234.5t27 -328.5zM550 162q39 0 73 23.5t60 79t42 148.5t18 231h-377q2 -138 18 -230.5t41.5 -148.5t58 -79.5
t66.5 -23.5zM557 1300q-39 0 -73 -22.5t-59.5 -76.5t-41.5 -143.5t-18 -223.5h378q-2 134 -17.5 223.5t-40 143.5t-57.5 76.5t-71 22.5z"" />
    <glyph glyph-name=""iota"" unicode=""&#x3b9;"" horiz-adv-x=""569"" 
d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h282v-855q0 -32 6 -64t16.5 -62t25 -55.5t32.5 -45.5h-300z"" />
    <glyph glyph-name=""kappa"" unicode=""&#x3ba;"" horiz-adv-x=""1142"" 
d=""M842 0l-291 455l-127 -106v-349h-281v1082h281v-494l397 494h291l-380 -462l409 -620h-299z"" />
    <glyph glyph-name=""lambda"" unicode=""&#x3bb;"" 
d=""M1108 0h-294l-136 462q-4 13 -10.5 35.5t-14.5 51t-17 59.5t-16 60t-12.5 53t-7.5 38q-7 -27 -20.5 -70.5t-29.5 -91t-32.5 -93t-29.5 -75.5l-182 -429h-297l474 1006l-26 73q-27 69 -49 117t-43.5 78.5t-45.5 44t-56 13.5q-20 0 -47 -5.5t-46 -13.5l-48 194
q31 11 80.5 20.5t106.5 9.5q81 0 139 -21.5t102.5 -67.5t80 -117t69.5 -169z"" />
    <glyph glyph-name=""mu"" unicode=""&#x3bc;"" horiz-adv-x=""1253"" 
d=""M849 0q-1 12 -3.5 34t-4.5 48.5t-3.5 53.5t-1.5 48h-3q-38 -99 -99 -151.5t-147 -52.5q-52 0 -95.5 24t-66.5 66h-4q3 -32 3.5 -59.5t0.5 -55.5v-371h-281v1498h281v-605q0 -64 9.5 -116t31 -89.5t56.5 -58t87 -20.5q50 0 90 22.5t69 63t44.5 98t15.5 127.5v578h281v-840
q0 -34 0.5 -70.5t2 -70t3 -60.5t2.5 -41h-268z"" />
    <glyph glyph-name=""nu"" unicode=""&#x3bd;"" 
d=""M1047 846q0 -99 -31.5 -208t-85.5 -219.5t-124.5 -217.5t-148.5 -201h-267l-390 1082h297l261 -843q56 80 95.5 154t64.5 146.5t36.5 146t11.5 151.5q0 81 -14.5 140.5t-34.5 104.5h280q23 -45 36.5 -101.5t13.5 -134.5z"" />
    <glyph glyph-name=""xi"" unicode=""&#x3be;"" horiz-adv-x=""912"" 
d=""M324 420q0 -53 20 -87t55.5 -56.5t84 -37.5t104.5 -30q54 -15 111.5 -34t104.5 -52.5t77 -87t30 -137.5q0 -42 -10 -85.5t-24.5 -84t-30.5 -74.5t-29 -55l-183 74q9 15 18.5 33.5t17.5 38.5t13.5 41t5.5 42q0 37 -17.5 62.5t-50 43.5t-78.5 31.5t-104 28.5
q-64 14 -130.5 33.5t-120.5 56.5t-88 98t-34 157q0 76 26 152t81.5 140.5t143.5 112t212 66.5v2q-67 5 -126.5 22t-103 47t-69 73t-25.5 98q0 57 25 98t64.5 70t88 46.5t95.5 26.5v8q-12 -1 -46 -2t-74 -2.5t-78 -2.5t-56 -1h-76v191h654v-185q-69 -7 -134 -21t-115.5 -38
t-81 -61t-30.5 -91q0 -51 26.5 -83.5t71 -52.5t102 -30t118.5 -15v-191q-100 -12 -180.5 -30t-137 -50.5t-87 -84t-30.5 -131.5z"" />
    <glyph glyph-name=""omicron"" unicode=""&#x3bf;"" horiz-adv-x=""1251"" 
d=""M1171 542q0 -124 -34.5 -227t-103.5 -177.5t-172 -116t-240 -41.5q-132 0 -233 41t-169.5 115t-103.5 177.5t-35 228.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q146 0 249 -42t168.5 -116.5t96 -177t30.5 -224.5zM877 542q0 193 -63 280t-183 87q-124 0 -190 -88
t-66 -279q0 -97 17.5 -167t49.5 -115t77 -66.5t99 -21.5q62 0 110.5 21.5t81.5 66.5t50 115t17 167z"" />
    <glyph glyph-name=""pi"" unicode=""&#x3c0;"" horiz-adv-x=""1568"" 
d=""M1240 892v-589q0 -72 28 -99.5t76 -27.5q26 0 52 4t46 8l20 -184q-44 -10 -101.5 -17t-121.5 -7q-141 0 -209.5 74.5t-68.5 210.5v627h-363v-124q0 -130 -6.5 -239t-18.5 -202t-28 -173t-35 -154h-287q19 76 37 157.5t32.5 173.5t23 198t8.5 231v132q-97 0 -171.5 -8.5
t-110.5 -28.5v198q15 7 37 12.5t46.5 9t50 5.5t48.5 2h1289v-190h-273z"" />
    <glyph glyph-name=""rho"" unicode=""&#x3c1;"" horiz-adv-x=""1267"" 
d=""M1187 516q0 -118 -32 -216.5t-91.5 -169.5t-144.5 -110.5t-192 -39.5q-55 0 -100.5 10.5t-84 29t-69.5 43.5t-57 54h-4q2 -30 3 -57.5t1 -59.5v-425h-295v1006q0 119 34.5 215.5t100.5 164.5t161.5 105t216.5 37q114 0 214.5 -39.5t175.5 -114.5t119 -184t44 -249z
M893 526q0 90 -18.5 161t-52.5 120.5t-81.5 75.5t-104.5 26q-59 0 -100.5 -23t-68 -66.5t-39 -106t-12.5 -141.5v-272q52 -57 118 -91.5t143 -34.5q53 0 93.5 25t67.5 70.5t41 110.5t14 146z"" />
    <glyph glyph-name=""sigma1"" unicode=""&#x3c2;"" horiz-adv-x=""1065"" 
d=""M340 445q0 -58 22 -95t60.5 -62.5t91.5 -44t115 -39.5q40 -12 81.5 -24t81 -28t74.5 -37.5t61 -53.5t41.5 -76t15.5 -105q0 -39 -11 -80t-27.5 -79t-35 -70t-32.5 -52l-178 74q9 15 18.5 33t17.5 38t13.5 41t5.5 42q0 37 -21 62t-59 43t-89.5 31.5t-113.5 28.5
q-45 12 -91.5 26t-90.5 35.5t-82 52t-67 75t-45.5 105.5t-16.5 142q0 59 11 131.5t36 147.5t66 146.5t101.5 127t141.5 89t186 33.5q115 0 203.5 -37.5t147.5 -103.5l-139 -149q-18 19 -39 37t-46 32t-54 22.5t-63 8.5q-55 0 -97.5 -24t-75 -62.5t-55 -88.5t-36.5 -102
t-20.5 -102t-6.5 -89z"" />
    <glyph glyph-name=""sigma"" unicode=""&#x3c3;"" horiz-adv-x=""1401"" 
d=""M1170 458q0 -105 -34 -193t-101.5 -151t-169 -98.5t-237.5 -35.5t-238.5 37t-171.5 106.5t-103.5 170.5t-34.5 230q0 144 47.5 249t132 174t202 102t257.5 33h642v-190h-195q-10 0 -29.5 0.5t-43 1.5t-48 2t-43.5 2v-4q31 -40 61 -87t54 -101t38.5 -116t14.5 -132z
M876 492q0 63 -8.5 120t-22.5 107.5t-32.5 93.5t-38.5 79h-74q-68 0 -127 -22.5t-103 -68t-69.5 -114.5t-25.5 -163q0 -177 62.5 -264.5t183.5 -87.5q65 0 112.5 22t79.5 63.5t47.5 100.5t15.5 134z"" />
    <glyph glyph-name=""tau"" unicode=""&#x3c4;"" horiz-adv-x=""914"" 
d=""M270 892q-39 0 -78.5 -3t-74 -8.5t-61 -12t-38.5 -13.5v198q12 6 33.5 11.5t47 9.5t52.5 6t50 2h679v-190h-305v-580q0 -40 8 -66t22.5 -41.5t36 -21.5t48.5 -6q17 0 41 2.5t40 5.5l24 -178q-17 -5 -42 -10t-52.5 -9t-55 -6.5t-49.5 -2.5q-155 0 -227 70t-72 202v641h-27
z"" />
    <glyph glyph-name=""upsilon"" unicode=""&#x3c5;"" horiz-adv-x=""1192"" 
d=""M1108 571q0 -136 -29.5 -245.5t-92 -186.5t-159.5 -118t-233 -41q-240 0 -353.5 110.5t-113.5 342.5v649h281v-622q0 -136 47.5 -204.5t155.5 -68.5q59 0 100 23t67 73.5t37.5 129.5t11.5 190q0 63 -11.5 132t-29.5 133.5t-40 120.5t-43 93h286q20 -40 41 -96.5
t38.5 -123.5t28.5 -141.5t11 -149.5z"" />
    <glyph glyph-name=""phi"" unicode=""&#x3c6;"" horiz-adv-x=""1465"" 
d=""M1386 565q0 -151 -40.5 -258.5t-113 -177.5t-171.5 -105.5t-216 -41.5v-407h-238v405q-121 5 -218.5 41t-166 105t-105.5 173t-37 245q0 133 30 231t87 165.5t140.5 107.5t191.5 58l21 -179q-51 -13 -88 -48t-61 -86.5t-35 -115t-11 -133.5q0 -93 17.5 -162t50 -115.5
t79.5 -71t105 -28.5v535q0 198 87 300t273 102q95 0 172.5 -38t132.5 -108.5t84.5 -170t29.5 -222.5zM1111 567q0 191 -37.5 277t-105.5 86q-57 0 -90 -54.5t-33 -176.5v-533q128 6 197 106t69 295z"" />
    <glyph glyph-name=""chi"" unicode=""&#x3c7;"" horiz-adv-x=""1179"" 
d=""M233 1104q60 0 105 -21t84.5 -68t78 -122t85.5 -183l20 -46q2 -5 6.5 -19.5t7.5 -26.5q5 14 13 33.5t16.5 39.5t16.5 38t13 28l155 325h297l-375 -690l413 -816h-300l-195 432q-7 15 -17.5 40t-21 52.5t-19.5 53.5t-14 44q-5 -17 -15 -43t-21 -52.5t-21.5 -51
t-17.5 -38.5l-214 -437h-300l452 829l-119 243q-37 76 -64.5 125t-50.5 77t-44.5 38.5t-48.5 10.5q-41 0 -81 -16l-40 191q31 11 85.5 20.5t130.5 9.5z"" />
    <glyph glyph-name=""psi"" unicode=""&#x3c8;"" horiz-adv-x=""1543"" 
d=""M901 176q66 1 111.5 15.5t74 49t41 91.5t12.5 142v608h275v-624q0 -122 -27.5 -211.5t-89 -148t-158.5 -88t-237 -30.5v-405h-259v405q-136 1 -233.5 30.5t-160 88t-92 148t-29.5 211.5v624h275v-607q0 -85 14.5 -141.5t44 -91t75 -49t106.5 -16.5v1163h257v-1164z"" />
    <glyph glyph-name=""omega"" unicode=""&#x3c9;"" horiz-adv-x=""1730"" 
d=""M995 474q0 -142 47 -220t132 -78q54 0 90.5 24t58.5 69t31 108.5t9 141.5q0 72 -14.5 137.5t-45 118.5t-78.5 89.5t-116 49.5l23 189q121 -18 217 -64.5t162.5 -120t102 -174t35.5 -227.5q0 -128 -29 -228t-84.5 -168.5t-136.5 -104.5t-185 -36q-74 0 -131 16t-99 46
t-71 74.5t-46 101.5h-4q-17 -57 -46 -101.5t-71 -74.5t-99 -46t-131 -16q-104 0 -185 36t-136.5 104.5t-84.5 168.5t-29 228q0 127 35.5 227.5t102 174t162.5 120t216 64.5l23 -187q-68 -13 -116 -50t-79 -89.5t-45 -118t-14 -137.5q0 -78 9 -141.5t31 -108.5t58 -69.5
t90 -24.5q86 0 134.5 78t48.5 219v187h258v-187z"" />
    <glyph glyph-name=""iotadieresis"" unicode=""&#x3ca;"" horiz-adv-x=""569"" 
d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h282v-855q0 -32 6 -64t16.5 -62t25 -55.5t32.5 -45.5h-300zM395 1199v219h217v-219h-217zM-39 1199v219h214v-219h-214z"" />
    <glyph glyph-name=""upsilondieresis"" unicode=""&#x3cb;"" horiz-adv-x=""1192"" 
d=""M1108 571q0 -136 -29.5 -245.5t-92 -186.5t-159.5 -118t-233 -41q-240 0 -353.5 110.5t-113.5 342.5v649h281v-622q0 -136 47.5 -204.5t155.5 -68.5q59 0 100 23t67 73.5t37.5 129.5t11.5 190q0 63 -11.5 132t-29.5 133.5t-40 120.5t-43 93h286q20 -40 41 -96.5
t38.5 -123.5t28.5 -141.5t11 -149.5zM692 1199v219h217v-219h-217zM258 1199v219h214v-219h-214z"" />
    <glyph glyph-name=""omicrontonos"" unicode=""&#x3cc;"" horiz-adv-x=""1251"" 
d=""M1171 542q0 -124 -34.5 -227t-103.5 -177.5t-172 -116t-240 -41.5q-132 0 -233 41t-169.5 115t-103.5 177.5t-35 228.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q146 0 249 -42t168.5 -116.5t96 -177t30.5 -224.5zM877 542q0 193 -63 280t-183 87q-124 0 -190 -88
t-66 -279q0 -97 17.5 -167t49.5 -115t77 -66.5t99 -21.5q62 0 110.5 21.5t81.5 66.5t50 115t17 167zM527 1183v33l69 292h257v-37l-221 -288h-105z"" />
    <glyph glyph-name=""upsilontonos"" unicode=""&#x3cd;"" horiz-adv-x=""1192"" 
d=""M1108 571q0 -136 -29.5 -245.5t-92 -186.5t-159.5 -118t-233 -41q-240 0 -353.5 110.5t-113.5 342.5v649h281v-622q0 -136 47.5 -204.5t155.5 -68.5q59 0 100 23t67 73.5t37.5 129.5t11.5 190q0 63 -11.5 132t-29.5 133.5t-40 120.5t-43 93h286q20 -40 41 -96.5
t38.5 -123.5t28.5 -141.5t11 -149.5zM465 1183v33l69 292h257v-37l-221 -288h-105z"" />
    <glyph glyph-name=""omegatonos"" unicode=""&#x3ce;"" horiz-adv-x=""1730"" 
d=""M995 474q0 -142 47 -220t132 -78q54 0 90.5 24t58.5 69t31 108.5t9 141.5q0 72 -14.5 137.5t-45 118.5t-78.5 89.5t-116 49.5l23 189q121 -18 217 -64.5t162.5 -120t102 -174t35.5 -227.5q0 -128 -29 -228t-84.5 -168.5t-136.5 -104.5t-185 -36q-74 0 -131 16t-99 46
t-71 74.5t-46 101.5h-4q-17 -57 -46 -101.5t-71 -74.5t-99 -46t-131 -16q-104 0 -185 36t-136.5 104.5t-84.5 168.5t-29 228q0 127 35.5 227.5t102 174t162.5 120t216 64.5l23 -187q-68 -13 -116 -50t-79 -89.5t-45 -118t-14 -137.5q0 -78 9 -141.5t31 -108.5t58 -69.5
t90 -24.5q86 0 134.5 78t48.5 219v187h258v-187zM788 1183v33l69 292h257v-37l-221 -288h-105z"" />
    <glyph glyph-name=""uni0400"" unicode=""&#x400;"" horiz-adv-x=""1366"" 
d=""M137 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149zM736 1530l-340 242v43h258l251 -254v-31h-169z"" />
    <glyph glyph-name=""afii10023"" unicode=""&#x401;"" horiz-adv-x=""1370"" 
d=""M137 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149zM846 1530v219h197v-219h-197zM392 1530v219h194v-219h-194z"" />
    <glyph glyph-name=""afii10051"" unicode=""&#x402;"" horiz-adv-x=""1813"" 
d=""M773 1181v-336q36 15 87.5 33t114.5 33.5t134.5 26t146.5 10.5q117 0 202.5 -27t141 -82t82 -139.5t26.5 -199.5v-54q0 -108 -21 -194t-72 -146.5t-135.5 -93t-212.5 -32.5q-74 0 -133 11.5t-106.5 34t-85.5 56t-70 76.5l202 171q17 -22 35.5 -43t40.5 -37.5t48 -26.5
t57 -10q54 0 87.5 16.5t51.5 48t24 78t6 106.5v9q0 67 -12 115.5t-42 80t-80.5 46.5t-128.5 15q-54 0 -109 -6t-106 -16t-95.5 -21.5t-77.5 -22.5v-661h-295v1181h-455v228h1206v-228h-456z"" />
    <glyph glyph-name=""afii10052"" unicode=""&#x403;"" horiz-adv-x=""1161"" 
d=""M456 1530v31l252 254h258v-43l-340 -242h-170zM1121 1409v-228h-689v-1180h-295v1408h984z"" />
    <glyph glyph-name=""afii10053"" unicode=""&#x404;"" horiz-adv-x=""1457"" 
d=""M787 212q81 0 141 23.5t103 61.5t72 86t48 97l252 -97q-31 -76 -80 -149t-123 -129t-176 -90.5t-240 -34.5q-180 0 -312 54.5t-218 152t-128 231.5t-42 293q0 165 41.5 298t126.5 226.5t214.5 144t304.5 50.5q136 0 238 -29t176.5 -81.5t123 -124t76.5 -157.5l-255 -71
q-14 45 -42.5 86.5t-72 73.5t-102 51.5t-133.5 19.5q-91 0 -162 -25t-120.5 -72.5t-77.5 -116t-33 -155.5h546v-228h-547q6 -89 34 -161t78 -122.5t122.5 -78t166.5 -27.5z"" />
    <glyph glyph-name=""afii10054"" unicode=""&#x405;"" horiz-adv-x=""1366"" 
d=""M1286 406q0 -96 -35 -174.5t-108.5 -134.5t-188 -86.5t-272.5 -30.5q-140 0 -247 25t-183.5 74t-124 121.5t-68.5 166.5l285 47q12 -47 35 -86t63.5 -67.5t101 -44t146.5 -15.5q150 0 229.5 45.5t79.5 142.5q0 58 -32 95t-85 61t-122 40t-144 31q-60 14 -120 29
t-114.5 36t-101.5 50t-81.5 71.5t-54 99.5t-19.5 134q0 105 42 180t116.5 122.5t177.5 69.5t225 22q138 0 236.5 -21.5t165 -65.5t105 -110.5t56.5 -155.5l-286 -39q-22 91 -89.5 137t-193.5 46q-78 0 -129.5 -13.5t-82 -36.5t-43.5 -53.5t-13 -64.5q0 -52 25 -85.5t70 -56
t107.5 -38t137.5 -31.5q66 -14 131 -29.5t124 -36.5t110 -51t88.5 -73.5t59 -103.5t21.5 -142z"" />
    <glyph glyph-name=""afii10055"" unicode=""&#x406;"" horiz-adv-x=""569"" 
d=""M137 0v1409h295v-1409h-295z"" />
    <glyph glyph-name=""afii10056"" unicode=""&#x407;"" horiz-adv-x=""565"" 
d=""M137 0v1409h295v-1409h-295zM411 1530v219h197v-219h-197zM-43 1530v219h194v-219h-194z"" />
    <glyph glyph-name=""afii10057"" unicode=""&#x408;"" 
d=""M524 -20q-106 0 -189 22t-144 70t-100.5 124.5t-59.5 185.5l293 43q10 -59 28 -99.5t43.5 -66t58.5 -37t72 -11.5q88 0 133.5 59t45.5 169v739h-281v231h575v-963q0 -107 -31 -193.5t-91.5 -147t-149 -93t-203.5 -32.5z"" />
    <glyph glyph-name=""afii10058"" unicode=""&#x409;"" horiz-adv-x=""2240"" 
d=""M2168 431q0 -90 -32.5 -169t-98 -137t-163 -91.5t-227.5 -33.5h-691v1165h-347l-49 -348q-23 -161 -45.5 -285.5t-49 -217t-59 -155.5t-75 -102t-97.5 -56t-127 -17q-27 0 -56 4.5t-43 12.5v247q8 -4 21.5 -5.5t21.5 -1.5q23 0 43 10.5t38.5 38.5t36.5 77t35.5 126.5
t36.5 186.5t40 256l67 473h903v-561h428q123 0 215 -30t152.5 -84.5t91 -131.5t30.5 -171zM1870 427q0 93 -69.5 143.5t-207.5 50.5h-342v-391h348q140 0 205.5 50.5t65.5 146.5z"" />
    <glyph glyph-name=""afii10059"" unicode=""&#x40a;"" horiz-adv-x=""2176"" 
d=""M2102 431q0 -90 -32.5 -169t-98 -137t-163 -91.5t-227.5 -33.5h-602v604h-547v-604h-295v1409h295v-561h547v561h295v-561h339q123 0 215 -30t152.5 -84.5t91 -131.5t30.5 -171zM1804 427q0 93 -69.5 143.5t-207.5 50.5h-253v-391h259q140 0 205.5 50.5t65.5 146.5z"" />
    <glyph glyph-name=""afii10060"" unicode=""&#x40b;"" horiz-adv-x=""1792"" 
d=""M773 1181v-319q37 14 82.5 29t97.5 27t111 19.5t123 7.5q235 0 353.5 -113t118.5 -352v-480h-284v449q0 72 -15 124.5t-49 86t-87.5 50t-131.5 16.5q-88 0 -170.5 -16t-148.5 -37v-673h-295v1181h-455v228h1206v-228h-456z"" />
    <glyph glyph-name=""afii10061"" unicode=""&#x40c;"" horiz-adv-x=""1250"" 
d=""M137 1409h295v-599q27 0 53 14t57 46t69 84.5t87 130.5l206 324h300l-265 -405q-23 -35 -48 -71t-48 -67t-43 -54t-32 -32l485 -780h-321l-374 640q-11 -7 -26.5 -13t-33 -11t-35 -8t-32.5 -3v-605h-294v1409zM515 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""uni040D"" unicode=""&#x40d;"" horiz-adv-x=""1479"" 
d=""M738 1495l-340 276v43h258l251 -288v-31h-169zM995 0l-614 1085q5 -44 9 -88q4 -38 6.5 -82t2.5 -84v-831h-262v1409h337l623 -1094q-5 42 -9 88q-4 39 -6.5 88t-2.5 99v819h262v-1409h-346z"" />
    <glyph glyph-name=""afii10062"" unicode=""&#x40e;"" horiz-adv-x=""1274"" 
d=""M760 318q-40 -83 -79.5 -146t-88 -106t-111 -64.5t-148.5 -21.5q-31 0 -66.5 4t-69 12t-64 19t-53.5 25l82 246q38 -18 77 -30t83 -12q35 0 62.5 10t52 33t47.5 60.5t48 92.5l17 37l-556 932h307l388 -680l298 680h299zM627 1514q-82 0 -144 13t-106.5 36.5t-74 56
t-47 70t-25.5 79.5t-10 85h224q5 -103 52 -151t131 -48t131 48t52 151h224q-2 -43 -10 -85t-25.5 -79.5t-47 -70t-74 -56t-106.5 -36.5t-144 -13z"" />
    <glyph glyph-name=""afii10145"" unicode=""&#x40f;"" horiz-adv-x=""1472"" 
d=""M611 -408v408h-474v1409h295v-1165h617v1165h285v-1409h-473v-408h-250z"" />
    <glyph glyph-name=""afii10017"" unicode=""&#x410;"" horiz-adv-x=""1479"" 
d=""M1133 0l-125 360h-537l-125 -360h-295l514 1409h348l512 -1409h-292zM803 987q-12 35 -23.5 70.5t-20 65t-14 48.5t-6.5 21q-1 -3 -6 -22t-13.5 -48t-20 -64.5t-23.5 -70.5l-139 -405h405z"" />
    <glyph glyph-name=""afii10018"" unicode=""&#x411;"" horiz-adv-x=""1472"" 
d=""M1399 431q0 -90 -32.5 -169t-98 -137t-163 -91.5t-227.5 -33.5h-741v1409h1061v-227h-766v-334h478q123 0 215 -30t152.5 -84.5t91 -131.5t30.5 -171zM1101 427q0 93 -69.5 143.5t-207.5 50.5h-392v-391h398q140 0 205.5 50.5t65.5 146.5z"" />
    <glyph glyph-name=""afii10019"" unicode=""&#x412;"" horiz-adv-x=""1479"" 
d=""M1386 402q0 -107 -43 -183.5t-117.5 -125t-173.5 -71t-210 -22.5h-705v1409h645q125 0 222.5 -21.5t164.5 -65.5t101.5 -110.5t34.5 -156.5q0 -120 -66.5 -202.5t-202.5 -111.5q171 -20 260.5 -107.5t89.5 -231.5zM1008 1015q0 95 -60.5 135t-179.5 40h-336v-349h338
q125 0 181.5 43.5t56.5 130.5zM1090 425q0 56 -22 94t-60.5 61t-90 33t-111.5 10h-374v-404h385q58 0 108 9.5t86.5 33t57.5 63.5t21 100z"" />
    <glyph glyph-name=""afii10020"" unicode=""&#x413;"" horiz-adv-x=""1161"" 
d=""M1121 1409v-228h-689v-1180h-295v1408h984z"" />
    <glyph glyph-name=""afii10021"" unicode=""&#x414;"" horiz-adv-x=""1459"" 
d=""M1237 244h185v-652h-250v408h-904v-408h-250v652h156q34 62 66 142t59.5 173t50 195.5t37.5 209.5l61 445h789v-1165zM952 244v921h-262l-31 -234q-12 -85 -30 -180.5t-40.5 -187.5t-49.5 -175t-56 -144h469z"" />
    <glyph glyph-name=""afii10022"" unicode=""&#x415;"" horiz-adv-x=""1366"" 
d=""M137 0v1409h1108v-228h-813v-354h752v-228h-752v-371h854v-228h-1149z"" />
    <glyph glyph-name=""afii10024"" unicode=""&#x416;"" horiz-adv-x=""1851"" 
d=""M786 0v612q-15 0 -32.5 2t-34.5 5.5t-33 8.5t-27 12l-349 -640h-316l455 780q-12 9 -30.5 31.5t-40 53t-44.5 66t-45 71.5l-251 407h300l198 -324q48 -78 83 -131t63 -85t52 -45.5t51 -13.5v599h284v-599q27 0 51 13.5t52.5 45.5t63.5 85t83 131l198 324h300l-251 -407
q-22 -36 -45 -71.5t-44.5 -66t-40 -53t-30.5 -31.5l455 -780h-316l-349 640q-26 -13 -61.5 -20.5t-65.5 -7.5v-612h-283z"" />
    <glyph glyph-name=""afii10025"" unicode=""&#x417;"" horiz-adv-x=""1283"" 
d=""M638 -20q-126 0 -222.5 26t-167.5 75.5t-120.5 121.5t-81.5 165l264 93q20 -55 49 -101t68.5 -80t91.5 -53t119 -19q129 0 196 53.5t67 150.5q0 101 -79.5 145.5t-248.5 44.5h-59v227h59q151 0 223 48t72 148q0 91 -61.5 139t-169.5 48q-63 0 -110 -20t-81.5 -54t-58 -79
t-38.5 -94l-268 61q31 92 78 166t115 127t159 81.5t209 28.5q116 0 210 -26t161 -73.5t103.5 -115.5t36.5 -152q0 -69 -20 -124.5t-56.5 -97t-88.5 -70t-115 -44.5q67 -10 124.5 -34.5t100 -65t67 -97t24.5 -129.5q0 -93 -37 -170t-107.5 -132.5t-173 -86.5t-233.5 -31z"" />
    <glyph glyph-name=""afii10026"" unicode=""&#x418;"" horiz-adv-x=""1472"" 
d=""M136 0v1409h262v-819q0 -50 -1 -99t-3 -88q-2 -46 -4 -88l613 1094h332v-1409h-262v831q0 40 1 84t3 82l4 88l-609 -1085h-336z"" />
    <glyph glyph-name=""afii10027"" unicode=""&#x419;"" horiz-adv-x=""1472"" 
d=""M136 0v1409h262v-819q0 -50 -1 -99t-3 -88q-2 -46 -4 -88l613 1094h332v-1409h-262v831q0 40 1 84t3 82l4 88l-609 -1085h-336zM742 1514q-82 0 -144 13t-106.5 36.5t-74 56t-47 70t-25.5 79.5t-10 85h224q5 -103 52 -151t131 -48t131 48t52 151h224q-2 -43 -10 -85
t-25.5 -79.5t-47 -70t-74 -56t-106.5 -36.5t-144 -13z"" />
    <glyph glyph-name=""afii10028"" unicode=""&#x41a;"" horiz-adv-x=""1250"" 
d=""M137 1409h295v-599q27 0 53 14t57 46t69 84.5t87 130.5l206 324h300l-265 -405q-23 -35 -48 -71t-48 -67t-43 -54t-32 -32l485 -780h-321l-374 640q-11 -7 -26.5 -13t-33 -11t-35 -8t-32.5 -3v-605h-294v1409z"" />
    <glyph glyph-name=""afii10029"" unicode=""&#x41b;"" horiz-adv-x=""1437"" 
d=""M1016 1165h-407l-49 -348q-23 -161 -45.5 -285.5t-49 -217t-59 -155.5t-75 -102t-97.5 -56t-127 -17q-27 0 -56 4.5t-43 12.5v247q8 -4 21.5 -5.5t21.5 -1.5q23 0 43 10.5t38.5 38.5t36.5 77t35.5 126.5t36.5 186.5t40 256l67 473h952v-1409h-284v1165z"" />
    <glyph glyph-name=""afii10030"" unicode=""&#x41c;"" horiz-adv-x=""1706"" 
d=""M1307 0v854q0 51 1.5 105t3.5 99q3 53 5 103q-21 -79 -40 -150q-8 -30 -17 -62t-17.5 -62t-16.5 -56t-14 -45l-254 -786h-210l-254 786q-6 19 -13.5 45t-16 56t-17.5 62t-18 62q-20 71 -42 150q3 -58 6 -114q2 -48 4 -101t2 -92v-854h-262v1409h395l252 -788
q10 -31 21.5 -76t22.5 -87q12 -49 26 -102q14 52 27 100q6 21 12 43t12 43t12 40t11 34l248 793h393v-1409h-262z"" />
    <glyph glyph-name=""afii10031"" unicode=""&#x41d;"" horiz-adv-x=""1479"" 
d=""M1046 0v604h-614v-604h-295v1409h295v-561h614v561h295v-1409h-295z"" />
    <glyph glyph-name=""afii10032"" unicode=""&#x41e;"" horiz-adv-x=""1593"" 
d=""M1507 711q0 -165 -49 -300t-141 -231t-224.5 -148t-299.5 -52q-177 0 -309.5 54.5t-221.5 152t-133.5 231.5t-44.5 293q0 165 46.5 298t137 226.5t223 144t304.5 50.5t304.5 -51t223 -145t137.5 -226.5t47 -296.5zM1206 711q0 111 -26.5 200.5t-78.5 153.5t-128.5 98.5
t-177.5 34.5q-103 0 -180.5 -34.5t-129.5 -98.5t-78 -153.5t-26 -200.5q0 -110 26.5 -201.5t78.5 -157.5t129 -103t178 -37q108 0 186 37.5t128.5 104t74.5 158t24 199.5z"" />
    <glyph glyph-name=""afii10033"" unicode=""&#x41f;"" horiz-adv-x=""1472"" 
d=""M1050 0v1165h-619v-1165h-294v1409h1198v-1409h-285z"" />
    <glyph glyph-name=""afii10034"" unicode=""&#x420;"" horiz-adv-x=""1366"" 
d=""M1296 963q0 -91 -30.5 -175.5t-93.5 -149.5t-160 -103.5t-230 -38.5h-350v-496h-295v1409h633q135 0 234 -32.5t164 -91.5t96.5 -141t31.5 -181zM999 958q0 109 -65.5 165.5t-196.5 56.5h-305v-457h313q66 0 113.5 17t79 48t46.5 74.5t15 95.5z"" />
    <glyph glyph-name=""afii10035"" unicode=""&#x421;"" horiz-adv-x=""1479"" 
d=""M795 212q83 0 143.5 23.5t105 61.5t74 86t48.5 97l257 -97q-31 -76 -81 -149t-125 -129t-178.5 -90.5t-243.5 -34.5q-183 0 -317 54.5t-221.5 152t-130 231.5t-42.5 293q0 165 42.5 298t128.5 226.5t217.5 144t309.5 50.5q138 0 241.5 -29t179 -81.5t125 -124
t77.5 -157.5l-260 -71q-14 45 -43 86.5t-73.5 73.5t-104.5 51.5t-136 19.5q-107 0 -184 -34.5t-126.5 -98.5t-73 -153.5t-23.5 -200.5q0 -110 23.5 -201.5t73.5 -157.5t128.5 -103t188.5 -37z"" />
    <glyph glyph-name=""afii10036"" unicode=""&#x422;"" horiz-adv-x=""1251"" 
d=""M773 1181v-1181h-295v1181h-455v228h1206v-228h-456z"" />
    <glyph glyph-name=""afii10037"" unicode=""&#x423;"" horiz-adv-x=""1274"" 
d=""M768 318q-40 -83 -79.5 -146t-88 -106t-111 -64.5t-148.5 -21.5q-31 0 -66.5 4t-69 12t-64 19t-53.5 25l82 246q38 -18 77 -30t83 -12q35 0 62.5 10t52 33t47.5 60.5t48 92.5l17 37l-556 932h307l388 -680l298 680h299z"" />
    <glyph glyph-name=""afii10038"" unicode=""&#x424;"" horiz-adv-x=""1748"" 
d=""M1380 730q0 152 -79 237t-244 85h-44v-655h51q84 0 143.5 25t98 69.5t56.5 105.5t18 133zM735 -11v199h-79q-148 0 -258 44t-183 119t-108.5 174t-35.5 209q0 119 37 216.5t111.5 166.5t186.5 106.5t262 37.5h67v158h278v-158h67q150 0 262 -37.5t186.5 -106.5
t111.5 -166.5t37 -216.5q0 -110 -35.5 -209t-108.5 -174t-182.5 -119t-258.5 -44h-79v-199h-278zM368 730q0 -72 18 -133t56.5 -105.5t98 -69.5t143.5 -25h51v655h-44q-165 0 -244 -85t-79 -237z"" />
    <glyph glyph-name=""afii10039"" unicode=""&#x425;"" horiz-adv-x=""1366"" 
d=""M1038 0l-354 561l-354 -561h-312l488 741l-447 668h312l313 -498l313 498h310l-428 -668l469 -741h-310z"" />
    <glyph glyph-name=""afii10040"" unicode=""&#x426;"" horiz-adv-x=""1496"" 
d=""M1231 -408v408h-1094v1409h295v-1165h569v1165h285v-1165h195v-652h-250z"" />
    <glyph glyph-name=""afii10041"" unicode=""&#x427;"" horiz-adv-x=""1439"" 
d=""M1006 0v547q-39 -14 -86.5 -29t-102.5 -27t-117 -19.5t-129 -7.5q-240 0 -350.5 113t-110.5 352v480h284v-449q0 -72 12.5 -124.5t44 -86t85 -50t135.5 -16.5q92 0 178.5 16t156.5 37v673h295v-1409h-295z"" />
    <glyph glyph-name=""afii10042"" unicode=""&#x428;"" horiz-adv-x=""2058"" 
d=""M137 0v1409h285v-1165h464v1165h285v-1165h465v1165h285v-1409h-1784z"" />
    <glyph glyph-name=""afii10043"" unicode=""&#x429;"" horiz-adv-x=""2087"" 
d=""M137 0v1409h285v-1165h443v1165h285v-1165h442v1165h285v-1165h195v-652h-250v408h-1685z"" />
    <glyph glyph-name=""afii10044"" unicode=""&#x42a;"" horiz-adv-x=""1781"" 
d=""M1219 848q123 0 215 -30t152.5 -84.5t91 -131.5t30.5 -171q0 -90 -32.5 -169t-98 -137t-163 -91.5t-227.5 -33.5h-709v1181h-456v228h751v-561h446zM1410 427q0 93 -69.5 143.5t-207.5 50.5h-360v-391h366q140 0 205.5 50.5t65.5 146.5z"" />
    <glyph glyph-name=""afii10045"" unicode=""&#x42b;"" horiz-adv-x=""2005"" 
d=""M1359 431q0 -90 -32.5 -169t-98 -137t-163 -91.5t-227.5 -33.5h-701v1409h295v-561h438q123 0 215 -30t152.5 -84.5t91 -131.5t30.5 -171zM1061 427q0 93 -69.5 143.5t-207.5 50.5h-352v-391h358q140 0 205.5 50.5t65.5 146.5zM1573 0v1409h295v-1409h-295z"" />
    <glyph glyph-name=""afii10046"" unicode=""&#x42c;"" horiz-adv-x=""1472"" 
d=""M1399 431q0 -90 -32.5 -169t-98 -137t-163 -91.5t-227.5 -33.5h-741v1409h295v-561h478q123 0 215 -30t152.5 -84.5t91 -131.5t30.5 -171zM1101 427q0 93 -69.5 143.5t-207.5 50.5h-392v-391h398q140 0 205.5 50.5t65.5 146.5z"" />
    <glyph glyph-name=""afii10047"" unicode=""&#x42d;"" horiz-adv-x=""1457"" 
d=""M670 212q95 0 167 27.5t122 78t78 122.5t34 161h-547v228h546q-5 87 -33 155.5t-77.5 116t-120.5 72.5t-162 25q-75 0 -133.5 -19.5t-102 -51.5t-72 -73.5t-42.5 -86.5l-255 71q28 86 76.5 157.5t123 124t176.5 81.5t238 29q175 0 304.5 -50.5t214.5 -144t126.5 -226.5
t41.5 -298q0 -159 -42 -293t-128 -231.5t-218 -152t-312 -54.5q-138 0 -240 34.5t-176 90.5t-123 129t-80 149l252 97q19 -49 48 -97t72 -86t103 -61.5t141 -23.5z"" />
    <glyph glyph-name=""afii10048"" unicode=""&#x42e;"" horiz-adv-x=""2112"" 
d=""M2026 711q0 -165 -45 -300t-130.5 -231t-208.5 -148t-278 -52q-150 0 -265.5 46t-197 128.5t-129 197t-60.5 252.5h-280v-604h-295v1409h295v-561h283q17 135 67.5 243t133 183t195.5 115.5t255 40.5q159 0 282 -51t207 -145t127.5 -226.5t43.5 -296.5zM1725 711
q0 111 -22 200.5t-67 153.5t-112.5 98.5t-157.5 34.5q-92 0 -160 -34.5t-112.5 -98.5t-66.5 -153.5t-22 -200.5q0 -110 22 -201.5t67 -157.5t112.5 -103t158.5 -37q97 0 165 37.5t111.5 104t63.5 158t20 199.5z"" />
    <glyph glyph-name=""afii10049"" unicode=""&#x42f;"" horiz-adv-x=""1472"" 
d=""M35 0l381 592q-67 16 -124 50.5t-98.5 85.5t-65 116.5t-23.5 144.5q0 97 32.5 174.5t98.5 132t164.5 84t230.5 29.5h704v-1409h-295v535h-346l-327 -535h-332zM402 977q0 -47 15 -86t45.5 -67.5t78 -44t113.5 -15.5h386v416h-378q-125 0 -192.5 -50t-67.5 -153z"" />
    <glyph glyph-name=""afii10065"" unicode=""&#x430;"" 
d=""M393 -20q-78 0 -139.5 21.5t-104.5 63t-66 102.5t-23 139q0 96 33.5 161.5t91.5 106t136 59t166 19.5l233 4v55q0 59 -10.5 98.5t-30.5 64.5t-49.5 35.5t-67.5 10.5q-35 0 -62.5 -7t-47.5 -24.5t-32.5 -47t-17.5 -74.5l-293 14q12 71 44 129.5t88.5 101.5t139 66.5
t193.5 23.5q101 0 180 -25t134 -74.5t84 -121.5t29 -167v-394q0 -38 3.5 -68t13 -50.5t27 -31t45.5 -10.5q32 0 62 6v-152q-25 -6 -45 -11t-40 -8t-42.5 -5t-52.5 -2q-106 0 -156.5 52t-60.5 153h-6q-56 -101 -143.5 -157t-212.5 -56zM720 501l-144 -2q-45 -2 -85.5 -7.5
t-71 -23t-48.5 -50.5t-18 -90q0 -77 35.5 -114.5t94.5 -37.5q54 0 98 23t74.5 60.5t47.5 86.5t17 100v55z"" />
    <glyph glyph-name=""afii10066"" unicode=""&#x431;"" horiz-adv-x=""1265"" 
d=""M890 501q0 97 -16.5 161t-47.5 102.5t-75.5 54t-99.5 15.5q-59 0 -107 -16.5t-82.5 -55t-53 -102.5t-18.5 -159q0 -96 18.5 -159.5t51.5 -101t77.5 -53t96.5 -15.5q59 0 106.5 15t80.5 52.5t51 101t18 160.5zM697 1027q251 0 369 -130.5t118 -392.5q0 -265 -141 -394.5
t-409 -129.5q-127 0 -227.5 35t-170 113t-106 203t-36.5 305q0 192 32.5 331t105 235.5t188.5 154t282 85.5q65 11 121 19.5t107.5 15.5t99.5 13t97 12v-235q-97 -10 -188 -21.5t-193 -27.5q-88 -13 -158 -29t-123 -40t-91 -58.5t-62.5 -86.5t-37 -123t-15.5 -168
q22 67 58 124.5t89 99.5t125 66t166 24z"" />
    <glyph glyph-name=""afii10067"" unicode=""&#x432;"" horiz-adv-x=""1259"" 
d=""M679 1082q93 0 178.5 -12t150 -43t103 -83t38.5 -133q0 -52 -19.5 -93t-53 -70t-77.5 -47.5t-93 -27.5v-7q59 -7 108.5 -24.5t86.5 -48.5t57.5 -75.5t20.5 -105.5q0 -157 -119.5 -234.5t-338.5 -77.5h-578v1082h536zM425 175h227q66 0 112 8t74.5 26t41 46t12.5 67
q0 42 -13.5 71.5t-43.5 47.5t-78 26t-116 8h-216v-300zM425 907v-260h208q64 0 107 7.5t68.5 23t36.5 40.5t11 60q0 67 -48 98t-162 31h-221z"" />
    <glyph glyph-name=""afii10068"" unicode=""&#x433;"" horiz-adv-x=""853"" 
d=""M798 1082v-190h-373v-892h-282v1082h655z"" />
    <glyph glyph-name=""afii10069"" unicode=""&#x434;"" horiz-adv-x=""1300"" 
d=""M834 892h-236q-18 -138 -38 -249t-41.5 -197.5t-43.5 -149.5t-45 -106h404v702zM259 0v-408h-245v598h125q30 47 58 114t55.5 170.5t54.5 251t55 356.5h754v-892h146v-598h-245v408h-758z"" />
    <glyph glyph-name=""afii10070"" unicode=""&#x435;"" 
d=""M586 -20q-117 0 -210.5 34.5t-159.5 105t-101 177t-35 249.5q0 155 41.5 261t112 171.5t162.5 94.5t194 29q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-8h-694q0 -68 12 -126.5t39 -101t70 -67t104 -24.5q74 0 121 31.5t67 97.5l265 -23q-18 -46 -50.5 -98
t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM586 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420q-8 131 -63 196.5t-148 65.5z"" />
    <glyph glyph-name=""afii10072"" unicode=""&#x436;"" horiz-adv-x=""1452"" 
d=""M600 457q-25 0 -54 3t-43 8l-223 -468h-297l318 571q-17 14 -39 44.5t-53 85.5l-216 381h274l136 -257q39 -75 67 -118t49.5 -64.5t40.5 -27.5t40 -7v474h252v-474q21 1 40 7t40.5 27.5t49.5 64.5t67 118l136 257h274l-216 -381q-30 -56 -52.5 -86t-39.5 -44l318 -571
h-297l-223 468q-7 -3 -18.5 -5t-24.5 -3.5t-27 -2t-27 -0.5v-457h-252v457z"" />
    <glyph glyph-name=""afii10073"" unicode=""&#x437;"" horiz-adv-x=""1018"" 
d=""M493 -20q-179 0 -289 80t-151 228l241 44q9 -39 28 -69.5t45 -51.5t58 -32t66 -11q80 0 124.5 39.5t44.5 103.5q0 50 -21.5 81t-60.5 48.5t-93.5 24t-119.5 6.5v177q63 0 115 6.5t89.5 23t58 45t20.5 73.5q0 60 -39 93.5t-111 33.5q-30 0 -60.5 -6.5t-56 -23t-44 -44.5
t-23.5 -70l-237 22q13 75 49.5 131.5t93.5 94t132 56.5t163 19q91 0 165 -20.5t126.5 -57.5t81 -88.5t28.5 -114.5q0 -56 -19 -98.5t-52.5 -73.5t-79 -51t-97.5 -31v-2q56 -6 107 -25.5t89.5 -52.5t61.5 -79t23 -104q0 -69 -28 -128.5t-84.5 -103t-142 -68t-201.5 -24.5z
"" />
    <glyph glyph-name=""afii10074"" unicode=""&#x438;"" horiz-adv-x=""1259"" 
d=""M404 1082v-486q0 -23 -2 -63t-5 -83t-6.5 -81.5t-6.5 -59.5l448 773h285v-1082h-260v550q0 19 1.5 49t4.5 62t6.5 62t7.5 50l-435 -773h-300v1082h262z"" />
    <glyph glyph-name=""afii10075"" unicode=""&#x439;"" horiz-adv-x=""1259"" 
d=""M404 1082v-486q0 -23 -2 -63t-5 -83t-6.5 -81.5t-6.5 -59.5l448 773h285v-1082h-260v550q0 19 1.5 49t4.5 62t6.5 62t7.5 50l-435 -773h-300v1082h262zM638 1184q-82 0 -144 13t-106.5 36.5t-74 56t-47 70t-25.5 79.5t-10 85h224q5 -103 52 -151t131 -48t131 48t52 151
h224q-2 -43 -10 -85t-25.5 -79.5t-47 -70t-74 -56t-106.5 -36.5t-144 -13z"" />
    <glyph glyph-name=""afii10076"" unicode=""&#x43a;"" horiz-adv-x=""1025"" 
d=""M142 1082h282v-464q23 1 41 5.5t38.5 24.5t47 61t65.5 116l126 257h274l-206 -381q-32 -60 -58.5 -88t-43.5 -42l318 -571h-287l-233 458q-14 -5 -39 -8t-43 -3v-447h-282v1082z"" />
    <glyph glyph-name=""afii10077"" unicode=""&#x43b;"" horiz-adv-x=""1301"" 
d=""M876 0v892h-310q-25 -184 -46 -323t-43 -240.5t-47.5 -168.5t-60.5 -107t-82 -56.5t-112 -16.5q-14 0 -36.5 1t-46 3t-43 4.5t-28.5 4.5v191q11 -4 30 -6.5t38 -2.5q29 0 50.5 12.5t39.5 47.5t33.5 98t33 163.5t38 244.5t47.5 341h827v-1082h-282z"" />
    <glyph glyph-name=""afii10078"" unicode=""&#x43c;"" horiz-adv-x=""1515"" 
d=""M870 0h-213l-284 885q3 -29 6 -64.5t5.5 -70.5t3.5 -67t1 -55v-628h-246v1082h372l180 -561q20 -65 40 -139.5t28 -146.5q10 72 29 146.5t39 139.5l175 561h366v-1082h-246v628q0 22 1.5 55.5t4.5 70t6 72t6 61.5z"" />
    <glyph glyph-name=""afii10079"" unicode=""&#x43d;"" horiz-adv-x=""1237"" 
d=""M425 1082v-428h387v428h282v-1082h-282v463h-387v-463h-282v1082h282z"" />
    <glyph glyph-name=""afii10080"" unicode=""&#x43e;"" horiz-adv-x=""1251"" 
d=""M1171 542q0 -124 -34.5 -227t-103.5 -177.5t-172 -116t-240 -41.5q-132 0 -233 41t-169.5 115t-103.5 177.5t-35 228.5q0 121 33.5 223.5t101.5 177.5t171 117t241 42q146 0 249 -42t168.5 -116.5t96 -177t30.5 -224.5zM877 542q0 193 -63 280t-183 87q-124 0 -190 -88
t-66 -279q0 -97 17.5 -167t49.5 -115t77 -66.5t99 -21.5q62 0 110.5 21.5t81.5 66.5t50 115t17 167z"" />
    <glyph glyph-name=""afii10081"" unicode=""&#x43f;"" horiz-adv-x=""1237"" 
d=""M1094 1082v-1082h-282v892h-387v-892h-282v1082h951z"" />
    <glyph glyph-name=""afii10082"" unicode=""&#x440;"" horiz-adv-x=""1251"" 
d=""M1167 546q0 -123 -24.5 -227t-75.5 -179t-129.5 -117.5t-185.5 -42.5q-48 0 -95.5 10t-90.5 32.5t-79.5 59t-62.5 90.5h-6q1 -5 2 -25t2 -46.5t1.5 -56t0.5 -54.5v-415h-281v1258q0 83 -2.5 148t-5.5 101h273q2 -7 4.5 -27t4 -46t2.5 -54t1 -49h4q51 107 140 153t206 46
q103 0 178 -42t123.5 -116t72 -176.5t23.5 -224.5zM874 546q0 185 -56 274.5t-167 89.5q-42 0 -83.5 -17.5t-74 -60t-53 -114t-20.5 -180.5q0 -106 20 -176.5t52.5 -112.5t73.5 -59.5t83 -17.5q54 0 96 21.5t70.5 67t43.5 116.5t15 169z"" />
    <glyph glyph-name=""afii10083"" unicode=""&#x441;"" 
d=""M594 -20q-129 0 -225.5 40t-160.5 113t-96 175.5t-32 226.5q0 135 35 240.5t101 178t162.5 110.5t219.5 38q105 0 186.5 -28t140.5 -76.5t95.5 -114.5t50.5 -142l-283 -14q-12 83 -60 132.5t-136 49.5q-113 0 -165 -93t-52 -270q0 -374 221 -374q80 0 134 50.5t67 150.5
l282 -13q-10 -75 -45.5 -143.5t-96 -121t-146.5 -84t-197 -31.5z"" />
    <glyph glyph-name=""afii10084"" unicode=""&#x442;"" horiz-adv-x=""1003"" 
d=""M58 1082h888v-190h-303v-892h-282v892h-303v190z"" />
    <glyph glyph-name=""afii10085"" unicode=""&#x443;"" 
d=""M584 241l250 841h294l-428 -1139q-81 -197 -168 -279q-95 -89 -249 -89q-101 0 -177 13v200q53 -8 95.5 -8t74.5 9t58 30q51 42 92 144l18 48l-428 1071h297z"" />
    <glyph glyph-name=""afii10086"" unicode=""&#x444;"" horiz-adv-x=""1792"" 
d=""M1709 546q0 -123 -22.5 -227t-69.5 -179t-119 -117.5t-170 -42.5q-44 0 -87.5 10t-83.5 32.5t-73.5 59t-57.5 90.5h-6q1 -5 2 -25t2 -46.5t1.5 -56t0.5 -54.5v-415h-261v601h-2q-45 -105 -125.5 -150.5t-192.5 -45.5q-94 0 -162.5 42t-113 117t-66 177.5t-21.5 223.5
q0 123 22.5 226t69.5 177.5t119 116.5t171 42q49 0 94 -11t83.5 -34t70 -59t53.5 -87h2q0 10 -0.5 29.5t-0.5 44.5t-0.5 52t-0.5 52v395h261v-578q47 107 129 153t189 46q95 0 163.5 -42t113.5 -116t66.5 -176.5t21.5 -224.5zM769 547q0 107 -17.5 177.5t-45.5 112t-64 58
t-73 16.5q-47 0 -83 -21t-61 -66t-37.5 -115t-12.5 -169q0 -368 192 -368q37 0 73 18t64.5 61t46.5 115.5t18 180.5zM1416 546q0 185 -48.5 274.5t-145.5 89.5q-36 0 -72 -17.5t-64.5 -60t-46 -114t-17.5 -180.5q0 -106 17.5 -176.5t45.5 -112.5t64 -59.5t72 -17.5
q94 0 144.5 89t50.5 285z"" />
    <glyph glyph-name=""afii10087"" unicode=""&#x445;"" 
d=""M819 0l-252 392l-254 -392h-299l396 559l-377 523h303l231 -354l230 354h305l-377 -520l399 -562h-305z"" />
    <glyph glyph-name=""afii10088"" unicode=""&#x446;"" horiz-adv-x=""1259"" 
d=""M143 0v1082h282v-892h387v892h282v-892h146v-598h-245v408h-852z"" />
    <glyph glyph-name=""afii10089"" unicode=""&#x447;"" horiz-adv-x=""1189"" 
d=""M363 1082v-386q0 -33 8 -61.5t26 -49.5t48.5 -33t75.5 -12q33 0 62.5 3t58.5 9t59 14.5t65 18.5v497h281v-1082h-281v415q-43 -15 -85.5 -30.5t-88.5 -27.5t-96 -20t-107 -8q-74 0 -131 21.5t-96 62.5t-59 99.5t-20 131.5v438h280z"" />
    <glyph glyph-name=""afii10090"" unicode=""&#x448;"" horiz-adv-x=""1707"" 
d=""M1560 0h-1417v1082h262v-892h316v892h262v-892h315v892h262v-1082z"" />
    <glyph glyph-name=""afii10091"" unicode=""&#x449;"" horiz-adv-x=""1728"" 
d=""M143 0v1082h262v-892h317v892h262v-892h316v892h262v-892h146v-598h-245v408h-1320z"" />
    <glyph glyph-name=""afii10092"" unicode=""&#x44a;"" horiz-adv-x=""1493"" 
d=""M941 647q235 0 351 -77t116 -241q0 -77 -28.5 -138t-86.5 -103.5t-145.5 -65t-205.5 -22.5h-531v892h-373v190h655v-435h248zM693 175h188q69 0 115.5 10t74 29.5t39 48.5t11.5 66q0 38 -12.5 65.5t-40.5 45.5t-74 26.5t-112 8.5h-189v-300z"" />
    <glyph glyph-name=""afii10093"" unicode=""&#x44b;"" horiz-adv-x=""1749"" 
d=""M697 647q235 0 356 -77t121 -241q0 -77 -30 -138t-90 -103.5t-149 -65t-207 -22.5h-555v1082h282v-435h272zM425 175h212q69 0 117 10t77.5 29.5t42.5 48.5t13 66q0 76 -58 111t-191 35h-213v-300zM1325 0v1082h281v-1082h-281z"" />
    <glyph glyph-name=""afii10094"" unicode=""&#x44c;"" horiz-adv-x=""1259"" 
d=""M697 647q235 0 356 -77t121 -241q0 -77 -30 -138t-90 -103.5t-149 -65t-207 -22.5h-555v1082h282v-435h272zM425 175h212q69 0 117 10t77.5 29.5t42.5 48.5t13 66q0 76 -58 111t-191 35h-213v-300z"" />
    <glyph glyph-name=""afii10095"" unicode=""&#x44d;"" horiz-adv-x=""1131"" 
d=""M52 360l282 13q13 -100 67 -150.5t134 -50.5q58 0 98 18.5t65.5 54t38 88t15.5 120.5h-309v190h309q-3 61 -15 110.5t-37 84t-64.5 53t-96.5 18.5q-88 0 -136 -49.5t-60 -132.5l-283 14q14 76 50.5 142t95.5 114.5t140.5 76.5t186.5 28q123 0 219.5 -38t162.5 -110.5
t101 -178t35 -240.5q0 -124 -32 -226.5t-96 -175.5t-160.5 -113t-225.5 -40q-111 0 -197 31.5t-146.5 84t-96 121t-45.5 143.5z"" />
    <glyph glyph-name=""afii10096"" unicode=""&#x44e;"" horiz-adv-x=""1749"" 
d=""M1669 542q0 -124 -33 -227t-99.5 -177.5t-166 -116t-231.5 -41.5q-117 0 -208.5 34.5t-157 98t-104 152.5t-48.5 198h-196v-463h-282v1082h282v-428h200q14 99 52.5 181.5t103 141.5t155.5 92t209 33q141 0 240.5 -42t162.5 -116.5t92 -177t29 -224.5zM1375 542
q0 193 -58 280t-168 87q-115 0 -175.5 -88t-60.5 -279q0 -97 16 -167t45.5 -115t71 -66.5t91.5 -21.5q114 0 176 87.5t62 282.5z"" />
    <glyph glyph-name=""afii10097"" unicode=""&#x44f;"" horiz-adv-x=""1195"" 
d=""M578 435l-272 -435h-307l322 471q-50 12 -92.5 35.5t-74 61t-49 88t-17.5 116.5q0 79 32 137.5t93 96.5t150 57t202 19h487v-1082h-282v435h-192zM772 907h-192q-102 0 -153.5 -36.5t-51.5 -114.5q0 -72 46 -110.5t143 -38.5h208v300z"" />
    <glyph glyph-name=""uni0450"" unicode=""&#x450;"" 
d=""M524 1194l-340 276v43h258l251 -288v-31h-169zM586 -20q-117 0 -210.5 34.5t-159.5 105t-101 177t-35 249.5q0 155 41.5 261t112 171.5t162.5 94.5t194 29q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-8h-694q0 -68 12 -126.5t39 -101t70 -67t104 -24.5
q74 0 121 31.5t67 97.5l265 -23q-18 -46 -50.5 -98t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM586 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420q-8 131 -63 196.5t-148 65.5z"" />
    <glyph glyph-name=""afii10071"" unicode=""&#x451;"" 
d=""M586 -20q-117 0 -210.5 34.5t-159.5 105t-101 177t-35 249.5q0 155 41.5 261t112 171.5t162.5 94.5t194 29q128 0 218.5 -44.5t148.5 -124.5t85 -191.5t27 -246.5v-8h-694q0 -68 12 -126.5t39 -101t70 -67t104 -24.5q74 0 121 31.5t67 97.5l265 -23q-18 -46 -50.5 -98
t-86.5 -95.5t-134.5 -72t-195.5 -28.5zM586 925q-43 0 -80.5 -14.5t-65 -46t-44.5 -81.5t-19 -120h420q-8 131 -63 196.5t-148 65.5zM694 1199v219h217v-219h-217zM260 1199v219h214v-219h-214z"" />
    <glyph glyph-name=""afii10099"" unicode=""&#x452;"" horiz-adv-x=""1251"" 
d=""M837 -425q-56 0 -97.5 2.5t-72.5 6.5v198q13 -2 26 -3t25 -1q39 0 63.5 8t38.5 27t19 50t5 77v626q0 63 -10 115.5t-33 90t-60 58.5t-90 21q-51 0 -92.5 -22.5t-71.5 -64t-46.5 -99t-16.5 -126.5v-539h-281v1175h-133v170h133v139h281v-139h310v-170h-310v-136
q0 -32 -1 -64.5t-2.5 -61t-2.5 -51.5t-2 -36h4q57 124 143 180t205 56q98 0 165.5 -32t110 -88t61.5 -132t19 -164v-774q0 -65 -16 -119t-50.5 -94t-89 -62t-131.5 -22z"" />
    <glyph glyph-name=""afii10100"" unicode=""&#x453;"" horiz-adv-x=""853"" 
d=""M798 1082v-190h-373v-892h-282v1082h655zM303 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""afii10101"" unicode=""&#x454;"" horiz-adv-x=""1131"" 
d=""M594 -20q-129 0 -225.5 40t-160.5 113t-96 175.5t-32 226.5q0 135 35 240.5t101 178t162.5 110.5t219.5 38q105 0 186.5 -28t140.5 -76.5t95.5 -114.5t50.5 -142l-283 -14q-12 83 -60 132.5t-136 49.5q-101 0 -154.5 -67.5t-58.5 -198.5h309v-190h-309q5 -141 60 -211
t157 -70q80 0 134 50.5t67 150.5l282 -13q-10 -75 -45.5 -143.5t-96 -121t-146.5 -84t-197 -31.5z"" />
    <glyph glyph-name=""afii10102"" unicode=""&#x455;"" 
d=""M1055 316q0 -78 -32.5 -140t-94.5 -105.5t-152 -67t-205 -23.5q-103 0 -186 15t-145.5 49.5t-104.5 89.5t-63 136l247 37q12 -45 33 -73t52 -43t72.5 -20t94.5 -5q48 0 89.5 5.5t72 19t47.5 38t17 61.5q0 42 -24.5 66.5t-67 40t-100 27t-122.5 26.5q-68 15 -134 36
t-118 57t-84 91.5t-32 140.5q0 77 30 137.5t88 103t143.5 65t196.5 22.5q88 0 164 -16.5t136 -52t100.5 -90.5t56.5 -133l-249 -26q-7 39 -25 64.5t-44.5 40.5t-61.5 20.5t-77 5.5q-100 0 -150 -25.5t-50 -85.5q0 -37 20.5 -59t58 -36.5t89 -25t112.5 -25.5
q75 -16 147.5 -37.5t129 -59t91 -96.5t34.5 -150z"" />
    <glyph glyph-name=""afii10103"" unicode=""&#x456;"" horiz-adv-x=""569"" 
d=""M143 0v1082h281v-1082h-281zM145 1277v207h281v-207h-281z"" />
    <glyph glyph-name=""afii10104"" unicode=""&#x457;"" horiz-adv-x=""576"" 
d=""M145 0v1082h281v-1082h-281zM396 1199v219h217v-219h-217zM-38 1199v219h214v-219h-214z"" />
    <glyph glyph-name=""afii10105"" unicode=""&#x458;"" horiz-adv-x=""569"" 
d=""M144 1277v207h281v-207h-281zM138 -425q-56 0 -97.5 2.5t-72.5 6.5v198q13 -2 26 -3t25 -1q39 0 63 8t38 27t19 50t5 77v1142h281v-1210q0 -65 -16 -119t-50.5 -94t-89 -62t-131.5 -22z"" />
    <glyph glyph-name=""afii10106"" unicode=""&#x459;"" horiz-adv-x=""1984"" 
d=""M868 0v892h-302q-25 -184 -46 -323t-43 -240.5t-47.5 -168.5t-60.5 -107t-82 -56.5t-112 -16.5q-14 0 -36.5 1t-46 3t-43 4.5t-28.5 4.5v191q11 -4 30 -6.5t38 -2.5q29 0 50.5 12.5t39.5 47.5t33.5 98t33 163.5t38 244.5t47.5 341h819v-435h272q235 0 356 -77t121 -241
q0 -77 -30 -138t-90 -103.5t-149 -65t-207 -22.5h-555zM1150 175h212q69 0 117 10t77.5 29.5t42.5 48.5t13 66q0 76 -58 111t-191 35h-213v-300z"" />
    <glyph glyph-name=""afii10107"" unicode=""&#x45a;"" horiz-adv-x=""1856"" 
d=""M1294 647q235 0 356 -77t121 -241q0 -77 -30 -138t-90 -103.5t-149 -65t-207 -22.5h-519v463h-351v-463h-282v1082h282v-428h351v428h282v-435h236zM1058 175h176q69 0 117 10t77.5 29.5t42.5 48.5t13 66q0 76 -58 111t-191 35h-177v-300z"" />
    <glyph glyph-name=""afii10108"" unicode=""&#x45b;"" horiz-adv-x=""1251"" 
d=""M844 0v566q0 63 -10 115.5t-33 90t-60 58.5t-90 21q-51 0 -92.5 -22.5t-71.5 -64t-46.5 -99t-16.5 -126.5v-539h-281v1175h-133v170h133v139h281v-139h310v-170h-310v-136q0 -32 -1 -64.5t-2.5 -61t-2.5 -51.5t-2 -36h4q57 124 143 180t205 56q98 0 165.5 -32t110 -88
t61.5 -132t19 -164v-646h-280z"" />
    <glyph glyph-name=""afii10109"" unicode=""&#x45c;"" horiz-adv-x=""1025"" 
d=""M142 1082h282v-464q23 1 41 5.5t38.5 24.5t47 61t65.5 116l126 257h274l-206 -381q-32 -60 -58.5 -88t-43.5 -42l318 -571h-287l-233 458q-14 -5 -39 -8t-43 -3v-447h-282v1082zM406 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""uni045D"" unicode=""&#x45d;"" horiz-adv-x=""1259"" 
d=""M593 1194l-340 276v43h258l251 -288v-31h-169zM404 1082v-486q0 -23 -2 -63t-5 -83t-6.5 -81.5t-6.5 -59.5l448 773h285v-1082h-260v550q0 19 1.5 49t4.5 62t6.5 62t7.5 50l-435 -773h-300v1082h262z"" />
    <glyph glyph-name=""afii10110"" unicode=""&#x45e;"" 
d=""M584 241l250 841h294l-428 -1139q-81 -197 -168 -279q-95 -89 -249 -89q-101 0 -177 13v200q53 -8 95.5 -8t74.5 9t58 30q51 42 92 144l18 48l-428 1071h297zM568 1184q-82 0 -144 13t-106.5 36.5t-74 56t-47 70t-25.5 79.5t-10 85h224q5 -103 52 -151t131 -48t131 48
t52 151h224q-2 -43 -10 -85t-25.5 -79.5t-47 -70t-74 -56t-106.5 -36.5t-144 -13z"" />
    <glyph glyph-name=""afii10193"" unicode=""&#x45f;"" horiz-adv-x=""1237"" 
d=""M496 0h-353v1082h282v-891h387v891h282v-1082h-353v-408h-245v408z"" />
    <glyph glyph-name=""afii10050"" unicode=""&#x490;"" horiz-adv-x=""997"" 
d=""M703 1409v411h250v-639h-521v-1180h-295v1408h566z"" />
    <glyph glyph-name=""afii10098"" unicode=""&#x491;"" horiz-adv-x=""915"" 
d=""M584 1082v408h245v-598h-404v-892h-282v1082h441z"" />
    <glyph glyph-name=""Wgrave"" unicode=""&#x1e80;"" horiz-adv-x=""1933"" 
d=""M1567 0h-350l-191 815q-9 37 -19.5 88t-19.5 99q-11 55 -20 114q-11 -59 -22 -115q-5 -24 -10 -49.5t-10.5 -50t-10 -46.5t-9.5 -40l-190 -815h-350l-363 1409h299l176 -784q15 -64 28 -126t24 -111q12 -57 22 -109q15 74 29 144q6 30 13 62t13.5 63t13 59.5t11.5 51.5
l174 750h330l178 -750q6 -24 12 -53.5t12 -61l12 -63t11 -61.5q12 -70 24 -141q12 56 25 116q11 51 25 112t28 118l170 784h299zM1004 1530l-340 242v43h258l251 -254v-31h-169z"" />
    <glyph glyph-name=""wgrave"" unicode=""&#x1e81;"" horiz-adv-x=""1593"" 
d=""M436 255l209 827h301l207 -827l184 827h260l-284 -1082h-297l-219 882l-226 -882h-297l-280 1082h264zM785 1183l-340 276v43h258l251 -288v-31h-169z"" />
    <glyph glyph-name=""Wacute"" unicode=""&#x1e82;"" horiz-adv-x=""1933"" 
d=""M1567 0h-350l-191 815q-9 37 -19.5 88t-19.5 99q-11 55 -20 114q-11 -59 -22 -115q-5 -24 -10 -49.5t-10.5 -50t-10 -46.5t-9.5 -40l-190 -815h-350l-363 1409h299l176 -784q15 -64 28 -126t24 -111q12 -57 22 -109q15 74 29 144q6 30 13 62t13.5 63t13 59.5t11.5 51.5
l174 750h330l178 -750q6 -24 12 -53.5t12 -61l12 -63t11 -61.5q12 -70 24 -141q12 56 25 116q11 51 25 112t28 118l170 784h299zM823 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""wacute"" unicode=""&#x1e83;"" horiz-adv-x=""1593"" 
d=""M436 255l209 827h301l207 -827l184 827h260l-284 -1082h-297l-219 882l-226 -882h-297l-280 1082h264zM637 1183v31l252 288h258v-43l-340 -276h-170z"" />
    <glyph glyph-name=""Wdieresis"" unicode=""&#x1e84;"" horiz-adv-x=""1933"" 
d=""M1567 0h-350l-191 815q-9 37 -19.5 88t-19.5 99q-11 55 -20 114q-11 -59 -22 -115q-5 -24 -10 -49.5t-10.5 -50t-10 -46.5t-9.5 -40l-190 -815h-350l-363 1409h299l176 -784q15 -64 28 -126t24 -111q12 -57 22 -109q15 74 29 144q6 30 13 62t13.5 63t13 59.5t11.5 51.5
l174 750h330l178 -750q6 -24 12 -53.5t12 -61l12 -63t11 -61.5q12 -70 24 -141q12 56 25 116q11 51 25 112t28 118l170 784h299zM1098 1530v219h197v-219h-197zM644 1530v219h194v-219h-194z"" />
    <glyph glyph-name=""wdieresis"" unicode=""&#x1e85;"" horiz-adv-x=""1593"" 
d=""M436 255l209 827h301l207 -827l184 827h260l-284 -1082h-297l-219 882l-226 -882h-297l-280 1082h264zM906 1199v219h217v-219h-217zM472 1199v219h214v-219h-214z"" />
    <glyph glyph-name=""Ygrave"" unicode=""&#x1ef2;"" horiz-adv-x=""1366"" 
d=""M831 578v-578h-294v578l-502 831h309l338 -596l342 596h309zM717 1530l-340 242v43h258l251 -254v-31h-169z"" />
    <glyph glyph-name=""ygrave"" unicode=""&#x1ef3;"" 
d=""M584 241l250 841h294l-428 -1139q-81 -197 -168 -279q-95 -89 -249 -89q-101 0 -177 13v200q53 -8 95.5 -8t74.5 9t58 30q51 42 92 144l18 48l-428 1071h297zM545 1183l-340 276v43h258l251 -288v-31h-169z"" />
    <glyph glyph-name=""uni2010"" unicode=""&#x2010;"" horiz-adv-x=""682"" 
d=""M80 409v244h520v-244h-520z"" />
    <glyph glyph-name=""uni2011"" unicode=""&#x2011;"" horiz-adv-x=""682"" 
d=""M80 409v244h520v-244h-520z"" />
    <glyph glyph-name=""endash"" unicode=""&#x2013;"" 
d=""M62 448v203h1014v-203h-1014z"" />
    <glyph glyph-name=""emdash"" unicode=""&#x2014;"" horiz-adv-x=""2048"" 
d=""M0 448v203h2048v-203h-2048z"" />
    <glyph glyph-name=""afii00208"" unicode=""&#x2015;"" horiz-adv-x=""2048"" 
d=""M0 448v203h2048v-203h-2048z"" />
    <glyph glyph-name=""underscoredbl"" unicode=""&#x2017;"" horiz-adv-x=""1131"" 
d=""M-20 -512v78h1177v-78h-1177zM-20 -250v78h1177v-78h-1177z"" />
    <glyph glyph-name=""quoteleft"" unicode=""&#x2018;"" horiz-adv-x=""569"" 
d=""M139 831v195q0 67 7.5 122t21.5 101t34 85.5t45 74.5h183q-28 -35 -52 -74t-41.5 -80t-27.5 -82t-10 -81h127v-261h-287z"" />
    <glyph glyph-name=""quoteright"" unicode=""&#x2019;"" horiz-adv-x=""569"" 
d=""M430 1214q0 -67 -7 -121.5t-21 -101t-34.5 -85.5t-46.5 -75h-182q28 36 52 75t41.5 79.5t27.5 82t10 81.5h-127v260h287v-195z"" />
    <glyph glyph-name=""quotesinglbase"" unicode=""&#x201a;"" horiz-adv-x=""569"" 
d=""M431 66q0 -67 -7.5 -122t-21.5 -101.5t-34 -85.5t-45 -74h-185q29 35 53.5 74t42.5 80t28 82t10 81h-129v260h288v-194z"" />
    <glyph glyph-name=""quotereversed"" unicode=""&#x201b;"" horiz-adv-x=""569"" 
d=""M426 1409v-260h-127q0 -40 10 -81.5t27.5 -82t41.5 -79.5t52 -75h-182q-26 36 -46.5 75t-34.5 85.5t-21 101t-7 121.5v195h287z"" />
    <glyph glyph-name=""quotedblleft"" unicode=""&#x201c;"" horiz-adv-x=""1024"" 
d=""M579 831v195q0 67 7.5 122t22 101t35 85.5t46.5 74.5h182q-28 -35 -52 -74t-41.5 -80t-27.5 -82t-10 -81h127v-261h-289zM151 831v195q0 67 7.5 122t21.5 101t34 85.5t45 74.5h183q-28 -35 -52 -74t-41.5 -80t-27.5 -82t-10 -81h127v-261h-287z"" />
    <glyph glyph-name=""quotedblright"" unicode=""&#x201d;"" horiz-adv-x=""1024"" 
d=""M872 1217q0 -68 -7.5 -123.5t-21.5 -102t-34 -85.5t-46 -75h-184q57 72 95 154.5t38 163.5h-127v260h287v-192zM442 1217q0 -68 -7 -123.5t-21 -102t-34.5 -85.5t-46.5 -75h-182q28 36 52 75t41.5 79.5t27.5 82t10 81.5h-127v260h287v-192z"" />
    <glyph glyph-name=""quotedblbase"" unicode=""&#x201e;"" horiz-adv-x=""1024"" 
d=""M872 66q0 -67 -7.5 -122t-21.5 -101.5t-34 -85.5t-46 -74h-184q29 35 53 74t42 80t28 82t10 81h-127v260h287v-194zM442 66q0 -67 -7 -122t-21 -101.5t-34.5 -85.5t-46.5 -74h-182q28 35 52 74t41.5 80t27.5 82t10 81h-127v260h287v-194z"" />
    <glyph glyph-name=""dagger"" unicode=""&#x2020;"" 
d=""M669 960l-22 -1098h-155l-22 1098l-332 -27v204l332 -29l-28 376h255l-28 -376l333 29v-204z"" />
    <glyph glyph-name=""daggerdbl"" unicode=""&#x2021;"" 
d=""M478 980l-341 -27v204l341 -29l-16 356h215l-16 -356l341 29v-204l-341 27l-26 -310l26 -307l340 27v-204l-340 29l16 -356h-215l16 356l-342 -29v204l342 -27l26 307z"" />
    <glyph glyph-name=""bullet"" unicode=""&#x2022;"" horiz-adv-x=""717"" 
d=""M651 676q0 -61 -23.5 -114.5t-63.5 -93.5t-93.5 -63.5t-114.5 -23.5q-60 0 -113 23.5t-92.5 63.5t-62.5 93.5t-23 114.5t23 114.5t62.5 93t92.5 62.5t113 23q61 0 114.5 -23t93.5 -62.5t63.5 -93t23.5 -114.5z"" />
    <glyph glyph-name=""ellipsis"" unicode=""&#x2026;"" horiz-adv-x=""2048"" 
d=""M1528 0v305h288v-305h-288zM880 0v305h286v-305h-286zM225 0v305h288v-305h-288z"" />
    <glyph glyph-name=""perthousand"" unicode=""&#x2030;"" horiz-adv-x=""2048"" 
d=""M382 0h-197l812 1409h199zM331 1419q58 0 110 -16.5t91 -57t61.5 -109.5t22.5 -175q0 -100 -23 -168.5t-62 -111t-91.5 -61t-112.5 -18.5t-112 18.5t-90.5 60.5t-61 110.5t-22.5 169.5q0 106 22 175t61 109.5t92 57t115 16.5zM440 1061q0 69 -7 114t-20.5 71.5t-34 37.5
t-47.5 11q-30 0 -51.5 -11t-36 -38t-21 -72t-6.5 -113q0 -67 7 -112t21 -72t35 -38.5t50 -11.5q27 0 48 11.5t35 38.5t21 72t7 112zM1057 714q58 0 110 -16.5t91 -57t61.5 -109.5t22.5 -175q0 -100 -23 -168.5t-62 -111t-91.5 -61t-112.5 -18.5t-112 18.5t-90.5 60.5
t-61 110.5t-22.5 169.5q0 106 22 175t61 109.5t92 57t115 16.5zM1166 356q0 69 -7 114t-20.5 71.5t-34 37.5t-47.5 11q-30 0 -52 -11t-36 -38t-21 -72t-7 -113q0 -67 7 -112t21 -72t35.5 -38.5t50.5 -11.5q27 0 48 11.5t35 38.5t21 72t7 112zM1722 714q59 0 110.5 -16.5
t90.5 -57t61.5 -109.5t22.5 -175q0 -100 -22.5 -168.5t-62 -111t-92 -61t-112.5 -18.5t-112 18.5t-90.5 60.5t-61 110.5t-22.5 169.5q0 106 22 175t61 109.5t92 57t115 16.5zM1831 356q0 69 -7 114t-20.5 71.5t-34 37.5t-47.5 11q-30 0 -51.5 -11t-36 -38t-21 -72t-6.5 -113
q0 -67 7 -112t21 -72t35 -38.5t50 -11.5q27 0 48 11.5t35 38.5t21 72t7 112z"" />
    <glyph glyph-name=""minute"" unicode=""&#x2032;"" horiz-adv-x=""491"" 
d=""M85 890l64 519h306l-158 -519h-212z"" />
    <glyph glyph-name=""second"" unicode=""&#x2033;"" horiz-adv-x=""981"" 
d=""M85 890l64 519h306l-158 -519h-212zM574 890l64 519h306l-158 -519h-212z"" />
    <glyph glyph-name=""guilsinglleft"" unicode=""&#x2039;"" horiz-adv-x=""682"" 
d=""M350 141l-258 361v71l258 367h236v-37l-254 -366l256 -361v-35h-238z"" />
    <glyph glyph-name=""guilsinglright"" unicode=""&#x203a;"" horiz-adv-x=""682"" 
d=""M93 141v35l256 361l-254 366v37h238l256 -367v-71l-256 -361h-240z"" />
    <glyph glyph-name=""exclamdbl"" unicode=""&#x203c;"" horiz-adv-x=""1237"" 
d=""M455 426h-230l-32 983h294zM193 0v270h288v-270h-288zM1012 426h-230l-32 983h294zM750 0v270h288v-270h-288z"" />
    <glyph glyph-name=""uni203E"" unicode=""&#x203e;"" horiz-adv-x=""682"" 
d=""M812 1454h-942v166h942v-166z"" />
    <glyph glyph-name=""uni2215"" unicode=""&#x2044;"" horiz-adv-x=""342"" 
d=""M-176 0h-201l895 1409h201z"" />
    <glyph glyph-name=""uni2215"" unicode=""&#x2215;"" horiz-adv-x=""342"" 
d=""M-176 0h-201l895 1409h201z"" />
    <glyph glyph-name=""uni207F"" unicode=""&#x207f;"" horiz-adv-x=""811"" 
d=""M531 519v384q0 44 -5.5 73.5t-18 47.5t-32.5 25.5t-50 7.5q-62 0 -98.5 -48t-36.5 -139v-351h-178v511q0 20 -0.5 43t-1 43t-1.5 34.5t-1 18.5h166q1 -3 2 -16.5t2.5 -30.5t2.5 -34.5t1 -29.5h3q15 28 34 51t43.5 39t56.5 24.5t74 8.5q110 0 163.5 -54t53.5 -175v-433
h-179z"" />
    <glyph glyph-name=""franc"" unicode=""&#x20a3;"" 
d=""M422 1201v-396h637v-208h-637v-190h314v-149h-314v-258h-285v258h-130v149h130v1002h955v-208h-670z"" />
    <glyph glyph-name=""lira"" unicode=""&#x20a4;"" 
d=""M1118 363q-13 -73 -43 -139t-79 -115.5t-116 -79t-154 -29.5h-694v205q39 22 72 46.5t56 58t36 80t13 112.5v6h-188v149h178v112h-178v149h178v104q0 92 24 167.5t75.5 129t132 82.5t194.5 29q96 0 164 -20.5t115.5 -58.5t78 -91.5t49.5 -120.5l-233 -47q-21 77 -62 112
t-107 35q-91 0 -131 -57.5t-40 -182.5v-81h286v-149h-286v-112h286v-149h-286v-4q0 -59 -12.5 -104t-35.5 -79.5t-57 -61t-77 -50.5h380q104 0 157.5 49.5t70.5 143.5z"" />
    <glyph glyph-name=""peseta"" unicode=""&#x20a7;"" horiz-adv-x=""2240"" 
d=""M1427 8q-34 -11 -66.5 -17.5t-80.5 -6.5q-125 0 -181.5 61t-56.5 184v418h-104v113q-27 -48 -67.5 -86.5t-94.5 -66.5t-120.5 -43t-146.5 -15h-110v-549h-241v1409h314q131 0 229 -30.5t163 -86t97.5 -134t32.5 -173.5q0 -47 -8 -90t-23 -82h86l88 242h125v-242h147v-166
h-147v-369q0 -37 5.5 -61.5t16.5 -38.5t28 -20t41 -6q23 0 39 3.5t35 10.5v-158zM2171 241q0 -127 -97 -194t-276 -67q-83 0 -147.5 13.5t-111.5 43.5t-78 77.5t-47 115.5l199 26q15 -61 59.5 -85t123.5 -24q36 0 66.5 3t52.5 12t34 25t12 41q0 27 -17.5 43.5t-48.5 27.5
t-74 19.5t-95 19.5q-49 11 -97.5 27.5t-86.5 45t-61.5 71.5t-23.5 106q0 115 89 175.5t260 60.5q149 0 237 -63.5t111 -187.5l-201 -17q-5 28 -18.5 47t-33 31t-43.5 17t-50 5q-69 0 -102.5 -13.5t-33.5 -49.5q0 -21 16 -34.5t45 -23t68.5 -17.5t87.5 -19q48 -10 98.5 -27
t91 -46.5t66.5 -74t26 -110.5zM752 983q0 67 -18.5 111.5t-54 71.5t-87.5 38.5t-118 11.5h-75v-476h83q67 0 117.5 12.5t84.5 41t51 75t17 114.5z"" />
    <glyph glyph-name=""Euro"" unicode=""&#x20ac;"" 
d=""M658 199q72 0 115 46t53 128l277 -16q-13 -80 -44 -149t-85 -119.5t-133 -79.5t-187 -29q-125 0 -216.5 39t-153.5 109.5t-97 168t-48 213.5h-129l40 149h77q-1 5 -1.5 20t-0.5 31q0 17 0.5 34.5t1.5 21.5h-117l40 149h87q15 123 53 219t101.5 162t153.5 100t209 34
q101 0 177 -27.5t130 -76t86.5 -114t45.5 -141.5l-280 -16q-10 74 -52 115t-116 41q-47 0 -84 -16t-64.5 -51.5t-45 -91.5t-25.5 -137h327l-29 -149h-303q-1 -11 -1.5 -26.5t-0.5 -29.5t1 -26.5t2 -24.5h340l-30 -149h-304q6 -67 21 -124t42.5 -98.5t68.5 -65t98 -23.5z"" />
    <glyph glyph-name=""afii61248"" unicode=""&#x2105;"" horiz-adv-x=""1813"" 
d=""M419 525q-99 0 -168.5 34.5t-113 95t-63.5 143t-20 178.5q0 131 31.5 217.5t82.5 138t116 72.5t132 21q75 0 131.5 -21.5t96.5 -58.5t63.5 -87.5t33.5 -108.5l-188 -12q-8 63 -41 100.5t-92 37.5q-85 0 -119.5 -71.5t-34.5 -217.5q0 -151 35 -223.5t119 -72.5
q60 0 94 38.5t42 105.5l188 -10q-7 -58 -30 -112.5t-63.5 -95.5t-98.5 -66t-133 -25zM1759 432q0 -125 -28 -211t-76 -138.5t-112.5 -75.5t-137.5 -23q-75 0 -139.5 23t-112 75.5t-75 138.5t-27.5 211q0 132 27.5 218.5t75.5 138t113.5 72t141.5 20.5q72 0 136 -20.5
t111.5 -72t75 -138t27.5 -218.5zM548 0h-206l920 1409h209zM1544 432q0 87 -8.5 144t-25.5 90.5t-42 47t-59 13.5q-37 0 -63.5 -13.5t-43.5 -47.5t-25.5 -91t-8.5 -143q0 -84 8 -139.5t25.5 -89.5t43.5 -48t62 -14q33 0 58.5 14t43 47.5t26.5 89.5t9 140z"" />
    <glyph glyph-name=""afii61289"" unicode=""&#x2113;"" horiz-adv-x=""1001"" 
d=""M582 195q80 0 122.5 53t65.5 160h146q-10 -51 -25.5 -102.5t-38.5 -99t-54.5 -89t-74 -72t-97.5 -48t-125 -17.5q-169 0 -248.5 83.5t-79.5 246.5v166q-64 -25 -132 -48v195q33 11 67.5 23.5t65.5 24.5l-1 390q0 68 18.5 134t64.5 118t123.5 84t194.5 32
q83 0 148.5 -19.5t111.5 -57.5t70 -93t24 -127q0 -98 -32.5 -182.5t-94 -154t-149.5 -124.5t-199 -93v-201q0 -96 34 -139t95 -43zM689 1107q0 69 -27 111t-84 42q-34 0 -57 -12t-36 -32t-18.5 -47t-5.5 -57v-336q54 22 96.5 56.5t71.5 77.5t44.5 93t15.5 104z"" />
    <glyph glyph-name=""afii61352"" unicode=""&#x2116;"" horiz-adv-x=""2283"" 
d=""M1524 0v166h635v-166h-635zM1039 0l-678 1095q5 -46 9 -93q4 -40 6.5 -85.5t2.5 -85.5v-831h-242v1409h297l683 -1104q-5 49 -9 99q-4 43 -6.5 92.5t-2.5 93.5v819h242v-1409h-302zM2175 623q0 -77 -21.5 -141t-64 -110t-105.5 -71.5t-147 -25.5q-80 0 -141.5 25.5
t-103.5 71t-63.5 109.5t-21.5 142q0 75 20.5 138.5t62 109.5t104.5 72t147 26q88 0 151.5 -26t104 -72t59.5 -109.5t19 -138.5zM1961 623q0 56 -7.5 93t-22.5 59.5t-37 31.5t-51 9t-52 -9.5t-39 -32t-24.5 -59.5t-8.5 -92q0 -57 8.5 -95t24 -61t37 -32.5t47.5 -9.5
q30 0 53 9.5t39 32.5t24.5 61t8.5 95z"" />
    <glyph glyph-name=""trademark"" unicode=""&#x2122;"" horiz-adv-x=""2048"" 
d=""M1059 768h-166v641h248l139 -301q9 -20 20.5 -47.5t21.5 -52.5q11 -29 23 -60q12 31 23 60l21 52.5t20 47.5l144 301h243v-641h-165v340q0 14 1 42t3 57q2 34 4 73q-16 -39 -30 -75q-12 -31 -25 -61.5t-21 -47.5l-154 -328h-131l-149 328q-8 19 -21 49.5t-26 60.5
q-15 35 -30 74q2 -41 4 -76q2 -30 2.5 -57.5t0.5 -38.5v-340zM548 1270v-502h-180v502h-243v139h674v-139h-251z"" />
    <glyph glyph-name=""uni2126"" unicode=""&#x2126;"" horiz-adv-x=""1573"" 
d=""M787 1430q156 0 281 -41t212 -119t133.5 -189.5t46.5 -252.5q0 -102 -23.5 -190.5t-73.5 -165t-127.5 -140.5t-186.5 -115q30 3 61 6q26 2 55.5 3.5t54.5 1.5h268v-228h-629v309q87 43 146 93.5t95 108t52 123.5t16 140q0 101 -25.5 180t-74 133t-119 82.5t-161.5 28.5
t-161.5 -28.5t-119 -82.5t-74 -133t-25.5 -180q0 -74 16 -140t53 -123.5t96.5 -108t147.5 -93.5v-309h-636v228h270q26 0 56.5 -1.5t56.5 -3.5q31 -3 61 -6q-111 51 -189.5 115t-129 140.5t-74 165.5t-23.5 191q0 141 46.5 252.5t133.5 189t212 118.5t282 41z"" />
    <glyph glyph-name=""estimated"" unicode=""&#x212e;"" horiz-adv-x=""1229"" 
d=""M619 -34q-130 0 -229 46.5t-166 125t-101.5 180.5t-34.5 213q0 98 22 178t60 142.5t89 109t110 76.5t123 44.5t127 14.5q113 0 209.5 -39.5t167.5 -112.5t111.5 -177.5t40.5 -235.5h-827v-356q22 -24 54 -46.5t71 -40t83 -27.5t90 -10q75 0 133 16t104.5 46t85 73.5
t72.5 98.5l72 -42q-36 -57 -77.5 -107t-96.5 -88t-126.5 -60t-166.5 -22zM917 616v277q-19 20 -48.5 41t-67.5 38t-84.5 28t-99.5 11q-51 0 -94.5 -9.5t-80.5 -25.5t-67 -37t-54 -45v-278h596z"" />
    <glyph glyph-name=""oneeighth"" unicode=""&#x215b;"" horiz-adv-x=""1708"" 
d=""M114 694v121h184v468l-173 -108v122l180 117h175v-599h170v-121h-536zM524 0h-201l895 1409h201zM1608 205q0 -46 -17.5 -85.5t-53.5 -67.5t-91.5 -44t-131.5 -16t-131.5 16t-91.5 44.5t-53.5 67t-17.5 84.5q0 39 12.5 69.5t33.5 52t47.5 35t54.5 17.5v2q-60 14 -94.5 59
t-34.5 103q0 86 69.5 138t203.5 52q72 0 124 -14t86 -39t50.5 -60.5t16.5 -77.5q0 -28 -9 -54.5t-26 -48t-41 -36.5t-55 -21v-2q32 -5 59.5 -18.5t47.5 -35t31.5 -52t11.5 -68.5zM1402 524q0 36 -18.5 59.5t-69.5 23.5q-50 0 -69 -23.5t-19 -59.5q0 -16 3.5 -31.5t13 -28
t27 -20t44.5 -7.5q29 0 46.5 8t26.5 20.5t12 28t3 30.5zM1419 220q0 18 -4.5 34.5t-17 29.5t-33.5 20.5t-54 7.5q-30 0 -50 -7.5t-32.5 -20.5t-17.5 -30t-5 -35q0 -45 23.5 -72.5t85.5 -27.5q31 0 51.5 7.5t32.5 20.5t16.5 32t4.5 41z"" />
    <glyph glyph-name=""threeeighths"" unicode=""&#x215c;"" horiz-adv-x=""1708"" 
d=""M504 0h-201l895 1409h201zM1608 205q0 -46 -17.5 -85.5t-53.5 -67.5t-91.5 -44t-131.5 -16t-131.5 16t-91.5 44.5t-53.5 67t-17.5 84.5q0 39 12.5 69.5t33.5 52t47.5 35t54.5 17.5v2q-60 14 -94.5 59t-34.5 103q0 86 69.5 138t203.5 52q72 0 124 -14t86 -39t50.5 -60.5
t16.5 -77.5q0 -28 -9 -54.5t-26 -48t-41 -36.5t-55 -21v-2q32 -5 59.5 -18.5t47.5 -35t31.5 -52t11.5 -68.5zM1402 524q0 36 -18.5 59.5t-69.5 23.5q-50 0 -69 -23.5t-19 -59.5q0 -16 3.5 -31.5t13 -28t27 -20t44.5 -7.5q29 0 46.5 8t26.5 20.5t12 28t3 30.5zM1419 220
q0 18 -4.5 34.5t-17 29.5t-33.5 20.5t-54 7.5q-30 0 -50 -7.5t-32.5 -20.5t-17.5 -30t-5 -35q0 -45 23.5 -72.5t85.5 -27.5q31 0 51.5 7.5t32.5 20.5t16.5 32t4.5 41zM678 895q0 -99 -75 -155t-213 -56q-84 0 -140.5 18t-92 47.5t-52 66.5t-21.5 76l189 12q5 -45 32.5 -69
t81.5 -24q49 0 75.5 23.5t26.5 72.5q0 31 -13.5 49.5t-34 28t-45 12.5t-46.5 3h-56v126h51q23 0 45.5 4t40.5 14t29.5 27.5t11.5 44.5q0 39 -23 61t-66 22q-42 0 -67.5 -22t-30.5 -67l-186 12q6 51 31 89.5t63.5 64t88 38t106.5 12.5q68 0 119 -14.5t84.5 -40t50.5 -60
t17 -73.5q0 -64 -36.5 -109.5t-115.5 -61.5v-2q45 -5 77.5 -20.5t53 -38.5t30.5 -51.5t10 -59.5z"" />
    <glyph glyph-name=""fiveeighths"" unicode=""&#x215d;"" horiz-adv-x=""1708"" 
d=""M504 0h-201l895 1409h201zM1608 205q0 -46 -17.5 -85.5t-53.5 -67.5t-91.5 -44t-131.5 -16t-131.5 16t-91.5 44.5t-53.5 67t-17.5 84.5q0 39 12.5 69.5t33.5 52t47.5 35t54.5 17.5v2q-60 14 -94.5 59t-34.5 103q0 86 69.5 138t203.5 52q72 0 124 -14t86 -39t50.5 -60.5
t16.5 -77.5q0 -28 -9 -54.5t-26 -48t-41 -36.5t-55 -21v-2q32 -5 59.5 -18.5t47.5 -35t31.5 -52t11.5 -68.5zM1402 524q0 36 -18.5 59.5t-69.5 23.5q-50 0 -69 -23.5t-19 -59.5q0 -16 3.5 -31.5t13 -28t27 -20t44.5 -7.5q29 0 46.5 8t26.5 20.5t12 28t3 30.5zM1419 220
q0 18 -4.5 34.5t-17 29.5t-33.5 20.5t-54 7.5q-30 0 -50 -7.5t-32.5 -20.5t-17.5 -30t-5 -35q0 -45 23.5 -72.5t85.5 -27.5q31 0 51.5 7.5t32.5 20.5t16.5 32t4.5 41zM690 939q0 -55 -19.5 -102t-57.5 -81t-94 -53t-130 -19q-68 0 -118.5 16t-85.5 44t-55 64.5t-27 78.5
l190 12q3 -17 10 -33t19 -28t30 -19.5t43 -7.5q49 0 78 32t29 92q0 53 -26 84t-78 31q-34 0 -59.5 -13.5t-39.5 -32.5h-178l29 405h495v-138h-337l-10 -136q23 19 62.5 32.5t85.5 13.5q57 0 102.5 -17.5t77 -49.5t48 -76.5t16.5 -98.5z"" />
    <glyph glyph-name=""seveneighths"" unicode=""&#x215e;"" horiz-adv-x=""1708"" 
d=""M484 0h-201l895 1409h201zM1608 205q0 -46 -17.5 -85.5t-53.5 -67.5t-91.5 -44t-131.5 -16t-131.5 16t-91.5 44.5t-53.5 67t-17.5 84.5q0 39 12.5 69.5t33.5 52t47.5 35t54.5 17.5v2q-60 14 -94.5 59t-34.5 103q0 86 69.5 138t203.5 52q72 0 124 -14t86 -39t50.5 -60.5
t16.5 -77.5q0 -28 -9 -54.5t-26 -48t-41 -36.5t-55 -21v-2q32 -5 59.5 -18.5t47.5 -35t31.5 -52t11.5 -68.5zM1402 524q0 36 -18.5 59.5t-69.5 23.5q-50 0 -69 -23.5t-19 -59.5q0 -16 3.5 -31.5t13 -28t27 -20t44.5 -7.5q29 0 46.5 8t26.5 20.5t12 28t3 30.5zM1419 220
q0 18 -4.5 34.5t-17 29.5t-33.5 20.5t-54 7.5q-30 0 -50 -7.5t-32.5 -20.5t-17.5 -30t-5 -35q0 -45 23.5 -72.5t85.5 -27.5q31 0 51.5 7.5t32.5 20.5t16.5 32t4.5 41zM744 1281q-64 -79 -111.5 -147.5t-78.5 -136.5t-46.5 -141t-15.5 -162h-193q0 83 20 156.5t56.5 143
t87 137.5t110.5 140h-410v138h579z"" />
    <glyph glyph-name=""arrowleft"" unicode=""&#x2190;"" horiz-adv-x=""2048"" 
d=""M641 551q29 -34 58.5 -83t60.5 -114h-72q-58 68 -123 124t-147 98v36q82 42 147 98t123 124h72q-31 -65 -60.5 -114t-58.5 -83h989v-86h-989z"" />
    <glyph glyph-name=""arrowup"" unicode=""&#x2191;"" horiz-adv-x=""1024"" 
d=""M469 928q-34 -29 -83 -58.5t-114 -60.5v72q68 58 124 123t98 147h36q42 -82 98 -147t124 -123v-72q-65 31 -114 60.5t-83 58.5v-989h-86v989z"" />
    <glyph glyph-name=""arrowright"" unicode=""&#x2192;"" horiz-adv-x=""2048"" 
d=""M1407 637q-29 34 -58.5 83t-60.5 114h72q58 -68 123 -124t147 -98v-36q-82 -42 -147 -98t-123 -124h-72q31 65 60.5 114t58.5 83h-989v86h989z"" />
    <glyph glyph-name=""arrowdown"" unicode=""&#x2193;"" horiz-adv-x=""1024"" 
d=""M555 162q34 29 83 58.5t114 60.5v-72q-68 -58 -124 -123t-98 -147h-36q-42 82 -98 147t-124 123v72q65 -31 114 -60.5t83 -58.5v989h86v-989z"" />
    <glyph glyph-name=""arrowboth"" unicode=""&#x2194;"" horiz-adv-x=""2048"" 
d=""M641 551q29 -34 58.5 -83t60.5 -114h-72q-58 68 -123 124t-147 98v36q82 42 147 98t123 124h72q-31 -65 -60.5 -114t-58.5 -83h766q-29 34 -58.5 83t-60.5 114h72q58 -68 123 -124t147 -98v-36q-82 -42 -147 -98t-123 -124h-72q31 65 60.5 114t58.5 83h-766z"" />
    <glyph glyph-name=""arrowupdn"" unicode=""&#x2195;"" horiz-adv-x=""1024"" 
d=""M469 928q-34 -29 -83 -58.5t-114 -60.5v72q68 58 124 123t98 147h36q42 -82 98 -147t124 -123v-72q-65 31 -114 60.5t-83 58.5v-766q34 29 83 58.5t114 60.5v-72q-68 -58 -124 -123t-98 -147h-36q-42 82 -98 147t-124 123v72q65 -31 114 -60.5t83 -58.5v766z"" />
    <glyph glyph-name=""arrowupdnbse"" unicode=""&#x21a8;"" horiz-adv-x=""1024"" 
d=""M272 -104h480v-80h-480v80zM469 928q-34 -29 -83 -58.5t-114 -60.5v72q68 58 124 123t98 147h36q42 -82 98 -147t124 -123v-72q-65 31 -114 60.5t-83 58.5v-766q34 29 83 58.5t114 60.5v-72q-68 -58 -124 -123t-98 -147h-36q-42 82 -98 147t-124 123v72q65 -31 114 -60.5
t83 -58.5v766z"" />
    <glyph glyph-name=""partialdiff"" unicode=""&#x2202;"" horiz-adv-x=""1012"" 
d=""M945 907q0 -49 -3 -101.5t-9 -105.5t-14.5 -105.5t-20.5 -100.5q-28 -117 -73 -212.5t-107.5 -164t-143 -105.5t-181.5 -37q-94 0 -159 32t-105.5 86.5t-58 126.5t-17.5 151q0 59 10 127t32 136t56 131t82 111.5t110.5 77.5t140.5 29q76 0 137 -43t92 -119h4q1 20 1 42
v48q0 173 -53 268t-164 95q-25 0 -53.5 -5t-56 -14t-53.5 -21.5t-46 -27.5l45 205q39 23 92.5 40t119.5 17q110 0 185.5 -46t122.5 -123t67.5 -179t20.5 -213zM685 645q-7 36 -21.5 67t-35 53.5t-45.5 35t-54 12.5q-41 0 -74.5 -21.5t-60 -56.5t-46.5 -81t-32.5 -94.5
t-19 -96.5t-6.5 -88q0 -46 8.5 -84t25.5 -65t42 -41.5t57 -14.5q51 0 94.5 40.5t77 107.5t57 152t33.5 175z"" />
    <glyph glyph-name=""uni2206"" unicode=""&#x2206;"" horiz-adv-x=""1253"" 
d=""M43 0v215l397 1194h368l401 -1194v-215h-1166zM709 920q-14 47 -28.5 95.5t-26.5 89.5t-20.5 69.5t-9.5 33.5q-1 -5 -9 -34t-19.5 -70.5t-25 -90t-27.5 -93.5l-207 -689h580z"" />
    <glyph glyph-name=""product"" unicode=""&#x220f;"" horiz-adv-x=""1686"" 
d=""M1200 -455v1620h-701v-1620h-295v1864h1278v-1864h-282z"" />
    <glyph glyph-name=""summation"" unicode=""&#x2211;"" horiz-adv-x=""1460"" 
d=""M134 -455v160l606 776l-586 776v152h1137v-227h-766l528 -697l-548 -712h843v-228h-1214z"" />
    <glyph glyph-name=""minus"" unicode=""&#x2212;"" horiz-adv-x=""1196"" 
d=""M85 569v224h1027v-224h-1027z"" />
    <glyph glyph-name=""radical"" unicode=""&#x221a;"" horiz-adv-x=""1124"" 
d=""M624 -25h-168l-270 754h-184v166h311l219 -635l412 1360h186z"" />
    <glyph glyph-name=""infinity"" unicode=""&#x221e;"" horiz-adv-x=""1460"" 
d=""M1389 583q0 -74 -23.5 -140.5t-66.5 -117t-102 -80t-131 -29.5q-103 0 -187 56t-149 183q-28 -49 -62.5 -91t-76 -73t-90 -48t-104.5 -17q-70 0 -130 26t-103 74t-67.5 117t-24.5 154q0 77 23.5 144t66.5 116.5t103 78t132 28.5q103 0 185.5 -55.5t147.5 -183.5
q27 49 60.5 91t73.5 73t87.5 48.5t102.5 17.5q75 0 137 -26t106 -74.5t68 -117t24 -154.5zM1042 782q-60 0 -113 -48t-101 -149q44 -94 93.5 -145t119.5 -51q36 0 65.5 15.5t50 42t31.5 62t11 76.5t-10.5 77t-30.5 62.5t-49 42t-67 15.5zM631 595q-22 47 -43.5 84
t-45.5 62.5t-51.5 38.5t-62.5 13q-37 0 -67.5 -15.5t-52.5 -42t-34 -62.5t-12 -78q0 -39 11 -74.5t32 -62.5t52 -42.5t72 -15.5q59 0 107 47.5t95 147.5z"" />
    <glyph glyph-name=""orthogonal"" unicode=""&#x221f;"" horiz-adv-x=""2005"" 
d=""M408 1223h94v-1129h1130v-94h-1224v1223z"" />
    <glyph glyph-name=""intersection"" unicode=""&#x2229;"" horiz-adv-x=""1479"" 
d=""M281 -2v512q0 116 34 212t95 165t144.5 107t181.5 38q99 0 183.5 -38t146 -107t96.5 -165t35 -212v-512h-103v514q0 98 -26.5 175.5t-74 131.5t-112.5 82.5t-143 28.5t-143 -28t-112 -82t-73 -132t-26 -178v-512h-103z"" />
    <glyph glyph-name=""integral"" unicode=""&#x222b;"" horiz-adv-x=""561"" 
d=""M26 -455q-19 0 -40.5 1.5t-42.5 4.5t-39.5 6.5t-32.5 8.5v217q21 -8 52 -16.5t67 -8.5q44 0 74 15t48 41.5t25.5 62.5t7.5 78v1151q0 87 26 157.5t76.5 120t125.5 76.5t174 27q40 0 83.5 -5.5t71.5 -13.5v-219q-20 10 -51.5 17.5t-67.5 7.5q-44 0 -74 -15.5t-48.5 -42.5
t-26.5 -62.5t-8 -74.5v-1153q0 -87 -25.5 -157.5t-76 -120t-125 -76.5t-173.5 -27z"" />
    <glyph glyph-name=""approxequal"" unicode=""&#x2248;"" horiz-adv-x=""1124"" 
d=""M814 756q-75 0 -147.5 20.5t-147.5 46.5q-132 47 -221 47q-39 0 -72.5 -6t-64 -17t-59.5 -27.5t-59 -37.5v213q51 39 119 61.5t152 22.5q41 0 82 -6.5t81 -17t79 -23.5t77 -26q45 -16 98.5 -29.5t101.5 -13.5q68 0 132 25t116 67v-219q-32 -23 -62.5 -38.5t-62 -24.5
t-66.5 -13t-76 -4zM814 274q-75 0 -147.5 22t-147.5 48q-66 23 -120.5 34t-100.5 11q-39 0 -72.5 -6t-64 -17.5t-59.5 -27.5t-59 -37v213q51 38 119 61t152 23q83 0 163 -23t156 -49q22 -7 47 -15t51 -15t52 -11t50 -4q68 0 132 25t116 67v-219q-32 -22 -62.5 -37.5t-62 -25
t-66.5 -13.5t-76 -4z"" />
    <glyph glyph-name=""notequal"" unicode=""&#x2260;"" horiz-adv-x=""1124"" 
d=""M461 291l-129 -254h-213l129 254h-219v221h327l166 330h-493v223h602l133 258h211l-131 -258h252v-223h-361l-166 -330h527v-221h-635z"" />
    <glyph glyph-name=""equivalence"" unicode=""&#x2261;"" horiz-adv-x=""1195"" 
d=""M100 956v148h995v-148h-995zM100 244v148h995v-148h-995zM100 600v148h995v-148h-995z"" />
    <glyph glyph-name=""lessequal"" unicode=""&#x2264;"" horiz-adv-x=""1124"" 
d=""M49 631v321l1026 346v-227l-832 -280l832 -279v-227zM49 0v223h1024v-223h-1024z"" />
    <glyph glyph-name=""greaterequal"" unicode=""&#x2265;"" horiz-adv-x=""1124"" 
d=""M49 285v227l831 279l-831 280v227l1026 -346v-321zM49 0v223h1026v-223h-1026z"" />
    <glyph glyph-name=""house"" unicode=""&#x2302;"" horiz-adv-x=""1237"" 
d=""M157 0v635l461 518l461 -518v-635h-922zM237 82h762v518l-381 426l-381 -426v-518z"" />
    <glyph glyph-name=""revlogicalnot"" unicode=""&#x2310;"" horiz-adv-x=""1196"" 
d=""M100 180v574h995v-146h-850v-428h-145z"" />
    <glyph glyph-name=""integraltp"" unicode=""&#x2320;"" horiz-adv-x=""1237"" 
d=""M693 -614h-147v1878q0 196 84 319q82 123 210 123q63 0 100.5 -31.5t37.5 -79.5q0 -40 -25.5 -66t-62.5 -26q-30 0 -43 10q-8 4 -21 16t-33 34q-33 39 -49 39q-36 0 -45 -39q-6 -35 -6 -140v-2037z"" />
    <glyph glyph-name=""integralbt"" unicode=""&#x2321;"" horiz-adv-x=""1237"" 
d=""M546 1706h147v-1880q0 -205 -90 -330q-40 -56 -91.5 -83t-113.5 -27q-30 0 -55 8t-43.5 22.5t-28.5 34t-10 43.5q0 20 7 37t18.5 29t27 19t33.5 7q33 0 59 -16q5 -2 15.5 -13.5t25.5 -31.5q31 -37 47 -37q37 0 45 41q7 31 7 137v2040z"" />
    <glyph glyph-name=""SF100000"" unicode=""&#x2500;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF110000"" unicode=""&#x2502;"" horiz-adv-x=""1280"" 
d=""M472 1864h145v-2485h-145v2485z"" />
    <glyph glyph-name=""SF010000"" unicode=""&#x250c;"" horiz-adv-x=""1451"" 
d=""M653 694h808v-145h-663v-1170h-145v1315z"" />
    <glyph glyph-name=""SF030000"" unicode=""&#x2510;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h808v-1315h-145v1170h-663z"" />
    <glyph glyph-name=""SF020000"" unicode=""&#x2514;"" horiz-adv-x=""1451"" 
d=""M653 1864h145v-1170h663v-145h-808v1315z"" />
    <glyph glyph-name=""SF040000"" unicode=""&#x2518;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h663v1170h145v-1315h-808z"" />
    <glyph glyph-name=""SF080000"" unicode=""&#x251c;"" horiz-adv-x=""1451"" 
d=""M653 1864h145v-1170h663v-145h-663v-1170h-145v2485z"" />
    <glyph glyph-name=""SF090000"" unicode=""&#x2524;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h663v1170h145v-2485h-145v1170h-663z"" />
    <glyph glyph-name=""SF060000"" unicode=""&#x252c;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h1471v-145h-663v-1170h-145v1170h-663z"" />
    <glyph glyph-name=""SF070000"" unicode=""&#x2534;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h663v1170h145v-1170h663v-145h-1471z"" />
    <glyph glyph-name=""SF050000"" unicode=""&#x253c;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h663v1170h145v-1170h663v-145h-663v-1170h-145v1170h-663z"" />
    <glyph glyph-name=""SF430000"" unicode=""&#x2550;"" horiz-adv-x=""1451"" 
d=""M-10 729v145h1471v-145h-1471zM-10 369v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF240000"" unicode=""&#x2551;"" horiz-adv-x=""1451"" 
d=""M473 1864h145v-2485h-145v2485zM833 1864h145v-2485h-145v2485z"" />
    <glyph glyph-name=""SF510000"" unicode=""&#x2552;"" horiz-adv-x=""1451"" 
d=""M653 874h808v-145h-663v-215h663v-145h-663v-990h-145v1495z"" />
    <glyph glyph-name=""SF520000"" unicode=""&#x2553;"" horiz-adv-x=""1451"" 
d=""M1461 694v-145h-483v-1170h-145v1170h-215v-1170h-145v1315h988z"" />
    <glyph glyph-name=""SF390000"" unicode=""&#x2554;"" horiz-adv-x=""1451"" 
d=""M473 874h988v-145h-843v-1350h-145v1495zM833 514h628v-145h-483v-990h-145v1135z"" />
    <glyph glyph-name=""SF220000"" unicode=""&#x2555;"" horiz-adv-x=""1451"" 
d=""M-10 369v145h663v215h-663v145h808v-1495h-145v990h-663z"" />
    <glyph glyph-name=""SF210000"" unicode=""&#x2556;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h988v-1315h-145v1170h-215v-1170h-145v1170h-483z"" />
    <glyph glyph-name=""SF250000"" unicode=""&#x2557;"" horiz-adv-x=""1451"" 
d=""M978 874v-1495h-145v1350h-843v145h988zM618 -621h-145v990h-483v145h628v-1135z"" />
    <glyph glyph-name=""SF500000"" unicode=""&#x2558;"" horiz-adv-x=""1451"" 
d=""M653 1864h145v-990h663v-145h-663v-215h663v-145h-808v1495z"" />
    <glyph glyph-name=""SF490000"" unicode=""&#x2559;"" horiz-adv-x=""1451"" 
d=""M833 1864h145v-1170h483v-145h-988v1315h145v-1170h215v1170z"" />
    <glyph glyph-name=""SF380000"" unicode=""&#x255a;"" horiz-adv-x=""1451"" 
d=""M473 1864h145v-1350h843v-145h-988v1495zM833 1864h145v-990h483v-145h-628v1135z"" />
    <glyph glyph-name=""SF280000"" unicode=""&#x255b;"" horiz-adv-x=""1451"" 
d=""M-10 369v145h663v215h-663v145h663v990h145v-1495h-808z"" />
    <glyph glyph-name=""SF270000"" unicode=""&#x255c;"" horiz-adv-x=""1451"" 
d=""M978 549h-988v145h483v1170h145v-1170h215v1170h145v-1315z"" />
    <glyph glyph-name=""SF260000"" unicode=""&#x255d;"" horiz-adv-x=""1451"" 
d=""M978 369h-988v145h843v1350h145v-1495zM473 1864h145v-1135h-628v145h483v990z"" />
    <glyph glyph-name=""SF360000"" unicode=""&#x255e;"" horiz-adv-x=""1451"" 
d=""M653 1864h145v-990h663v-145h-663v-215h663v-145h-663v-990h-145v2485z"" />
    <glyph glyph-name=""SF370000"" unicode=""&#x255f;"" horiz-adv-x=""1451"" 
d=""M833 1864h145v-1170h483v-145h-483v-1170h-145v2485zM473 1864h145v-2485h-145v2485z"" />
    <glyph glyph-name=""SF420000"" unicode=""&#x2560;"" horiz-adv-x=""1451"" 
d=""M618 -621h-145v2485h145v-2485zM833 514h628v-145h-483v-990h-145v1135zM833 1864h145v-990h483v-145h-628v1135z"" />
    <glyph glyph-name=""SF190000"" unicode=""&#x2561;"" horiz-adv-x=""1451"" 
d=""M-10 369v145h663v215h-663v145h663v990h145v-2485h-145v990h-663z"" />
    <glyph glyph-name=""SF200000"" unicode=""&#x2562;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h483v1170h145v-2485h-145v1170h-483zM833 1864h145v-2485h-145v2485z"" />
    <glyph glyph-name=""SF230000"" unicode=""&#x2563;"" horiz-adv-x=""1451"" 
d=""M833 1864h145v-2485h-145v2485zM473 1864h145v-1135h-628v145h483v990zM618 -621h-145v990h-483v145h628v-1135z"" />
    <glyph glyph-name=""SF470000"" unicode=""&#x2564;"" horiz-adv-x=""1451"" 
d=""M-10 369v145h1471v-145h-663v-990h-145v990h-663zM-10 729v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF480000"" unicode=""&#x2565;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h1471v-145h-483v-1170h-145v1170h-215v-1170h-145v1170h-483z"" />
    <glyph glyph-name=""SF410000"" unicode=""&#x2566;"" horiz-adv-x=""1451"" 
d=""M618 -621h-145v990h-483v145h628v-1135zM833 514h628v-145h-483v-990h-145v1135zM1461 874v-145h-1471v145h1471z"" />
    <glyph glyph-name=""SF450000"" unicode=""&#x2567;"" horiz-adv-x=""1451"" 
d=""M-10 729v145h663v990h145v-990h663v-145h-1471zM-10 369v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF460000"" unicode=""&#x2568;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h483v1170h145v-1170h215v1170h145v-1170h483v-145h-1471z"" />
    <glyph glyph-name=""SF400000"" unicode=""&#x2569;"" horiz-adv-x=""1451"" 
d=""M833 1864h145v-990h483v-145h-628v1135zM473 1864h145v-1135h-628v145h483v990zM-10 369v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF540000"" unicode=""&#x256a;"" horiz-adv-x=""1451"" 
d=""M-10 369v145h663v215h-663v145h663v990h145v-990h663v-145h-663v-215h663v-145h-663v-990h-145v990h-663z"" />
    <glyph glyph-name=""SF530000"" unicode=""&#x256b;"" horiz-adv-x=""1451"" 
d=""M833 1864h145v-1170h483v-145h-483v-1170h-145v1170h-215v-1170h-145v1170h-483v145h483v1170h145v-1170h215v1170z"" />
    <glyph glyph-name=""SF440000"" unicode=""&#x256c;"" horiz-adv-x=""1451"" 
d=""M833 1864h145v-990h483v-145h-628v1135zM618 -621h-145v990h-483v145h628v-1135zM833 514h628v-145h-483v-990h-145v1135zM473 1864h145v-1135h-628v145h483v990z"" />
    <glyph glyph-name=""upblock"" unicode=""&#x2580;"" horiz-adv-x=""1451"" 
d=""M1451 621h-1451v1243h1451v-1243z"" />
    <glyph glyph-name=""dnblock"" unicode=""&#x2584;"" horiz-adv-x=""1451"" 
d=""M1451 -621h-1451v1242h1451v-1242z"" />
    <glyph glyph-name=""block"" unicode=""&#x2588;"" horiz-adv-x=""1451"" 
d=""M1451 -621h-1451v2485h1451v-2485z"" />
    <glyph glyph-name=""lfblock"" unicode=""&#x258c;"" horiz-adv-x=""1451"" 
d=""M726 -621h-726v2485h726v-2485z"" />
    <glyph glyph-name=""rtblock"" unicode=""&#x2590;"" horiz-adv-x=""1451"" 
d=""M1451 -621h-726v2485h726v-2485z"" />
    <glyph glyph-name=""ltshade"" unicode=""&#x2591;"" horiz-adv-x=""1451"" 
d=""M103 1314h104v-98h-104v98zM517 1314h104v-98h-104v98zM933 1314h103v-98h-103v98zM310 1119h104v-96h-104v96zM725 1119h104v-96h-104v96zM1140 1119h104v-96h-104v96zM933 927h103v-96h-103v96zM517 927h104v-96h-104v96zM103 927h104v-96h-104v96zM1140 732h104v-96
h-104v96zM725 732h104v-96h-104v96zM310 732h104v-96h-104v96zM103 540h104v-96h-104v96zM517 540h104v-96h-104v96zM933 540h103v-96h-103v96zM1140 345h104v-96h-104v96zM725 345h104v-96h-104v96zM310 345h104v-96h-104v96zM103 153h104v-97h-104v97zM517 153h104v-97
h-104v97zM933 153h103v-97h-103v97zM310 -42h104v-94h-104v94zM725 -42h104v-94h-104v94zM1140 -42h104v-94h-104v94zM933 -234h103v-97h-103v97zM517 -234h104v-97h-104v97zM103 -234h104v-97h-104v97zM310 -427h104v-96h-104v96zM725 -427h104v-96h-104v96zM1140 -427h104
v-96h-104v96zM310 1506h104v-98h-104v98zM725 1506h104v-98h-104v98zM1140 1506h104v-98h-104v98zM103 1699h104v-96h-104v96zM517 1699h104v-96h-104v96zM933 1699h103v-96h-103v96zM1347 1314h104v-98h-104v98zM1347 927h104v-96h-104v96zM1347 540h104v-96h-104v96z
M1347 153h104v-97h-104v97zM1347 -234h104v-97h-104v97zM1347 1699h104v-96h-104v96z"" />
    <glyph glyph-name=""shade"" unicode=""&#x2592;"" horiz-adv-x=""1451"" 
d=""M103 1314h104v-98h-104v98zM310 1314h104v-98h-104v98zM517 1314h104v-98h-104v98zM725 1314h104v-98h-104v98zM933 1314h104v-98h-104v98zM1140 1314h104v-98h-104v98zM0 1119h103v-96h-103v96zM207 1119h103v-96h-103v96zM414 1119h103v-96h-103v96zM621 1119h104v-96
h-104v96zM829 1119h104v-96h-104v96zM1037 1119h103v-96h-103v96zM103 927h104v-96h-104v96zM310 927h104v-96h-104v96zM517 927h104v-96h-104v96zM725 927h104v-96h-104v96zM933 927h104v-96h-104v96zM1140 927h104v-96h-104v96zM0 732h103v-96h-103v96zM207 732h103v-96
h-103v96zM414 732h103v-96h-103v96zM621 732h104v-96h-104v96zM829 732h104v-96h-104v96zM1037 732h103v-96h-103v96zM103 540h104v-96h-104v96zM310 540h104v-96h-104v96zM517 540h104v-96h-104v96zM725 540h104v-96h-104v96zM933 540h104v-96h-104v96zM1140 540h104v-96
h-104v96zM0 345h103v-96h-103v96zM414 345h103v-96h-103v96zM621 345h104v-96h-104v96zM829 345h104v-96h-104v96zM1037 345h103v-96h-103v96zM207 345h103v-96h-103v96zM1140 153h104v-97h-104v97zM933 153h104v-97h-104v97zM725 153h104v-97h-104v97zM517 153h104v-97
h-104v97zM310 153h104v-97h-104v97zM103 153h104v-97h-104v97zM0 -42h103v-94h-103v94zM207 -42h103v-94h-103v94zM414 -42h103v-94h-103v94zM621 -42h104v-94h-104v94zM829 -42h104v-94h-104v94zM1037 -42h103v-94h-103v94zM1140 -234h104v-97h-104v97zM933 -234h104v-97
h-104v97zM725 -234h104v-97h-104v97zM517 -234h104v-97h-104v97zM310 -234h104v-97h-104v97zM103 -234h104v-97h-104v97zM0 -427h103v-96h-103v96zM207 -427h103v-96h-103v96zM414 -427h103v-96h-103v96zM621 -427h104v-96h-104v96zM829 -427h104v-96h-104v96zM1037 -427
h103v-96h-103v96zM0 1506h103v-98h-103v98zM207 1506h103v-98h-103v98zM414 1506h103v-98h-103v98zM621 1506h104v-98h-104v98zM829 1506h104v-98h-104v98zM1037 1506h103v-98h-103v98zM103 1699h104v-96h-104v96zM310 1699h104v-96h-104v96zM517 1699h104v-96h-104v96z
M725 1699h104v-96h-104v96zM933 1699h104v-96h-104v96zM1140 1699h104v-96h-104v96zM1347 1314h104v-98h-104v98zM1244 1119h103v-96h-103v96zM1347 927h104v-96h-104v96zM1244 732h103v-96h-103v96zM1347 540h104v-96h-104v96zM1244 345h103v-96h-103v96zM1347 153h104v-97
h-104v97zM1244 -42h103v-94h-103v94zM1347 -234h104v-97h-104v97zM1244 -427h103v-96h-103v96zM1244 1506h103v-98h-103v98zM1347 1699h104v-96h-104v96z"" />
    <glyph glyph-name=""dkshade"" unicode=""&#x2593;"" horiz-adv-x=""1493"" 
d=""M1493 -621h-1493v290h106v97h-106v290h106v97h-106v291h106v96h-106v289h106v98h-106v289h106v98h-106v289h106v96h107v-96h106v96h107v-96h106v96h107v-96h107v96h107v-96h107v96h107v-96h106v96h107v-96h106v96h107v-193h-107v-98h107v-289h-107v-96h107v-291h-107v-96
h107v-291h-107v-96h107v-291h-107v-94h107v-291h-107v-96h107v-98zM106 1119v-96h107v96h-107zM319 1119v-96h107v96h-107zM532 1119v-96h107v96h-107zM746 1119v-96h107v96h-107zM960 927h-107v-98h107v98zM746 927h-107v-98h107v98zM532 927h-106v-98h106v98zM319 927
h-106v-98h106v98zM106 732v-96h107v96h-107zM319 732v-96h107v96h-107zM532 732v-96h107v96h-107zM746 732v-96h107v96h-107zM319 540h-106v-96h106v96zM426 540v-96h106v96h-106zM639 540v-96h107v96h-107zM853 540v-96h107v96h-107zM106 345v-96h107v96h-107zM532 345v-96
h107v96h-107zM426 249v96h-107v-96h107zM746 345v-96h107v96h-107zM960 56v97h-107v-97h107zM746 56v97h-107v-97h107zM532 56v97h-106v-97h106zM319 56v97h-106v-97h106zM106 -42v-94h107v94h-107zM319 -42v-94h107v94h-107zM532 -42v-94h107v94h-107zM746 -42v-94h107v94
h-107zM960 -331v97h-107v-97h107zM746 -331v97h-107v-97h107zM532 -331v97h-106v-97h106zM319 -331v97h-106v-97h106zM106 -427v-96h107v96h-107zM319 -427v-96h107v96h-107zM532 -427v-96h107v96h-107zM746 -427v-96h107v96h-107zM960 1314h-107v-98h107v98zM746 1314h-107
v-98h107v98zM532 1314h-106v-98h106v98zM319 1314h-106v-98h106v98zM853 1506h-107v-98h107v98zM639 1506h-107v-98h107v98zM426 1506h-107v-98h107v98zM213 1506h-107v-98h107v98zM960 1119v-96h107v96h-107zM1173 1119v-96h107v96h-107zM1386 927h-106v-98h106v98z
M1173 927h-106v-98h106v98zM960 732v-96h107v96h-107zM1173 732v-96h107v96h-107zM1173 540h-106v-96h106v96zM1280 540v-96h106v96h-106zM960 345v-96h107v96h-107zM1280 249v96h-107v-96h107zM1386 56v97h-106v-97h106zM1173 56v97h-106v-97h106zM960 -42v-94h107v94h-107
zM1173 -42v-94h107v94h-107zM1386 -331v97h-106v-97h106zM1173 -331v97h-106v-97h106zM960 -427v-96h107v96h-107zM1173 -427v-96h107v96h-107zM1386 1314h-106v-98h106v98zM1173 1314h-106v-98h106v98zM1280 1506h-107v-98h107v98zM1067 1506h-107v-98h107v98z"" />
    <glyph glyph-name=""filledbox"" unicode=""&#x25a0;"" horiz-adv-x=""1237"" 
d=""M123 1108h991v-991h-991v991z"" />
    <glyph glyph-name=""H22073"" unicode=""&#x25a1;"" horiz-adv-x=""1237"" 
d=""M6 1225h1225v-1225h-1225v1225zM82 1149v-1073h1073v1073h-1073z"" />
    <glyph glyph-name=""H18543"" unicode=""&#x25aa;"" horiz-adv-x=""726"" 
d=""M617 383h-508v508h508v-508z"" />
    <glyph glyph-name=""H18551"" unicode=""&#x25ab;"" horiz-adv-x=""726"" 
d=""M617 383h-508v508h508v-508zM541 459v354h-356v-354h356z"" />
    <glyph glyph-name=""filledrect"" unicode=""&#x25ac;"" horiz-adv-x=""2048"" 
d=""M0 616h2048v-616h-2048v616z"" />
    <glyph glyph-name=""triagup"" unicode=""&#x25b2;"" horiz-adv-x=""2027"" 
d=""M414 0l600 1198l598 -1198h-1198z"" />
    <glyph glyph-name=""triagrt"" unicode=""&#x25ba;"" horiz-adv-x=""2027"" 
d=""M401 1196l1225 -610l-1225 -613v1223z"" />
    <glyph glyph-name=""triagdn"" unicode=""&#x25bc;"" horiz-adv-x=""2027"" 
d=""M1612 1171l-598 -1198l-600 1198h1198z"" />
    <glyph glyph-name=""triaglf"" unicode=""&#x25c4;"" horiz-adv-x=""2027"" 
d=""M1626 1196v-1223l-1225 613z"" />
    <glyph glyph-name=""lozenge"" unicode=""&#x25ca;"" horiz-adv-x=""1012"" 
d=""M558 0h-104l-451 721l451 725h104l454 -723zM507 1204l-289 -481l289 -494l289 494z"" />
    <glyph glyph-name=""circle"" unicode=""&#x25cb;"" horiz-adv-x=""1237"" 
d=""M167 612q0 94 35 176.5t96 144t143 97t176 35.5t176.5 -35.5t144 -97t97 -144t35.5 -176.5t-35.5 -176t-97 -143t-144 -96t-176.5 -35t-176 35t-143 96t-96 143t-35 176zM253 612q0 -76 28.5 -142t77.5 -115.5t115.5 -78t142.5 -28.5t143 28.5t116.5 78t78.5 115.5
t29 142t-29 143t-78.5 116.5t-116.5 78.5t-143 29t-142.5 -29t-115.5 -78.5t-77.5 -116.5t-28.5 -143z"" />
    <glyph glyph-name=""H18533"" unicode=""&#x25cf;"" horiz-adv-x=""1237"" 
d=""M618 1018q110 0 217 -57q53 -28 94 -69t70 -93q29 -54 44.5 -109t15.5 -112q0 -183 -129 -312t-312 -129q-182 0 -311 129t-129 312q0 58 15 112.5t44 108.5q29 52 70.5 93t93.5 69q108 57 217 57z"" />
    <glyph glyph-name=""invbullet"" unicode=""&#x25d8;"" horiz-adv-x=""1237"" 
d=""M41 0v1155h1155v-1155h-1155zM176 577q0 -91 34.5 -171t94.5 -140t140 -94.5t171 -34.5t171.5 34.5t140.5 94.5t94.5 140t34.5 171t-34.5 171.5t-94.5 140.5t-140.5 94.5t-171.5 34.5t-171 -34.5t-140 -94.5t-94.5 -140.5t-34.5 -171.5z"" />
    <glyph glyph-name=""invcircle"" unicode=""&#x25d9;"" horiz-adv-x=""1237"" 
d=""M41 0v1155h1155v-1155h-1155zM253 577q0 75 29 141.5t78.5 116t116 78.5t141.5 29t141.5 -29t116 -78.5t78.5 -116t29 -141.5t-29 -141.5t-78.5 -116t-116 -78.5t-141.5 -29t-141.5 29t-116 78.5t-78.5 116t-29 141.5zM176 577q0 -91 34.5 -171t94.5 -140t140 -94.5
t171 -34.5t171.5 34.5t140.5 94.5t94.5 140t34.5 171t-34.5 171.5t-94.5 140.5t-140.5 94.5t-171.5 34.5t-171 -34.5t-140 -94.5t-94.5 -140.5t-34.5 -171.5z"" />
    <glyph glyph-name=""openbullet"" unicode=""&#x25e6;"" horiz-adv-x=""726"" 
d=""M611 637q0 -53 -18.5 -96t-55.5 -80q-37 -35 -80 -53.5t-94 -18.5q-101 0 -176 72q-35 37 -53.5 80t-18.5 96q0 102 72 174q74 74 176 74q103 0 174 -74q74 -71 74 -174zM535 637q0 70 -51 121t-121 51t-121 -51t-51 -121q0 -69 51 -123q49 -49 121 -49t121 49
q51 54 51 123z"" />
    <glyph glyph-name=""smileface"" unicode=""&#x263a;"" horiz-adv-x=""2091"" 
d=""M1657 584q0 -254 -180 -432q-179 -179 -432 -179t-432 179q-180 178 -180 432q0 128 45 235.5t135 198.5q178 178 432 178t432 -178q90 -91 135 -198.5t45 -235.5zM1567 584q0 217 -153 370q-151 154 -369 154t-369 -154q-153 -153 -153 -370q0 -216 153 -369
q152 -154 369 -154t369 154q153 153 153 369zM889 711q0 -32 -23 -55t-55 -23t-54.5 23t-22.5 55t22.5 54.5t54.5 22.5t55 -22.5t23 -54.5zM1356 711q0 -32 -22 -55t-54 -23t-55.5 23t-23.5 55t23.5 54.5t55.5 22.5t54 -22.5t22 -54.5zM822 422q76 -137 223 -137
q145 0 221 137l62 -35q-98 -186 -283 -186q-94 0 -164.5 47.5t-118.5 138.5z"" />
    <glyph glyph-name=""invsmileface"" unicode=""&#x263b;"" horiz-adv-x=""2155"" 
d=""M1689 584q0 -254 -180 -432q-179 -179 -432 -179t-432 179q-180 178 -180 432q0 128 45 235.5t135 198.5q178 178 432 178t432 -178q90 -91 135 -198.5t45 -235.5zM921 711q0 32 -23 54.5t-55 22.5t-54.5 -22.5t-22.5 -54.5t22.5 -55t54.5 -23t55 23t23 55zM1388 711
q0 32 -22 54.5t-54 22.5t-55.5 -22.5t-23.5 -54.5t23.5 -55t55.5 -23t54 23t22 55zM794 387q48 -91 118.5 -138.5t164.5 -47.5q185 0 283 186l-62 35q-76 -137 -221 -137q-147 0 -223 137z"" />
    <glyph glyph-name=""sun"" unicode=""&#x263c;"" horiz-adv-x=""1877"" 
d=""M905 1083h66v-217q32 -3 60.5 -9t55.5 -16.5t53.5 -26.5t55.5 -38l186 182l45 -45l-184 -184q45 -59 67 -115.5t25 -113.5h215v-62h-215q-8 -60 -30 -115t-62 -106l184 -188l-49 -43l-182 182q-31 -23 -58.5 -39t-50.5 -27q-24 -9 -53 -15t-63 -11v-217h-66v217
q-63 9 -118 32t-103 58l-188 -180l-43 45l182 184q-40 51 -63 106.5t-31 118.5h-215v62h215q12 128 92 223l-180 184l40 49l189 -182q57 40 113 62t110 28v217zM936 805q-69 0 -127.5 -25t-106.5 -73q-98 -100 -98 -236q0 -137 98 -235q48 -50 106.5 -73.5t127.5 -23.5
q139 0 235 97q99 97 99 235q0 137 -99 236q-49 48 -107.5 73t-127.5 25z"" />
    <glyph glyph-name=""female"" unicode=""&#x2640;"" horiz-adv-x=""1536"" 
d=""M732 578q-55 8 -100 31t-80 65q-71 80 -71 188q0 122 83 205q44 43 94.5 64.5t110.5 21.5q118 0 201 -86q86 -83 86 -205q0 -109 -72 -190q-72 -82 -178 -94v-166h256v-70h-256v-262h-74v262h-258v70h258v166zM767 1069q-83 0 -145 -59q-29 -31 -44.5 -66.5t-15.5 -79.5
q0 -43 15.5 -78.5t44.5 -66.5q62 -62 145 -62q87 0 146 62q61 61 61 145q0 44 -15 79.5t-44 66.5q-62 59 -148 59z"" />
    <glyph glyph-name=""male"" unicode=""&#x2642;"" horiz-adv-x=""1536"" 
d=""M1023 1024q-17 5 -44 14t-64 23q-28 11 -48 23t-34 26q-5 3 -6.5 8t-1.5 10q0 8 6 17q3 2 6 3t8 1t12.5 -1t20.5 -3q32 -8 63.5 -12.5t63.5 -4.5q46 0 78 3.5t51 9.5q36 12 49 12q16 0 16 -14q0 -9 -6 -27q-9 -34 -12.5 -73.5t-3.5 -84.5q0 -31 2 -63t10 -66q2 -11 3 -19
t1 -13t-1 -8.5t-3 -6.5q-9 -6 -14 -6q-21 0 -41 39q-22 42 -37.5 83t-26.5 83l-237 -238q84 -81 84 -190q0 -125 -86 -211q-87 -88 -205 -88t-205 84q-84 84 -84 201t84 204q85 86 207 86q71 0 154 -43zM628 750q-90 0 -152 -62q-61 -61 -61 -149q0 -91 61 -152
q64 -61 152 -61q89 0 149 61q62 62 62 152q0 87 -62 149q-60 62 -149 62z"" />
    <glyph glyph-name=""spade"" unicode=""&#x2660;"" horiz-adv-x=""1088"" 
d=""M544 1231q14 -54 34 -101.5t46 -91.5q28 -43 75.5 -95.5t116.5 -115.5q141 -126 176 -192q37 -67 37 -137q0 -95 -63 -158q-66 -66 -154 -66q-157 0 -256 191q3 -147 39 -234q38 -86 119.5 -135.5t218.5 -58.5l8 -37h-792l6 37q125 0 211 49q43 25 76 59.5t55 80t32 105
t9 134.5q-45 -96 -111 -143.5t-149 -47.5q-90 0 -156 66q-63 63 -63 154q0 74 30 133q23 42 62 84.5t96 89.5q69 59 124 115.5t93 113.5q56 83 80 201z"" />
    <glyph glyph-name=""club"" unicode=""&#x2663;"" horiz-adv-x=""1344"" 
d=""M1094 0h-842l8 35q84 17 138 33.5t81 33.5q41 25 73 62.5t58 87.5q52 100 52 209q0 8 -1 19t-1 28q-58 -121 -148 -180q-43 -28 -87 -43t-89 -15q-59 0 -107.5 21t-89.5 59q-79 83 -79 199q0 115 73 194q73 80 166 80q31 0 71 -12.5t91 -38.5q-20 34 -33.5 60t-21.5 45
q-5 17 -8 36t-3 39q0 115 78 193q40 38 88.5 58t108.5 20q116 0 196 -80q80 -78 80 -187q0 -86 -69 -184q84 40 100 43q14 5 29 6.5t32 1.5q51 0 94 -18.5t79 -59.5q73 -76 73 -192q0 -118 -80 -201q-80 -80 -192 -80q-62 0 -128 30t-116 81q-17 19 -38.5 49.5t-47.5 75.5
q3 -81 14.5 -143.5t34.5 -108.5q22 -45 55.5 -83t79.5 -69q61 -39 220 -69z"" />
    <glyph glyph-name=""heart"" unicode=""&#x2665;"" horiz-adv-x=""1216"" 
d=""M610 -23q-14 56 -35 106.5t-47 98.5q-28 50 -79.5 123.5t-127.5 175.5q-56 76 -90.5 122.5t-48.5 68.5q-43 65 -61.5 118t-18.5 109q0 103 68 174q70 70 172 70q98 0 176 -72q28 -28 51.5 -68t40.5 -94q34 119 105 177.5t159 58.5q50 0 92.5 -18t77.5 -52q70 -70 70 -164
q0 -86 -41 -174q-20 -45 -59 -104.5t-99 -134.5q-75 -96 -129 -172t-86 -131q-31 -54 -53 -109t-37 -109z"" />
    <glyph glyph-name=""diamond"" unicode=""&#x2666;"" horiz-adv-x=""1045"" 
d=""M519 1223q45 -78 101.5 -160.5t125.5 -175.5t127 -163.5t105 -123.5q-39 -40 -99 -115t-143 -186q-69 -93 -122 -172.5t-93 -151.5q-13 25 -30.5 54t-39.5 61q-38 57 -87 124.5t-109 147.5q-14 20 -61 79.5t-128 158.5q50 59 114 139t144 187q59 77 107 151t88 146z"" />
    <glyph glyph-name=""musicalnote"" unicode=""&#x266a;"" horiz-adv-x=""1024"" 
d=""M489 1153h76v-100l153 -193q51 -69 80 -150.5t29 -166.5q0 -78 -24 -145t-70 -126h-47q29 65 43 127t14 121q0 60 -14 109.5t-43 89.5q-57 81 -121 90v-506q0 -63 -18.5 -112t-55.5 -87q-72 -75 -180 -75q-57 0 -86 27t-29 73q0 73 60 133q63 60 143 60q44 0 90 -19v850z
"" />
    <glyph glyph-name=""musicalnotedbl"" unicode=""&#x266b;"" horiz-adv-x=""1536"" 
d=""M1263 324q0 -63 -18 -113.5t-56 -85.5q-37 -37 -81 -56.5t-95 -19.5q-57 0 -85.5 27t-28.5 74q0 76 57 133q62 59 143 59q48 0 90 -18v448l-550 -149v-394q0 -62 -18.5 -111t-53.5 -87q-74 -74 -180 -74q-57 0 -86 26.5t-29 71.5q0 76 59 133q60 60 144 60q45 0 90 -19
v752l698 178v-835zM639 750l550 149v117l-550 -152v-114z"" />
    <glyph glyph-name=""uniFB01"" unicode=""&#xf001;"" horiz-adv-x=""1251"" 
d=""M825 1277v207h281v-207h-281zM825 0v1082h281v-1082h-281zM473 892v-892h-280v892h-158v190h158v113q0 62 15 114.5t51 91.5t97 61t152 22q48 0 94.5 -5t83.5 -11v-181q-18 4 -40.5 6.5t-41.5 2.5q-39 0 -64.5 -8t-40 -24t-20.5 -40.5t-6 -56.5v-85h213v-190h-213z"" />
    <glyph glyph-name=""uniFB01"" unicode=""&#xfb01;"" horiz-adv-x=""1251"" 
d=""M825 1277v207h281v-207h-281zM825 0v1082h281v-1082h-281zM473 892v-892h-280v892h-158v190h158v113q0 62 15 114.5t51 91.5t97 61t152 22q48 0 94.5 -5t83.5 -11v-181q-18 4 -40.5 6.5t-41.5 2.5q-39 0 -64.5 -8t-40 -24t-20.5 -40.5t-6 -56.5v-85h213v-190h-213z"" />
    <glyph glyph-name=""uniFB02"" unicode=""&#xf002;"" horiz-adv-x=""1251"" 
d=""M826 0v1484h280v-1484h-280zM473 892v-892h-280v892h-158v190h158v113q0 62 15 114.5t51 91.5t97 61t152 22q48 0 94.5 -5t83.5 -11v-181q-18 4 -40.5 6.5t-41.5 2.5q-39 0 -64.5 -8t-40 -24t-20.5 -40.5t-6 -56.5v-85h213v-190h-213z"" />
    <glyph glyph-name=""uniFB02"" unicode=""&#xfb02;"" horiz-adv-x=""1251"" 
d=""M826 0v1484h280v-1484h-280zM473 892v-892h-280v892h-158v190h158v113q0 62 15 114.5t51 91.5t97 61t152 22q48 0 94.5 -5t83.5 -11v-181q-18 4 -40.5 6.5t-41.5 2.5q-39 0 -64.5 -8t-40 -24t-20.5 -40.5t-6 -56.5v-85h213v-190h-213z"" />
    <glyph glyph-name=""uniF005"" unicode=""&#xf005;"" horiz-adv-x=""682"" 
d=""M544 -231q0 -44 -15.5 -79.5t-51 -61t-93.5 -39.5t-143 -14q-45 0 -101 6v118q25 -5 46 -6t38 -1q75 0 106 18.5t31 50.5q0 69 -113 69h-25t-26 -2l38 109q20 2 48.5 3.5t63.5 1.5q91 0 144 -46t53 -127z"" />
    <glyph glyph-name=""middot"" horiz-adv-x=""682"" 
d=""M141 531v305h288v-305h-288z"" />
    <glyph glyph-name=""commaaccent"" horiz-adv-x=""682"" 
d=""M348 -204q0 -44 -7 -79.5t-20 -66t-30 -56t-37 -49.5h-137q45 48 69.5 90t24.5 80h-108v207h245v-126z"" />
    <glyph glyph-name=""foursuperior"" horiz-adv-x=""682"" 
d=""M562 834v-140h-183v140h-344v148l316 432h211v-440h103v-140h-103zM383 1276q-3 -4 -11.5 -19.5t-19 -33.5t-20.5 -33.5t-14 -21.5l-141 -194h202v194q0 8 0.5 22t1 30t1.5 31t1 25z"" />
    <glyph glyph-name=""fivesuperior"" horiz-adv-x=""682"" 
d=""M640 939q0 -55 -19.5 -102t-57.5 -81t-94 -53t-130 -19q-68 0 -118.5 16t-85.5 44t-55 64.5t-27 78.5l190 12q3 -17 10 -33t19 -28t30 -19.5t43 -7.5q49 0 78 32t29 92q0 53 -26 84t-78 31q-34 0 -59.5 -13.5t-39.5 -32.5h-178l29 405h495v-138h-337l-10 -136
q23 19 62.5 32.5t85.5 13.5q57 0 102.5 -17.5t77 -49.5t48 -76.5t16.5 -98.5z"" />
    <glyph glyph-name=""sevensuperior"" horiz-adv-x=""682"" 
d=""M624 1281q-64 -79 -111.5 -147.5t-78.5 -136.5t-46.5 -141t-15.5 -162h-193q0 83 20 156.5t56.5 143t87 137.5t110.5 140h-410v138h579z"" />
    <glyph glyph-name=""eightsuperior"" horiz-adv-x=""682"" 
d=""M633 897q0 -46 -17.5 -85.5t-53.5 -67.5t-91.5 -44t-131.5 -16t-131.5 16t-91.5 44.5t-53.5 67t-17.5 84.5q0 39 12.5 69.5t33.5 52t47.5 35t54.5 17.5v2q-60 14 -94.5 59t-34.5 103q0 86 69.5 138t203.5 52q72 0 124 -14t86 -39t50.5 -60.5t16.5 -77.5q0 -28 -9 -54.5
t-26 -48t-41 -36.5t-55 -21v-2q32 -5 59.5 -18.5t47.5 -35t31.5 -52t11.5 -68.5zM427 1216q0 36 -18.5 59.5t-69.5 23.5q-50 0 -69 -23.5t-19 -59.5q0 -16 3.5 -31.5t13 -28t27 -20t44.5 -7.5q29 0 46.5 8t26.5 20.5t12 28t3 30.5zM444 912q0 18 -4.5 34.5t-17 29.5
t-33.5 20.5t-54 7.5q-30 0 -50 -7.5t-32.5 -20.5t-17.5 -30t-5 -35q0 -45 23.5 -72.5t85.5 -27.5q31 0 51.5 7.5t32.5 20.5t16.5 32t4.5 41z"" />
    <glyph glyph-name=""cyrillicbreve"" horiz-adv-x=""682"" 
d=""M340 1184q-82 0 -144 13t-106.5 36.5t-74 56t-47 70t-25.5 79.5t-10 85h224q5 -103 52 -151t131 -48t131 48t52 151h224q-2 -43 -10 -85t-25.5 -79.5t-47 -70t-74 -56t-106.5 -36.5t-144 -13z"" />
    <glyph glyph-name=""caroncommaaccent"" horiz-adv-x=""455"" 
d=""M358 1263q0 -43 -7 -79t-20 -66.5t-30 -56t-37 -49.5h-137q45 48 69.5 96t24.5 94h-108v207h245v-146z"" />
    <glyph glyph-name=""commaaccentrotate"" horiz-adv-x=""455"" 
d=""M103 1358q0 87 22 145.5t62 105.5h147q-45 -48 -69.5 -96t-24.5 -94h108v-207h-245v146z"" />
    <glyph glyph-name=""grave.uc"" horiz-adv-x=""682"" 
d=""M427 1530l-340 242v43h258l251 -254v-31h-169z"" />
    <glyph glyph-name=""acute.uc"" horiz-adv-x=""682"" 
d=""M87 1530v31l252 254h258v-43l-340 -242h-170z"" />
    <glyph glyph-name=""circumflex.uc"" horiz-adv-x=""682"" 
d=""M710 1559v-29h-159l-203 151h-4l-211 -151h-160v29l258 276h229z"" />
    <glyph glyph-name=""caron.uc"" horiz-adv-x=""682"" 
d=""M460 1530h-229l-258 276v29h160l211 -152h4l203 152h159v-29z"" />
    <glyph glyph-name=""dieresis.uc"" horiz-adv-x=""682"" 
d=""M469 1530v219h197v-219h-197zM15 1530v219h194v-219h-194z"" />
    <glyph glyph-name=""tilde.uc"" horiz-adv-x=""682"" 
d=""M508 1530q-44 0 -88.5 19t-86.5 42.5t-79.5 42.5t-67.5 19q-26 0 -43 -8.5t-27.5 -24.5t-16.5 -38.5t-11 -51.5h-137q3 45 11 96t31.5 95t66.5 73t116 29q45 0 90 -19t87 -42.5t78.5 -42.5t65.5 -19q25 0 41.5 8.5t28 24.5t18 39t11.5 51h135q-2 -45 -10 -96t-31 -95
t-66 -73t-116 -29z"" />
    <glyph glyph-name=""hungarumlaut.uc"" horiz-adv-x=""682"" 
d=""M50 1530h-132v34l215 252h235v-43zM456 1530h-132v34l215 252h235v-43z"" />
    <glyph glyph-name=""breve.uc"" horiz-adv-x=""682"" 
d=""M347 1520q-80 0 -143 24t-107.5 63.5t-70.5 91.5t-31 109h163q8 -32 26 -57t43 -42.5t56.5 -27t65.5 -9.5q36 0 67.5 9.5t56.5 27t42 42.5t24 57h164q-8 -57 -33.5 -109t-69 -91.5t-106.5 -63.5t-147 -24z"" />
    <hkern u1=""&#x20;"" u2=""&#x3ab;"" k=""37"" />
    <hkern u1=""&#x20;"" u2=""&#x3a5;"" k=""37"" />
    <hkern u1=""&#x20;"" u2=""&#x39b;"" k=""76"" />
    <hkern u1=""&#x20;"" u2=""&#x394;"" k=""76"" />
    <hkern u1=""&#x20;"" u2=""&#x391;"" k=""76"" />
    <hkern u1=""&#x20;"" u2=""&#x386;"" k=""76"" />
    <hkern u1=""&#x20;"" u2=""Y"" k=""37"" />
    <hkern u1=""&#x20;"" u2=""A"" k=""76"" />
    <hkern u1=""&#x31;"" u2=""&#x31;"" k=""113"" />
    <hkern u1=""A"" u2=""&#x2019;"" k=""113"" />
    <hkern u1=""A"" u2=""y"" k=""76"" />
    <hkern u1=""A"" u2=""w"" k=""37"" />
    <hkern u1=""A"" u2=""v"" k=""76"" />
    <hkern u1=""A"" u2=""Y"" k=""188"" />
    <hkern u1=""A"" u2=""W"" k=""113"" />
    <hkern u1=""A"" u2=""V"" k=""152"" />
    <hkern u1=""A"" u2=""T"" k=""152"" />
    <hkern u1=""A"" u2=""&#x20;"" k=""76"" />
    <hkern u1=""F"" u2=""A"" k=""113"" />
    <hkern u1=""F"" u2=""&#x2e;"" k=""227"" />
    <hkern u1=""F"" u2=""&#x2c;"" k=""227"" />
    <hkern u1=""L"" u2=""&#x2019;"" k=""113"" />
    <hkern u1=""L"" u2=""y"" k=""76"" />
    <hkern u1=""L"" u2=""Y"" k=""188"" />
    <hkern u1=""L"" u2=""W"" k=""113"" />
    <hkern u1=""L"" u2=""V"" k=""152"" />
    <hkern u1=""L"" u2=""T"" k=""152"" />
    <hkern u1=""L"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""P"" u2=""A"" k=""152"" />
    <hkern u1=""P"" u2=""&#x2e;"" k=""264"" />
    <hkern u1=""P"" u2=""&#x2c;"" k=""264"" />
    <hkern u1=""P"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""R"" u2=""Y"" k=""76"" />
    <hkern u1=""R"" u2=""W"" k=""37"" />
    <hkern u1=""R"" u2=""V"" k=""37"" />
    <hkern u1=""T"" u2=""y"" k=""152"" />
    <hkern u1=""T"" u2=""w"" k=""152"" />
    <hkern u1=""T"" u2=""u"" k=""152"" />
    <hkern u1=""T"" u2=""s"" k=""152"" />
    <hkern u1=""T"" u2=""r"" k=""113"" />
    <hkern u1=""T"" u2=""o"" k=""152"" />
    <hkern u1=""T"" u2=""i"" k=""37"" />
    <hkern u1=""T"" u2=""e"" k=""152"" />
    <hkern u1=""T"" u2=""c"" k=""152"" />
    <hkern u1=""T"" u2=""a"" k=""152"" />
    <hkern u1=""T"" u2=""O"" k=""37"" />
    <hkern u1=""T"" u2=""A"" k=""152"" />
    <hkern u1=""T"" u2=""&#x3b;"" k=""227"" />
    <hkern u1=""T"" u2=""&#x3a;"" k=""227"" />
    <hkern u1=""T"" u2=""&#x2e;"" k=""227"" />
    <hkern u1=""T"" u2=""&#x2d;"" k=""113"" />
    <hkern u1=""T"" u2=""&#x2c;"" k=""227"" />
    <hkern u1=""V"" u2=""y"" k=""76"" />
    <hkern u1=""V"" u2=""u"" k=""76"" />
    <hkern u1=""V"" u2=""r"" k=""113"" />
    <hkern u1=""V"" u2=""o"" k=""152"" />
    <hkern u1=""V"" u2=""i"" k=""37"" />
    <hkern u1=""V"" u2=""e"" k=""113"" />
    <hkern u1=""V"" u2=""a"" k=""113"" />
    <hkern u1=""V"" u2=""A"" k=""152"" />
    <hkern u1=""V"" u2=""&#x3b;"" k=""113"" />
    <hkern u1=""V"" u2=""&#x3a;"" k=""113"" />
    <hkern u1=""V"" u2=""&#x2e;"" k=""188"" />
    <hkern u1=""V"" u2=""&#x2d;"" k=""113"" />
    <hkern u1=""V"" u2=""&#x2c;"" k=""188"" />
    <hkern u1=""W"" u2=""y"" k=""37"" />
    <hkern u1=""W"" u2=""u"" k=""37"" />
    <hkern u1=""W"" u2=""r"" k=""37"" />
    <hkern u1=""W"" u2=""o"" k=""37"" />
    <hkern u1=""W"" u2=""i"" k=""18"" />
    <hkern u1=""W"" u2=""e"" k=""37"" />
    <hkern u1=""W"" u2=""a"" k=""76"" />
    <hkern u1=""W"" u2=""A"" k=""113"" />
    <hkern u1=""W"" u2=""&#x3b;"" k=""37"" />
    <hkern u1=""W"" u2=""&#x3a;"" k=""37"" />
    <hkern u1=""W"" u2=""&#x2e;"" k=""113"" />
    <hkern u1=""W"" u2=""&#x2d;"" k=""41"" />
    <hkern u1=""W"" u2=""&#x2c;"" k=""113"" />
    <hkern u1=""Y"" u2=""v"" k=""113"" />
    <hkern u1=""Y"" u2=""u"" k=""113"" />
    <hkern u1=""Y"" u2=""q"" k=""152"" />
    <hkern u1=""Y"" u2=""p"" k=""113"" />
    <hkern u1=""Y"" u2=""o"" k=""152"" />
    <hkern u1=""Y"" u2=""i"" k=""76"" />
    <hkern u1=""Y"" u2=""e"" k=""113"" />
    <hkern u1=""Y"" u2=""a"" k=""113"" />
    <hkern u1=""Y"" u2=""A"" k=""188"" />
    <hkern u1=""Y"" u2=""&#x3b;"" k=""152"" />
    <hkern u1=""Y"" u2=""&#x3a;"" k=""152"" />
    <hkern u1=""Y"" u2=""&#x2e;"" k=""227"" />
    <hkern u1=""Y"" u2=""&#x2d;"" k=""113"" />
    <hkern u1=""Y"" u2=""&#x2c;"" k=""227"" />
    <hkern u1=""Y"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""f"" u2=""&#x2019;"" k=""-37"" />
    <hkern u1=""r"" u2=""&#x2019;"" k=""-76"" />
    <hkern u1=""r"" u2=""&#x2e;"" k=""113"" />
    <hkern u1=""r"" u2=""&#x2c;"" k=""113"" />
    <hkern u1=""v"" u2=""&#x2e;"" k=""152"" />
    <hkern u1=""v"" u2=""&#x2c;"" k=""152"" />
    <hkern u1=""w"" u2=""&#x2e;"" k=""76"" />
    <hkern u1=""w"" u2=""&#x2c;"" k=""76"" />
    <hkern u1=""y"" u2=""&#x2e;"" k=""152"" />
    <hkern u1=""y"" u2=""&#x2c;"" k=""152"" />
    <hkern u1=""&#x386;"" u2=""&#x3c7;"" k=""76"" />
    <hkern u1=""&#x386;"" u2=""&#x3bd;"" k=""76"" />
    <hkern u1=""&#x386;"" u2=""&#x3b3;"" k=""76"" />
    <hkern u1=""&#x386;"" u2=""&#x3ab;"" k=""186"" />
    <hkern u1=""&#x386;"" u2=""&#x3a6;"" k=""55"" />
    <hkern u1=""&#x386;"" u2=""&#x3a5;"" k=""186"" />
    <hkern u1=""&#x386;"" u2=""&#x3a4;"" k=""170"" />
    <hkern u1=""&#x386;"" u2=""&#x39f;"" k=""55"" />
    <hkern u1=""&#x386;"" u2=""&#x398;"" k=""55"" />
    <hkern u1=""&#x38c;"" u2=""&#x3ab;"" k=""57"" />
    <hkern u1=""&#x38c;"" u2=""&#x3a5;"" k=""57"" />
    <hkern u1=""&#x38e;"" u2=""&#x3cc;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x3ca;"" k=""-92"" />
    <hkern u1=""&#x38e;"" u2=""&#x3c6;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x3c3;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x3bf;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x3bc;"" k=""76"" />
    <hkern u1=""&#x38e;"" u2=""&#x3ba;"" k=""76"" />
    <hkern u1=""&#x38e;"" u2=""&#x3b9;"" k=""76"" />
    <hkern u1=""&#x38e;"" u2=""&#x3b7;"" k=""76"" />
    <hkern u1=""&#x38e;"" u2=""&#x3b4;"" k=""76"" />
    <hkern u1=""&#x38e;"" u2=""&#x3b1;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x3af;"" k=""76"" />
    <hkern u1=""&#x38e;"" u2=""&#x3ae;"" k=""76"" />
    <hkern u1=""&#x38e;"" u2=""&#x3ac;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x3a9;"" k=""78"" />
    <hkern u1=""&#x38e;"" u2=""&#x3a6;"" k=""78"" />
    <hkern u1=""&#x38e;"" u2=""&#x39f;"" k=""78"" />
    <hkern u1=""&#x38e;"" u2=""&#x39b;"" k=""186"" />
    <hkern u1=""&#x38e;"" u2=""&#x398;"" k=""78"" />
    <hkern u1=""&#x38e;"" u2=""&#x394;"" k=""186"" />
    <hkern u1=""&#x38e;"" u2=""&#x391;"" k=""186"" />
    <hkern u1=""&#x38e;"" u2=""&#x390;"" k=""-256"" />
    <hkern u1=""&#x38f;"" u2=""&#x3ab;"" k=""57"" />
    <hkern u1=""&#x38f;"" u2=""&#x3a5;"" k=""57"" />
    <hkern u1=""&#x391;"" u2=""&#x2019;"" k=""113"" />
    <hkern u1=""&#x391;"" u2=""&#x3c7;"" k=""76"" />
    <hkern u1=""&#x391;"" u2=""&#x3bd;"" k=""76"" />
    <hkern u1=""&#x391;"" u2=""&#x3b3;"" k=""76"" />
    <hkern u1=""&#x391;"" u2=""&#x3ab;"" k=""186"" />
    <hkern u1=""&#x391;"" u2=""&#x3a6;"" k=""55"" />
    <hkern u1=""&#x391;"" u2=""&#x3a5;"" k=""186"" />
    <hkern u1=""&#x391;"" u2=""&#x3a4;"" k=""170"" />
    <hkern u1=""&#x391;"" u2=""&#x39f;"" k=""55"" />
    <hkern u1=""&#x391;"" u2=""&#x398;"" k=""55"" />
    <hkern u1=""&#x393;"" u2=""&#x3ca;"" k=""-94"" />
    <hkern u1=""&#x393;"" u2=""&#x3b9;"" k=""66"" />
    <hkern u1=""&#x393;"" u2=""&#x3af;"" k=""66"" />
    <hkern u1=""&#x393;"" u2=""&#x39b;"" k=""223"" />
    <hkern u1=""&#x393;"" u2=""&#x394;"" k=""223"" />
    <hkern u1=""&#x393;"" u2=""&#x391;"" k=""223"" />
    <hkern u1=""&#x393;"" u2=""&#x2e;"" k=""225"" />
    <hkern u1=""&#x393;"" u2=""&#x2c;"" k=""225"" />
    <hkern u1=""&#x394;"" u2=""&#x3ab;"" k=""186"" />
    <hkern u1=""&#x394;"" u2=""&#x3a5;"" k=""186"" />
    <hkern u1=""&#x394;"" u2=""&#x3a4;"" k=""170"" />
    <hkern u1=""&#x394;"" u2=""&#x39f;"" k=""55"" />
    <hkern u1=""&#x394;"" u2=""&#x398;"" k=""55"" />
    <hkern u1=""&#x398;"" u2=""&#x3ab;"" k=""57"" />
    <hkern u1=""&#x398;"" u2=""&#x3a5;"" k=""57"" />
    <hkern u1=""&#x398;"" u2=""&#x39b;"" k=""55"" />
    <hkern u1=""&#x398;"" u2=""&#x394;"" k=""55"" />
    <hkern u1=""&#x398;"" u2=""&#x391;"" k=""55"" />
    <hkern u1=""&#x39a;"" u2=""&#x3ce;"" k=""47"" />
    <hkern u1=""&#x39a;"" u2=""&#x3cc;"" k=""47"" />
    <hkern u1=""&#x39a;"" u2=""&#x3c9;"" k=""47"" />
    <hkern u1=""&#x39a;"" u2=""&#x3c6;"" k=""47"" />
    <hkern u1=""&#x39a;"" u2=""&#x3c3;"" k=""47"" />
    <hkern u1=""&#x39a;"" u2=""&#x3bf;"" k=""47"" />
    <hkern u1=""&#x39a;"" u2=""&#x3be;"" k=""47"" />
    <hkern u1=""&#x39a;"" u2=""&#x3b8;"" k=""47"" />
    <hkern u1=""&#x39a;"" u2=""&#x3b6;"" k=""47"" />
    <hkern u1=""&#x39a;"" u2=""&#x3b4;"" k=""47"" />
    <hkern u1=""&#x39a;"" u2=""&#x3b1;"" k=""47"" />
    <hkern u1=""&#x39a;"" u2=""&#x3ac;"" k=""47"" />
    <hkern u1=""&#x39a;"" u2=""&#x3a6;"" k=""94"" />
    <hkern u1=""&#x39a;"" u2=""&#x39f;"" k=""94"" />
    <hkern u1=""&#x39a;"" u2=""&#x398;"" k=""94"" />
    <hkern u1=""&#x39b;"" u2=""&#x3ab;"" k=""186"" />
    <hkern u1=""&#x39b;"" u2=""&#x3a5;"" k=""186"" />
    <hkern u1=""&#x39b;"" u2=""&#x3a4;"" k=""170"" />
    <hkern u1=""&#x39b;"" u2=""&#x39f;"" k=""55"" />
    <hkern u1=""&#x39b;"" u2=""&#x398;"" k=""55"" />
    <hkern u1=""&#x39f;"" u2=""&#x3ab;"" k=""57"" />
    <hkern u1=""&#x39f;"" u2=""&#x3a5;"" k=""57"" />
    <hkern u1=""&#x39f;"" u2=""&#x39b;"" k=""55"" />
    <hkern u1=""&#x39f;"" u2=""&#x394;"" k=""55"" />
    <hkern u1=""&#x39f;"" u2=""&#x391;"" k=""55"" />
    <hkern u1=""&#x3a1;"" u2=""&#x39b;"" k=""152"" />
    <hkern u1=""&#x3a1;"" u2=""&#x394;"" k=""152"" />
    <hkern u1=""&#x3a1;"" u2=""&#x391;"" k=""152"" />
    <hkern u1=""&#x3a1;"" u2=""&#x2e;"" k=""262"" />
    <hkern u1=""&#x3a1;"" u2=""&#x2c;"" k=""262"" />
    <hkern u1=""&#x3a3;"" u2=""&#x3c4;"" k=""35"" />
    <hkern u1=""&#x3a3;"" u2=""&#x3c0;"" k=""35"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3cd;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3cc;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3cb;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3ca;"" k=""-92"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c8;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c7;"" k=""123"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c6;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c5;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c3;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3bf;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3bd;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3bc;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b9;"" k=""37"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b7;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b5;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b4;"" k=""84"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b3;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b1;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3ad;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3ac;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3a9;"" k=""37"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3a6;"" k=""55"" />
    <hkern u1=""&#x3a4;"" u2=""&#x39f;"" k=""37"" />
    <hkern u1=""&#x3a4;"" u2=""&#x39b;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x398;"" k=""37"" />
    <hkern u1=""&#x3a4;"" u2=""&#x394;"" k=""164"" />
    <hkern u1=""&#x3a4;"" u2=""&#x391;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x390;"" k=""-242"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3a;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x2e;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x2d;"" k=""113"" />
    <hkern u1=""&#x3a4;"" u2=""&#x2c;"" k=""225"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3cc;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3ca;"" k=""-92"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3c6;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3c3;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3bf;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3bc;"" k=""76"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3ba;"" k=""76"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b9;"" k=""76"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b7;"" k=""76"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b4;"" k=""76"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b3;"" k=""84"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b1;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3af;"" k=""76"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3ae;"" k=""76"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3ac;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3a9;"" k=""78"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3a6;"" k=""78"" />
    <hkern u1=""&#x3a5;"" u2=""&#x39f;"" k=""78"" />
    <hkern u1=""&#x3a5;"" u2=""&#x39b;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x398;"" k=""78"" />
    <hkern u1=""&#x3a5;"" u2=""&#x394;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x391;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x390;"" k=""-256"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3a;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x2e;"" k=""225"" />
    <hkern u1=""&#x3a5;"" u2=""&#x2d;"" k=""113"" />
    <hkern u1=""&#x3a5;"" u2=""&#x2c;"" k=""225"" />
    <hkern u1=""&#x3a6;"" u2=""&#x3ab;"" k=""57"" />
    <hkern u1=""&#x3a6;"" u2=""&#x3a5;"" k=""57"" />
    <hkern u1=""&#x3a6;"" u2=""&#x3a4;"" k=""55"" />
    <hkern u1=""&#x3a6;"" u2=""&#x391;"" k=""55"" />
    <hkern u1=""&#x3a7;"" u2=""&#x3ce;"" k=""27"" />
    <hkern u1=""&#x3a7;"" u2=""&#x3c9;"" k=""27"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3ce;"" k=""37"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3cc;"" k=""37"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3c9;"" k=""37"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3c6;"" k=""37"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3c3;"" k=""37"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3bf;"" k=""37"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3b4;"" k=""37"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3b1;"" k=""37"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3ac;"" k=""37"" />
    <hkern u1=""&#x3a9;"" u2=""&#x3ab;"" k=""57"" />
    <hkern u1=""&#x3a9;"" u2=""&#x3a5;"" k=""57"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3cc;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3ca;"" k=""-92"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3c6;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3c3;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3bf;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3bc;"" k=""76"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3ba;"" k=""76"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3b9;"" k=""76"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3b7;"" k=""76"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3b4;"" k=""76"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3b1;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3af;"" k=""76"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3ae;"" k=""76"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3ac;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3a9;"" k=""78"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3a6;"" k=""78"" />
    <hkern u1=""&#x3ab;"" u2=""&#x39f;"" k=""78"" />
    <hkern u1=""&#x3ab;"" u2=""&#x39b;"" k=""186"" />
    <hkern u1=""&#x3ab;"" u2=""&#x398;"" k=""78"" />
    <hkern u1=""&#x3ab;"" u2=""&#x394;"" k=""186"" />
    <hkern u1=""&#x3ab;"" u2=""&#x391;"" k=""186"" />
    <hkern u1=""&#x3ab;"" u2=""&#x390;"" k=""-256"" />
    <hkern u1=""&#x3b4;"" u2=""&#x3c7;"" k=""74"" />
    <hkern u1=""&#x3b4;"" u2=""&#x3c4;"" k=""57"" />
    <hkern u1=""&#x3b4;"" u2=""&#x3c0;"" k=""57"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3ce;"" k=""115"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3cc;"" k=""115"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c9;"" k=""115"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c6;"" k=""115"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c4;"" k=""76"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c3;"" k=""115"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c0;"" k=""76"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3bf;"" k=""115"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3bd;"" k=""66"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3ba;"" k=""49"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b9;"" k=""49"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b8;"" k=""76"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b7;"" k=""49"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b4;"" k=""76"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b3;"" k=""66"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b1;"" k=""115"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3ae;"" k=""49"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3ac;"" k=""115"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3ce;"" k=""68"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3cc;"" k=""68"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3c9;"" k=""68"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3c6;"" k=""68"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3c3;"" k=""68"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3c2;"" k=""68"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3bf;"" k=""68"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3be;"" k=""68"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3b8;"" k=""29"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3b6;"" k=""68"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3b4;"" k=""68"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3b1;"" k=""68"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3ac;"" k=""68"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3ce;"" k=""25"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3cd;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3cc;"" k=""25"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3cb;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c9;"" k=""25"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c6;"" k=""25"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c5;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c3;"" k=""25"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c2;"" k=""25"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3bf;"" k=""25"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3be;"" k=""25"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3b6;"" k=""25"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3b4;"" k=""25"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3b1;"" k=""25"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3b0;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3ac;"" k=""25"" />
    <hkern u1=""&#x3be;"" u2=""&#x3cc;"" k=""25"" />
    <hkern u1=""&#x3be;"" u2=""&#x3c6;"" k=""25"" />
    <hkern u1=""&#x3be;"" u2=""&#x3c3;"" k=""25"" />
    <hkern u1=""&#x3be;"" u2=""&#x3c2;"" k=""25"" />
    <hkern u1=""&#x3be;"" u2=""&#x3bf;"" k=""25"" />
    <hkern u1=""&#x3be;"" u2=""&#x3be;"" k=""25"" />
    <hkern u1=""&#x3be;"" u2=""&#x3b6;"" k=""25"" />
    <hkern u1=""&#x3be;"" u2=""&#x3b4;"" k=""25"" />
    <hkern u1=""&#x3be;"" u2=""&#x3b1;"" k=""25"" />
    <hkern u1=""&#x3be;"" u2=""&#x3ac;"" k=""25"" />
    <hkern u1=""&#x3bf;"" u2=""&#x3c7;"" k=""74"" />
    <hkern u1=""&#x3bf;"" u2=""&#x3c4;"" k=""57"" />
    <hkern u1=""&#x3bf;"" u2=""&#x3c0;"" k=""57"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3ce;"" k=""57"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3c9;"" k=""57"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3c6;"" k=""57"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3c3;"" k=""57"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3c2;"" k=""57"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3bf;"" k=""57"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3bb;"" k=""76"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3b6;"" k=""57"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3b4;"" k=""57"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3b1;"" k=""57"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3ac;"" k=""57"" />
    <hkern u1=""&#x3c1;"" u2=""&#x3c4;"" k=""57"" />
    <hkern u1=""&#x3c1;"" u2=""&#x3c0;"" k=""57"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3ce;"" k=""57"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3c9;"" k=""57"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3c6;"" k=""57"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3c3;"" k=""57"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3c2;"" k=""57"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3bf;"" k=""57"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3b6;"" k=""57"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3b4;"" k=""57"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3b1;"" k=""57"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3ac;"" k=""57"" />
    <hkern u1=""&#x3c6;"" u2=""&#x3c7;"" k=""74"" />
    <hkern u1=""&#x3c6;"" u2=""&#x3c4;"" k=""57"" />
    <hkern u1=""&#x3c6;"" u2=""&#x3c0;"" k=""57"" />
    <hkern u1=""&#x3c6;"" u2=""&#x3bb;"" k=""25"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3ce;"" k=""43"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3cc;"" k=""74"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3c9;"" k=""43"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3c6;"" k=""74"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3c3;"" k=""74"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3c2;"" k=""74"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3bf;"" k=""74"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3b6;"" k=""74"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3b4;"" k=""74"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3b1;"" k=""74"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3ac;"" k=""74"" />
    <hkern u1=""&#x3c9;"" u2=""&#x3c7;"" k=""43"" />
    <hkern u1=""&#x3c9;"" u2=""&#x3c4;"" k=""57"" />
    <hkern u1=""&#x3c9;"" u2=""&#x3c0;"" k=""57"" />
    <hkern u1=""&#x3cc;"" u2=""&#x3c7;"" k=""74"" />
    <hkern u1=""&#x3cc;"" u2=""&#x3c4;"" k=""57"" />
    <hkern u1=""&#x3cc;"" u2=""&#x3c0;"" k=""57"" />
    <hkern u1=""&#x3ce;"" u2=""&#x3c7;"" k=""43"" />
    <hkern u1=""&#x3ce;"" u2=""&#x3c4;"" k=""57"" />
    <hkern u1=""&#x3ce;"" u2=""&#x3c0;"" k=""57"" />
    <hkern u1=""&#x403;"" u2=""&#xbb;"" k=""78"" />
    <hkern u1=""&#x403;"" u2=""&#xab;"" k=""78"" />
    <hkern u1=""&#x403;"" u2=""&#x3b;"" k=""27"" />
    <hkern u1=""&#x403;"" u2=""&#x3a;"" k=""27"" />
    <hkern u1=""&#x403;"" u2=""&#x2e;"" k=""256"" />
    <hkern u1=""&#x403;"" u2=""&#x2c;"" k=""231"" />
    <hkern u1=""&#x409;"" u2=""&#x2019;"" k=""205"" />
    <hkern u1=""&#x40a;"" u2=""&#x2019;"" k=""205"" />
    <hkern u1=""&#x410;"" u2=""&#x2019;"" k=""104"" />
    <hkern u1=""&#x410;"" u2=""&#x44d;"" k=""-25"" />
    <hkern u1=""&#x410;"" u2=""&#x442;"" k=""27"" />
    <hkern u1=""&#x410;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x410;"" u2=""&#x431;"" k=""27"" />
    <hkern u1=""&#x410;"" u2=""&#x430;"" k=""-25"" />
    <hkern u1=""&#x410;"" u2=""&#x42d;"" k=""51"" />
    <hkern u1=""&#x410;"" u2=""&#x427;"" k=""156"" />
    <hkern u1=""&#x410;"" u2=""&#x424;"" k=""51"" />
    <hkern u1=""&#x410;"" u2=""&#x423;"" k=""78"" />
    <hkern u1=""&#x410;"" u2=""&#x422;"" k=""102"" />
    <hkern u1=""&#x410;"" u2=""&#x421;"" k=""51"" />
    <hkern u1=""&#x410;"" u2=""&#x41f;"" k=""27"" />
    <hkern u1=""&#x410;"" u2=""&#x41e;"" k=""27"" />
    <hkern u1=""&#x410;"" u2=""&#x41b;"" k=""-25"" />
    <hkern u1=""&#x410;"" u2=""&#x414;"" k=""-76"" />
    <hkern u1=""&#x411;"" u2=""&#x443;"" k=""27"" />
    <hkern u1=""&#x411;"" u2=""&#x42f;"" k=""51"" />
    <hkern u1=""&#x411;"" u2=""&#x42d;"" k=""51"" />
    <hkern u1=""&#x411;"" u2=""&#x42a;"" k=""78"" />
    <hkern u1=""&#x411;"" u2=""&#x427;"" k=""78"" />
    <hkern u1=""&#x411;"" u2=""&#x425;"" k=""51"" />
    <hkern u1=""&#x411;"" u2=""&#x424;"" k=""27"" />
    <hkern u1=""&#x411;"" u2=""&#x423;"" k=""51"" />
    <hkern u1=""&#x411;"" u2=""&#x422;"" k=""51"" />
    <hkern u1=""&#x411;"" u2=""&#x421;"" k=""27"" />
    <hkern u1=""&#x411;"" u2=""&#x41b;"" k=""51"" />
    <hkern u1=""&#x411;"" u2=""&#x417;"" k=""27"" />
    <hkern u1=""&#x411;"" u2=""&#x416;"" k=""51"" />
    <hkern u1=""&#x411;"" u2=""&#x410;"" k=""78"" />
    <hkern u1=""&#x412;"" u2=""&#x447;"" k=""78"" />
    <hkern u1=""&#x412;"" u2=""&#x445;"" k=""27"" />
    <hkern u1=""&#x412;"" u2=""&#x442;"" k=""27"" />
    <hkern u1=""&#x412;"" u2=""&#x42f;"" k=""51"" />
    <hkern u1=""&#x412;"" u2=""&#x42a;"" k=""102"" />
    <hkern u1=""&#x412;"" u2=""&#x427;"" k=""78"" />
    <hkern u1=""&#x412;"" u2=""&#x425;"" k=""78"" />
    <hkern u1=""&#x412;"" u2=""&#x424;"" k=""51"" />
    <hkern u1=""&#x412;"" u2=""&#x423;"" k=""78"" />
    <hkern u1=""&#x412;"" u2=""&#x422;"" k=""78"" />
    <hkern u1=""&#x412;"" u2=""&#x421;"" k=""78"" />
    <hkern u1=""&#x412;"" u2=""&#x41e;"" k=""51"" />
    <hkern u1=""&#x412;"" u2=""&#x41b;"" k=""51"" />
    <hkern u1=""&#x412;"" u2=""&#x417;"" k=""27"" />
    <hkern u1=""&#x412;"" u2=""&#x416;"" k=""78"" />
    <hkern u1=""&#x412;"" u2=""&#x414;"" k=""27"" />
    <hkern u1=""&#x412;"" u2=""&#x410;"" k=""102"" />
    <hkern u1=""&#x413;"" u2=""&#x44f;"" k=""78"" />
    <hkern u1=""&#x413;"" u2=""&#x44e;"" k=""78"" />
    <hkern u1=""&#x413;"" u2=""&#x44c;"" k=""78"" />
    <hkern u1=""&#x413;"" u2=""&#x44b;"" k=""78"" />
    <hkern u1=""&#x413;"" u2=""&#x443;"" k=""78"" />
    <hkern u1=""&#x413;"" u2=""&#x440;"" k=""78"" />
    <hkern u1=""&#x413;"" u2=""&#x43e;"" k=""102"" />
    <hkern u1=""&#x413;"" u2=""&#x43d;"" k=""51"" />
    <hkern u1=""&#x413;"" u2=""&#x43c;"" k=""78"" />
    <hkern u1=""&#x413;"" u2=""&#x43b;"" k=""102"" />
    <hkern u1=""&#x413;"" u2=""&#x438;"" k=""51"" />
    <hkern u1=""&#x413;"" u2=""&#x435;"" k=""104"" />
    <hkern u1=""&#x413;"" u2=""&#x434;"" k=""78"" />
    <hkern u1=""&#x413;"" u2=""&#x432;"" k=""51"" />
    <hkern u1=""&#x413;"" u2=""&#x430;"" k=""27"" />
    <hkern u1=""&#x413;"" u2=""&#x421;"" k=""27"" />
    <hkern u1=""&#x413;"" u2=""&#x41e;"" k=""27"" />
    <hkern u1=""&#x413;"" u2=""&#x41b;"" k=""51"" />
    <hkern u1=""&#x413;"" u2=""&#x414;"" k=""51"" />
    <hkern u1=""&#x413;"" u2=""&#x410;"" k=""129"" />
    <hkern u1=""&#x413;"" u2=""&#xbb;"" k=""78"" />
    <hkern u1=""&#x413;"" u2=""&#xab;"" k=""78"" />
    <hkern u1=""&#x413;"" u2=""&#x3b;"" k=""27"" />
    <hkern u1=""&#x413;"" u2=""&#x3a;"" k=""27"" />
    <hkern u1=""&#x413;"" u2=""&#x2e;"" k=""256"" />
    <hkern u1=""&#x413;"" u2=""&#x2c;"" k=""231"" />
    <hkern u1=""&#x414;"" u2=""&#x443;"" k=""-25"" />
    <hkern u1=""&#x414;"" u2=""&#x43e;"" k=""-25"" />
    <hkern u1=""&#x414;"" u2=""&#x437;"" k=""-51"" />
    <hkern u1=""&#x414;"" u2=""&#x435;"" k=""-25"" />
    <hkern u1=""&#x414;"" u2=""&#x427;"" k=""27"" />
    <hkern u1=""&#x414;"" u2=""&#x424;"" k=""27"" />
    <hkern u1=""&#x414;"" u2=""&#x423;"" k=""-25"" />
    <hkern u1=""&#x414;"" u2=""&#x417;"" k=""-25"" />
    <hkern u1=""&#x416;"" u2=""&#x43e;"" k=""27"" />
    <hkern u1=""&#x416;"" u2=""&#x430;"" k=""-25"" />
    <hkern u1=""&#x416;"" u2=""&#x42a;"" k=""-76"" />
    <hkern u1=""&#x416;"" u2=""&#x427;"" k=""-25"" />
    <hkern u1=""&#x416;"" u2=""&#x423;"" k=""-51"" />
    <hkern u1=""&#x416;"" u2=""&#x422;"" k=""-51"" />
    <hkern u1=""&#x416;"" u2=""&#x421;"" k=""51"" />
    <hkern u1=""&#x416;"" u2=""&#x41e;"" k=""27"" />
    <hkern u1=""&#x416;"" u2=""&#x417;"" k=""-25"" />
    <hkern u1=""&#x417;"" u2=""&#x42f;"" k=""51"" />
    <hkern u1=""&#x417;"" u2=""&#x427;"" k=""78"" />
    <hkern u1=""&#x417;"" u2=""&#x424;"" k=""51"" />
    <hkern u1=""&#x417;"" u2=""&#x423;"" k=""78"" />
    <hkern u1=""&#x417;"" u2=""&#x422;"" k=""78"" />
    <hkern u1=""&#x417;"" u2=""&#x421;"" k=""51"" />
    <hkern u1=""&#x417;"" u2=""&#x41e;"" k=""27"" />
    <hkern u1=""&#x417;"" u2=""&#x41b;"" k=""51"" />
    <hkern u1=""&#x417;"" u2=""&#x416;"" k=""51"" />
    <hkern u1=""&#x41a;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x41a;"" u2=""&#x437;"" k=""-25"" />
    <hkern u1=""&#x41a;"" u2=""&#x430;"" k=""-25"" />
    <hkern u1=""&#x41a;"" u2=""&#x42d;"" k=""-25"" />
    <hkern u1=""&#x41a;"" u2=""&#x427;"" k=""-51"" />
    <hkern u1=""&#x41a;"" u2=""&#x424;"" k=""27"" />
    <hkern u1=""&#x41a;"" u2=""&#x423;"" k=""-51"" />
    <hkern u1=""&#x41a;"" u2=""&#x422;"" k=""-51"" />
    <hkern u1=""&#x41a;"" u2=""&#x421;"" k=""27"" />
    <hkern u1=""&#x41a;"" u2=""&#x417;"" k=""-76"" />
    <hkern u1=""&#x41b;"" u2=""&#x430;"" k=""-51"" />
    <hkern u1=""&#x41c;"" u2=""&#x447;"" k=""27"" />
    <hkern u1=""&#x41c;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x41c;"" u2=""&#x430;"" k=""-25"" />
    <hkern u1=""&#x41e;"" u2=""&#x43b;"" k=""27"" />
    <hkern u1=""&#x41e;"" u2=""&#x434;"" k=""51"" />
    <hkern u1=""&#x41e;"" u2=""&#x42f;"" k=""27"" />
    <hkern u1=""&#x41e;"" u2=""&#x425;"" k=""78"" />
    <hkern u1=""&#x41e;"" u2=""&#x423;"" k=""51"" />
    <hkern u1=""&#x41e;"" u2=""&#x41b;"" k=""51"" />
    <hkern u1=""&#x41e;"" u2=""&#x416;"" k=""27"" />
    <hkern u1=""&#x41e;"" u2=""&#x414;"" k=""27"" />
    <hkern u1=""&#x41e;"" u2=""&#x410;"" k=""51"" />
    <hkern u1=""&#x420;"" u2=""&#x44f;"" k=""27"" />
    <hkern u1=""&#x420;"" u2=""&#x43e;"" k=""51"" />
    <hkern u1=""&#x420;"" u2=""&#x435;"" k=""51"" />
    <hkern u1=""&#x420;"" u2=""&#x434;"" k=""129"" />
    <hkern u1=""&#x420;"" u2=""&#x430;"" k=""27"" />
    <hkern u1=""&#x420;"" u2=""&#x42f;"" k=""51"" />
    <hkern u1=""&#x420;"" u2=""&#x425;"" k=""78"" />
    <hkern u1=""&#x420;"" u2=""&#x424;"" k=""27"" />
    <hkern u1=""&#x420;"" u2=""&#x423;"" k=""27"" />
    <hkern u1=""&#x420;"" u2=""&#x422;"" k=""27"" />
    <hkern u1=""&#x420;"" u2=""&#x421;"" k=""51"" />
    <hkern u1=""&#x420;"" u2=""&#x41e;"" k=""27"" />
    <hkern u1=""&#x420;"" u2=""&#x41c;"" k=""27"" />
    <hkern u1=""&#x420;"" u2=""&#x41b;"" k=""129"" />
    <hkern u1=""&#x420;"" u2=""&#x417;"" k=""27"" />
    <hkern u1=""&#x420;"" u2=""&#x416;"" k=""27"" />
    <hkern u1=""&#x420;"" u2=""&#x414;"" k=""129"" />
    <hkern u1=""&#x420;"" u2=""&#x410;"" k=""180"" />
    <hkern u1=""&#x420;"" u2=""&#x3b;"" k=""27"" />
    <hkern u1=""&#x420;"" u2=""&#x3a;"" k=""27"" />
    <hkern u1=""&#x420;"" u2=""&#x2e;"" k=""307"" />
    <hkern u1=""&#x420;"" u2=""&#x2c;"" k=""283"" />
    <hkern u1=""&#x421;"" u2=""&#x447;"" k=""27"" />
    <hkern u1=""&#x421;"" u2=""&#x444;"" k=""27"" />
    <hkern u1=""&#x421;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x421;"" u2=""&#x436;"" k=""-25"" />
    <hkern u1=""&#x421;"" u2=""&#x431;"" k=""27"" />
    <hkern u1=""&#x421;"" u2=""&#x430;"" k=""-25"" />
    <hkern u1=""&#x421;"" u2=""&#x42d;"" k=""27"" />
    <hkern u1=""&#x421;"" u2=""&#x42a;"" k=""27"" />
    <hkern u1=""&#x421;"" u2=""&#x427;"" k=""51"" />
    <hkern u1=""&#x421;"" u2=""&#x425;"" k=""78"" />
    <hkern u1=""&#x421;"" u2=""&#x423;"" k=""27"" />
    <hkern u1=""&#x421;"" u2=""&#x422;"" k=""51"" />
    <hkern u1=""&#x421;"" u2=""&#x41e;"" k=""51"" />
    <hkern u1=""&#x421;"" u2=""&#x41c;"" k=""27"" />
    <hkern u1=""&#x421;"" u2=""&#x41b;"" k=""51"" />
    <hkern u1=""&#x421;"" u2=""&#x417;"" k=""27"" />
    <hkern u1=""&#x421;"" u2=""&#x414;"" k=""27"" />
    <hkern u1=""&#x421;"" u2=""&#x410;"" k=""51"" />
    <hkern u1=""&#x422;"" u2=""&#x44f;"" k=""51"" />
    <hkern u1=""&#x422;"" u2=""&#x44e;"" k=""27"" />
    <hkern u1=""&#x422;"" u2=""&#x44c;"" k=""27"" />
    <hkern u1=""&#x422;"" u2=""&#x44b;"" k=""27"" />
    <hkern u1=""&#x422;"" u2=""&#x449;"" k=""27"" />
    <hkern u1=""&#x422;"" u2=""&#x445;"" k=""78"" />
    <hkern u1=""&#x422;"" u2=""&#x443;"" k=""78"" />
    <hkern u1=""&#x422;"" u2=""&#x441;"" k=""129"" />
    <hkern u1=""&#x422;"" u2=""&#x440;"" k=""78"" />
    <hkern u1=""&#x422;"" u2=""&#x43f;"" k=""27"" />
    <hkern u1=""&#x422;"" u2=""&#x43e;"" k=""129"" />
    <hkern u1=""&#x422;"" u2=""&#x43c;"" k=""104"" />
    <hkern u1=""&#x422;"" u2=""&#x43b;"" k=""129"" />
    <hkern u1=""&#x422;"" u2=""&#x43a;"" k=""78"" />
    <hkern u1=""&#x422;"" u2=""&#x438;"" k=""78"" />
    <hkern u1=""&#x422;"" u2=""&#x435;"" k=""102"" />
    <hkern u1=""&#x422;"" u2=""&#x432;"" k=""78"" />
    <hkern u1=""&#x422;"" u2=""&#x430;"" k=""51"" />
    <hkern u1=""&#x422;"" u2=""&#x42f;"" k=""27"" />
    <hkern u1=""&#x422;"" u2=""&#x424;"" k=""78"" />
    <hkern u1=""&#x422;"" u2=""&#x41e;"" k=""51"" />
    <hkern u1=""&#x422;"" u2=""&#x41b;"" k=""51"" />
    <hkern u1=""&#x422;"" u2=""&#x416;"" k=""-51"" />
    <hkern u1=""&#x422;"" u2=""&#x414;"" k=""51"" />
    <hkern u1=""&#x422;"" u2=""&#x410;"" k=""129"" />
    <hkern u1=""&#x422;"" u2=""&#xab;"" k=""51"" />
    <hkern u1=""&#x422;"" u2=""&#x3b;"" k=""27"" />
    <hkern u1=""&#x422;"" u2=""&#x3a;"" k=""27"" />
    <hkern u1=""&#x422;"" u2=""&#x2e;"" k=""231"" />
    <hkern u1=""&#x422;"" u2=""&#x2c;"" k=""205"" />
    <hkern u1=""&#x423;"" u2=""&#x44f;"" k=""102"" />
    <hkern u1=""&#x423;"" u2=""&#x44e;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x449;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x448;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x446;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x445;"" k=""51"" />
    <hkern u1=""&#x423;"" u2=""&#x441;"" k=""129"" />
    <hkern u1=""&#x423;"" u2=""&#x440;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x43f;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x43e;"" k=""129"" />
    <hkern u1=""&#x423;"" u2=""&#x43d;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x43c;"" k=""102"" />
    <hkern u1=""&#x423;"" u2=""&#x43b;"" k=""129"" />
    <hkern u1=""&#x423;"" u2=""&#x43a;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x439;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x438;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x437;"" k=""102"" />
    <hkern u1=""&#x423;"" u2=""&#x436;"" k=""27"" />
    <hkern u1=""&#x423;"" u2=""&#x435;"" k=""129"" />
    <hkern u1=""&#x423;"" u2=""&#x434;"" k=""129"" />
    <hkern u1=""&#x423;"" u2=""&#x433;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x432;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x431;"" k=""51"" />
    <hkern u1=""&#x423;"" u2=""&#x42f;"" k=""51"" />
    <hkern u1=""&#x423;"" u2=""&#x42d;"" k=""27"" />
    <hkern u1=""&#x423;"" u2=""&#x424;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x41e;"" k=""51"" />
    <hkern u1=""&#x423;"" u2=""&#x41b;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x414;"" k=""104"" />
    <hkern u1=""&#x423;"" u2=""&#x410;"" k=""154"" />
    <hkern u1=""&#x423;"" u2=""&#xbb;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#xab;"" k=""78"" />
    <hkern u1=""&#x423;"" u2=""&#x3b;"" k=""51"" />
    <hkern u1=""&#x423;"" u2=""&#x3a;"" k=""51"" />
    <hkern u1=""&#x423;"" u2=""&#x2e;"" k=""256"" />
    <hkern u1=""&#x423;"" u2=""&#x2c;"" k=""231"" />
    <hkern u1=""&#x424;"" u2=""&#x43b;"" k=""51"" />
    <hkern u1=""&#x424;"" u2=""&#x42f;"" k=""53"" />
    <hkern u1=""&#x424;"" u2=""&#x427;"" k=""27"" />
    <hkern u1=""&#x424;"" u2=""&#x424;"" k=""27"" />
    <hkern u1=""&#x424;"" u2=""&#x423;"" k=""78"" />
    <hkern u1=""&#x424;"" u2=""&#x422;"" k=""78"" />
    <hkern u1=""&#x424;"" u2=""&#x41b;"" k=""78"" />
    <hkern u1=""&#x424;"" u2=""&#x414;"" k=""104"" />
    <hkern u1=""&#x424;"" u2=""&#x410;"" k=""51"" />
    <hkern u1=""&#x425;"" u2=""&#x443;"" k=""27"" />
    <hkern u1=""&#x425;"" u2=""&#x43e;"" k=""27"" />
    <hkern u1=""&#x425;"" u2=""&#x42d;"" k=""51"" />
    <hkern u1=""&#x425;"" u2=""&#x424;"" k=""78"" />
    <hkern u1=""&#x425;"" u2=""&#x421;"" k=""78"" />
    <hkern u1=""&#x425;"" u2=""&#x41e;"" k=""53"" />
    <hkern u1=""&#x425;"" u2=""&#x417;"" k=""27"" />
    <hkern u1=""&#x426;"" u2=""&#x43e;"" k=""-25"" />
    <hkern u1=""&#x426;"" u2=""&#x435;"" k=""-25"" />
    <hkern u1=""&#x426;"" u2=""&#x430;"" k=""-76"" />
    <hkern u1=""&#x429;"" u2=""&#x430;"" k=""-25"" />
    <hkern u1=""&#x42a;"" u2=""&#x2019;"" k=""205"" />
    <hkern u1=""&#x42a;"" u2=""&#x42f;"" k=""78"" />
    <hkern u1=""&#x42c;"" u2=""&#x2019;"" k=""154"" />
    <hkern u1=""&#x42c;"" u2=""&#x42f;"" k=""78"" />
    <hkern u1=""&#x42c;"" u2=""&#x42d;"" k=""78"" />
    <hkern u1=""&#x42c;"" u2=""&#x427;"" k=""154"" />
    <hkern u1=""&#x42c;"" u2=""&#x425;"" k=""104"" />
    <hkern u1=""&#x42c;"" u2=""&#x422;"" k=""207"" />
    <hkern u1=""&#x42c;"" u2=""&#x421;"" k=""51"" />
    <hkern u1=""&#x42c;"" u2=""&#x41e;"" k=""27"" />
    <hkern u1=""&#x42c;"" u2=""&#x41c;"" k=""51"" />
    <hkern u1=""&#x42c;"" u2=""&#x41b;"" k=""78"" />
    <hkern u1=""&#x42c;"" u2=""&#x417;"" k=""51"" />
    <hkern u1=""&#x42c;"" u2=""&#x416;"" k=""78"" />
    <hkern u1=""&#x42c;"" u2=""&#x414;"" k=""27"" />
    <hkern u1=""&#x42c;"" u2=""&#x410;"" k=""51"" />
    <hkern u1=""&#x42d;"" u2=""&#x43b;"" k=""51"" />
    <hkern u1=""&#x42d;"" u2=""&#x436;"" k=""-25"" />
    <hkern u1=""&#x42d;"" u2=""&#x434;"" k=""27"" />
    <hkern u1=""&#x42d;"" u2=""&#x42f;"" k=""51"" />
    <hkern u1=""&#x42d;"" u2=""&#x425;"" k=""51"" />
    <hkern u1=""&#x42d;"" u2=""&#x424;"" k=""27"" />
    <hkern u1=""&#x42d;"" u2=""&#x41b;"" k=""78"" />
    <hkern u1=""&#x42d;"" u2=""&#x417;"" k=""27"" />
    <hkern u1=""&#x42d;"" u2=""&#x416;"" k=""51"" />
    <hkern u1=""&#x42d;"" u2=""&#x414;"" k=""51"" />
    <hkern u1=""&#x42e;"" u2=""&#x43b;"" k=""51"" />
    <hkern u1=""&#x42e;"" u2=""&#x436;"" k=""-25"" />
    <hkern u1=""&#x42e;"" u2=""&#x434;"" k=""51"" />
    <hkern u1=""&#x42e;"" u2=""&#x427;"" k=""27"" />
    <hkern u1=""&#x42e;"" u2=""&#x425;"" k=""78"" />
    <hkern u1=""&#x42e;"" u2=""&#x422;"" k=""51"" />
    <hkern u1=""&#x42e;"" u2=""&#x421;"" k=""27"" />
    <hkern u1=""&#x42e;"" u2=""&#x41b;"" k=""78"" />
    <hkern u1=""&#x42e;"" u2=""&#x416;"" k=""51"" />
    <hkern u1=""&#x42e;"" u2=""&#x414;"" k=""51"" />
    <hkern u1=""&#x42e;"" u2=""&#x410;"" k=""51"" />
    <hkern u1=""&#x430;"" u2=""&#x447;"" k=""51"" />
    <hkern u1=""&#x430;"" u2=""&#x437;"" k=""-25"" />
    <hkern u1=""&#x431;"" u2=""&#x44f;"" k=""27"" />
    <hkern u1=""&#x431;"" u2=""&#x44d;"" k=""27"" />
    <hkern u1=""&#x431;"" u2=""&#x44a;"" k=""27"" />
    <hkern u1=""&#x431;"" u2=""&#x447;"" k=""51"" />
    <hkern u1=""&#x431;"" u2=""&#x445;"" k=""51"" />
    <hkern u1=""&#x431;"" u2=""&#x443;"" k=""27"" />
    <hkern u1=""&#x431;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x431;"" u2=""&#x43c;"" k=""27"" />
    <hkern u1=""&#x431;"" u2=""&#x43b;"" k=""51"" />
    <hkern u1=""&#x431;"" u2=""&#x437;"" k=""27"" />
    <hkern u1=""&#x431;"" u2=""&#x436;"" k=""27"" />
    <hkern u1=""&#x431;"" u2=""&#x434;"" k=""51"" />
    <hkern u1=""&#x432;"" u2=""&#x44f;"" k=""27"" />
    <hkern u1=""&#x432;"" u2=""&#x44a;"" k=""51"" />
    <hkern u1=""&#x432;"" u2=""&#x447;"" k=""78"" />
    <hkern u1=""&#x432;"" u2=""&#x444;"" k=""27"" />
    <hkern u1=""&#x432;"" u2=""&#x443;"" k=""51"" />
    <hkern u1=""&#x432;"" u2=""&#x442;"" k=""27"" />
    <hkern u1=""&#x432;"" u2=""&#x441;"" k=""51"" />
    <hkern u1=""&#x432;"" u2=""&#x43e;"" k=""27"" />
    <hkern u1=""&#x432;"" u2=""&#x43c;"" k=""27"" />
    <hkern u1=""&#x432;"" u2=""&#x43b;"" k=""27"" />
    <hkern u1=""&#x432;"" u2=""&#x436;"" k=""27"" />
    <hkern u1=""&#x432;"" u2=""&#x435;"" k=""27"" />
    <hkern u1=""&#x432;"" u2=""&#x431;"" k=""27"" />
    <hkern u1=""&#x432;"" u2=""&#x430;"" k=""27"" />
    <hkern u1=""&#x433;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x433;"" u2=""&#x43e;"" k=""27"" />
    <hkern u1=""&#x433;"" u2=""&#x43b;"" k=""51"" />
    <hkern u1=""&#x433;"" u2=""&#x434;"" k=""78"" />
    <hkern u1=""&#x433;"" u2=""&#x2e;"" k=""205"" />
    <hkern u1=""&#x433;"" u2=""&#x2c;"" k=""180"" />
    <hkern u1=""&#x434;"" u2=""&#x44a;"" k=""27"" />
    <hkern u1=""&#x434;"" u2=""&#x443;"" k=""-25"" />
    <hkern u1=""&#x434;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x434;"" u2=""&#x437;"" k=""-25"" />
    <hkern u1=""&#x435;"" u2=""&#x447;"" k=""51"" />
    <hkern u1=""&#x435;"" u2=""&#x445;"" k=""27"" />
    <hkern u1=""&#x435;"" u2=""&#x443;"" k=""27"" />
    <hkern u1=""&#x435;"" u2=""&#x442;"" k=""27"" />
    <hkern u1=""&#x435;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x435;"" u2=""&#x43c;"" k=""27"" />
    <hkern u1=""&#x435;"" u2=""&#x436;"" k=""27"" />
    <hkern u1=""&#x435;"" u2=""&#x431;"" k=""27"" />
    <hkern u1=""&#x436;"" u2=""&#x447;"" k=""51"" />
    <hkern u1=""&#x436;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x436;"" u2=""&#x43e;"" k=""51"" />
    <hkern u1=""&#x436;"" u2=""&#x437;"" k=""-25"" />
    <hkern u1=""&#x436;"" u2=""&#x435;"" k=""27"" />
    <hkern u1=""&#x436;"" u2=""&#x430;"" k=""-25"" />
    <hkern u1=""&#x437;"" u2=""&#x44a;"" k=""51"" />
    <hkern u1=""&#x437;"" u2=""&#x447;"" k=""78"" />
    <hkern u1=""&#x437;"" u2=""&#x444;"" k=""27"" />
    <hkern u1=""&#x437;"" u2=""&#x443;"" k=""51"" />
    <hkern u1=""&#x437;"" u2=""&#x441;"" k=""51"" />
    <hkern u1=""&#x437;"" u2=""&#x43e;"" k=""51"" />
    <hkern u1=""&#x437;"" u2=""&#x43c;"" k=""51"" />
    <hkern u1=""&#x437;"" u2=""&#x43b;"" k=""27"" />
    <hkern u1=""&#x437;"" u2=""&#x437;"" k=""27"" />
    <hkern u1=""&#x437;"" u2=""&#x436;"" k=""27"" />
    <hkern u1=""&#x437;"" u2=""&#x435;"" k=""27"" />
    <hkern u1=""&#x437;"" u2=""&#x431;"" k=""51"" />
    <hkern u1=""&#x437;"" u2=""&#x430;"" k=""27"" />
    <hkern u1=""&#x43a;"" u2=""&#x44d;"" k=""27"" />
    <hkern u1=""&#x43a;"" u2=""&#x447;"" k=""27"" />
    <hkern u1=""&#x43a;"" u2=""&#x444;"" k=""27"" />
    <hkern u1=""&#x43a;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x43a;"" u2=""&#x43e;"" k=""27"" />
    <hkern u1=""&#x43a;"" u2=""&#x43b;"" k=""-25"" />
    <hkern u1=""&#x43b;"" u2=""&#x447;"" k=""51"" />
    <hkern u1=""&#x43b;"" u2=""&#x443;"" k=""27"" />
    <hkern u1=""&#x43b;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x43b;"" u2=""&#x43e;"" k=""27"" />
    <hkern u1=""&#x43b;"" u2=""&#x435;"" k=""27"" />
    <hkern u1=""&#x43b;"" u2=""&#x431;"" k=""27"" />
    <hkern u1=""&#x43c;"" u2=""&#x44d;"" k=""27"" />
    <hkern u1=""&#x43c;"" u2=""&#x444;"" k=""27"" />
    <hkern u1=""&#x43c;"" u2=""&#x443;"" k=""27"" />
    <hkern u1=""&#x43c;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x43c;"" u2=""&#x43e;"" k=""27"" />
    <hkern u1=""&#x43c;"" u2=""&#x437;"" k=""27"" />
    <hkern u1=""&#x43c;"" u2=""&#x431;"" k=""27"" />
    <hkern u1=""&#x43c;"" u2=""&#x430;"" k=""27"" />
    <hkern u1=""&#x43e;"" u2=""&#x44f;"" k=""27"" />
    <hkern u1=""&#x43e;"" u2=""&#x44d;"" k=""27"" />
    <hkern u1=""&#x43e;"" u2=""&#x447;"" k=""51"" />
    <hkern u1=""&#x43e;"" u2=""&#x445;"" k=""51"" />
    <hkern u1=""&#x43e;"" u2=""&#x443;"" k=""27"" />
    <hkern u1=""&#x43e;"" u2=""&#x442;"" k=""51"" />
    <hkern u1=""&#x43e;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x43e;"" u2=""&#x43c;"" k=""27"" />
    <hkern u1=""&#x43e;"" u2=""&#x43b;"" k=""51"" />
    <hkern u1=""&#x43e;"" u2=""&#x437;"" k=""27"" />
    <hkern u1=""&#x43e;"" u2=""&#x436;"" k=""27"" />
    <hkern u1=""&#x43e;"" u2=""&#x434;"" k=""27"" />
    <hkern u1=""&#x440;"" u2=""&#x44f;"" k=""27"" />
    <hkern u1=""&#x440;"" u2=""&#x44d;"" k=""27"" />
    <hkern u1=""&#x440;"" u2=""&#x447;"" k=""51"" />
    <hkern u1=""&#x440;"" u2=""&#x445;"" k=""27"" />
    <hkern u1=""&#x440;"" u2=""&#x443;"" k=""27"" />
    <hkern u1=""&#x440;"" u2=""&#x442;"" k=""27"" />
    <hkern u1=""&#x440;"" u2=""&#x43c;"" k=""27"" />
    <hkern u1=""&#x440;"" u2=""&#x43b;"" k=""51"" />
    <hkern u1=""&#x440;"" u2=""&#x437;"" k=""27"" />
    <hkern u1=""&#x440;"" u2=""&#x436;"" k=""27"" />
    <hkern u1=""&#x440;"" u2=""&#x434;"" k=""51"" />
    <hkern u1=""&#x441;"" u2=""&#x44a;"" k=""27"" />
    <hkern u1=""&#x441;"" u2=""&#x447;"" k=""53"" />
    <hkern u1=""&#x441;"" u2=""&#x445;"" k=""27"" />
    <hkern u1=""&#x441;"" u2=""&#x431;"" k=""27"" />
    <hkern u1=""&#x441;"" u2=""&#x430;"" k=""-25"" />
    <hkern u1=""&#x442;"" u2=""&#x443;"" k=""-51"" />
    <hkern u1=""&#x442;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x442;"" u2=""&#x43e;"" k=""27"" />
    <hkern u1=""&#x442;"" u2=""&#x43b;"" k=""27"" />
    <hkern u1=""&#x442;"" u2=""&#x436;"" k=""-25"" />
    <hkern u1=""&#x442;"" u2=""&#x434;"" k=""27"" />
    <hkern u1=""&#x442;"" u2=""&#x2e;"" k=""180"" />
    <hkern u1=""&#x442;"" u2=""&#x2c;"" k=""154"" />
    <hkern u1=""&#x443;"" u2=""&#x44f;"" k=""27"" />
    <hkern u1=""&#x443;"" u2=""&#x44d;"" k=""27"" />
    <hkern u1=""&#x443;"" u2=""&#x445;"" k=""-25"" />
    <hkern u1=""&#x443;"" u2=""&#x444;"" k=""27"" />
    <hkern u1=""&#x443;"" u2=""&#x442;"" k=""-25"" />
    <hkern u1=""&#x443;"" u2=""&#x441;"" k=""51"" />
    <hkern u1=""&#x443;"" u2=""&#x440;"" k=""27"" />
    <hkern u1=""&#x443;"" u2=""&#x43e;"" k=""51"" />
    <hkern u1=""&#x443;"" u2=""&#x43c;"" k=""27"" />
    <hkern u1=""&#x443;"" u2=""&#x43b;"" k=""27"" />
    <hkern u1=""&#x443;"" u2=""&#x437;"" k=""27"" />
    <hkern u1=""&#x443;"" u2=""&#x436;"" k=""-25"" />
    <hkern u1=""&#x443;"" u2=""&#x435;"" k=""27"" />
    <hkern u1=""&#x443;"" u2=""&#x434;"" k=""51"" />
    <hkern u1=""&#x443;"" u2=""&#x430;"" k=""27"" />
    <hkern u1=""&#x443;"" u2=""&#xbb;"" k=""-51"" />
    <hkern u1=""&#x443;"" u2=""&#x3b;"" k=""27"" />
    <hkern u1=""&#x443;"" u2=""&#x3a;"" k=""27"" />
    <hkern u1=""&#x443;"" u2=""&#x2e;"" k=""180"" />
    <hkern u1=""&#x443;"" u2=""&#x2c;"" k=""154"" />
    <hkern u1=""&#x444;"" u2=""&#x44f;"" k=""27"" />
    <hkern u1=""&#x444;"" u2=""&#x447;"" k=""51"" />
    <hkern u1=""&#x444;"" u2=""&#x443;"" k=""27"" />
    <hkern u1=""&#x444;"" u2=""&#x442;"" k=""27"" />
    <hkern u1=""&#x444;"" u2=""&#x43e;"" k=""27"" />
    <hkern u1=""&#x444;"" u2=""&#x43c;"" k=""27"" />
    <hkern u1=""&#x444;"" u2=""&#x43b;"" k=""51"" />
    <hkern u1=""&#x444;"" u2=""&#x435;"" k=""27"" />
    <hkern u1=""&#x444;"" u2=""&#x434;"" k=""27"" />
    <hkern u1=""&#x444;"" u2=""&#x431;"" k=""27"" />
    <hkern u1=""&#x445;"" u2=""&#x44d;"" k=""27"" />
    <hkern u1=""&#x445;"" u2=""&#x447;"" k=""51"" />
    <hkern u1=""&#x445;"" u2=""&#x444;"" k=""27"" />
    <hkern u1=""&#x445;"" u2=""&#x443;"" k=""-25"" />
    <hkern u1=""&#x445;"" u2=""&#x441;"" k=""51"" />
    <hkern u1=""&#x445;"" u2=""&#x43e;"" k=""51"" />
    <hkern u1=""&#x445;"" u2=""&#x437;"" k=""27"" />
    <hkern u1=""&#x445;"" u2=""&#x435;"" k=""51"" />
    <hkern u1=""&#x445;"" u2=""&#x431;"" k=""27"" />
    <hkern u1=""&#x446;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x446;"" u2=""&#x437;"" k=""-25"" />
    <hkern u1=""&#x446;"" u2=""&#x430;"" k=""-25"" />
    <hkern u1=""&#x449;"" u2=""&#x43e;"" k=""27"" />
    <hkern u1=""&#x449;"" u2=""&#x430;"" k=""-25"" />
    <hkern u1=""&#x44c;"" u2=""&#x447;"" k=""180"" />
    <hkern u1=""&#x44c;"" u2=""&#x442;"" k=""180"" />
    <hkern u1=""&#x44d;"" u2=""&#x44f;"" k=""27"" />
    <hkern u1=""&#x44d;"" u2=""&#x445;"" k=""27"" />
    <hkern u1=""&#x44d;"" u2=""&#x442;"" k=""27"" />
    <hkern u1=""&#x44d;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x44d;"" u2=""&#x43c;"" k=""27"" />
    <hkern u1=""&#x44d;"" u2=""&#x43b;"" k=""51"" />
    <hkern u1=""&#x44d;"" u2=""&#x437;"" k=""27"" />
    <hkern u1=""&#x44d;"" u2=""&#x436;"" k=""27"" />
    <hkern u1=""&#x44d;"" u2=""&#x434;"" k=""27"" />
    <hkern u1=""&#x44d;"" u2=""&#x431;"" k=""27"" />
    <hkern u1=""&#x44e;"" u2=""&#x44d;"" k=""27"" />
    <hkern u1=""&#x44e;"" u2=""&#x447;"" k=""78"" />
    <hkern u1=""&#x44e;"" u2=""&#x445;"" k=""51"" />
    <hkern u1=""&#x44e;"" u2=""&#x442;"" k=""51"" />
    <hkern u1=""&#x44e;"" u2=""&#x441;"" k=""27"" />
    <hkern u1=""&#x44e;"" u2=""&#x43c;"" k=""27"" />
    <hkern u1=""&#x44e;"" u2=""&#x43b;"" k=""51"" />
    <hkern u1=""&#x44e;"" u2=""&#x436;"" k=""27"" />
    <hkern u1=""&#x44e;"" u2=""&#x434;"" k=""27"" />
    <hkern u1=""&#x44e;"" u2=""&#x431;"" k=""27"" />
    <hkern u1=""&#x45e;"" u2=""&#xab;"" k=""51"" />
    <hkern u1=""&#x45e;"" u2=""&#x3b;"" k=""27"" />
    <hkern u1=""&#x45e;"" u2=""&#x3a;"" k=""27"" />
    <hkern u1=""&#x45e;"" u2=""&#x2e;"" k=""180"" />
    <hkern u1=""&#x45e;"" u2=""&#x2c;"" k=""154"" />
    <hkern u1=""&#x490;"" u2=""&#xbb;"" k=""51"" />
    <hkern u1=""&#x490;"" u2=""&#xab;"" k=""51"" />
    <hkern u1=""&#x490;"" u2=""&#x3b;"" k=""27"" />
    <hkern u1=""&#x490;"" u2=""&#x3a;"" k=""27"" />
    <hkern u1=""&#x490;"" u2=""&#x2e;"" k=""154"" />
    <hkern u1=""&#x490;"" u2=""&#x2c;"" k=""129"" />
    <hkern u1=""&#x2018;"" u2=""&#x2018;"" k=""76"" />
    <hkern u1=""&#x2019;"" u2=""&#x2019;"" k=""76"" />
    <hkern u1=""&#x2019;"" u2=""s"" k=""76"" />
    <hkern u1=""&#x2019;"" u2=""&#x20;"" k=""113"" />
    <hkern u1=""&#x201e;"" u2=""&#x42a;"" k=""180"" />
    <hkern u1=""&#x201e;"" u2=""&#x427;"" k=""207"" />
    <hkern u1=""&#x201e;"" u2=""&#x422;"" k=""180"" />
    <hkern u1=""&#x201e;"" u2=""&#x40b;"" k=""205"" />
    <hkern u1=""&#x201e;"" u2=""&#x402;"" k=""205"" />
  </font>
</defs></svg>";
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Font\LiberationSansFont.cs
using System;

namespace MatterHackers.Agg.Font
{
	public class LiberationSansFont
	{
		private static TypeFace instance;

		public static TypeFace Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new TypeFace();
					instance.ReadSVG(FontData());
				}

				return instance;
			}
		}

		private static String FontData()
		{
			return @"<?xml version=""1.0"" standalone=""no""?>
<!DOCTYPE svg PUBLIC ""-//W3C//DTD SVG 1.1//EN"" ""http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"" >
<svg>
<metadata>
Created by FontForge 20110222 at Mon Jun 27 20:33:45 2011
 By Application Server
Copyright (c) 2007 Red Hat, Inc. All rights reserved. LIBERATION is a trademark of Red Hat, Inc.
</metadata>
<defs>
<font id=""LiberationSans"" horiz-adv-x=""1139"" >
  <font-face
    font-family=""Liberation Sans""
    font-weight=""400""
    font-stretch=""normal""
    units-per-em=""2048""
    panose-1=""2 11 6 4 2 2 2 2 2 4""
    ascent=""1638""
    descent=""-410""
    x-height=""1082""
    cap-height=""1409""
    bbox=""-416 -621 2151 1864""
    underline-thickness=""150""
    underline-position=""-142""
    unicode-range=""U+0020-F005""
  />
<missing-glyph horiz-adv-x=""748""
d=""M68 0v1365h544v-1365h-544zM136 68h408v1229h-408v-1229z"" />
    <glyph glyph-name="".notdef"" horiz-adv-x=""748""
d=""M68 0v1365h544v-1365h-544zM136 68h408v1229h-408v-1229z"" />
    <glyph glyph-name="".null"" horiz-adv-x=""0""
 />
    <glyph glyph-name=""nonmarkingreturn"" horiz-adv-x=""682""
 />
    <glyph glyph-name=""uni00A0"" unicode="" "" horiz-adv-x=""569""
 />
    <glyph glyph-name=""FIGURE SPACE"" unicode=""&#x2007;""
/>
    <glyph glyph-name=""uni00A0"" unicode=""&#xa0;"" horiz-adv-x=""569""
 />
    <glyph glyph-name=""exclam"" unicode=""!"" horiz-adv-x=""569""
d=""M359 397h-148l-24 1012h196zM185 0v201h194v-201h-194z"" />
    <glyph glyph-name=""quotedbl"" unicode=""&#x22;"" horiz-adv-x=""727""
d=""M618 966h-142l-20 443h184zM249 966h-141l-21 443h184z"" />
    <glyph glyph-name=""numbersign"" unicode=""#""
d=""M896 885l-78 -369h260v-108h-283l-88 -408h-110l86 408h-363l-84 -408h-110l84 408h-201v108h225l78 369h-252v108h274l89 408h110l-88 -408h363l88 408h110l-88 -408h211v-108h-233zM425 885l-80 -369h362l78 369h-360z"" />
    <glyph glyph-name=""dollar"" unicode=""$""
d=""M518 20q-217 9 -339.5 101.5t-156.5 257.5l170 37q11 -53 34 -96.5t62 -75.5t95.5 -51.5t134.5 -24.5v496l-20 5q-77 18 -151 43t-132 66.5t-93.5 105.5t-35.5 162q0 84 32 146t89.5 103.5t136.5 63.5t174 26v131h124v-131q100 -5 172.5 -27.5t123.5 -62.5t84 -97.5
t53 -132.5l-174 -33q-20 94 -81 146.5t-178 63.5v-445q59 -14 116 -29t108.5 -35.5t95.5 -48.5t76 -67.5t50 -94t18 -126.5q0 -77 -28 -142.5t-85 -115.5t-144.5 -81t-206.5 -37v-162h-124v162zM934 394q0 63 -23.5 103t-64 65.5t-93.5 41.5t-111 31v-468q65 4 119 19.5
t92.5 43.5t59.5 68.5t21 95.5zM258 1048q0 -54 20 -91t55 -62t82.5 -41.5t102.5 -30.5v421q-72 -4 -122 -20.5t-80.5 -42.5t-44 -60t-13.5 -73z"" />
    <glyph glyph-name=""percent"" unicode=""%"" horiz-adv-x=""1821""
d=""M1748 434q0 -125 -25.5 -210.5t-69 -138t-101.5 -75t-124 -22.5t-123.5 22.5t-100 74.5t-67 137.5t-24.5 211.5q0 133 24 220t67 138.5t101.5 72t126.5 20.5q66 0 123.5 -20.5t100 -72t67.5 -138.5t25 -220zM527 0h-155l922 1409h157zM394 1421q64 0 121 -20.5t100 -71.5
t67.5 -137t24.5 -217q0 -126 -25 -212t-67.5 -139.5t-100.5 -76.5t-124 -23q-67 0 -125 23t-100.5 76t-67 139t-24.5 213q0 131 24.5 217t67.5 137t102 71.5t127 20.5zM1600 434q0 99 -11 164.5t-32.5 104.5t-53 55t-71.5 16q-42 0 -74 -16.5t-54 -55.5t-33 -104.5
t-11 -163.5q0 -95 11.5 -159t33 -103.5t53 -56.5t72.5 -17q39 0 70.5 17t53.5 56.5t34 103.5t12 159zM560 975q0 98 -11 163t-32 104t-52 55t-71 16q-43 0 -75.5 -16.5t-54.5 -55.5t-33 -104t-11 -162q0 -95 11.5 -160t33 -104.5t53.5 -56.5t74 -17q38 0 69 17t53 56.5
t34 104.5t12 160z"" />
    <glyph glyph-name=""ampersand"" unicode=""&#x26;"" horiz-adv-x=""1366""
d=""M1193 -12q-96 0 -168 33t-130 94q-30 -26 -68 -50t-84.5 -43t-101 -30.5t-118.5 -11.5q-117 0 -202.5 30t-140.5 82.5t-81.5 124t-26.5 154.5q0 79 25.5 143.5t71 117t108.5 94t138 74.5q-18 34 -32.5 72.5t-25.5 77.5t-17 78t-6 74q0 66 20 123.5t62.5 100t109 67
t159.5 24.5q73 0 134.5 -19t106.5 -55t70 -89t25 -121q0 -75 -33 -133.5t-89 -104.5t-130 -83.5t-157 -70.5q62 -114 135 -214.5t158 -197.5q61 90 101.5 189.5t69.5 220.5l145 -43q-35 -139 -88.5 -252.5t-123.5 -216.5q53 -54 106 -76t102 -22q32 0 61.5 3.5t55.5 12.5
v-135q-28 -11 -65.5 -16.5t-75.5 -5.5zM869 1133q0 37 -13.5 67t-37.5 51.5t-58.5 33t-76.5 11.5q-96 0 -146 -51.5t-50 -142.5q0 -59 18.5 -123.5t46.5 -120.5q65 26 123 53.5t101 60t68 72t25 89.5zM795 217q-89 105 -171 220t-148 237q-113 -48 -174.5 -122t-61.5 -179
q0 -55 17.5 -102.5t53.5 -83t90.5 -56t127.5 -20.5q44 0 83.5 9.5t73.5 24.5t61.5 34t47.5 38z"" />
    <glyph glyph-name=""quotesingle"" unicode=""'"" horiz-adv-x=""391""
d=""M266 966h-141l-21 443h184z"" />
    <glyph glyph-name=""parenleft"" unicode=""("" horiz-adv-x=""682""
d=""M127 532q0 139 21 266t66 244t115 227t167 215h174q-94 -105 -162.5 -215.5t-112.5 -228t-65.5 -244.5t-21.5 -266t21.5 -266t65.5 -245t112.5 -228t162.5 -215h-174q-97 105 -167 215t-115 227t-66 243.5t-21 266.5v4z"" />
    <glyph glyph-name=""parenright"" unicode="")"" horiz-adv-x=""682""
d=""M555 528q0 -140 -21 -266.5t-66 -243.5t-115 -227t-167 -215h-174q94 105 162.5 215t112.5 228t65.5 245t21.5 266t-21.5 266t-65.5 244.5t-112.5 228t-162.5 215.5h174q97 -105 167 -215t115 -227t66 -244t21 -266v-4z"" />
    <glyph glyph-name=""asterisk"" unicode=""*"" horiz-adv-x=""797""
d=""M456 1114l264 103l45 -132l-282 -73l185 -250l-119 -72l-150 258l-156 -256l-119 72l189 248l-280 73l45 134l267 -107l-12 297h136z"" />
    <glyph glyph-name=""plus"" unicode=""+"" horiz-adv-x=""1196""
d=""M671 608v-428h-147v428h-424v146h424v428h147v-428h424v-146h-424z"" />
    <glyph glyph-name=""comma"" unicode="","" horiz-adv-x=""569""
d=""M385 219v-168q0 -53 -4.5 -96.5t-14.5 -81t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v219h195z"" />
    <glyph glyph-name=""uni00AD"" unicode=""-"" horiz-adv-x=""682""
d=""M91 464v160h500v-160h-500z"" />
    <glyph glyph-name=""uni00AD"" unicode=""&#xad;"" horiz-adv-x=""682""
d=""M91 464v160h500v-160h-500z"" />
    <glyph glyph-name=""period"" unicode=""."" horiz-adv-x=""569""
d=""M187 0v219h195v-219h-195z"" />
    <glyph glyph-name=""slash"" unicode=""/"" horiz-adv-x=""569""
d=""M0 -20l411 1504h158l-407 -1504h-162z"" />
    <glyph glyph-name=""zero"" unicode=""0""
d=""M1059 705q0 -203 -38.5 -341.5t-105 -224t-156.5 -122.5t-192 -37q-103 0 -192 37t-154.5 122t-103 223.5t-37.5 342.5q0 213 37.5 352.5t103.5 222.5t156 116.5t196 33.5q101 0 189.5 -33.5t154.5 -116.5t104 -222.5t38 -352.5zM876 705q0 168 -20 279.5t-59 178
t-95.5 94t-128.5 27.5q-76 0 -134 -28t-97.5 -94.5t-59.5 -178t-20 -278.5q0 -162 20.5 -273t60 -178.5t96.5 -97t130 -29.5q71 0 128 29.5t96.5 97t61 178.5t21.5 273z"" />
    <glyph glyph-name=""one"" unicode=""1""
d=""M156 0v153h359v1084l-318 -227v170l333 229h166v-1256h343v-153h-883z"" />
    <glyph glyph-name=""two"" unicode=""2""
d=""M103 0v127q51 117 124.5 206.5t154.5 162t160.5 134.5t143.5 124t103.5 130t39.5 154q0 60 -18 105.5t-52 76.5t-81.5 46.5t-105.5 15.5q-54 0 -101.5 -15t-84.5 -45t-60.5 -74.5t-30.5 -103.5l-184 17q9 76 42 143t91 117.5t139.5 79.5t188.5 29q105 0 187 -25
t138.5 -74t86.5 -121t30 -166q0 -71 -25.5 -135t-68 -122t-98.5 -112t-117 -105.5t-123 -102t-116.5 -101.5t-97.5 -103.5t-67 -109.5h735v-153h-933z"" />
    <glyph glyph-name=""three"" unicode=""3""
d=""M1049 389q0 -97 -31.5 -173t-92 -128.5t-150 -80t-204.5 -27.5q-131 0 -220.5 32.5t-147.5 86t-87 122t-38 141.5l186 17q8 -56 29.5 -102t58.5 -79t91 -51t128 -18q136 0 213.5 67t77.5 199q0 78 -34.5 125.5t-86 74t-112 35.5t-111.5 9h-102v156h98q51 0 106 10.5
t100.5 38t75 74.5t29.5 120q0 113 -66.5 178.5t-197.5 65.5q-119 0 -192.5 -61t-85.5 -172l-181 14q11 93 51 162t101.5 114.5t140.5 68t168 22.5q118 0 203 -29.5t139 -80t79.5 -118.5t25.5 -145q0 -62 -17 -116t-53 -97t-91.5 -74t-133.5 -47v-4q85 -9 148 -38.5
t104 -73.5t61.5 -100t20.5 -118z"" />
    <glyph glyph-name=""four"" unicode=""4""
d=""M881 319v-319h-170v319h-664v140l645 950h189v-948h198v-142h-198zM711 1206q-2 -5 -10 -19.5t-18 -32.5t-20.5 -36.5t-18.5 -30.5l-361 -532q-5 -8 -14.5 -21t-19.5 -26.5t-20 -26.5t-16 -20h498v745z"" />
    <glyph glyph-name=""five"" unicode=""5""
d=""M1053 459q0 -106 -32 -194t-95 -151.5t-156.5 -98.5t-216.5 -35q-111 0 -193.5 26t-139.5 71.5t-90.5 106.5t-47.5 131l182 21q11 -40 31 -77.5t54.5 -67t85 -47t122.5 -17.5q70 0 127 21.5t97.5 63.5t62.5 103t22 140q0 65 -21 119.5t-60 94t-95.5 61.5t-128.5 22
q-45 0 -83 -8t-70.5 -22t-59 -32.5t-49.5 -38.5h-176l47 758h801v-153h-637l-27 -447q48 37 120 63.5t171 26.5q105 0 189 -32t143 -90.5t91 -139.5t32 -178z"" />
    <glyph glyph-name=""six"" unicode=""6""
d=""M1049 461q0 -106 -29.5 -194.5t-87 -152t-142.5 -99t-196 -35.5q-123 0 -215 47t-153 135.5t-91.5 217t-30.5 292.5q0 188 34.5 330t99.5 237t158.5 143t211.5 48q72 0 135 -15t114.5 -48.5t90.5 -88.5t62 -135l-172 -31q-28 91 -89.5 131.5t-142.5 40.5q-74 0 -134 -35
t-102 -104.5t-64.5 -174.5t-22.5 -245q49 91 138 138.5t204 47.5q96 0 174 -31t133.5 -89.5t86 -142t30.5 -187.5zM866 453q0 73 -18 132t-54 100.5t-89 64t-123 22.5q-49 0 -99 -14.5t-90.5 -47t-66 -85.5t-25.5 -129q0 -78 20 -145.5t57.5 -117.5t90.5 -79t119 -29
q65 0 116.5 22.5t87.5 65t55 103.5t19 137z"" />
    <glyph glyph-name=""seven"" unicode=""7""
d=""M1036 1263q-106 -162 -195 -311.5t-153 -301t-99.5 -311t-35.5 -339.5h-188q0 169 40 331.5t108 319t158 307.5t191 298h-757v153h931v-146z"" />
    <glyph glyph-name=""eight"" unicode=""8""
d=""M1050 393q0 -90 -28.5 -165.5t-87 -130.5t-149.5 -86t-215 -31t-214.5 31t-150 85.5t-88 130t-28.5 164.5q0 77 23.5 137t63 103.5t90 70t104.5 35.5v4q-59 14 -105.5 45t-78 74.5t-48 96.5t-16.5 112q0 74 28.5 139.5t84.5 115t139 78t192 28.5q115 0 199.5 -29
t140 -78.5t82.5 -115.5t27 -140q0 -58 -16.5 -111t-48 -96.5t-78 -74t-107.5 -42.5v-4q61 -10 113 -36.5t90 -70t60 -103.5t22 -136zM828 1057q0 53 -13.5 97t-44.5 75.5t-81 49t-123 17.5q-71 0 -120 -17.5t-80.5 -49t-45.5 -75.5t-14 -97q0 -42 11 -86t40 -80t80 -59
t131 -23q85 0 136.5 23t79 59t36 80t8.5 86zM863 410q0 51 -14 98.5t-48 84t-91.5 59t-143.5 22.5q-79 0 -134.5 -22.5t-90 -59.5t-50.5 -85.5t-16 -100.5q0 -65 16 -118.5t51 -92t92 -59.5t138 -21q82 0 138 21t90 59.5t48.5 93t14.5 121.5z"" />
    <glyph glyph-name=""nine"" unicode=""9""
d=""M1042 733q0 -188 -35.5 -329.5t-101.5 -235.5t-160.5 -141t-212.5 -47q-81 0 -146 16.5t-116 51.5t-87 91t-58 135l172 27q28 -91 87.5 -133.5t150.5 -42.5q73 0 133.5 34.5t103 103.5t66.5 173t26 244q-21 -47 -57.5 -84t-83 -62.5t-100.5 -39t-109 -13.5
q-96 0 -173.5 34.5t-131.5 96.5t-83.5 149.5t-29.5 194.5q0 109 31.5 197t91.5 149.5t147.5 94.5t198.5 33q235 0 356 -174t121 -523zM846 907q0 78 -18.5 147t-55 120t-90 80.5t-123.5 29.5q-65 0 -117 -23t-88 -65.5t-55.5 -103.5t-19.5 -136q0 -71 17.5 -132t52.5 -105.5
t87 -70t121 -25.5q50 0 101.5 17t93 52t68 88.5t26.5 126.5z"" />
    <glyph glyph-name=""colon"" unicode="":"" horiz-adv-x=""569""
d=""M187 875v207h195v-207h-195zM187 0v207h195v-207h-195z"" />
    <glyph glyph-name=""uni037E"" unicode="";"" horiz-adv-x=""569""
d=""M385 207v-156q0 -53 -4.5 -96.5t-14.5 -81t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v207h195zM190 875v207h195v-207h-195z"" />
    <glyph glyph-name=""uni037E"" unicode=""&#x37e;"" horiz-adv-x=""569""
d=""M385 207v-156q0 -53 -4.5 -96.5t-14.5 -81t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v207h195zM190 875v207h195v-207h-195z"" />
    <glyph glyph-name=""less"" unicode=""&#x3c;"" horiz-adv-x=""1196""
d=""M101 571v205l995 418v-154l-858 -366l858 -367v-153z"" />
    <glyph glyph-name=""equal"" unicode=""="" horiz-adv-x=""1196""
d=""M100 856v148h995v-148h-995zM100 344v148h995v-148h-995z"" />
    <glyph glyph-name=""greater"" unicode=""&#x3e;"" horiz-adv-x=""1196""
d=""M101 154v153l858 367l-858 366v154l995 -418v-205z"" />
    <glyph glyph-name=""question"" unicode=""?""
d=""M1063 1032q0 -71 -18.5 -125t-49.5 -96.5t-70.5 -76t-80.5 -63.5t-80.5 -59t-71 -63t-51 -75.5t-20.5 -96.5h-175q2 69 21.5 121t50.5 92t70 71.5t79 60t78.5 57t68.5 63.5t48.5 79t18.5 103t-21 105t-59.5 77.5t-93 47.5t-121.5 16q-140 0 -222 -70t-96 -192l-184 12
q11 84 44.5 158.5t94 130.5t150 88.5t211.5 32.5q114 0 203 -28t150.5 -79.5t93.5 -125.5t32 -165zM438 0v201h195v-201h-195z"" />
    <glyph glyph-name=""at"" unicode=""@"" horiz-adv-x=""2079""
d=""M1902 755q0 -144 -33.5 -263.5t-92.5 -205.5t-141.5 -134t-179.5 -48q-56 0 -95.5 13.5t-64.5 37t-36 55.5t-11 70q0 15 1 36.5t2 33.5h-6q-24 -45 -58.5 -89.5t-81 -79t-105 -56t-129.5 -21.5q-84 0 -146.5 29t-103 80.5t-60.5 122t-20 153.5q0 120 35.5 230.5
t101.5 195t158.5 135.5t206.5 51q60 0 108 -13.5t84.5 -37.5t63.5 -57.5t45 -73.5h6l39 160h156l-116 -506q-19 -84 -28 -144t-9 -109q0 -48 21.5 -71t59.5 -23q62 0 115.5 40.5t93 111.5t62 167t22.5 208q0 129 -41.5 240t-122 192t-199.5 127t-275 46q-134 0 -247.5 -32
t-205.5 -90t-161.5 -138.5t-116.5 -176.5t-71 -205.5t-24 -224.5q0 -141 43 -260t125.5 -204.5t204 -133.5t279.5 -48q105 0 196 16.5t167 40.5t136 52.5t104 52.5l55 -112q-50 -30 -117.5 -61.5t-150.5 -57.5t-181 -42.5t-209 -16.5q-190 0 -337.5 57.5t-249 160.5
t-154 245t-52.5 311q0 139 31.5 267t90.5 238t144 200t192.5 154t235 99t271.5 35q201 0 347 -59t241.5 -159t141.5 -232t46 -279zM1296 747q0 50 -17 92t-48.5 72t-76 46.5t-100.5 16.5q-86 0 -151 -42.5t-108.5 -111.5t-66 -155.5t-22.5 -173.5q0 -120 47.5 -188
t146.5 -68q69 0 129 31t108 82t83 117t53 137q9 36 16 76t7 69z"" />
    <glyph glyph-name=""A"" unicode=""A"" horiz-adv-x=""1366""
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527z"" />
    <glyph glyph-name=""B"" unicode=""B"" horiz-adv-x=""1366""
d=""M1258 397q0 -107 -42 -182.5t-113 -123t-165 -69.5t-198 -22h-572v1409h512q117 0 209 -19.5t156 -61.5t97.5 -106.5t33.5 -154.5q0 -59 -16.5 -111t-50 -94.5t-84 -73t-117.5 -45.5q85 -10 150.5 -39t109.5 -74t67 -104.5t23 -128.5zM984 1044q0 114 -78 163t-226 49
h-321v-446h321q84 0 142 16.5t94 47t52 73.5t16 97zM1065 412q0 67 -24.5 114t-70.5 77t-110.5 44t-144.5 14h-356v-508h371q73 0 134.5 12t106 42t69.5 80t25 125z"" />
    <glyph glyph-name=""C"" unicode=""C"" horiz-adv-x=""1479""
d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5
t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21z"" />
    <glyph glyph-name=""D"" unicode=""D"" horiz-adv-x=""1479""
d=""M1381 719q0 -176 -53 -310.5t-145 -225t-217.5 -137t-270.5 -46.5h-527v1409h466q163 0 300.5 -40.5t236.5 -125t154.5 -214.5t55.5 -310zM1189 719q0 143 -41 244.5t-115 166.5t-177 95.5t-226 30.5h-271v-1103h314q111 0 205.5 36t163.5 107t108 177t39 246z"" />
    <glyph glyph-name=""E"" unicode=""E"" horiz-adv-x=""1366""
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110z"" />
    <glyph glyph-name=""F"" unicode=""F"" horiz-adv-x=""1251""
d=""M359 1253v-524h786v-158h-786v-571h-191v1409h1001v-156h-810z"" />
    <glyph glyph-name=""G"" unicode=""G"" horiz-adv-x=""1593""
d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5
q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293z"" />
    <glyph glyph-name=""H"" unicode=""H"" horiz-adv-x=""1479""
d=""M1121 0v653h-762v-653h-191v1409h191v-596h762v596h191v-1409h-191z"" />
    <glyph glyph-name=""I"" unicode=""I"" horiz-adv-x=""569""
d=""M189 0v1409h191v-1409h-191z"" />
    <glyph glyph-name=""J"" unicode=""J"" horiz-adv-x=""1024""
d=""M457 -20q-171 0 -280.5 89t-144.5 281l187 31q10 -65 33 -111.5t55 -76.5t71 -44t80 -14q104 0 164 71.5t60 209.5v837h-271v156h461v-989q0 -101 -28 -182t-81.5 -138.5t-130.5 -88.5t-175 -31z"" />
    <glyph glyph-name=""K"" unicode=""K"" horiz-adv-x=""1366""
d=""M1106 0l-563 680l-184 -140v-540h-191v1409h191v-706l679 706h225l-600 -612l680 -797h-237z"" />
    <glyph glyph-name=""L"" unicode=""L""
d=""M168 0v1409h191v-1253h712v-156h-903z"" />
    <glyph glyph-name=""M"" unicode=""M"" horiz-adv-x=""1706""
d=""M1366 0v940q0 51 1 104t3 97q2 51 5 99q-14 -51 -29 -101q-13 -43 -28.5 -91.5t-30.5 -87.5l-364 -960h-134l-369 960q-6 15 -12.5 35t-14 42.5t-15 46t-14.5 46.5q-17 53 -33 110q1 -56 3 -111q2 -47 3 -98.5t1 -90.5v-940h-170v1409h251l375 -977q7 -20 17 -51.5
t19 -64.5t16.5 -62.5t10.5 -45.5q3 16 11 46t18.5 63t20.5 64t18 51l368 977h245v-1409h-172z"" />
    <glyph glyph-name=""N"" unicode=""N"" horiz-adv-x=""1479""
d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230z"" />
    <glyph glyph-name=""O"" unicode=""O"" horiz-adv-x=""1593""
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231z"" />
    <glyph glyph-name=""P"" unicode=""P"" horiz-adv-x=""1366""
d=""M1258 985q0 -92 -30.5 -171.5t-91 -138t-151.5 -92.5t-212 -34h-414v-549h-191v1409h593q125 0 218 -30.5t155 -86t93 -134t31 -173.5zM1066 983q0 134 -82 203.5t-246 69.5h-379v-556h387q165 0 242.5 73t77.5 210z"" />
    <glyph glyph-name=""Q"" unicode=""Q"" horiz-adv-x=""1593""
d=""M1495 711q0 -149 -38.5 -272.5t-111 -216.5t-178 -151.5t-239.5 -76.5q21 -64 47.5 -109t60.5 -73.5t75.5 -42t92.5 -13.5q28 0 60 4t55 9v-134q-38 -9 -83.5 -15.5t-94.5 -6.5q-86 0 -150 25.5t-112.5 73t-83.5 116.5t-62 156q-158 8 -277.5 65.5t-199 154t-119.5 226
t-40 281.5q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5
q132 0 227.5 43t157 119.5t91 182.5t29.5 231z"" />
    <glyph glyph-name=""R"" unicode=""R"" horiz-adv-x=""1479""
d=""M1164 0l-366 585h-439v-585h-191v1409h663q120 0 212.5 -27.5t155.5 -79.5t96 -127t33 -169q0 -67 -19.5 -132t-61.5 -119t-107 -93t-156 -55l400 -607h-220zM1136 1004q0 64 -22 111t-64 78.5t-102 47t-136 15.5h-453v-520h461q82 0 142 20.5t98.5 56.5t57 85t18.5 106z
"" />
    <glyph glyph-name=""S"" unicode=""S"" horiz-adv-x=""1366""
d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5
t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5
q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134z"" />
    <glyph glyph-name=""T"" unicode=""T"" horiz-adv-x=""1251""
d=""M720 1253v-1253h-190v1253h-484v156h1158v-156h-484z"" />
    <glyph glyph-name=""U"" unicode=""U"" horiz-adv-x=""1479""
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33z"" />
    <glyph glyph-name=""V"" unicode=""V"" horiz-adv-x=""1366""
d=""M782 0h-198l-575 1409h201l390 -992q15 -45 30 -89.5t27 -79.5q14 -41 27 -80q12 37 26 78q12 35 26.5 79t31.5 92l388 992h201z"" />
    <glyph glyph-name=""W"" unicode=""W"" horiz-adv-x=""1933""
d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183
l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199z"" />
    <glyph glyph-name=""X"" unicode=""X"" horiz-adv-x=""1366""
d=""M1112 0l-423 616l-432 -616h-211l536 732l-495 677h211l392 -553l381 553h211l-482 -670l523 -739h-211z"" />
    <glyph glyph-name=""Y"" unicode=""Y"" horiz-adv-x=""1366""
d=""M777 584v-584h-190v584l-542 825h210l429 -671l427 671h210z"" />
    <glyph glyph-name=""Z"" unicode=""Z"" horiz-adv-x=""1251""
d=""M1187 0h-1122v143l858 1110h-785v156h1002v-139l-858 -1114h905v-156z"" />
    <glyph glyph-name=""bracketleft"" unicode=""["" horiz-adv-x=""569""
d=""M146 -425v1909h407v-129h-233v-1651h233v-129h-407z"" />
    <glyph glyph-name=""backslash"" unicode=""\"" horiz-adv-x=""569""
d=""M407 -20l-407 1504h158l411 -1504h-162z"" />
    <glyph glyph-name=""bracketright"" unicode=""]"" horiz-adv-x=""569""
d=""M16 -425v129h233v1651h-233v129h407v-1909h-407z"" />
    <glyph glyph-name=""asciicircum"" unicode=""^"" horiz-adv-x=""961""
d=""M787 673l-309 633l-306 -633h-162l368 736h203l370 -736h-164z"" />
    <glyph glyph-name=""underscore"" unicode=""_""
d=""M-31 -407v130h1193v-130h-1193z"" />
    <glyph glyph-name=""grave"" unicode=""`"" horiz-adv-x=""682""
d=""M436 1201l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""a"" unicode=""a""
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48z"" />
    <glyph glyph-name=""b"" unicode=""b""
d=""M1053 546q0 -566 -398 -566q-123 0 -204.5 44.5t-132.5 143.5h-2q0 -26 -1.5 -54t-3 -52t-3 -41t-2.5 -21h-174q1 9 2 30.5t2 51.5t1.5 66t0.5 75v1261h180v-423q0 -30 -0.5 -57.5t-1.5 -48.5q-1 -25 -2 -47h4q50 104 132.5 149t204.5 45q205 0 301.5 -138t96.5 -418z
M864 540q0 112 -14 192t-45 131.5t-79 75.5t-117 24q-71 0 -125.5 -23t-91 -74t-55.5 -134t-19 -203q0 -116 19 -195t55.5 -128.5t90.5 -71t124 -21.5q66 0 114 23t80 74t47.5 132.5t15.5 197.5z"" />
    <glyph glyph-name=""c"" unicode=""c"" horiz-adv-x=""1024""
d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5
q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183z"" />
    <glyph glyph-name=""d"" unicode=""d""
d=""M821 174q-50 -104 -132.5 -149t-204.5 -45q-205 0 -301.5 138t-96.5 418q0 566 398 566q123 0 205 -45t132 -143h2q0 10 -0.5 31.5t-1 45t-0.5 44.5v30v419h180v-1261q0 -39 0.5 -75t1.5 -66t2 -51.5t2 -30.5h-172q-2 10 -3.5 28.5t-3 42.5t-2.5 50.5t-1 52.5h-4z
M275 542q0 -112 14 -192t45 -131.5t79 -75.5t117 -24q71 0 125.5 23t91 74.5t55.5 134.5t19 203q0 115 -19 194.5t-56 128.5t-90.5 70.5t-123.5 21.5q-66 0 -114 -23t-80 -74t-47.5 -132.5t-15.5 -197.5z"" />
    <glyph glyph-name=""e"" unicode=""e""
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584z"" />
    <glyph glyph-name=""f"" unicode=""f"" horiz-adv-x=""569""
d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211z"" />
    <glyph glyph-name=""g"" unicode=""g""
d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234
t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24
q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191z"" />
    <glyph glyph-name=""h"" unicode=""h""
d=""M317 897q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-721h-181v686q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-638h-180v1484h180v-386q0 -33 -1 -66t-2.5 -61t-2.5 -47.5
t-2 -26.5h3z"" />
    <glyph glyph-name=""i"" unicode=""i"" horiz-adv-x=""455""
d=""M137 1312v172h180v-172h-180zM137 0v1082h180v-1082h-180z"" />
    <glyph glyph-name=""j"" unicode=""j"" horiz-adv-x=""455""
d=""M137 1312v172h180v-172h-180zM317 -134q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v1189h180v-1216z"" />
    <glyph glyph-name=""k"" unicode=""k"" horiz-adv-x=""1024""
d=""M816 0l-366 494l-132 -109v-385h-180v1484h180v-927l475 525h211l-439 -465l462 -617h-211z"" />
    <glyph glyph-name=""l"" unicode=""l"" horiz-adv-x=""455""
d=""M138 0v1484h180v-1484h-180z"" />
    <glyph glyph-name=""m"" unicode=""m"" horiz-adv-x=""1706""
d=""M768 0v686q0 79 -10 132t-33.5 85.5t-61.5 46t-93 13.5q-57 0 -103 -22.5t-78.5 -65t-50 -105t-17.5 -143.5v-627h-179v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q24 47 52 85t65.5 64.5t86 41t112.5 14.5q123 0 194.5 -49
t99.5 -156h3q24 47 54 85t70 64.5t90 41t114 14.5q82 0 141.5 -22t97.5 -68t56 -118.5t18 -172.5v-721h-178v686q0 79 -10 132t-33.5 85.5t-61.5 46t-93 13.5q-57 0 -103 -21.5t-78.5 -63.5t-50 -105t-17.5 -146v-627h-178z"" />
    <glyph glyph-name=""n"" unicode=""n""
d=""M825 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22
t107 -68t61.5 -118.5t19.5 -172.5v-721h-181z"" />
    <glyph glyph-name=""o"" unicode=""o""
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209z"" />
    <glyph glyph-name=""p"" unicode=""p""
d=""M1053 546q0 -123 -20 -227t-66.5 -179t-123 -117.5t-188.5 -42.5q-116 0 -203 44t-133 144h-5q1 -2 1.5 -18t1 -40t1 -53.5t0.5 -58.5v-423h-180v1286q0 39 -0.5 75t-1.5 65.5t-2 50.5t-2 30h174q1 -3 2.5 -21t3 -43.5t3 -54.5t1.5 -55h4q25 52 57 88.5t73 60t91.5 34
t113.5 10.5q112 0 188.5 -40t123 -112.5t66.5 -175t20 -227.5zM864 542q0 100 -12 178t-41.5 132t-78.5 82t-123 28q-60 0 -113 -17t-92.5 -65t-62.5 -132.5t-23 -219.5q0 -115 19 -194.5t55.5 -128.5t90.5 -70.5t124 -21.5q75 0 124.5 29t79 84t41.5 134.5t12 181.5z"" />
    <glyph glyph-name=""q"" unicode=""q""
d=""M484 -20q-206 0 -302 139t-96 417q0 282 98.5 424t299.5 142q67 0 118.5 -12t92 -35.5t71 -58.5t55.5 -82h2q0 25 1.5 55.5t3 57.5t3.5 46.5t4 22.5h173q-2 -17 -4.5 -89t-2.5 -206v-1226h-180v439q0 26 0.5 54t1.5 53q1 28 2 57h-2q-26 -51 -57.5 -88.5t-72.5 -62
t-92.5 -36t-116.5 -11.5zM821 554q0 118 -20.5 198t-58 128t-91 68.5t-119.5 20.5q-69 0 -118 -25.5t-79.5 -78t-45 -133t-14.5 -190.5q0 -108 13.5 -188t44 -132t79 -77.5t118.5 -25.5q60 0 113 18.5t92.5 67t62.5 133t23 216.5z"" />
    <glyph glyph-name=""r"" unicode=""r"" horiz-adv-x=""682""
d=""M142 0v830q0 34 -0.5 69.5t-1.5 68.5t-2 62t-2 52h170q1 -23 2.5 -52.5t3 -60.5t2 -59.5t0.5 -48.5h4q19 62 40.5 107.5t50.5 75t69 44t97 14.5q22 0 42 -3.5t31 -6.5v-165q-18 5 -42 7.5t-54 2.5q-62 0 -105.5 -28t-71 -77.5t-40.5 -118t-13 -149.5v-564h-180z"" />
    <glyph glyph-name=""s"" unicode=""s"" horiz-adv-x=""1024""
d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38
t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5
t44.5 -77t16.5 -102z"" />
    <glyph glyph-name=""t"" unicode=""t"" horiz-adv-x=""569""
d=""M554 8q-41 -11 -83.5 -17.5t-98.5 -6.5q-216 0 -216 245v722h-125v131h132l53 242h120v-242h200v-131h-200v-683q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133z"" />
    <glyph glyph-name=""u"" unicode=""u""
d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181z"" />
    <glyph glyph-name=""v"" unicode=""v"" horiz-adv-x=""1024""
d=""M613 0h-213l-393 1082h192l238 -704q7 -22 16.5 -53.5t19.5 -65.5t18.5 -65.5t14.5 -52.5q6 21 15.5 52.5t19.5 64.5t20.5 64.5t18.5 53.5l246 706h191z"" />
    <glyph glyph-name=""w"" unicode=""w"" horiz-adv-x=""1479""
d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62
q8 -34 16 -69q8 38 16 74q7 31 14.5 64.5t14.5 59.5l191 735h176z"" />
    <glyph glyph-name=""x"" unicode=""x"" horiz-adv-x=""1024""
d=""M801 0l-291 444l-293 -444h-194l385 556l-367 526h199l270 -421l268 421h201l-367 -524l390 -558h-201z"" />
    <glyph glyph-name=""y"" unicode=""y"" horiz-adv-x=""1024""
d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190z"" />
    <glyph glyph-name=""z"" unicode=""z"" horiz-adv-x=""1024""
d=""M49 0v137l661 806h-621v139h824v-137l-662 -806h699v-139h-901z"" />
    <glyph glyph-name=""braceleft"" unicode=""{"" horiz-adv-x=""684""
d=""M513 -425q-65 0 -114.5 20.5t-82.5 58.5t-50 92t-17 122v361q0 63 -14.5 107t-42 72t-67.5 42t-91 16v127q51 2 91 16t67.5 42t42 72t14.5 106v362q0 141 66.5 217t197.5 76h135v-129h-63q-91 0 -129.5 -53.5t-38.5 -161.5v-356q0 -50 -15 -92t-41 -74t-61.5 -54
t-76.5 -32v-2q43 -10 78.5 -32t61 -54.5t40 -74.5t14.5 -93v-357q0 -106 38.5 -160.5t129.5 -54.5h63v-129h-135z"" />
    <glyph glyph-name=""bar"" unicode=""|"" horiz-adv-x=""532""
d=""M183 -434v1918h166v-1918h-166z"" />
    <glyph glyph-name=""braceright"" unicode=""}"" horiz-adv-x=""684""
d=""M94 -296q91 0 130.5 54.5t39.5 160.5v357q0 51 14 93t39.5 74.5t61 54.5t78.5 32v2q-42 10 -77 32t-61 54t-40.5 74t-14.5 92v356q0 108 -39.5 161.5t-130.5 53.5h-60v129h132q131 0 197.5 -76t66.5 -217v-362q0 -62 14.5 -106t42 -72t68 -42t92.5 -16v-127
q-52 -2 -92.5 -16t-68 -42t-42 -72t-14.5 -107v-361q0 -68 -17 -122t-50 -92t-82.5 -58.5t-114.5 -20.5h-132v129h60z"" />
    <glyph glyph-name=""asciitilde"" unicode=""~"" horiz-adv-x=""1196""
d=""M844 553q-69 0 -141.5 22t-145.5 48q-129 45 -217 45q-38 0 -70.5 -6t-62.5 -17.5t-58 -27.5t-57 -37v143q50 38 116 61t147 23q40 0 80 -6.5t78.5 -16.5t76 -23t74.5 -26q21 -8 46 -15.5t50.5 -14.5t51 -11t48.5 -4q69 0 130.5 25t113.5 67v-149q-32 -23 -61.5 -38
t-60 -24.5t-64.5 -13.5t-74 -4z"" />
    <glyph glyph-name=""exclamdown"" unicode=""&#xa1;"" horiz-adv-x=""682""
d=""M266 685h148l24 -1012h-196zM440 1082v-201h-194v201h194z"" />
    <glyph glyph-name=""cent"" unicode=""&#xa2;""
d=""M538 282v830q-166 -24 -202 -228q-13 -78 -13 -177t13 -177q38 -218 202 -248zM662 284q150 34 174 205l182 -12q-27 -211 -210 -301q-63 -31 -146 -39v-168h-124v168q-211 19 -312 177q-91 142 -91 383q0 278 121 421q102 120 282 136v155h124v-155q222 -23 311 -202
q27 -55 39 -118l-185 -14q-14 90 -61 133.5t-104 55.5v-825z"" />
    <glyph glyph-name=""sterling"" unicode=""&#xa3;""
d=""M1104 311q-9 -80 -37.5 -138.5t-73 -97t-102 -57t-124.5 -18.5h-698v154q89 46 132 126t43 201v144h-186v129h186v280q0 92 24 165.5t73.5 124.5t125.5 78.5t179 27.5q70 0 131.5 -14.5t111 -43.5t85 -72t53.5 -100l-174 -57q-10 31 -29.5 57t-46 44t-59 28t-68.5 10
q-114 0 -170 -57.5t-56 -182.5v-288h408v-129h-408v-126q0 -56 -11 -109t-33 -99t-53.5 -81.5t-71.5 -56.5h483q38 0 71.5 9.5t60 30.5t45 54.5t26.5 81.5z"" />
    <glyph glyph-name=""currency"" unicode=""&#xa4;""
d=""M137 684q0 71 20.5 134.5t57.5 117.5l-100 100l104 103l99 -101q54 39 117.5 60.5t136.5 21.5q71 0 134 -21t117 -59l97 97l104 -105l-96 -96q37 -54 58.5 -117.5t21.5 -134.5t-22 -135t-60 -117l100 -100l-102 -105l-101 101q-54 -37 -117 -57.5t-134 -20.5
q-72 0 -136 21t-116 59l-105 -105l-102 105l102 102q-37 54 -57.5 117.5t-20.5 134.5zM291 686q0 -58 22 -109t60.5 -89t89.5 -60t109 -22q57 0 108 22t89.5 60t60.5 89t22 109t-22 109t-60.5 89t-89.5 60.5t-108 22.5q-58 0 -109 -22.5t-89.5 -60.5t-60.5 -89t-22 -109z
"" />
    <glyph glyph-name=""yen"" unicode=""&#xa5;""
d=""M720 709h321v-125h-383v-154h383v-127h-383v-303h-178v303h-381v127h381l2 154h-383v125h320l-421 700h199l371 -647l375 647h199z"" />
    <glyph glyph-name=""brokenbar"" unicode=""&#xa6;"" horiz-adv-x=""532""
d=""M183 706v778h166v-778h-166zM183 -434v779h166v-779h-166z"" />
    <glyph glyph-name=""section"" unicode=""&#xa7;""
d=""M588 1484q79 0 148 -15t123 -46.5t90.5 -80.5t51.5 -118l-161 -20q-8 45 -31 74t-57 46t-76 23.5t-88 6.5q-125 0 -189.5 -39.5t-64.5 -110.5q0 -45 25 -77t66.5 -55t96 -39t113.5 -30q68 -16 137.5 -39t125.5 -59.5t91 -89.5t35 -129q0 -45 -14 -88.5t-41.5 -80
t-68.5 -64t-95 -40.5q49 -21 88.5 -46.5t67 -57.5t42.5 -72.5t15 -91.5q0 -73 -29 -131.5t-85 -100t-138 -63.5t-189 -22q-93 0 -170 13.5t-135.5 45.5t-98 84t-58.5 129l161 31q12 -55 39 -88.5t66 -52t89 -25t107 -6.5q58 0 109 9t89 29t60.5 52.5t22.5 79.5
q0 54 -28.5 90t-76 61.5t-109 43.5t-126.5 34q-65 15 -130.5 38t-117.5 59.5t-84.5 89t-32.5 126.5q0 45 16 86.5t45.5 77t71.5 62t95 41.5q-42 14 -79.5 37t-66 55t-45 72t-16.5 88q0 139 105.5 216.5t308.5 77.5zM866 663q0 48 -26.5 82.5t-70.5 60t-100.5 43t-117.5 31.5
q-58 -3 -102.5 -19.5t-74.5 -42.5t-45.5 -60.5t-15.5 -73.5q0 -46 24.5 -79t65.5 -57t95 -41t114 -32q54 1 100.5 13t80.5 35.5t53.5 58.5t19.5 81z"" />
    <glyph glyph-name=""dieresis"" unicode=""&#xa8;"" horiz-adv-x=""682""
d=""M439 1219v184h163v-184h-163zM45 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""copyright"" unicode=""&#xa9;"" horiz-adv-x=""1509""
d=""M1477 707q0 -100 -26 -192.5t-73 -173t-112.5 -146t-146 -112.5t-173 -73t-192.5 -26q-99 0 -191.5 26t-172.5 73t-146.5 112.5t-113.5 146t-73 173t-26 192.5t26 192t73 172.5t113 146.5t146.5 113t172.5 73t192 26q150 0 281.5 -57t230 -155t155 -229.5t56.5 -281.5z
M1385 707q0 86 -22.5 166.5t-63.5 150t-99 127t-128 98.5t-150.5 63.5t-167.5 22.5q-130 0 -244 -49.5t-199.5 -135t-135 -199.5t-49.5 -244q0 -131 49.5 -245.5t135 -200t199.5 -134.5t244 -49q87 0 167.5 22.5t150.5 63t128 98t99 127.5t63.5 150.5t22.5 167.5zM498 709
q0 -72 16.5 -132t50 -103t83.5 -67t117 -24q49 0 86.5 13.5t65.5 36t47.5 50t33.5 56.5l115 -35q-22 -43 -51 -83.5t-70 -72t-96.5 -50.5t-130.5 -19q-101 0 -175.5 32t-123.5 89t-73 136t-24 173q0 97 24 175.5t72.5 134t121.5 85t171 29.5q75 0 131 -18t96 -47.5t67.5 -67
t45.5 -76.5l-114 -33q-12 26 -31 51t-46.5 44t-63.5 30.5t-83 11.5q-69 0 -118.5 -23t-81.5 -64.5t-47 -100.5t-15 -131z"" />
    <glyph glyph-name=""ordfeminine"" unicode=""&#xaa;"" horiz-adv-x=""758""
d=""M260 651q-53 0 -96 14.5t-74 42.5t-47.5 69t-16.5 93q0 69 25.5 115t68.5 74t99.5 40t118.5 13l178 4v60q0 46 -10.5 76t-30 47.5t-47.5 24.5t-63 7q-67 0 -107.5 -29.5t-49.5 -105.5l-149 10q7 47 28.5 88t59 72t91.5 48.5t125 17.5q68 0 122.5 -14.5t93 -44.5
t59.5 -77.5t21 -113.5v-308q0 -58 14 -83t49 -25q12 0 23 2.5t20 5.5v-104q-19 -5 -40 -9t-43 -4q-41 0 -69.5 11t-47.5 30.5t-29 45t-12 54.5h-4q-38 -77 -104 -112t-156 -35zM299 762q48 0 88 17t68.5 44.5t44.5 63t16 72.5v65l-138 -4q-41 -2 -78 -7.5t-64.5 -20
t-43.5 -40.5t-16 -69q0 -56 29 -88.5t94 -32.5z"" />
    <glyph glyph-name=""guillemotleft"" unicode=""&#xab;""
d=""M886 141l-338 365v63l338 371h168v-31l-338 -372l340 -367v-29h-170zM419 141l-336 365v63l336 371h167v-31l-335 -372l337 -367v-29h-169z"" />
    <glyph glyph-name=""logicalnot"" unicode=""&#xac;"" horiz-adv-x=""1196""
d=""M950 180v428h-850v146h995v-574h-145z"" />
    <glyph glyph-name=""registered"" unicode=""&#xae;"" horiz-adv-x=""1509""
d=""M1477 707q0 -100 -26 -192.5t-73 -173t-112.5 -146t-146 -112.5t-173 -73t-192.5 -26q-99 0 -191.5 26t-172.5 73t-146.5 112.5t-113.5 146t-73 173t-26 192.5t26 192t73 172.5t113 146.5t146.5 113t172.5 73t192 26q150 0 281.5 -57t230 -155t155 -229.5t56.5 -281.5z
M1385 707q0 86 -22.5 166.5t-63.5 150t-99 127t-128 98.5t-150.5 63.5t-167.5 22.5q-130 0 -244 -49.5t-199.5 -135t-135 -199.5t-49.5 -244q0 -131 49.5 -245.5t135 -200t199.5 -134.5t244 -49q87 0 167.5 22.5t150.5 63t128 98t99 127.5t63.5 150.5t22.5 167.5zM955 289
l-199 336h-161v-336h-127v831h307q142 0 217.5 -63t75.5 -174q0 -102 -52 -163.5t-137 -80.5l221 -350h-145zM941 881q0 69 -47.5 105t-128.5 36h-170v-301h182q80 0 122 42.5t42 117.5z"" />
    <glyph glyph-name=""macron"" unicode=""&#xaf;"" horiz-adv-x=""1131""
d=""M1148 1452h-1165v94h1165v-94z"" />
    <glyph glyph-name=""degree"" unicode=""&#xb0;"" horiz-adv-x=""819""
d=""M696 1145q0 -59 -22.5 -111t-61.5 -90.5t-91.5 -61t-111.5 -22.5t-111 22.5t-91 61t-62 90.5t-23 111q0 60 23 112t62 90.5t91 60.5t111 22t111.5 -22t91.5 -60.5t61.5 -90.5t22.5 -112zM587 1145q0 37 -13.5 70t-37.5 57.5t-56.5 38.5t-70.5 14q-37 0 -69.5 -14
t-56.5 -38.5t-38 -57.5t-14 -70t14 -69.5t38 -57t56.5 -39t69.5 -14.5q38 0 70.5 14.5t56.5 39t37.5 57t13.5 69.5z"" />
    <glyph glyph-name=""plusminus"" unicode=""&#xb1;"" horiz-adv-x=""1124""
d=""M636 680v-395h-147v395h-424v145h424v394h147v-394h424v-145h-424zM65 0v145h995v-145h-995z"" />
    <glyph glyph-name=""uni00B2"" unicode=""&#xb2;"" horiz-adv-x=""682""
d=""M43 563l-2 103q27 61 71 109t94 88.5t101.5 76.5t92.5 72.5t67 76.5t26 89q0 62 -35.5 99.5t-109.5 37.5q-68 0 -112 -36.5t-52 -104.5l-133 8q6 51 29 94.5t61 75.5t91.5 50.5t121.5 18.5q65 0 116.5 -16.5t87 -46.5t54 -73t18.5 -97q0 -62 -27 -112t-68.5 -93
t-92.5 -80.5t-98.5 -74t-86.5 -73.5t-57 -79h443v-113h-600z"" />
    <glyph glyph-name=""uni00B3"" unicode=""&#xb3;"" horiz-adv-x=""682""
d=""M642 795q0 -116 -77.5 -180t-219.5 -64q-87 0 -145 19.5t-94.5 51.5t-54.5 72.5t-24 83.5l136 13q9 -67 53 -101.5t129 -34.5q77 0 118.5 36t41.5 112q0 45 -18.5 72t-46.5 41.5t-61.5 19t-62.5 4.5h-61v109h57q29 0 59.5 6.5t55.5 22t41 42t16 66.5q0 60 -37 94.5
t-108 34.5q-68 0 -110 -35t-48 -100l-135 12q7 58 32 101t64.5 71.5t90.5 42.5t110 14q69 0 121 -16.5t87 -46t52.5 -69t17.5 -85.5q0 -75 -43 -130t-133 -75v-2q52 -5 89.5 -23.5t61.5 -45.5t35 -61.5t11 -71.5z"" />
    <glyph glyph-name=""acute"" unicode=""&#xb4;"" horiz-adv-x=""682""
d=""M72 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""uni00B5"" unicode=""&#xb5;"" horiz-adv-x=""1180""
d=""M140 -425v1507h181v-686q0 -78 16 -131t45 -85.5t71 -46.5t94 -14q128 0 201 87t73 249v627h180v-816q0 -44 5.5 -72t15.5 -44t24.5 -22.5t32.5 -6.5q11 0 27 2.5t27 5.5v-129q-26 -8 -51.5 -14t-61.5 -6q-54 0 -89.5 15t-57.5 41t-32 61.5t-12 76.5h-3
q-52 -95 -125.5 -144.5t-173.5 -49.5q-67 0 -121.5 20.5t-85.5 58.5v-484h-180z"" />
    <glyph glyph-name=""paragraph"" unicode=""&#xb6;"" horiz-adv-x=""1100""
d=""M884 1307v-1571h-112v1571h-217v-1571h-113v958q-80 0 -146.5 22.5t-114.5 66.5t-74.5 110.5t-26.5 155.5q0 84 25 150.5t72.5 113t116.5 71.5t156 25h563v-102h-129z"" />
    <glyph glyph-name=""uni2219"" unicode=""&#xb7;"" horiz-adv-x=""569""
d=""M187 446v220h195v-220h-195z"" />
    <glyph glyph-name=""uni2219"" unicode=""&#x2219;"" horiz-adv-x=""569""
d=""M187 446v220h195v-220h-195z"" />
    <glyph glyph-name=""cedilla"" unicode=""&#xb8;"" horiz-adv-x=""682""
d=""M483 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5z"" />
    <glyph glyph-name=""uni00B9"" unicode=""&#xb9;"" horiz-adv-x=""682""
d=""M80 563v107h211v620l-202 -138v120l210 137h123v-739h215v-107h-557z"" />
    <glyph glyph-name=""ordmasculine"" unicode=""&#xba;"" horiz-adv-x=""748""
d=""M723 1042q0 -188 -88 -289.5t-263 -101.5q-168 0 -256.5 100.5t-88.5 290.5q0 91 21.5 163.5t65 123t109 77t153.5 26.5q93 0 158.5 -26.5t107.5 -76.5t61.5 -122.5t19.5 -164.5zM574 1042q0 83 -12.5 138t-37.5 87.5t-61 46t-84 13.5t-85.5 -13.5t-63 -46.5t-38.5 -88
t-13 -137q0 -84 14 -139t39.5 -88t60.5 -46t78 -13q49 0 86.5 13t63.5 46t39.5 88t13.5 139z"" />
    <glyph glyph-name=""guillemotright"" unicode=""&#xbb;""
d=""M718 141h-168v29l338 367l-336 372v31h166l338 -371v-63zM253 141h-170v29l338 367l-336 372v31h168l335 -371v-63z"" />
    <glyph glyph-name=""onequarter"" unicode=""&#xbc;"" horiz-adv-x=""1708""
d=""M56 563v107h211v620l-202 -138v120l210 137h123v-739h215v-107h-557zM493 0h-148l881 1409h145zM1503 180v-178h-131v178h-406v111l386 557h151v-555h111v-113h-111zM1374 715q-7 -13 -18 -31.5t-23 -38t-23 -37t-18 -28.5l-199 -287h279v289v33v38t0.5 36t1.5 26z"" />
    <glyph glyph-name=""onehalf"" unicode=""&#xbd;"" horiz-adv-x=""1708""
d=""M56 563v107h211v620l-202 -138v120l210 137h123v-739h215v-107h-557zM493 0h-148l881 1409h145zM1053 2l-2 103q27 61 71 109t94 88.5t101.5 76.5t92.5 72.5t67 76.5t26 89q0 62 -35.5 99.5t-109.5 37.5q-68 0 -112 -36.5t-52 -104.5l-133 8q6 51 29 94.5t61 75.5
t91.5 50.5t121.5 18.5q65 0 116.5 -16.5t87 -46.5t54 -73t18.5 -97q0 -62 -27 -112t-68.5 -93t-92.5 -80.5t-98.5 -74t-86.5 -73.5t-57 -79h443v-113h-600z"" />
    <glyph glyph-name=""threequarters"" unicode=""&#xbe;"" horiz-adv-x=""1708""
d=""M513 0h-148l881 1409h145zM1503 180v-178h-131v178h-406v111l386 557h151v-555h111v-113h-111zM1374 715q-7 -13 -18 -31.5t-23 -38t-23 -37t-18 -28.5l-199 -287h279v289v33v38t0.5 36t1.5 26zM688 795q0 -116 -77.5 -180t-219.5 -64q-87 0 -145 19.5t-94.5 51.5
t-54.5 72.5t-24 83.5l136 13q9 -67 53 -101.5t129 -34.5q77 0 118.5 36t41.5 112q0 45 -18.5 72t-46.5 41.5t-61.5 19t-62.5 4.5h-61v109h57q29 0 59.5 6.5t55.5 22t41 42t16 66.5q0 60 -37 94.5t-108 34.5q-68 0 -110 -35t-48 -100l-135 12q7 58 32 101t64.5 71.5
t90.5 42.5t110 14q69 0 121 -16.5t87 -46t52.5 -69t17.5 -85.5q0 -75 -43 -130t-133 -75v-2q52 -5 89.5 -23.5t61.5 -45.5t35 -61.5t11 -71.5z"" />
    <glyph glyph-name=""questiondown"" unicode=""&#xbf;"" horiz-adv-x=""1251""
d=""M131 50q0 71 18.5 125t49.5 96.5t70.5 76t80.5 63.5t80.5 59t71 63t51 75.5t20.5 96.5h175q-2 -69 -21.5 -121t-50.5 -92t-70 -71.5t-79 -60t-78.5 -57t-68.5 -63.5t-48.5 -79t-18.5 -103t21 -105t59.5 -77.5t93 -47.5t121.5 -16q140 0 222 70t96 192l184 -12
q-11 -84 -44.5 -158.5t-94 -130.5t-150 -88.5t-211.5 -32.5q-114 0 -203 28t-150.5 79.5t-93.5 125t-32 165.5zM756 1082v-201h-195v201h195z"" />
    <glyph glyph-name=""Agrave"" unicode=""&#xc0;"" horiz-adv-x=""1366""
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM750 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""Aacute"" unicode=""&#xc1;"" horiz-adv-x=""1366""
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM547 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""Acircumflex"" unicode=""&#xc2;"" horiz-adv-x=""1366""
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM1014 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""Atilde"" unicode=""&#xc3;"" horiz-adv-x=""1366""
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM842 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88
h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""Adieresis"" unicode=""&#xc4;"" horiz-adv-x=""1366""
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM803 1530v184h163v-184h-163zM409 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""Aring"" unicode=""&#xc5;"" horiz-adv-x=""1366""
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM928 1546q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94
t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM820 1546q0 28 -10.5 52.5t-28.5 42.5t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5
t28.5 43.5t10.5 53.5z"" />
    <glyph glyph-name=""AE"" unicode=""&#xc6;"" horiz-adv-x=""2048""
d=""M969 0v412h-548l-198 -412h-199l686 1409h1209v-156h-759v-452h699v-154h-699v-491h800v-156h-991zM969 1262h-151q-1 -3 -9 -20.5t-19 -42.5t-24.5 -54t-25.5 -54.5t-21 -44.5t-11 -24l-217 -461h478v701z"" />
    <glyph glyph-name=""Ccedilla"" unicode=""&#xc7;"" horiz-adv-x=""1479""
d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5
t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM993 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5
t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5z"" />
    <glyph glyph-name=""Egrave"" unicode=""&#xc8;"" horiz-adv-x=""1366""
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM735 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""Eacute"" unicode=""&#xc9;"" horiz-adv-x=""1366""
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM551 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""Ecircumflex"" unicode=""&#xca;"" horiz-adv-x=""1366""
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM1037 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""Edieresis"" unicode=""&#xcb;"" horiz-adv-x=""1366""
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM816 1530v184h163v-184h-163zM422 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""Igrave"" unicode=""&#xcc;"" horiz-adv-x=""569""
d=""M189 0v1409h191v-1409h-191zM319 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""Iacute"" unicode=""&#xcd;"" horiz-adv-x=""569""
d=""M189 0v1409h191v-1409h-191zM142 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""Icircumflex"" unicode=""&#xce;"" horiz-adv-x=""569""
d=""M189 0v1409h191v-1409h-191zM616 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""Idieresis"" unicode=""&#xcf;"" horiz-adv-x=""569""
d=""M189 0v1409h191v-1409h-191zM401 1530v184h163v-184h-163zM7 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""Eth"" unicode=""&#xd0;"" horiz-adv-x=""1479""
d=""M14 801h154v608h466q163 0 300.5 -40.5t236.5 -125t154.5 -214.5t55.5 -310q0 -176 -53 -310.5t-145 -225t-217.5 -137t-270.5 -46.5h-527v647h-154v154zM1189 719q0 143 -41 244.5t-115 166.5t-177 95.5t-226 30.5h-271v-455h406v-154h-406v-494h314q111 0 205.5 36
t163.5 107t108 177t39 246z"" />
    <glyph glyph-name=""Ntilde"" unicode=""&#xd1;"" horiz-adv-x=""1479""
d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230zM909 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25
q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""Ograve"" unicode=""&#xd2;"" horiz-adv-x=""1593""
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM854 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""Oacute"" unicode=""&#xd3;"" horiz-adv-x=""1593""
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM621 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""Ocircumflex"" unicode=""&#xd4;"" horiz-adv-x=""1593""
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM1131 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""Otilde"" unicode=""&#xd5;"" horiz-adv-x=""1593""
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM941 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25
q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""Odieresis"" unicode=""&#xd6;"" horiz-adv-x=""1593""
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM910 1530v184h163v-184h-163zM516 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""multiply"" unicode=""&#xd7;"" horiz-adv-x=""1196""
d=""M142 330l354 354l-352 352l104 103l350 -353l350 351l105 -105l-350 -348l352 -352l-102 -105l-353 353l-356 -355z"" />
    <glyph glyph-name=""Oslash"" unicode=""&#xd8;"" horiz-adv-x=""1593""
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-127 0 -230 29t-184 83l-120 -145h-190l200 241q-88 97 -131 230t-43 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q125 0 228.5 -28t185.5 -82l121 146h192l-201 -242q85 -94 128.5 -223.5
t43.5 -289.5zM1300 711q0 112 -24.5 204t-73.5 164l-709 -853q59 -44 134 -67.5t168 -23.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM291 711q0 -113 25 -208t76 -170l707 853q-59 42 -134.5 65t-167.5 23q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231z"" />
    <glyph glyph-name=""Ugrave"" unicode=""&#xd9;"" horiz-adv-x=""1479""
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM813 1530
l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""Uacute"" unicode=""&#xda;"" horiz-adv-x=""1479""
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM565 1530v20
l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""Ucircumflex"" unicode=""&#xdb;"" horiz-adv-x=""1479""
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM1070 1550v-20
h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""Udieresis"" unicode=""&#xdc;"" horiz-adv-x=""1479""
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM853 1530v184
h163v-184h-163zM459 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""Yacute"" unicode=""&#xdd;"" horiz-adv-x=""1366""
d=""M777 584v-584h-190v584l-542 825h210l429 -671l427 671h210zM536 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""Thorn"" unicode=""&#xde;"" horiz-adv-x=""1366""
d=""M1258 735q0 -88 -29.5 -167.5t-90 -139.5t-151.5 -95.5t-214 -35.5h-414v-297h-191v1409h191v-252h402q125 0 218 -30t155 -85.5t93 -133.5t31 -173zM1066 731q0 134 -82 208.5t-246 74.5h-379v-576h387q82 0 142.5 22t100 61.5t58.5 93t19 116.5z"" />
    <glyph glyph-name=""germandbls"" unicode=""&#xdf;"" horiz-adv-x=""1251""
d=""M1167 295q0 -66 -20.5 -123.5t-64 -100t-111.5 -67t-162 -24.5q-80 0 -154 12.5t-129 36.5l-2 164q25 -14 58.5 -26.5t70.5 -22t76 -15t76 -5.5q92 0 141 43t49 122q0 56 -27 94.5t-67.5 69.5t-88 59.5t-88 65t-67.5 85.5t-27 122q0 51 16.5 87.5t41 65.5t53.5 53
t53.5 50t41 57.5t16.5 74.5q0 37 -16.5 68t-48 53.5t-76.5 35.5t-102 13q-68 0 -121.5 -17.5t-90 -56t-56 -99.5t-19.5 -149v-1021h-180v1027q0 118 31.5 204.5t91.5 142.5t147 83t197 27q102 0 179.5 -23t130 -63t79 -94.5t26.5 -116.5q0 -61 -16.5 -106t-42 -79.5
t-54.5 -61t-54.5 -50t-42 -47.5t-16.5 -52q0 -38 27.5 -67.5t68.5 -58t88.5 -60.5t88.5 -74.5t68.5 -99.5t27.5 -136z"" />
    <glyph glyph-name=""agrave"" unicode=""&#xe0;""
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM624 1201l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""aacute"" unicode=""&#xe1;""
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM412 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""acircumflex"" unicode=""&#xe2;""
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM880 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""atilde"" unicode=""&#xe3;""
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM737 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5
t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""adieresis"" unicode=""&#xe4;""
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM674 1219v184h163v-184h-163zM280 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""aring"" unicode=""&#xe5;""
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM799 1410q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM691 1410q0 28 -10.5 52.5t-28.5 42.5
t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5t28.5 43.5t10.5 53.5z"" />
    <glyph glyph-name=""ae"" unicode=""&#xe6;"" horiz-adv-x=""1821""
d=""M968 503v-17q1 -82 18 -150t52 -117t89.5 -76.5t132.5 -27.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-321 0 -423 257q-29 -51 -66 -97.5t-88 -82t-119.5 -56.5t-161.5 -21q-167 0 -251.5 86t-84.5 236q0 71 19 125
t52.5 93t79 64.5t99 41.5t112 22.5t118.5 7.5l240 4v59q0 67 -13 114t-41.5 76t-72.5 42.5t-105 13.5q-54 0 -98 -7.5t-76 -27t-51.5 -53t-26.5 -84.5l-188 17q10 64 39 117.5t81.5 92.5t132 60.5t191.5 21.5q128 0 214 -35t135 -104q63 74 151.5 106.5t194.5 32.5
q136 0 227.5 -44t147 -121.5t79 -182.5t23.5 -227v-24h-762zM786 534l-195 -4q-40 -1 -80.5 -4t-78.5 -12t-71 -24.5t-57.5 -41t-38.5 -62t-14 -87.5q0 -87 50 -135.5t143 -48.5q90 0 154.5 31.5t106 80.5t61.5 107t20 111v89zM1544 641q-15 171 -87 249.5t-207 78.5
q-45 0 -93 -14.5t-88.5 -51.5t-67.5 -100.5t-31 -161.5h574z"" />
    <glyph glyph-name=""ccedilla"" unicode=""&#xe7;"" horiz-adv-x=""1024""
d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5
q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM751 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5
t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5z"" />
    <glyph glyph-name=""egrave"" unicode=""&#xe8;""
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM657 1201l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""eacute"" unicode=""&#xe9;""
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM440 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""ecircumflex"" unicode=""&#xea;""
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM907 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""edieresis"" unicode=""&#xeb;""
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM687 1219v184h163v-184h-163zM293 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""igrave"" unicode=""&#xec;"" horiz-adv-x=""569""
d=""M194 0v1082h180v-1082h-180zM340 1201l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""iacute"" unicode=""&#xed;"" horiz-adv-x=""569""
d=""M194 0v1082h180v-1082h-180zM135 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""icircumflex"" unicode=""&#xee;"" horiz-adv-x=""569""
d=""M194 0v1082h180v-1082h-180zM617 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""idieresis"" unicode=""&#xef;"" horiz-adv-x=""569""
d=""M194 0v1082h180v-1082h-180zM402 1219v184h163v-184h-163zM8 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""eth"" unicode=""&#xf0;""
d=""M566 -20q-125 0 -215.5 36.5t-149.5 102.5t-87 158.5t-28 203.5q0 107 26 198t84 158t151 104.5t226 37.5q71 0 129.5 -16t101.5 -43q-43 86 -100.5 174t-133.5 157l-301 -133v114l218 94q-56 45 -116 84t-126 74h209q45 -20 86.5 -45.5t83.5 -56.5l306 132l-1 -112
l-211 -92q81 -74 145.5 -162t108.5 -188t67.5 -211.5t23.5 -232.5v-6q0 -122 -28.5 -220t-88.5 -167t-154 -106t-226 -37zM874 481q0 94 -16.5 162.5t-52 113.5t-92 67t-136.5 22q-81 0 -138.5 -22.5t-94 -68.5t-53 -114.5t-16.5 -159.5q0 -190 72 -279t217 -89q81 0 140 22
t96.5 67t55.5 114.5t18 164.5z"" />
    <glyph glyph-name=""ntilde"" unicode=""&#xf1;""
d=""M829 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22
t107 -68t61.5 -118.5t19.5 -172.5v-721h-181zM737 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5
t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""ograve"" unicode=""&#xf2;""
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM659 1201l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""oacute"" unicode=""&#xf3;""
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM431 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""ocircumflex"" unicode=""&#xf4;""
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM902 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""otilde"" unicode=""&#xf5;""
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM739 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5
t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""odieresis"" unicode=""&#xf6;""
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM689 1219v184h163v-184h-163zM295 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""divide"" unicode=""&#xf7;"" horiz-adv-x=""1124""
d=""M478 958v183h168v-183h-168zM65 608v146h995v-146h-995zM478 223v183h168v-183h-168z"" />
    <glyph glyph-name=""oslash"" unicode=""&#xf8;"" horiz-adv-x=""1251""
d=""M1112 542q0 -284 -125 -423t-363 -139q-97 0 -175 24t-138 74l-100 -116h-167l184 214q-41 68 -62 159t-21 207q0 560 485 560q103 0 181 -23t135 -68l91 105h167l-173 -201q42 -69 61.5 -161.5t19.5 -211.5zM923 542q0 68 -6 122.5t-17 98.5l-483 -562
q38 -49 90.5 -68.5t114.5 -19.5q69 0 125 19.5t95 68.5t60 132t21 209zM334 542q0 -130 24 -215l482 561q-37 45 -89 63t-118 18q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205z"" />
    <glyph glyph-name=""ugrave"" unicode=""&#xf9;""
d=""M320 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM672 1201l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""uacute"" unicode=""&#xfa;""
d=""M320 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM415 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""ucircumflex"" unicode=""&#xfb;""
d=""M320 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM901 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""udieresis"" unicode=""&#xfc;""
d=""M320 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM676 1219v184h163v-184h-163zM282 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""yacute"" unicode=""&#xfd;"" horiz-adv-x=""1024""
d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM355 1201
v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""thorn"" unicode=""&#xfe;""
d=""M138 1484h180v-423q0 -30 -0.5 -57.5t-1.5 -48.5q-1 -25 -2 -47h6q25 52 57 88.5t73 60t91.5 34t113.5 10.5q112 0 188.5 -40t123 -112.5t66.5 -175t20 -227.5q0 -123 -20 -227t-66.5 -179t-123 -117.5t-188.5 -42.5q-116 0 -203 44t-133 144h-5q1 -2 1.5 -18t1 -40
t1 -53.5t0.5 -58.5v-423h-180v1909zM864 542q0 100 -12 178t-41.5 132t-78.5 82t-123 28q-60 0 -113 -17t-92.5 -65t-62.5 -132.5t-23 -219.5q0 -115 19 -194.5t55.5 -128.5t90.5 -70.5t124 -21.5q75 0 124.5 29t79 84t41.5 134.5t12 181.5z"" />
    <glyph glyph-name=""ydieresis"" unicode=""&#xff;"" horiz-adv-x=""1024""
d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM626 1219
v184h163v-184h-163zM232 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""Amacron"" unicode=""&#x100;"" horiz-adv-x=""1366""
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM960 1570h-549v127h549v-127z"" />
    <glyph glyph-name=""amacron"" unicode=""&#x101;""
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM833 1236h-549v127h549v-127z"" />
    <glyph glyph-name=""Abreve"" unicode=""&#x102;"" horiz-adv-x=""1366""
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM685 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83
t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" />
    <glyph glyph-name=""abreve"" unicode=""&#x103;""
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM560 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68
t-134 -25.5z"" />
    <glyph glyph-name=""Aogonek"" unicode=""&#x104;"" horiz-adv-x=""1366""
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM1379 -389q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136
q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z"" />
    <glyph glyph-name=""aogonek"" unicode=""&#x105;""
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM1139 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66
t69.5 -24q29 0 58 6.5t57 17.5v-107z"" />
    <glyph glyph-name=""Cacute"" unicode=""&#x106;"" horiz-adv-x=""1479""
d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5
t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM667 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""cacute"" unicode=""&#x107;"" horiz-adv-x=""1024""
d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5
q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM431 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Ccircumflex"" unicode=""&#x108;"" horiz-adv-x=""1479""
d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5
t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM1122 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""ccircumflex"" unicode=""&#x109;"" horiz-adv-x=""1024""
d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5
q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM870 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""Cdotaccent"" unicode=""&#x10a;"" horiz-adv-x=""1479""
d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5
t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM702 1605v172h180v-172h-180z"" />
    <glyph glyph-name=""cdotaccent"" unicode=""&#x10b;"" horiz-adv-x=""1024""
d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5
q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM456 1312v172h180v-172h-180z"" />
    <glyph glyph-name=""Ccaron"" unicode=""&#x10c;"" horiz-adv-x=""1479""
d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5
t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM898 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""ccaron"" unicode=""&#x10d;"" horiz-adv-x=""1024""
d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5
q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM652 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" />
    <glyph glyph-name=""Dcaron"" unicode=""&#x10e;"" horiz-adv-x=""1479""
d=""M1381 719q0 -176 -53 -310.5t-145 -225t-217.5 -137t-270.5 -46.5h-527v1409h466q163 0 300.5 -40.5t236.5 -125t154.5 -214.5t55.5 -310zM1189 719q0 143 -41 244.5t-115 166.5t-177 95.5t-226 30.5h-271v-1103h314q111 0 205.5 36t163.5 107t108 177t39 246zM796 1530
h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""dcaron"" unicode=""&#x10f;"" horiz-adv-x=""1259""
d=""M821 174q-50 -104 -132.5 -149t-204.5 -45q-205 0 -301.5 138t-96.5 418q0 566 398 566q123 0 205 -45t132 -143h2q0 10 -0.5 31.5t-1 45t-0.5 44.5v30v419h180v-1261q0 -39 0.5 -75t1.5 -66t2 -51.5t2 -30.5h-172q-2 10 -3.5 28.5t-3 42.5t-2.5 50.5t-1 52.5h-4z
M275 542q0 -112 14 -192t45 -131.5t79 -75.5t117 -24q71 0 125.5 23t91 74.5t55.5 134.5t19 203q0 115 -19 194.5t-56 128.5t-90.5 70.5t-123.5 21.5q-66 0 -114 -23t-80 -74t-47.5 -132.5t-15.5 -197.5zM1279 1378q0 -87 -22 -145.5t-62 -105.5h-117q45 48 69.5 96t24.5 94
h-88v167h195v-106z"" />
    <glyph glyph-name=""Dcroat"" unicode=""&#x110;"" horiz-adv-x=""1479""
d=""M14 801h154v608h466q163 0 300.5 -40.5t236.5 -125t154.5 -214.5t55.5 -310q0 -176 -53 -310.5t-145 -225t-217.5 -137t-270.5 -46.5h-527v647h-154v154zM1189 719q0 143 -41 244.5t-115 166.5t-177 95.5t-226 30.5h-271v-455h406v-154h-406v-494h314q111 0 205.5 36
t163.5 107t108 177t39 246z"" />
    <glyph glyph-name=""dcroat"" unicode=""&#x111;""
d=""M821 174q-50 -104 -132.5 -149t-204.5 -45q-205 0 -301.5 138t-96.5 418q0 566 398 566q123 0 205 -45t132 -143h2q0 10 -0.5 31.5t-1 45t-0.5 44.5v30v141h-300v131h300v147h180v-147h132v-131h-132v-983q0 -39 0.5 -75t1.5 -66t2 -51.5t2 -30.5h-172q-2 10 -3.5 28.5
t-3 42.5t-2.5 50.5t-1 52.5h-4zM275 542q0 -112 14 -192t45 -131.5t79 -75.5t117 -24q71 0 125.5 23t91 74.5t55.5 134.5t19 203q0 115 -19 194.5t-56 128.5t-90.5 70.5t-123.5 21.5q-66 0 -114 -23t-80 -74t-47.5 -132.5t-15.5 -197.5z"" />
    <glyph glyph-name=""Emacron"" unicode=""&#x112;"" horiz-adv-x=""1366""
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM978 1570h-549v127h549v-127z"" />
    <glyph glyph-name=""emacron"" unicode=""&#x113;""
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM845 1236h-549v127h549v-127z"" />
    <glyph glyph-name=""Ebreve"" unicode=""&#x114;"" horiz-adv-x=""1366""
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM701 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" />
    <glyph glyph-name=""ebreve"" unicode=""&#x115;""
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM569 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117
q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68t-134 -25.5z"" />
    <glyph glyph-name=""Edotaccent"" unicode=""&#x116;"" horiz-adv-x=""1366""
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM613 1605v172h180v-172h-180z"" />
    <glyph glyph-name=""edotaccent"" unicode=""&#x117;""
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM480 1312v172h180v-172h-180z"" />
    <glyph glyph-name=""Eogonek"" unicode=""&#x118;"" horiz-adv-x=""1366""
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM1278 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24
q29 0 58 6.5t57 17.5v-107z"" />
    <glyph glyph-name=""eogonek"" unicode=""&#x119;""
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM811 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52
t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z"" />
    <glyph glyph-name=""Ecaron"" unicode=""&#x11a;"" horiz-adv-x=""1366""
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM805 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""ecaron"" unicode=""&#x11b;""
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM672 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" />
    <glyph glyph-name=""Gcircumflex"" unicode=""&#x11c;"" horiz-adv-x=""1593""
d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5
q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293zM1137 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""gcircumflex"" unicode=""&#x11d;""
d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234
t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24
q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191zM878 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""Gbreve"" unicode=""&#x11e;"" horiz-adv-x=""1593""
d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5
q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293zM810 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5
t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" />
    <glyph glyph-name=""gbreve"" unicode=""&#x11f;""
d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234
t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24
q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191zM546 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5
t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68t-134 -25.5z"" />
    <glyph glyph-name=""Gdotaccent"" unicode=""&#x120;"" horiz-adv-x=""1593""
d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5
q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293zM721 1605v172h180v-172h-180z"" />
    <glyph glyph-name=""gdotaccent"" unicode=""&#x121;""
d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234
t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24
q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191zM457 1312v172h180v-172h-180z"" />
    <glyph glyph-name=""Gcommaaccent"" unicode=""&#x122;"" horiz-adv-x=""1593""
d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5
q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293zM918 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""gcommaaccent"" unicode=""&#x123;""
d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234
t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24
q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191zM442 1317q0 87 22 145.5t62 105.5h117q-45 -48 -69.5 -96t-24.5 -94h88v-167h-195v106z"" />
    <glyph glyph-name=""Hcircumflex"" unicode=""&#x124;"" horiz-adv-x=""1479""
d=""M1121 0v653h-762v-653h-191v1409h191v-596h762v596h191v-1409h-191zM1071 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""hcircumflex"" unicode=""&#x125;""
d=""M317 897q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-721h-181v686q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-638h-180v1484h180v-386q0 -33 -1 -66t-2.5 -61t-2.5 -47.5
t-2 -26.5h3zM904 1614v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""Hbar"" unicode=""&#x126;"" horiz-adv-x=""1479""
d=""M1126 0v653h-767v-653h-191v1025h-154v154h154v230h191v-230h767v230h186v-230h153v-154h-153v-1025h-186zM1126 813v212h-767v-212h767z"" />
    <glyph glyph-name=""hbar"" unicode=""&#x127;""
d=""M317 857q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-681h-181v646q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-598h-180v1206h-132v131h132v147h180v-147h300v-131h-300
v-148q0 -33 -1 -66t-2.5 -61t-2.5 -47.5t-2 -26.5h3z"" />
    <glyph glyph-name=""Itilde"" unicode=""&#x128;"" horiz-adv-x=""569""
d=""M189 0v1409h191v-1409h-191zM443 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5
t-97 -25.5z"" />
    <glyph glyph-name=""itilde"" unicode=""&#x129;"" horiz-adv-x=""569""
d=""M194 0v1082h180v-1082h-180zM443 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5
t-97 -25.5z"" />
    <glyph glyph-name=""Imacron"" unicode=""&#x12a;"" horiz-adv-x=""569""
d=""M189 0v1409h191v-1409h-191zM561 1570h-549v127h549v-127z"" />
    <glyph glyph-name=""imacron"" unicode=""&#x12b;"" horiz-adv-x=""569""
d=""M194 0v1082h180v-1082h-180zM561 1236h-549v127h549v-127z"" />
    <glyph glyph-name=""Ibreve"" unicode=""&#x12c;"" horiz-adv-x=""569""
d=""M189 0v1409h191v-1409h-191zM286 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" />
    <glyph glyph-name=""ibreve"" unicode=""&#x12d;"" horiz-adv-x=""569""
d=""M194 0v1082h180v-1082h-180zM286 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68t-134 -25.5z"" />
    <glyph glyph-name=""Iogonek"" unicode=""&#x12e;"" horiz-adv-x=""569""
d=""M189 0v1409h191v-1409h-191zM442 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z"" />
    <glyph glyph-name=""iogonek"" unicode=""&#x12f;"" horiz-adv-x=""455""
d=""M137 1312v172h180v-172h-180zM137 0v1082h180v-1082h-180zM381 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5
v-107z"" />
    <glyph glyph-name=""Idotaccent"" unicode=""&#x130;"" horiz-adv-x=""569""
d=""M189 0v1409h191v-1409h-191zM195 1605v172h180v-172h-180z"" />
    <glyph glyph-name=""dotlessi"" unicode=""&#x131;"" horiz-adv-x=""569""
d=""M194 0v1082h180v-1082h-180z"" />
    <glyph glyph-name=""IJ"" unicode=""&#x132;"" horiz-adv-x=""1505""
d=""M170 0v1409h191v-1409h-191zM938 -20q-171 0 -280.5 89t-144.5 281l187 31q10 -65 33 -111.5t55 -76.5t71 -44t80 -14q104 0 164 71.5t60 209.5v837h-271v156h461v-989q0 -101 -28 -182t-81.5 -138.5t-130.5 -88.5t-175 -31z"" />
    <glyph glyph-name=""ij"" unicode=""&#x133;"" horiz-adv-x=""909""
d=""M137 1312v172h180v-172h-180zM137 0v1082h180v-1082h-180zM591 1312v172h180v-172h-180zM771 -134q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v1189h180v-1216z"" />
    <glyph glyph-name=""Jcircumflex"" unicode=""&#x134;"" horiz-adv-x=""1024""
d=""M457 -20q-171 0 -280.5 89t-144.5 281l187 31q10 -65 33 -111.5t55 -76.5t71 -44t80 -14q104 0 164 71.5t60 209.5v837h-271v156h461v-989q0 -101 -28 -182t-81.5 -138.5t-130.5 -88.5t-175 -31zM973 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""jcircumflex"" unicode=""&#x135;"" horiz-adv-x=""455""
d=""M77 -425q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v1189h180v-1216q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5zM559 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""Kcommaaccent"" unicode=""&#x136;"" horiz-adv-x=""1366""
d=""M1106 0l-563 680l-184 -140v-540h-191v1409h191v-706l679 706h225l-600 -612l680 -797h-237zM805 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""kcommaaccent"" unicode=""&#x137;"" horiz-adv-x=""1024""
d=""M816 0l-366 494l-132 -109v-385h-180v1484h180v-927l475 525h211l-439 -465l462 -617h-211zM662 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""kgreenlandic"" unicode=""&#x138;"" horiz-adv-x=""1024""
d=""M816 0l-366 494l-132 -108v-386h-180v1082h180v-525l475 525h211l-439 -465l462 -617h-211z"" />
    <glyph glyph-name=""Lacute"" unicode=""&#x139;""
d=""M168 0v1409h191v-1253h712v-156h-903zM245 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""lacute"" unicode=""&#x13a;"" horiz-adv-x=""455""
d=""M138 0v1484h180v-1484h-180zM91 1608v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""Lcommaaccent"" unicode=""&#x13b;""
d=""M168 0v1409h191v-1253h712v-156h-903zM717 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""lcommaaccent"" unicode=""&#x13c;"" horiz-adv-x=""455""
d=""M138 0v1484h180v-1484h-180zM327 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""Lcaron"" unicode=""&#x13d;""
d=""M168 0v1409h191v-1253h712v-156h-903zM858 1303q0 -87 -22 -145.5t-62 -105.5h-117q45 48 69.5 96t24.5 94h-88v167h195v-106z"" />
    <glyph glyph-name=""lcaron"" unicode=""&#x13e;"" horiz-adv-x=""597""
d=""M138 0v1484h180v-1484h-180zM617 1378q0 -87 -22 -145.5t-62 -105.5h-117q45 48 69.5 96t24.5 94h-88v167h195v-106z"" />
    <glyph glyph-name=""Ldot"" unicode=""&#x13f;""
d=""M168 0v1409h191v-1253h712v-156h-903zM625 687v172h180v-172h-180z"" />
    <glyph glyph-name=""ldot"" unicode=""&#x140;"" horiz-adv-x=""684""
d=""M138 0v1484h180v-1484h-180zM478 687v172h180v-172h-180z"" />
    <glyph glyph-name=""Lslash"" unicode=""&#x141;""
d=""M616 797l-257 -149v-492h712v-156h-903v538l-148 -85v158l148 85v713h191v-603l257 148v-157z"" />
    <glyph glyph-name=""lslash"" unicode=""&#x142;"" horiz-adv-x=""455""
d=""M138 0v542l-122 -68v158l122 68v784h180v-680l124 72v-159l-124 -71v-646h-180z"" />
    <glyph glyph-name=""Nacute"" unicode=""&#x143;"" horiz-adv-x=""1479""
d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230zM601 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""nacute"" unicode=""&#x144;""
d=""M829 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22
t107 -68t61.5 -118.5t19.5 -172.5v-721h-181zM460 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Ncommaaccent"" unicode=""&#x145;"" horiz-adv-x=""1479""
d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230zM836 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""ncommaaccent"" unicode=""&#x146;""
d=""M829 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22
t107 -68t61.5 -118.5t19.5 -172.5v-721h-181zM675 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""Ncaron"" unicode=""&#x147;"" horiz-adv-x=""1479""
d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230zM841 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""ncaron"" unicode=""&#x148;""
d=""M829 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22
t107 -68t61.5 -118.5t19.5 -172.5v-721h-181zM680 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" />
    <glyph glyph-name=""napostrophe"" unicode=""&#x149;"" horiz-adv-x=""1237""
d=""M923 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22
t107 -68t61.5 -118.5t19.5 -172.5v-721h-181zM199 1264q0 -53 -4.5 -96t-14.5 -80.5t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 129h-88v197h195v-145z"" />
    <glyph glyph-name=""Eng"" unicode=""&#x14a;"" horiz-adv-x=""1481""
d=""M941 -20q-56 0 -104 12t-87.5 32t-71 47t-55.5 57l127 115q37 -45 87 -77.5t109 -32.5q64 0 103 29t59.5 82.5t27 130t6.5 171.5v322q0 108 -19.5 185t-60 126t-104 72t-150.5 23q-94 0 -175.5 -31t-142 -83.5t-95.5 -122t-35 -146.5v-891h-191v1092q0 37 -0.5 83t-1 91
t-1 83t-1.5 60h184q1 -22 2.5 -53.5t2.5 -66t1.5 -69t0.5 -62.5h4q34 61 85.5 111.5t116.5 85.5t141.5 54.5t162.5 19.5q124 0 212.5 -32t144.5 -98.5t82.5 -168.5t26.5 -241v-347q0 -130 -15 -234t-58 -177t-119 -112t-199 -39z"" />
    <glyph glyph-name=""eng"" unicode=""&#x14b;""
d=""M769 -425q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v793q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170
q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22t107 -68t61.5 -118.5t19.5 -172.5v-855q0 -62 -11 -115t-38 -92t-73.5 -61.5t-118.5 -22.5z"" />
    <glyph glyph-name=""Omacron"" unicode=""&#x14c;"" horiz-adv-x=""1593""
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM1070 1570h-549v127h549v-127z"" />
    <glyph glyph-name=""omacron"" unicode=""&#x14d;""
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM844 1236h-549v127h549v-127z"" />
    <glyph glyph-name=""Obreve"" unicode=""&#x14e;"" horiz-adv-x=""1593""
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM795 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94
t-66.5 -79.5t-99.5 -55t-134 -20.5z"" />
    <glyph glyph-name=""obreve"" unicode=""&#x14f;""
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM569 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5
t-99.5 -68t-134 -25.5z"" />
    <glyph glyph-name=""Ohungarumlaut"" unicode=""&#x150;"" horiz-adv-x=""1593""
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM514 1530v20l197 227h207v-29l-310 -218h-94zM861 1530v20l197 227h207v-29l-310 -218h-94z"" />
    <glyph glyph-name=""ohungarumlaut"" unicode=""&#x151;""
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM287 1201v20l217 287h207v-29l-330 -278h-94zM634 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""OE"" unicode=""&#x152;"" horiz-adv-x=""2048""
d=""M999 0q-20 -3 -45.5 -4.5t-54 -3t-57 -2t-53.5 -0.5q-169 0 -298.5 53t-217 148.5t-132 228t-44.5 291.5q0 165 47 296.5t136 223t218 140.5t293 49q26 0 55 -1t57.5 -2.5t54.5 -3.5t45 -4h914v-156h-803v-452h743v-154h-743v-491h844v-156h-959zM789 145q32 0 70 1t64 3
v1111q-11 1 -27 2t-34.5 1.5t-37 0.5h-33.5q-125 0 -218.5 -37t-156 -108t-94 -174t-31.5 -234q0 -129 32 -233.5t95 -178.5t156 -114t215 -40z"" />
    <glyph glyph-name=""oe"" unicode=""&#x153;"" horiz-adv-x=""1933""
d=""M1070 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-137 0 -236 45.5t-160 137.5q-63 -93 -163.5 -138t-237.5 -45q-113 0 -203.5 34t-154 104t-97.5 175.5t-34 248.5
q0 279 126.5 419.5t368.5 140.5q281 0 398 -177q67 94 167 135.5t219 41.5q136 0 227.5 -44t147 -121.5t79 -182.5t23.5 -227v-24h-772zM881 542q0 126 -21 208t-59.5 131t-93.5 68.5t-123 19.5q-69 0 -126 -20.5t-97.5 -70t-63 -131.5t-22.5 -205q0 -126 23.5 -208.5
t64 -131.5t94.5 -69t116 -20q69 0 126 19.5t97.5 68.5t62.5 132t22 209zM1656 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584z"" />
    <glyph glyph-name=""Racute"" unicode=""&#x154;"" horiz-adv-x=""1479""
d=""M1164 0l-366 585h-439v-585h-191v1409h663q120 0 212.5 -27.5t155.5 -79.5t96 -127t33 -169q0 -67 -19.5 -132t-61.5 -119t-107 -93t-156 -55l400 -607h-220zM1136 1004q0 64 -22 111t-64 78.5t-102 47t-136 15.5h-453v-520h461q82 0 142 20.5t98.5 56.5t57 85t18.5 106z
M553 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""racute"" unicode=""&#x155;"" horiz-adv-x=""682""
d=""M142 0v830q0 34 -0.5 69.5t-1.5 68.5t-2 62t-2 52h170q1 -23 2.5 -52.5t3 -60.5t2 -59.5t0.5 -48.5h4q19 62 40.5 107.5t50.5 75t69 44t97 14.5q22 0 42 -3.5t31 -6.5v-165q-18 5 -42 7.5t-54 2.5q-62 0 -105.5 -28t-71 -77.5t-40.5 -118t-13 -149.5v-564h-180zM254 1201
v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Rcommaaccent"" unicode=""&#x156;"" horiz-adv-x=""1479""
d=""M1164 0l-366 585h-439v-585h-191v1409h663q120 0 212.5 -27.5t155.5 -79.5t96 -127t33 -169q0 -67 -19.5 -132t-61.5 -119t-107 -93t-156 -55l400 -607h-220zM1136 1004q0 64 -22 111t-64 78.5t-102 47t-136 15.5h-453v-520h461q82 0 142 20.5t98.5 56.5t57 85t18.5 106z
M845 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""rcommaaccent"" unicode=""&#x157;"" horiz-adv-x=""682""
d=""M142 0v830q0 34 -0.5 69.5t-1.5 68.5t-2 62t-2 52h170q1 -23 2.5 -52.5t3 -60.5t2 -59.5t0.5 -48.5h4q19 62 40.5 107.5t50.5 75t69 44t97 14.5q22 0 42 -3.5t31 -6.5v-165q-18 5 -42 7.5t-54 2.5q-62 0 -105.5 -28t-71 -77.5t-40.5 -118t-13 -149.5v-564h-180zM330 -193
q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""Rcaron"" unicode=""&#x158;"" horiz-adv-x=""1479""
d=""M1164 0l-366 585h-439v-585h-191v1409h663q120 0 212.5 -27.5t155.5 -79.5t96 -127t33 -169q0 -67 -19.5 -132t-61.5 -119t-107 -93t-156 -55l400 -607h-220zM1136 1004q0 64 -22 111t-64 78.5t-102 47t-136 15.5h-453v-520h461q82 0 142 20.5t98.5 56.5t57 85t18.5 106z
M796 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""rcaron"" unicode=""&#x159;"" horiz-adv-x=""682""
d=""M142 0v830q0 34 -0.5 69.5t-1.5 68.5t-2 62t-2 52h170q1 -23 2.5 -52.5t3 -60.5t2 -59.5t0.5 -48.5h4q19 62 40.5 107.5t50.5 75t69 44t97 14.5q22 0 42 -3.5t31 -6.5v-165q-18 5 -42 7.5t-54 2.5q-62 0 -105.5 -28t-71 -77.5t-40.5 -118t-13 -149.5v-564h-180zM494 1201
h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" />
    <glyph glyph-name=""Sacute"" unicode=""&#x15a;"" horiz-adv-x=""1366""
d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5
t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5
q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134zM562 1530v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""sacute"" unicode=""&#x15b;"" horiz-adv-x=""1024""
d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38
t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5
t44.5 -77t16.5 -102zM385 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Scircumflex"" unicode=""&#x15c;"" horiz-adv-x=""1366""
d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5
t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5
q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134zM1032 1548v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""scircumflex"" unicode=""&#x15d;"" horiz-adv-x=""1024""
d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38
t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5
t44.5 -77t16.5 -102zM834 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""Scedilla"" unicode=""&#x15e;"" horiz-adv-x=""1366""
d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5
t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5
q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134zM905 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33
q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5z"" />
    <glyph glyph-name=""scedilla"" unicode=""&#x15f;"" horiz-adv-x=""1024""
d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38
t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5
t44.5 -77t16.5 -102zM701 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5z"" />
    <glyph glyph-name=""Scaron"" unicode=""&#x160;"" horiz-adv-x=""1366""
d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5
t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5
q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134zM809 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""scaron"" unicode=""&#x161;"" horiz-adv-x=""1024""
d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38
t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5
t44.5 -77t16.5 -102zM611 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" />
    <glyph glyph-name=""Tcommaaccent"" unicode=""&#x162;"" horiz-adv-x=""1251""
d=""M830 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5zM720 1253v-1253h-190v1253
h-484v156h1158v-156h-484z"" />
    <glyph glyph-name=""tcommaaccent"" unicode=""&#x163;"" horiz-adv-x=""569""
d=""M554 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5zM554 8q-41 -11 -83.5 -17.5
t-98.5 -6.5q-216 0 -216 245v722h-125v131h132l53 242h120v-242h200v-131h-200v-683q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133z"" />
    <glyph glyph-name=""Tcaron"" unicode=""&#x164;"" horiz-adv-x=""1251""
d=""M720 1253v-1253h-190v1253h-484v156h1158v-156h-484zM727 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""tcaron"" unicode=""&#x165;"" horiz-adv-x=""768""
d=""M554 8q-41 -11 -83.5 -17.5t-98.5 -6.5q-216 0 -216 245v722h-125v131h132l53 242h120v-242h200v-131h-200v-683q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133zM785 1378q0 -87 -22 -145.5t-62 -105.5h-117q45 48 69.5 96t24.5 94h-88v167h195v-106z"" />
    <glyph glyph-name=""Tbar"" unicode=""&#x166;"" horiz-adv-x=""1251""
d=""M720 1253v-452h281v-154h-281v-647h-190v647h-279v154h279v452h-484v156h1158v-156h-484z"" />
    <glyph glyph-name=""tbar"" unicode=""&#x167;"" horiz-adv-x=""569""
d=""M336 516v-248q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133q-41 -11 -83.5 -17.5t-98.5 -6.5q-216 0 -216 245v287h-125v131h125v304h-125v131h132l53 242h120v-242h200v-131h-200v-304h200v-131h-200z"" />
    <glyph glyph-name=""Utilde"" unicode=""&#x168;"" horiz-adv-x=""1479""
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM896 1530
q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""utilde"" unicode=""&#x169;""
d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM738 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5
t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""Umacron"" unicode=""&#x16a;"" horiz-adv-x=""1479""
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM1015 1565h-549
v127h549v-127z"" />
    <glyph glyph-name=""umacron"" unicode=""&#x16b;""
d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM840 1236h-549v127h549v-127z"" />
    <glyph glyph-name=""Ubreve"" unicode=""&#x16c;"" horiz-adv-x=""1479""
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM738 1530
q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" />
    <glyph glyph-name=""ubreve"" unicode=""&#x16d;""
d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM564 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68t-134 -25.5z"" />
    <glyph glyph-name=""Uring"" unicode=""&#x16e;"" horiz-adv-x=""1479""
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM982 1613
q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM874 1613q0 28 -10.5 52.5t-28.5 42.5t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5
q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5t28.5 43.5t10.5 53.5z"" />
    <glyph glyph-name=""uring"" unicode=""&#x16f;""
d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM811 1410q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM703 1410q0 28 -10.5 52.5t-28.5 42.5t-42.5 28.5t-52.5 10.5
q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5t28.5 43.5t10.5 53.5z"" />
    <glyph glyph-name=""Uhungarumlaut"" unicode=""&#x170;"" horiz-adv-x=""1479""
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM445 1530v20
l197 227h207v-29l-310 -218h-94zM792 1530v20l197 227h207v-29l-310 -218h-94z"" />
    <glyph glyph-name=""uhungarumlaut"" unicode=""&#x171;""
d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM283 1201v20l217 287h207v-29l-330 -278h-94zM630 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Uogonek"" unicode=""&#x172;"" horiz-adv-x=""1479""
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM974 -400
q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z"" />
    <glyph glyph-name=""uogonek"" unicode=""&#x173;""
d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM1029 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z
"" />
    <glyph glyph-name=""Wcircumflex"" unicode=""&#x174;"" horiz-adv-x=""1933""
d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183
l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199zM1295 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""wcircumflex"" unicode=""&#x175;"" horiz-adv-x=""1479""
d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62
q8 -34 16 -69q8 38 16 74q7 31 14.5 64.5t14.5 59.5l191 735h176zM1066 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""Ycircumflex"" unicode=""&#x176;"" horiz-adv-x=""1366""
d=""M777 584v-584h-190v584l-542 825h210l429 -671l427 671h210zM1009 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""ycircumflex"" unicode=""&#x177;"" horiz-adv-x=""1024""
d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM844 1221
v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""Ydieresis"" unicode=""&#x178;"" horiz-adv-x=""1366""
d=""M777 584v-584h-190v584l-542 825h210l429 -671l427 671h210zM799 1530v184h163v-184h-163zM405 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""Zacute"" unicode=""&#x179;"" horiz-adv-x=""1251""
d=""M1187 0h-1122v143l858 1110h-785v156h1002v-139l-858 -1114h905v-156zM488 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""zacute"" unicode=""&#x17a;"" horiz-adv-x=""1024""
d=""M49 0v137l661 806h-621v139h824v-137l-662 -806h699v-139h-901zM381 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Zdotaccent"" unicode=""&#x17b;"" horiz-adv-x=""1251""
d=""M1187 0h-1122v143l858 1110h-785v156h1002v-139l-858 -1114h905v-156zM536 1605v172h180v-172h-180z"" />
    <glyph glyph-name=""zdotaccent"" unicode=""&#x17c;"" horiz-adv-x=""1024""
d=""M49 0v137l661 806h-621v139h824v-137l-662 -806h699v-139h-901zM409 1312v172h180v-172h-180z"" />
    <glyph glyph-name=""Zcaron"" unicode=""&#x17d;"" horiz-adv-x=""1251""
d=""M1187 0h-1122v143l858 1110h-785v156h1002v-139l-858 -1114h905v-156zM750 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""zcaron"" unicode=""&#x17e;"" horiz-adv-x=""1024""
d=""M49 0v137l661 806h-621v139h824v-137l-662 -806h699v-139h-901zM594 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" />
    <glyph glyph-name=""longs"" unicode=""&#x17f;"" horiz-adv-x=""455""
d=""M318 0h-180v1204q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-1179z"" />
    <glyph glyph-name=""florin"" unicode=""&#x192;""
d=""M932 1312q-17 5 -48 10t-62 5t-54 -9.5t-39.5 -29.5t-28.5 -52t-21 -77l-26 -137h211l-25 -131h-213l-254 -1325h-180l254 1325h-152l27 131h151l29 152q12 59 32 110t55.5 89t90 59.5t135.5 21.5q32 0 73 -5t76 -15z"" />
    <glyph glyph-name=""Aringacute"" unicode=""&#x1fa;"" horiz-adv-x=""1366""
d=""M926 1392q0 -45 -19 -84.5t-52 -69.5q-16 -15 -34 -26l541 -1212h-195l-161 371h-642l-162 -371h-198l548 1209q-21 12 -39 29q-33 30 -52 69.5t-19 84.5t19 84.5t52 69t77 46.5t94 17t94 -17t77 -46.5t52 -69t19 -84.5zM768 923q-16 36 -30.5 73t-25.5 67t-18.5 50.5
t-8.5 24.5q-2 -4 -9 -24.5t-18.5 -51.5t-26 -67.5t-29.5 -72.5l-180 -417h527zM818 1392q0 25 -10.5 47t-28.5 38.5t-42.5 26t-52.5 9.5q-29 0 -53.5 -9.5t-42.5 -26t-28.5 -38.5t-10.5 -47q0 -26 10.5 -48t28.5 -39.5t42 -27.5q21 -8 45 -9h9q28 0 52.5 9.5t42.5 27
t28.5 39.5t10.5 48zM571 1657v16l217 181h207v-23l-310 -174h-114z"" />
    <glyph glyph-name=""aringacute"" unicode=""&#x1fb;""
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM811 1239q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM703 1239q0 28 -10.5 52.5t-28.5 42.5
t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5t28.5 43.5t10.5 53.5zM427 1547v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""AEacute"" unicode=""&#x1fc;"" horiz-adv-x=""2048""
d=""M969 0v412h-548l-198 -412h-199l686 1409h1209v-156h-759v-452h699v-154h-699v-491h800v-156h-991zM969 1262h-151q-1 -3 -9 -20.5t-19 -42.5t-24.5 -54t-25.5 -54.5t-21 -44.5t-11 -24l-217 -461h478v701zM1068 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""aeacute"" unicode=""&#x1fd;"" horiz-adv-x=""1821""
d=""M968 503v-17q1 -82 18 -150t52 -117t89.5 -76.5t132.5 -27.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-321 0 -423 257q-29 -51 -66 -97.5t-88 -82t-119.5 -56.5t-161.5 -21q-167 0 -251.5 86t-84.5 236q0 71 19 125
t52.5 93t79 64.5t99 41.5t112 22.5t118.5 7.5l240 4v59q0 67 -13 114t-41.5 76t-72.5 42.5t-105 13.5q-54 0 -98 -7.5t-76 -27t-51.5 -53t-26.5 -84.5l-188 17q10 64 39 117.5t81.5 92.5t132 60.5t191.5 21.5q128 0 214 -35t135 -104q63 74 151.5 106.5t194.5 32.5
q136 0 227.5 -44t147 -121.5t79 -182.5t23.5 -227v-24h-762zM786 534l-195 -4q-40 -1 -80.5 -4t-78.5 -12t-71 -24.5t-57.5 -41t-38.5 -62t-14 -87.5q0 -87 50 -135.5t143 -48.5q90 0 154.5 31.5t106 80.5t61.5 107t20 111v89zM1544 641q-15 171 -87 249.5t-207 78.5
q-45 0 -93 -14.5t-88.5 -51.5t-67.5 -100.5t-31 -161.5h574zM759 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Oslashacute"" unicode=""&#x1fe;"" horiz-adv-x=""1593""
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-127 0 -230 29t-184 83l-120 -145h-190l200 241q-88 97 -131 230t-43 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q125 0 228.5 -28t185.5 -82l121 146h192l-201 -242q85 -94 128.5 -223.5
t43.5 -289.5zM1300 711q0 112 -24.5 204t-73.5 164l-709 -853q59 -44 134 -67.5t168 -23.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM291 711q0 -113 25 -208t76 -170l707 853q-59 42 -134.5 65t-167.5 23q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231zM659 1530
v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""oslashacute"" unicode=""&#x1ff;"" horiz-adv-x=""1251""
d=""M1112 542q0 -284 -125 -423t-363 -139q-97 0 -175 24t-138 74l-100 -116h-167l184 214q-41 68 -62 159t-21 207q0 560 485 560q103 0 181 -23t135 -68l91 105h167l-173 -201q42 -69 61.5 -161.5t19.5 -211.5zM923 542q0 68 -6 122.5t-17 98.5l-483 -562
q38 -49 90.5 -68.5t114.5 -19.5q69 0 125 19.5t95 68.5t60 132t21 209zM334 542q0 -130 24 -215l482 561q-37 45 -89 63t-118 18q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205zM506 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Scommaaccent"" unicode=""&#x218;"" horiz-adv-x=""1366""
d=""M801 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95zM1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5
t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67
t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134z"" />
    <glyph glyph-name=""scommaaccent"" unicode=""&#x219;"" horiz-adv-x=""1024""
d=""M625 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95zM950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8
t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112
q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5t44.5 -77t16.5 -102z"" />
    <glyph glyph-name=""uni021A"" unicode=""&#x21a;"" horiz-adv-x=""1251""
d=""M723 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95zM720 1253v-1253h-190v1253h-484v156h1158v-156h-484z"" />
    <glyph glyph-name=""uni021B"" unicode=""&#x21b;"" horiz-adv-x=""569""
d=""M443 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95zM554 8q-41 -11 -83.5 -17.5t-98.5 -6.5q-216 0 -216 245v722h-125v131h132l53 242h120v-242h200v-131h-200v-683q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133z"" />
    <glyph glyph-name=""circumflex"" unicode=""&#x2c6;"" horiz-adv-x=""682""
d=""M662 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""caron"" unicode=""&#x2c7;"" horiz-adv-x=""682""
d=""M438 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" />
    <glyph glyph-name=""uni02C9"" unicode=""&#x2c9;"" horiz-adv-x=""682""
d=""M600 1236h-549v127h549v-127z"" />
    <glyph glyph-name=""breve"" unicode=""&#x2d8;"" horiz-adv-x=""682""
d=""M297 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68t-134 -25.5z"" />
    <glyph glyph-name=""dotaccent"" unicode=""&#x2d9;"" horiz-adv-x=""682""
d=""M156 1312v172h180v-172h-180z"" />
    <glyph glyph-name=""ring"" unicode=""&#x2da;"" horiz-adv-x=""682""
d=""M535 1410q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM427 1410q0 28 -10.5 52.5t-28.5 42.5t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5
q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5t28.5 43.5t10.5 53.5z"" />
    <glyph glyph-name=""ogonek"" unicode=""&#x2db;"" horiz-adv-x=""682""
d=""M430 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z"" />
    <glyph glyph-name=""tilde"" unicode=""&#x2dc;"" horiz-adv-x=""682""
d=""M492 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""hungarumlaut"" unicode=""&#x2dd;"" horiz-adv-x=""682""
d=""M22 1201v20l217 287h207v-29l-330 -278h-94zM369 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""tonos"" unicode=""&#x384;"" horiz-adv-x=""682""
d=""M205 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""dieresistonos"" unicode=""&#x385;"" horiz-adv-x=""682""
d=""M250 1200v33l69 368h187v-37l-181 -364h-75zM29 1231v172h150v-172h-150zM501 1231v172h150v-172h-150z"" />
    <glyph glyph-name=""Alphatonos"" unicode=""&#x386;"" horiz-adv-x=""1367""
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM57 1086v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""anoteleia"" unicode=""&#x387;"" horiz-adv-x=""569""
d=""M187 446v220h195v-220h-195z"" />
    <glyph glyph-name=""Epsilontonos"" unicode=""&#x388;"" horiz-adv-x=""1606""
d=""M408 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM-11 1086v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""Etatonos"" unicode=""&#x389;"" horiz-adv-x=""1716""
d=""M1358 0v653h-762v-653h-191v1409h191v-596h762v596h191v-1409h-191zM-14 1086v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""Iotatonos"" unicode=""&#x38a;"" horiz-adv-x=""786""
d=""M406 0v1409h191v-1409h-191zM-24 1086v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""Omicrontonos"" unicode=""&#x38c;"" horiz-adv-x=""1586""
d=""M1491 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1296 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM-69 1086v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""Upsilontonos"" unicode=""&#x38e;"" horiz-adv-x=""1752""
d=""M1163 584v-584h-190v584l-542 825h210l429 -671l427 671h210zM65 1086v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""Omegatonos"" unicode=""&#x38f;"" horiz-adv-x=""1541""
d=""M775 1430q151 0 271.5 -43t204.5 -124t129 -198t45 -264q0 -106 -29.5 -201.5t-84 -179t-133 -152.5t-177.5 -123q42 2 81 5q33 2 68.5 4t58.5 2h244v-156h-589v224q96 51 165.5 114t114 134.5t65.5 151t21 164.5q0 116 -30.5 206.5t-88.5 152.5t-142.5 94.5t-192.5 32.5
q-109 0 -194 -32.5t-143 -94.5t-88.5 -152.5t-30.5 -206.5q0 -85 21 -164.5t65.5 -151t114 -134.5t165.5 -114v-224h-589v156h244q23 0 58.5 -2t68.5 -4q39 -3 81 -5q-99 54 -177.5 123t-133 152.5t-84 179t-29.5 201.5q0 147 45 264t129 198t204.5 124t271.5 43zM-69 1086
v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""iotadieresistonos"" unicode=""&#x390;"" horiz-adv-x=""455""
d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h180v-855q0 -32 5.5 -64t16 -62t25.5 -56t33 -45h-198zM141 1200v33l69 368h187v-37l-181 -364h-75zM-80 1231v172h150v-172h-150zM392 1231v172h150v-172h-150z"" />
    <glyph glyph-name=""Alpha"" unicode=""&#x391;"" horiz-adv-x=""1366""
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527z"" />
    <glyph glyph-name=""Beta"" unicode=""&#x392;"" horiz-adv-x=""1366""
d=""M1258 397q0 -107 -42 -182.5t-113 -123t-165 -69.5t-198 -22h-572v1409h512q117 0 209 -19.5t156 -61.5t97.5 -106.5t33.5 -154.5q0 -59 -16.5 -111t-50 -94.5t-84 -73t-117.5 -45.5q85 -10 150.5 -39t109.5 -74t67 -104.5t23 -128.5zM984 1044q0 114 -78 163t-226 49
h-321v-446h321q84 0 142 16.5t94 47t52 73.5t16 97zM1065 412q0 67 -24.5 114t-70.5 77t-110.5 44t-144.5 14h-356v-508h371q73 0 134.5 12t106 42t69.5 80t25 125z"" />
    <glyph glyph-name=""Gamma"" unicode=""&#x393;"" horiz-adv-x=""1128""
d=""M1071 1410v-156h-712v-1253h-191v1409h903z"" />
    <glyph glyph-name=""Delta"" unicode=""&#x394;"" horiz-adv-x=""1368""
d=""M62 141l517 1268h217l510 -1268v-141h-1245zM1106 156l-338 862q-16 40 -30.5 81t-25.5 75.5t-18.5 58.5t-8.5 32q-2 -8 -9 -32.5t-18.5 -59.5t-25.5 -76t-30 -81l-339 -860h843z"" />
    <glyph glyph-name=""Epsilon"" unicode=""&#x395;"" horiz-adv-x=""1366""
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110z"" />
    <glyph glyph-name=""Zeta"" unicode=""&#x396;"" horiz-adv-x=""1251""
d=""M1187 0h-1122v143l858 1110h-785v156h1002v-139l-858 -1114h905v-156z"" />
    <glyph glyph-name=""Eta"" unicode=""&#x397;"" horiz-adv-x=""1479""
d=""M1121 0v653h-762v-653h-191v1409h191v-596h762v596h191v-1409h-191z"" />
    <glyph glyph-name=""Theta"" unicode=""&#x398;"" horiz-adv-x=""1593""
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM502 794h587v-160h-587v160z"" />
    <glyph glyph-name=""Iota"" unicode=""&#x399;"" horiz-adv-x=""569""
d=""M189 0v1409h191v-1409h-191z"" />
    <glyph glyph-name=""Kappa"" unicode=""&#x39a;"" horiz-adv-x=""1366""
d=""M1106 0l-563 680l-184 -140v-540h-191v1409h191v-706l679 706h225l-600 -612l680 -797h-237z"" />
    <glyph glyph-name=""Lambda"" unicode=""&#x39b;"" horiz-adv-x=""1368""
d=""M1358 1h-201l-388 992q-17 47 -31.5 91.5t-26.5 79.5q-14 41 -26 78q-13 -39 -27 -80q-12 -35 -27 -79.5t-30 -89.5l-390 -992h-201l575 1409h198z"" />
    <glyph glyph-name=""Mu"" unicode=""&#x39c;"" horiz-adv-x=""1706""
d=""M1366 0v940q0 51 1 104t3 97q2 51 5 99q-14 -51 -29 -101q-13 -43 -28.5 -91.5t-30.5 -87.5l-364 -960h-134l-369 960q-6 15 -12.5 35t-14 42.5t-15 46t-14.5 46.5q-17 53 -33 110q1 -56 3 -111q2 -47 3 -98.5t1 -90.5v-940h-170v1409h251l375 -977q7 -20 17 -51.5
t19 -64.5t16.5 -62.5t10.5 -45.5q3 16 11 46t18.5 63t20.5 64t18 51l368 977h245v-1409h-172z"" />
    <glyph glyph-name=""Nu"" unicode=""&#x39d;"" horiz-adv-x=""1479""
d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230z"" />
    <glyph glyph-name=""Xi"" unicode=""&#x39e;"" horiz-adv-x=""1331""
d=""M125 1409h1081v-156h-1081v156zM1241 156v-156h-1151v156h1151zM1086 801v-154h-841v154h841z"" />
    <glyph glyph-name=""Omicron"" unicode=""&#x39f;"" horiz-adv-x=""1593""
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231z"" />
    <glyph glyph-name=""Pi"" unicode=""&#x3a0;"" horiz-adv-x=""1479""
d=""M1121 0v1248h-762v-1248h-191v1409h1144v-1409h-191z"" />
    <glyph glyph-name=""Rho"" unicode=""&#x3a1;"" horiz-adv-x=""1366""
d=""M1258 985q0 -92 -30.5 -171.5t-91 -138t-151.5 -92.5t-212 -34h-414v-549h-191v1409h593q125 0 218 -30.5t155 -86t93 -134t31 -173.5zM1066 983q0 134 -82 203.5t-246 69.5h-379v-556h387q165 0 242.5 73t77.5 210z"" />
    <glyph glyph-name=""Sigma"" unicode=""&#x3a3;"" horiz-adv-x=""1266""
d=""M108 0v162l538 579l-521 507v161h999v-156h-784l458 -445v-124l-490 -528h877v-156h-1077z"" />
    <glyph glyph-name=""Tau"" unicode=""&#x3a4;"" horiz-adv-x=""1251""
d=""M720 1253v-1253h-190v1253h-484v156h1158v-156h-484z"" />
    <glyph glyph-name=""Upsilon"" unicode=""&#x3a5;"" horiz-adv-x=""1366""
d=""M777 584v-584h-190v584l-542 825h210l429 -671l427 671h210z"" />
    <glyph glyph-name=""Phi"" unicode=""&#x3a6;"" horiz-adv-x=""1634""
d=""M1518 736q0 -105 -32 -199t-97.5 -165.5t-164 -113.5t-231.5 -42h-83v-227h-185v227h-83q-133 0 -231.5 42t-164 113.5t-97.5 165.5t-32 199q0 113 33.5 205.5t100 158t167 101.5t235.5 36h72v182h185v-182h71q135 0 236 -36t167.5 -101.5t100 -158t33.5 -205.5z
M1326 732q0 187 -92.5 277t-275.5 90h-48v-746h56q92 0 160 26.5t112.5 75.5t66 119t21.5 158zM309 732q0 -88 21.5 -158t66 -119t112.5 -75.5t160 -26.5h56v746h-52q-182 0 -273 -90t-91 -277z"" />
    <glyph glyph-name=""Chi"" unicode=""&#x3a7;"" horiz-adv-x=""1366""
d=""M1112 0l-423 616l-432 -616h-211l536 732l-495 677h211l392 -553l381 553h211l-482 -670l523 -739h-211z"" />
    <glyph glyph-name=""Psi"" unicode=""&#x3a8;"" horiz-adv-x=""1711""
d=""M763 0v427h-83q-133 0 -233.5 42t-167.5 113t-100.5 165.5t-33.5 198.5v463h191v-467q0 -80 23.5 -148.5t70 -118.5t116 -78.5t161.5 -28.5h56v841h185v-841h56q95 0 165 28.5t115.5 78.5t68 118.5t22.5 148.5v467h191v-463q0 -104 -34 -198.5t-101 -165.5t-167.5 -113
t-232.5 -42h-83v-427h-185z"" />
    <glyph glyph-name=""Omega"" unicode=""&#x3a9;"" horiz-adv-x=""1531""
d=""M765 1430q151 0 271.5 -43t204.5 -124t129 -198t45 -264q0 -106 -29.5 -201.5t-84 -179t-133 -152.5t-177.5 -123q42 2 81 5q33 2 68.5 4t58.5 2h244v-156h-589v224q96 51 165.5 114t114 134.5t65.5 151t21 164.5q0 116 -30.5 206.5t-88.5 152.5t-142.5 94.5t-192.5 32.5
q-109 0 -194 -32.5t-143 -94.5t-88.5 -152.5t-30.5 -206.5q0 -85 21 -164.5t65.5 -151t114 -134.5t165.5 -114v-224h-589v156h244q23 0 58.5 -2t68.5 -4q39 -3 81 -5q-99 54 -177.5 123t-133 152.5t-84 179t-29.5 201.5q0 147 45 264t129 198t204.5 124t271.5 43z"" />
    <glyph glyph-name=""Iotadieresis"" unicode=""&#x3aa;"" horiz-adv-x=""569""
d=""M189 0v1409h191v-1409h-191zM401 1530v184h163v-184h-163zM7 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""Upsilondieresis"" unicode=""&#x3ab;"" horiz-adv-x=""1366""
d=""M777 584v-584h-190l2 584l-544 825h205l434 -671l432 671h205zM802 1530v184h163v-184h-163zM408 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""alphatonos"" unicode=""&#x3ac;"" horiz-adv-x=""1184""
d=""M843 237q-26 -56 -58.5 -103t-76 -81.5t-99 -53.5t-125.5 -19q-205 0 -301.5 138t-96.5 418q0 284 108.5 425t317.5 141q69 0 125 -19.5t99 -54t74.5 -81t51.5 -100.5h2q4 21 11 49t16.5 59.5t21 64t24.5 62.5h188q-22 -47 -45 -111t-42.5 -133.5t-34.5 -139t-20 -127.5
q3 -103 14.5 -190.5t27 -159.5t33.5 -127t36 -94h-183q-11 28 -21.5 61t-18.5 65.5t-14.5 61.5t-9.5 49h-4zM275 542q0 -112 14 -192t43.5 -131.5t76 -75.5t112.5 -24q54 0 104 26t91 79.5t71.5 133.5t44.5 188q-12 86 -34.5 163t-58 134.5t-86.5 91.5t-121 34
q-66 0 -114 -23t-80 -74t-47.5 -132.5t-15.5 -197.5zM494 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""epsilontonos"" unicode=""&#x3ad;"" horiz-adv-x=""913""
d=""M456 114q54 0 102 15.5t87.5 39.5t71 52t52.5 54l105 -100q-32 -39 -74 -74.5t-95 -62t-118 -42.5t-143 -16q-96 0 -166.5 23t-116.5 65t-68.5 100t-22.5 127q0 58 21 105.5t57 82t84 55.5t102 26v2q-51 6 -93.5 26t-73 52t-47.5 75t-17 94q0 62 25 115t72.5 91.5
t115.5 60.5t155 22q118 0 213.5 -43t162.5 -142l-128 -88q-47 71 -109.5 105t-137.5 34q-91 0 -139 -42.5t-48 -116.5q0 -57 27.5 -92t76 -53.5t114 -24.5t140.5 -6v-135q-72 0 -141.5 -5.5t-124 -25.5t-87.5 -60t-33 -109q0 -45 14.5 -79.5t40.5 -57.5t63 -35t81 -12z
M407 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""etatonos"" unicode=""&#x3ae;""
d=""M825 -424v1110q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 68 -11 128.5t-25 102.5h170q9 -21 16 -45t12 -48.5t7.5 -48t2.5 -43.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22t107 -68
t61.5 -118.5t19.5 -172.5v-1145h-181zM518 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""iotatonos"" unicode=""&#x3af;"" horiz-adv-x=""455""
d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h180v-855q0 -32 5.5 -64t16 -62t25.5 -56t33 -45h-198zM158 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""upsilondieresistonos"" unicode=""&#x3b0;"" horiz-adv-x=""1120""
d=""M1022 571q0 -137 -26.5 -246t-83 -186t-144.5 -118t-211 -41q-109 0 -189 25t-132 78.5t-77.5 136.5t-25.5 199v663h181v-669q0 -146 58.5 -220t192.5 -74q73 0 125 25t84.5 79t47.5 139t15 205q0 68 -10 141.5t-26.5 143t-36.5 129.5t-41 101h188q18 -40 38 -96.5
t36 -123.5t26.5 -141.5t10.5 -149.5zM472 1200v33l69 368h187v-37l-181 -364h-75zM251 1231v172h150v-172h-150zM723 1231v172h150v-172h-150z"" />
    <glyph glyph-name=""alpha"" unicode=""&#x3b1;"" horiz-adv-x=""1184""
d=""M843 237q-26 -56 -58.5 -103t-76 -81.5t-99 -53.5t-125.5 -19q-205 0 -301.5 138t-96.5 418q0 284 108.5 425t317.5 141q69 0 125 -19.5t99 -54t74.5 -81t51.5 -100.5h2q4 21 11 49t16.5 59.5t21 64t24.5 62.5h188q-22 -47 -45 -111t-42.5 -133.5t-34.5 -139t-20 -127.5
q3 -103 14.5 -190.5t27 -159.5t33.5 -127t36 -94h-183q-11 28 -21.5 61t-18.5 65.5t-14.5 61.5t-9.5 49h-4zM275 542q0 -112 14 -192t43.5 -131.5t76 -75.5t112.5 -24q54 0 104 26t91 79.5t71.5 133.5t44.5 188q-12 86 -34.5 163t-58 134.5t-86.5 91.5t-121 34
q-66 0 -114 -23t-80 -74t-47.5 -132.5t-15.5 -197.5z"" />
    <glyph glyph-name=""beta"" unicode=""&#x3b2;"" horiz-adv-x=""1178""
d=""M1097 405q0 -89 -26.5 -166t-82 -135t-142 -91t-206.5 -33q-102 0 -182 27.5t-136 66.5h-6q3 -57 4.5 -103t1.5 -99v-297h-180v1452q0 237 114 347t340 110q99 0 175 -23.5t127 -68.5t77.5 -110t26.5 -147q0 -73 -17.5 -128.5t-48 -96.5t-71 -69t-86.5 -46
q57 -11 114 -38.5t102.5 -74t73.5 -115t28 -162.5zM322 205q28 -19 63.5 -36t76 -29.5t84 -19.5t86.5 -7q72 0 127 20.5t91.5 58.5t55.5 91t19 119q0 65 -19 120t-59.5 95.5t-104.5 63t-153 22.5v142q127 27 183.5 96.5t56.5 191.5q0 44 -13.5 82.5t-42 67t-72 44.5
t-103.5 16q-70 0 -122 -17.5t-86 -56t-51 -99.5t-17 -149v-816z"" />
    <glyph glyph-name=""gamma"" unicode=""&#x3b3;"" horiz-adv-x=""1024""
d=""M7 1082h192l245 -675q7 -22 17.5 -53.5t20.5 -65t18.5 -65t12.5 -53.5q5 21 14 52t19.5 64.5t21.5 65t19 53.5l239 677h191l-390 -1029q-17 -45 -32.5 -100.5t-29 -117.5t-25 -128t-18.5 -131h-191q17 131 41 237.5t48 197.5z"" />
    <glyph glyph-name=""delta"" unicode=""&#x3b4;"" horiz-adv-x=""1140""
d=""M864 471q0 85 -24.5 157.5t-59 130t-72.5 100.5t-64 70q-73 -26 -140 -66.5t-118 -97.5t-81 -130t-30 -164q0 -76 17.5 -141.5t54 -113.5t92 -75.5t132.5 -27.5q81 0 137 27t90.5 74.5t50 113t15.5 143.5zM607 1352q-13 0 -34 1t-43.5 2.5t-43 2.5t-33.5 2l316 -324
q54 -55 105 -113t90.5 -125t64 -146.5t24.5 -176.5q0 -110 -32 -201t-93.5 -156.5t-151.5 -101.5t-205 -36q-114 0 -204 34t-152.5 97.5t-95.5 155t-33 206.5q0 112 36.5 200t100 155.5t148 116t180.5 81.5l-319 339v119h733v-132h-358z"" />
    <glyph glyph-name=""epsilon"" unicode=""&#x3b5;"" horiz-adv-x=""913""
d=""M456 114q54 0 102 15.5t87.5 39.5t71 52t52.5 54l105 -100q-32 -39 -74 -74.5t-95 -62t-118 -42.5t-143 -16q-96 0 -166.5 23t-116.5 65t-68.5 100t-22.5 127q0 58 21 105.5t57 82t84 55.5t102 26v2q-51 6 -93.5 26t-73 52t-47.5 75t-17 94q0 62 25 115t72.5 91.5
t115.5 60.5t155 22q118 0 213.5 -43t162.5 -142l-128 -88q-47 71 -109.5 105t-137.5 34q-91 0 -139 -42.5t-48 -116.5q0 -57 27.5 -92t76 -53.5t114 -24.5t140.5 -6v-135q-72 0 -141.5 -5.5t-124 -25.5t-87.5 -60t-33 -109q0 -45 14.5 -79.5t40.5 -57.5t63 -35t81 -12z"" />
    <glyph glyph-name=""zeta"" unicode=""&#x3b6;"" horiz-adv-x=""903""
d=""M277 379q0 -64 21.5 -103.5t58.5 -64t87 -40t107 -30.5q54 -15 109.5 -32t100.5 -45.5t74 -72.5t29 -112q0 -34 -9 -68t-22 -65t-27.5 -56.5t-24.5 -42.5l-126 56q9 12 18.5 28.5t17.5 35.5t13.5 38.5t5.5 38.5q0 34 -18 56.5t-51 39t-80 29t-104 25.5q-42 10 -86.5 21.5
t-85.5 29.5t-77.5 43t-63.5 62t-42.5 87t-15.5 117q0 83 24.5 171t67 176t99 175.5t120 170.5t131 160.5t131.5 145.5v4q-12 -1 -29 -1.5t-35 -1t-35 -1t-28 -0.5h-345v131h642v-127q-62 -70 -127.5 -148.5t-127 -161.5t-115.5 -169t-94.5 -171.5t-64 -168.5t-23.5 -159z
"" />
    <glyph glyph-name=""eta"" unicode=""&#x3b7;""
d=""M825 -424v1110q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 68 -11 128.5t-25 102.5h170q9 -21 16 -45t12 -48.5t7.5 -48t2.5 -43.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22t107 -68
t61.5 -118.5t19.5 -172.5v-1145h-181z"" />
    <glyph glyph-name=""theta"" unicode=""&#x3b8;""
d=""M1033 733q0 -381 -120 -567t-348 -186q-108 0 -193.5 46t-144.5 139t-90 234.5t-31 333.5q0 373 116.5 561.5t348.5 188.5q121 0 208.5 -46.5t143.5 -140.5t83 -234.5t27 -328.5zM563 113q62 0 112 26t86.5 90t57.5 172t24 272h-547q3 -164 25 -271.5t57.5 -172
t82.5 -90.5t102 -26zM574 1354q-62 0 -111.5 -25.5t-85.5 -88.5t-57 -169t-24 -267h547q-3 161 -23 267t-54.5 169t-83 88.5t-108.5 25.5z"" />
    <glyph glyph-name=""iota"" unicode=""&#x3b9;"" horiz-adv-x=""455""
d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h180v-855q0 -32 5.5 -64t16 -62t25.5 -56t33 -45h-198z"" />
    <glyph glyph-name=""kappa"" unicode=""&#x3ba;"" horiz-adv-x=""1024""
d=""M816 0l-366 494l-132 -109v-385h-180v1082h180v-525l475 525h211l-439 -465l462 -617h-211z"" />
    <glyph glyph-name=""lambda"" unicode=""&#x3bb;"" horiz-adv-x=""1024""
d=""M463 965l-36 99q-27 73 -48 125.5t-43.5 86t-51 49t-68.5 15.5q-11 0 -27 -3.5t-22 -6.5l-35 130q25 9 61 16.5t68 7.5q55 0 98.5 -18t80 -58.5t70 -106t69.5 -160.5l427 -1141h-190l-207 577q-8 22 -17 50t-18 57.5t-17 57.5t-13 49q-7 -21 -18 -51t-23.5 -61
t-24.5 -58.5t-20 -45.5l-257 -575h-187z"" />
    <glyph glyph-name=""mu"" unicode=""&#x3bc;"" horiz-adv-x=""1180""
d=""M862 0q-1 6 -2.5 29t-3 52.5l-3 59t-1.5 49.5h-4q-26 -51 -54 -90.5t-62.5 -66t-77.5 -40t-100 -13.5q-82 0 -142 32t-92 90h-4q3 -32 3.5 -63.5t0.5 -58.5v-373h-182v1475h182v-644q0 -69 12.5 -127t42 -100.5t78.5 -66t123 -23.5q67 0 117 26t83.5 71.5t50 108.5
t16.5 138v617h181v-849q0 -34 0.5 -72t1.5 -71.5t2 -58t2 -31.5h-168z"" />
    <glyph glyph-name=""nu"" unicode=""&#x3bd;"" horiz-adv-x=""1024""
d=""M946 846q0 -99 -31.5 -208t-84.5 -219.5t-123 -217.5t-147 -201h-170l-390 1082h189l311 -928q142 185 204 356t62 327q0 81 -14.5 140.5t-34.5 104.5h177q24 -45 38 -101.5t14 -134.5z"" />
    <glyph glyph-name=""xi"" unicode=""&#x3be;"" horiz-adv-x=""917""
d=""M86 354q0 76 25.5 149.5t80.5 135.5t142.5 107t212.5 64v2q-68 5 -127 24.5t-102.5 53.5t-69 82t-25.5 110q0 64 25 110.5t64.5 78.5t88 52t95.5 30v8q-12 -1 -46 -2t-74 -2.5t-78 -2.5t-56 -1h-74v131h634v-125q-77 -9 -149 -26t-128 -46.5t-90 -74.5t-34 -112
q0 -63 30 -103.5t79.5 -65t114.5 -36.5t134 -18v-131q-100 -13 -187.5 -40t-153 -71.5t-103.5 -108t-38 -147.5q0 -64 21.5 -103.5t58.5 -64t87 -40t107 -30.5q54 -15 111 -32t104 -45.5t77.5 -72.5t30.5 -112q0 -34 -9 -68t-22 -65t-27.5 -56.5t-24.5 -42.5l-126 56
q9 12 18.5 28.5t17.5 35.5t13.5 38.5t5.5 38.5q0 34 -19.5 56.5t-54.5 39t-83.5 29t-105.5 25.5q-42 10 -86.5 21.5t-85.5 29.5t-77.5 43t-63.5 62t-42.5 87t-15.5 117z"" />
    <glyph glyph-name=""omicron"" unicode=""&#x3bf;""
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209z"" />
    <glyph glyph-name=""pi"" unicode=""&#x3c0;"" horiz-adv-x=""1413""
d=""M1126 -20q-59 0 -100 14t-67 43.5t-38 76.5t-12 113v724h-402v-72q0 -131 -8 -256.5t-21.5 -239.5t-31.5 -211.5t-37 -171.5h-188q19 76 38.5 174.5t35.5 211.5t26 236.5t10 248.5v80q-39 0 -78.5 -3.5t-74 -8.5t-61 -11.5t-38.5 -13.5v139q12 6 33.5 11.5t47 9.5t52.5 6
t50 2h1061v-131h-234v-685q0 -44 6.5 -72t18.5 -44t29.5 -22.5t39.5 -6.5q7 0 18.5 1t24 2t24 2.5t19.5 2.5v-129q-31 -8 -65.5 -14t-77.5 -6z"" />
    <glyph glyph-name=""rho"" unicode=""&#x3c1;"" horiz-adv-x=""1165""
d=""M1083 516q0 -118 -31.5 -216.5t-89 -169.5t-138 -110.5t-178.5 -39.5q-62 0 -111 10t-89 28.5t-73 45t-61 59.5h-4q2 -30 3 -60.5t1 -62.5v-425h-180v1006q0 119 30 215.5t88 164.5t142.5 105t194.5 37q103 0 193.5 -39.5t157.5 -114.5t106 -184.5t39 -248.5zM890 524
q0 104 -22 187t-63.5 140.5t-99.5 88t-130 30.5q-69 0 -119 -26.5t-82 -77t-47 -123.5t-15 -166v-317q28 -35 64 -62.5t76 -46t83.5 -28.5t87.5 -10q67 0 117 29t83.5 82.5t50 129.5t16.5 170z"" />
    <glyph glyph-name=""sigma1"" unicode=""&#x3c2;"" horiz-adv-x=""987""
d=""M582 961q-54 0 -98 -24.5t-77.5 -64.5t-58 -92t-40.5 -106t-23.5 -107t-7.5 -95q0 -68 16 -116t54 -84t100 -64.5t154 -58.5q53 -17 110 -35.5t104.5 -48t78 -74t30.5 -112.5q0 -34 -9 -68t-22 -65t-27.5 -56.5t-24.5 -42.5l-126 56q9 12 18.5 28.5t17.5 35.5t13.5 38.5
t5.5 38.5q0 30 -17.5 52t-51.5 40t-82.5 33.5t-111.5 32.5q-66 18 -122.5 38t-103.5 45.5t-83 59.5t-61 80.5t-38 107.5t-13 142q0 47 10 112t33 135t60.5 138t92.5 122t129 87t171 33q68 0 117.5 -10.5t86 -27.5t63.5 -39t49 -45l-116 -119q-18 19 -39 37t-45.5 32
t-53 22.5t-62.5 8.5z"" />
    <glyph glyph-name=""sigma"" unicode=""&#x3c3;"" horiz-adv-x=""1264""
d=""M1072 491q0 -112 -30.5 -206t-92 -161.5t-153 -105.5t-214.5 -38t-216 37t-155 106.5t-93.5 170.5t-31.5 230q0 144 43 249t119.5 174t183 102t232.5 33h569v-131h-165q-9 0 -26.5 0.5t-39 1.5t-43.5 2t-39 2v-4q28 -42 55.5 -91.5t49 -107t34.5 -123t13 -140.5zM883 488
q0 74 -10 140t-27 124t-39.5 107.5t-47.5 91.5h-89q-83 0 -154.5 -25t-125 -77.5t-84 -132.5t-30.5 -190q0 -207 75.5 -310t222.5 -103q78 0 136.5 26t96.5 74.5t57 118t19 156.5z"" />
    <glyph glyph-name=""tau"" unicode=""&#x3c4;"" horiz-adv-x=""809""
d=""M281 951q-39 0 -78.5 -3.5t-74 -8.5t-61 -11.5t-38.5 -13.5v139q12 6 33.5 11.5t47 9.5t52.5 6t50 2h580v-131h-304v-685q0 -44 6.5 -72t18.5 -44t29.5 -22.5t39.5 -6.5q7 0 18.5 1t24 2t24 2.5t19.5 2.5v-129q-31 -8 -65.5 -14t-77.5 -6q-59 0 -100 14t-67 43.5
t-38 76.5t-12 113v724h-27z"" />
    <glyph glyph-name=""upsilon"" unicode=""&#x3c5;"" horiz-adv-x=""1120""
d=""M1022 571q0 -137 -26.5 -246t-83 -186t-144.5 -118t-211 -41q-109 0 -189 25t-132 78.5t-77.5 136.5t-25.5 199v663h181v-669q0 -146 58.5 -220t192.5 -74q73 0 125 25t84.5 79t47.5 139t15 205q0 68 -10 141.5t-26.5 143t-36.5 129.5t-41 101h188q18 -40 38 -96.5
t36 -123.5t26.5 -141.5t10.5 -149.5z"" />
    <glyph glyph-name=""phi"" unicode=""&#x3c6;"" horiz-adv-x=""1328""
d=""M1242 565q0 -151 -37 -258.5t-103 -177.5t-158 -105.5t-202 -41.5v-407h-170v407q-114 5 -204.5 41t-153 105t-96 172.5t-33.5 244.5q0 102 24.5 196t76 169t131 126.5t188.5 69.5l21 -136q-69 -15 -117 -53.5t-78 -95.5t-43.5 -128.5t-13.5 -151.5q0 -213 73.5 -313.5
t224.5 -108.5v580q0 193 77 299t235 106q84 0 150.5 -38t112.5 -108.5t70.5 -170t24.5 -222.5zM1053 567q0 193 -43.5 298.5t-123.5 105.5q-68 0 -106 -64.5t-38 -204.5v-583q162 7 236.5 116t74.5 332z"" />
    <glyph glyph-name=""chi"" unicode=""&#x3c7;"" horiz-adv-x=""1075""
d=""M542 239l-333 -663h-188l440 825l-170 343q-27 54 -49 95t-42 68.5t-41 41.5t-46 14q-11 0 -27 -3.5t-23 -6.5l-34 131q24 9 55 14.5t63 5.5q48 0 83 -13.5t65 -44.5t59.5 -82t65.5 -126l142 -295l264 539h187l-368 -697l406 -809h-190z"" />
    <glyph glyph-name=""psi"" unicode=""&#x3c8;"" horiz-adv-x=""1460""
d=""M814 119q87 1 149 16.5t102 52t58.5 97t18.5 151.5v646h182v-644q0 -122 -29.5 -208t-91.5 -141t-158.5 -81.5t-230.5 -27.5v-405h-170v405q-134 1 -230 27.5t-158 81.5t-91.5 141t-29.5 208v644h181v-646q0 -90 19 -150.5t58.5 -97t101.5 -52.5t149 -17v1221h170v-1221z
"" />
    <glyph glyph-name=""omega"" unicode=""&#x3c9;"" horiz-adv-x=""1599""
d=""M883 449q0 -157 57 -243.5t159 -86.5q65 0 108.5 28t70 79t37.5 123.5t11 162.5q0 82 -14.5 157t-45 135.5t-79 102.5t-115.5 57l23 139q109 -18 188.5 -74t131 -136.5t76 -177.5t24.5 -198q0 -128 -26.5 -228t-77 -168.5t-124.5 -104.5t-169 -36q-68 0 -120 18t-90.5 52
t-64.5 83.5t-42 113.5h-4q-16 -64 -42 -113.5t-64.5 -83.5t-91 -52t-119.5 -18q-95 0 -169 36t-124.5 104.5t-77 168.5t-26.5 228q0 101 24.5 198t76 177.5t131 136.5t188.5 74l23 -139q-68 -15 -116 -57t-79 -102.5t-45 -135.5t-14 -157q0 -90 11 -162.5t37 -123.5t69 -79
t108 -28q51 0 92 22.5t69.5 64.5t43.5 103.5t15 139.5v252h166v-252z"" />
    <glyph glyph-name=""iotadieresis"" unicode=""&#x3ca;"" horiz-adv-x=""455""
d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h180v-855q0 -32 5.5 -64t16 -62t25.5 -56t33 -45h-198zM343 1219v184h163v-184h-163zM-51 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""upsilondieresis"" unicode=""&#x3cb;"" horiz-adv-x=""1120""
d=""M1022 571q0 -137 -26.5 -246t-83 -186t-144.5 -118t-211 -41q-109 0 -189 25t-132 78.5t-77.5 136.5t-25.5 199v663h181v-669q0 -146 58.5 -220t192.5 -74q73 0 125 25t84.5 79t47.5 139t15 205q0 68 -10 141.5t-26.5 143t-36.5 129.5t-41 101h188q18 -40 38 -96.5
t36 -123.5t26.5 -141.5t10.5 -149.5zM681 1219v184h163v-184h-163zM287 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""omicrontonos"" unicode=""&#x3cc;""
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM502 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""upsilontonos"" unicode=""&#x3cd;"" horiz-adv-x=""1120""
d=""M1022 571q0 -137 -26.5 -246t-83 -186t-144.5 -118t-211 -41q-109 0 -189 25t-132 78.5t-77.5 136.5t-25.5 199v663h181v-669q0 -146 58.5 -220t192.5 -74q73 0 125 25t84.5 79t47.5 139t15 205q0 68 -10 141.5t-26.5 143t-36.5 129.5t-41 101h188q18 -40 38 -96.5
t36 -123.5t26.5 -141.5t10.5 -149.5zM457 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""omegatonos"" unicode=""&#x3ce;"" horiz-adv-x=""1599""
d=""M883 449q0 -157 57 -243.5t159 -86.5q65 0 108.5 28t70 79t37.5 123.5t11 162.5q0 82 -14.5 157t-45 135.5t-79 102.5t-115.5 57l23 139q109 -18 188.5 -74t131 -136.5t76 -177.5t24.5 -198q0 -128 -26.5 -228t-77 -168.5t-124.5 -104.5t-169 -36q-68 0 -120 18t-90.5 52
t-64.5 83.5t-42 113.5h-4q-16 -64 -42 -113.5t-64.5 -83.5t-91 -52t-119.5 -18q-95 0 -169 36t-124.5 104.5t-77 168.5t-26.5 228q0 101 24.5 198t76 177.5t131 136.5t188.5 74l23 -139q-68 -15 -116 -57t-79 -102.5t-45 -135.5t-14 -157q0 -90 11 -162.5t37 -123.5t69 -79
t108 -28q51 0 92 22.5t69.5 64.5t43.5 103.5t15 139.5v252h166v-252zM716 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""uni0400"" unicode=""&#x400;"" horiz-adv-x=""1366""
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM735 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""afii10023"" unicode=""&#x401;"" horiz-adv-x=""1367""
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM816 1530v184h163v-184h-163zM422 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""afii10051"" unicode=""&#x402;"" horiz-adv-x=""1771""
d=""M720 1253v-352q33 7 87.5 17t118 19.5t128.5 16t118 6.5q226 0 334.5 -93.5t108.5 -281.5v-214q0 -93 -20.5 -165.5t-63.5 -122.5t-109.5 -76.5t-158.5 -26.5q-53 0 -97 8.5t-81.5 24.5t-69.5 39t-61 51l111 123q18 -16 38.5 -32.5t44.5 -29.5t52 -21.5t61 -8.5
q84 0 124 50.5t40 161.5v219q0 119 -64.5 180t-208.5 61q-51 0 -112.5 -5t-121.5 -12.5t-112.5 -16t-85.5 -16.5v-756h-190v1253h-484v156h1158v-156h-484z"" />
    <glyph glyph-name=""afii10052"" unicode=""&#x403;"" horiz-adv-x=""1109""
d=""M1071 1410v-156h-712v-1253h-191v1409h903zM441 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""afii10053"" unicode=""&#x404;"" horiz-adv-x=""1472""
d=""M792 1274q-111 0 -197.5 -34t-148.5 -97t-98.5 -152t-46.5 -199h654v-154h-654q9 -112 47.5 -204.5t102.5 -158.5t152 -102t197 -36q90 0 160.5 25t124.5 66t93.5 93.5t66.5 107.5l156 -77q-40 -79 -94 -147t-128 -118t-169.5 -78.5t-218.5 -28.5q-171 0 -299.5 54.5
t-215 152t-129.5 231.5t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21z"" />
    <glyph glyph-name=""afii10054"" unicode=""&#x405;"" horiz-adv-x=""1366""
d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5
t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5
q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134z"" />
    <glyph glyph-name=""afii10055"" unicode=""&#x406;"" horiz-adv-x=""569""
d=""M189 0v1409h191v-1409h-191z"" />
    <glyph glyph-name=""afii10056"" unicode=""&#x407;"" horiz-adv-x=""569""
d=""M189 0v1409h191v-1409h-191zM401 1530v184h163v-184h-163zM7 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""afii10057"" unicode=""&#x408;"" horiz-adv-x=""1024""
d=""M457 -20q-171 0 -280.5 89t-144.5 281l187 31q10 -65 33 -111.5t55 -76.5t71 -44t80 -14q104 0 164 71.5t60 209.5v837h-271v156h461v-989q0 -101 -28 -182t-81.5 -138.5t-130.5 -88.5t-175 -31z"" />
    <glyph glyph-name=""afii10058"" unicode=""&#x409;"" horiz-adv-x=""2165""
d=""M2059 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-585v1249h-416l-49 -368q-22 -172 -43.5 -305.5t-46 -233t-54.5 -168t-69 -111t-90 -61t-117 -18.5q-25 0 -48.5 2.5t-37.5 7.5v152q11 -4 28.5 -5.5t27.5 -1.5q30 0 56 11.5t48.5 42.5t43.5 84.5t40.5 138
t39.5 203.5t41 280l67 510h770v-596h382q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1867 411q0 121 -82 185.5t-246 64.5h-359v-510h367q164 0 242 68t78 192z"" />
    <glyph glyph-name=""afii10059"" unicode=""&#x40a;"" horiz-adv-x=""2069""
d=""M1963 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-545v653h-574v-653h-191v1409h191v-596h574v596h191v-596h342q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1771 411q0 121 -82 185.5t-246 64.5h-319v-510h327q164 0 242 68t78 192z"" />
    <glyph glyph-name=""afii10060"" unicode=""&#x40b;"" horiz-adv-x=""1749""
d=""M1393 0v575q0 122 -64 176.5t-197 54.5q-53 0 -111 -5t-113 -12.5t-104 -16.5t-84 -16v-756h-190v1253h-484v156h1203v-156h-529v-352q36 8 85 18t105 19t115 15.5t115 6.5q229 0 336 -93.5t107 -271.5v-595h-190z"" />
    <glyph glyph-name=""afii10061"" unicode=""&#x40c;"" horiz-adv-x=""1193""
d=""M168 1409h191v-619q57 0 97.5 12t78.5 46t83 95.5t111 160.5l205 305h200l-283 -410q-131 -189 -179 -224l509 -775h-222l-427 683q-17 -8 -40 -14.5t-47 -12t-46.5 -8.5t-39.5 -3v-645h-191v1409zM500 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""uni040D"" unicode=""&#x40d;"" horiz-adv-x=""1479""
d=""M841 1470l-330 278v29h207l217 -287v-20h-94zM1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230z"" />
    <glyph glyph-name=""afii10062"" unicode=""&#x40e;"" horiz-adv-x=""1301""
d=""M734 318q-47 -88 -87.5 -152t-85.5 -105t-99.5 -61t-129.5 -20q-32 0 -65 5t-65 14t-61 22t-52 29l81 144q35 -22 76.5 -40.5t89.5 -18.5q37 0 66 10.5t55.5 36.5t55 71t66.5 113l49 89l-573 954h218l449 -784l384 784h205zM690 1530q-111 0 -181.5 28.5t-111 74
t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164q-2 -57 -18 -114.5t-56.5 -103t-111 -74t-181.5 -28.5z"" />
    <glyph glyph-name=""afii10145"" unicode=""&#x40f;"" horiz-adv-x=""1472""
d=""M646 -408v408h-478v1409h191v-1249h759v1249h186v-1409h-478v-408h-180z"" />
    <glyph glyph-name=""afii10017"" unicode=""&#x410;"" horiz-adv-x=""1366""
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527z"" />
    <glyph glyph-name=""afii10018"" unicode=""&#x411;"" horiz-adv-x=""1344""
d=""M1238 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-585v1409h926v-156h-735v-440h382q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1046 411q0 121 -82 185.5t-246 64.5h-359v-510h367q164 0 242 68t78 192z"" />
    <glyph glyph-name=""afii10019"" unicode=""&#x412;"" horiz-adv-x=""1366""
d=""M1258 397q0 -107 -42 -182.5t-113 -123t-165 -69.5t-198 -22h-572v1409h512q117 0 209 -19.5t156 -61.5t97.5 -106.5t33.5 -154.5q0 -59 -16.5 -111t-50 -94.5t-84 -73t-117.5 -45.5q85 -10 150.5 -39t109.5 -74t67 -104.5t23 -128.5zM984 1044q0 114 -78 163t-226 49
h-321v-446h321q84 0 142 16.5t94 47t52 73.5t16 97zM1065 412q0 67 -24.5 114t-70.5 77t-110.5 44t-144.5 14h-356v-508h371q73 0 134.5 12t106 42t69.5 80t25 125z"" />
    <glyph glyph-name=""afii10020"" unicode=""&#x413;"" horiz-adv-x=""1109""
d=""M1071 1410v-156h-712v-1253h-191v1409h903z"" />
    <glyph glyph-name=""afii10021"" unicode=""&#x414;"" horiz-adv-x=""1387""
d=""M1174 160h175v-568h-180v408h-974v-408h-180v568h144q41 51 74 120t60.5 159.5t49.5 204.5t40 255l67 510h724v-1249zM988 160v1089h-375l-49 -368q-18 -134 -38 -244.5t-43 -199.5t-50 -157.5t-59 -119.5h614z"" />
    <glyph glyph-name=""afii10022"" unicode=""&#x415;"" horiz-adv-x=""1366""
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110z"" />
    <glyph glyph-name=""afii10024"" unicode=""&#x416;"" horiz-adv-x=""1891""
d=""M850 645q-17 0 -39.5 3t-46.5 8.5t-47 12t-40 14.5l-427 -683h-222l509 775q-48 35 -179 224l-283 410h200l205 -305q66 -99 111 -160.5t83 -95.5t78.5 -46t97.5 -12v619h191v-619q57 0 97.5 12t78.5 46t83 95.5t111 160.5l205 305h200l-283 -410q-131 -189 -179 -224
l509 -775h-222l-427 683q-17 -8 -40 -14.5t-47 -12t-46.5 -8.5t-39.5 -3v-645h-191v645z"" />
    <glyph glyph-name=""afii10025"" unicode=""&#x417;"" horiz-adv-x=""1237""
d=""M621 -20q-118 0 -206 25t-153 70.5t-112 109.5t-83 143l165 77q24 -55 57 -104t78.5 -86.5t106 -59.5t140.5 -22q77 0 138 18.5t103.5 53t65 84.5t22.5 114q0 133 -96 192t-298 59h-71v148h71q181 0 267.5 59.5t86.5 182.5q0 55 -19.5 98t-55.5 72.5t-88 44.5t-117 15
q-77 0 -134 -20t-98.5 -54t-69.5 -79t-47 -94l-178 61q33 82 81 145.5t114 107t150 66t189 22.5q108 0 194 -26.5t146 -74.5t92 -116t32 -151q0 -68 -20 -121.5t-56.5 -93.5t-88.5 -67.5t-115 -42.5q67 -10 125.5 -35t102 -66t69 -98.5t25.5 -130.5q0 -95 -34.5 -173
t-100.5 -134.5t-162 -87.5t-218 -31z"" />
    <glyph glyph-name=""afii10026"" unicode=""&#x418;"" horiz-adv-x=""1472""
d=""M168 0v1409h172v-924q0 -51 -1 -100t-3 -88q-2 -46 -4 -86l750 1198h222v-1409h-170v936q0 39 0.5 83.5t2.5 82.5q1 44 3 88l-742 -1190h-230z"" />
    <glyph glyph-name=""afii10027"" unicode=""&#x419;"" horiz-adv-x=""1472""
d=""M168 0v1409h172v-924q0 -51 -1 -100t-3 -88q-2 -46 -4 -86l750 1198h222v-1409h-170v936q0 39 0.5 83.5t2.5 82.5q1 44 3 88l-742 -1190h-230zM742 1530q-111 0 -181.5 28.5t-111 74t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164
q-2 -57 -18 -114.5t-56.5 -103t-111 -74t-181.5 -28.5z"" />
    <glyph glyph-name=""afii10028"" unicode=""&#x41a;"" horiz-adv-x=""1193""
d=""M168 1409h191v-619q57 0 97.5 12t78.5 46t83 95.5t111 160.5l205 305h200l-283 -410q-131 -189 -179 -224l509 -775h-222l-427 683q-17 -8 -40 -14.5t-47 -12t-46.5 -8.5t-39.5 -3v-645h-191v1409z"" />
    <glyph glyph-name=""afii10029"" unicode=""&#x41b;"" horiz-adv-x=""1344""
d=""M991 1249h-418l-49 -368q-22 -172 -43.5 -305.5t-46 -233t-54.5 -168t-69 -111t-90 -61t-117 -18.5q-25 0 -48.5 2.5t-37.5 7.5v152q11 -4 28.5 -5.5t27.5 -1.5q30 0 56 11.5t48.5 42.5t43.5 84.5t40.5 138t39.5 203.5t41 280l67 510h767v-1409h-186v1249z"" />
    <glyph glyph-name=""afii10030"" unicode=""&#x41c;"" horiz-adv-x=""1706""
d=""M1366 0v940q0 51 1 104t3 97q2 51 5 99q-14 -51 -29 -101q-13 -43 -28.5 -91.5t-30.5 -87.5l-364 -960h-134l-369 960q-6 15 -12.5 35t-14 42.5t-15 46t-14.5 46.5q-17 53 -33 110q1 -56 3 -111q2 -47 3 -98.5t1 -90.5v-940h-170v1409h251l375 -977q7 -20 17 -51.5
t19 -64.5t16.5 -62.5t10.5 -45.5q3 16 11 46t18.5 63t20.5 64t18 51l368 977h245v-1409h-172z"" />
    <glyph glyph-name=""afii10031"" unicode=""&#x41d;"" horiz-adv-x=""1479""
d=""M1121 0v653h-762v-653h-191v1409h191v-596h762v596h191v-1409h-191z"" />
    <glyph glyph-name=""afii10032"" unicode=""&#x41e;"" horiz-adv-x=""1593""
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231z"" />
    <glyph glyph-name=""afii10033"" unicode=""&#x41f;"" horiz-adv-x=""1472""
d=""M1119 0v1248h-762v-1248h-191v1409h1144v-1409h-191z"" />
    <glyph glyph-name=""afii10034"" unicode=""&#x420;"" horiz-adv-x=""1366""
d=""M1258 985q0 -92 -30.5 -171.5t-91 -138t-151.5 -92.5t-212 -34h-414v-549h-191v1409h593q125 0 218 -30.5t155 -86t93 -134t31 -173.5zM1066 983q0 134 -82 203.5t-246 69.5h-379v-556h387q165 0 242.5 73t77.5 210z"" />
    <glyph glyph-name=""afii10035"" unicode=""&#x421;"" horiz-adv-x=""1479""
d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5
t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21z"" />
    <glyph glyph-name=""afii10036"" unicode=""&#x422;"" horiz-adv-x=""1251""
d=""M720 1253v-1253h-190v1253h-484v156h1158v-156h-484z"" />
    <glyph glyph-name=""afii10037"" unicode=""&#x423;"" horiz-adv-x=""1301""
d=""M734 318q-47 -88 -87.5 -152t-85.5 -105t-99.5 -61t-129.5 -20q-32 0 -65 5t-65 14t-61 22t-52 29l81 144q35 -22 76.5 -40.5t89.5 -18.5q37 0 66 10.5t55.5 36.5t55 71t66.5 113l49 89l-573 954h218l449 -784l384 784h205z"" />
    <glyph glyph-name=""afii10038"" unicode=""&#x424;"" horiz-adv-x=""1557""
d=""M1439 736q0 -105 -32 -199t-97.5 -165.5t-164 -113.5t-231.5 -42h-40v-227h-191v227h-40q-133 0 -231.5 42t-164 113.5t-97.5 165.5t-32 199q0 113 33.5 205.5t100 158t167 101.5t235.5 36h29v182h191v-182h28q135 0 236 -36t167.5 -101.5t100 -158t33.5 -205.5z
M1247 732q0 187 -92.5 277t-275.5 90h-5v-746h13q92 0 160 26.5t112.5 75.5t66 119t21.5 158zM310 732q0 -88 21.5 -158t66 -119t112.5 -75.5t160 -26.5h13v746h-9q-182 0 -273 -90t-91 -277z"" />
    <glyph glyph-name=""afii10039"" unicode=""&#x425;"" horiz-adv-x=""1366""
d=""M1112 0l-423 616l-432 -616h-211l536 732l-495 677h211l392 -553l381 553h211l-482 -670l523 -739h-211z"" />
    <glyph glyph-name=""afii10040"" unicode=""&#x426;"" horiz-adv-x=""1515""
d=""M1477 160v-568h-180v408h-1129v1409h191v-1249h757v1249h186v-1249h175z"" />
    <glyph glyph-name=""afii10041"" unicode=""&#x427;"" horiz-adv-x=""1365""
d=""M1008 508q-36 -8 -83 -18t-100.5 -19t-111 -15t-113.5 -6q-114 0 -197 23.5t-137 69.5t-80 114.5t-26 157.5v594h190v-574q0 -123 65 -177t199 -54q53 0 108 5t107 12.5t98 16t81 15.5v756h190v-1409h-190v508z"" />
    <glyph glyph-name=""afii10042"" unicode=""&#x428;"" horiz-adv-x=""1877""
d=""M168 0v1409h191v-1249h489v1249h186v-1249h489v1249h186v-1409h-1541z"" />
    <glyph glyph-name=""afii10043"" unicode=""&#x429;"" horiz-adv-x=""1920""
d=""M1839 160v-568h-180v408h-1491v1409h191v-1249h467v1249h186v-1249h466v1249h186v-1249h175z"" />
    <glyph glyph-name=""afii10044"" unicode=""&#x42a;"" horiz-adv-x=""1621""
d=""M696 813h322q125 0 218 -29t155 -81.5t93 -126t31 -163.5q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-525v1253h-459v156h650v-596zM1323 411q0 121 -82 185.5t-246 64.5h-299v-510h307q164 0 242 68t78 192z"" />
    <glyph glyph-name=""afii10045"" unicode=""&#x42b;"" horiz-adv-x=""1813""
d=""M1238 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-585v1409h191v-596h382q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1046 411q0 121 -82 185.5t-246 64.5h-359v-510h367q164 0 242 68t78 192zM1454 0v1409h191v-1409h-191z"" />
    <glyph glyph-name=""afii10046"" unicode=""&#x42c;"" horiz-adv-x=""1344""
d=""M1238 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-585v1409h191v-596h382q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1046 407q0 121 -82 186.5t-246 65.5h-359v-508h367q165 0 242.5 65.5t77.5 190.5z"" />
    <glyph glyph-name=""afii10047"" unicode=""&#x42d;"" horiz-adv-x=""1472""
d=""M713 1274q-88 0 -156.5 -21t-119.5 -56t-85.5 -80.5t-53.5 -95.5l-181 60q71 173 222 261t376 88q164 0 292 -50.5t215.5 -144t133 -226.5t45.5 -298q0 -159 -43 -293t-129 -231.5t-214.5 -152t-299.5 -54.5q-118 0 -212.5 27t-169 76.5t-131 117.5t-97.5 151l156 78
q27 -55 67.5 -107.5t95 -94t124.5 -66.5t157 -25q109 0 197 36t152 102t102.5 158.5t47.5 204.5h-654v154h654q-10 110 -46.5 199t-98.5 152t-148.5 97t-197.5 34z"" />
    <glyph glyph-name=""afii10048"" unicode=""&#x42e;"" horiz-adv-x=""2069""
d=""M1971 711q0 -165 -45 -300t-130 -231t-207.5 -148t-277.5 -52q-156 0 -275.5 49.5t-202 139t-127.5 213t-52 271.5h-295v-653h-191v1409h191v-596h298q13 142 62.5 256.5t132.5 194.5t199 123t262 43q159 0 281.5 -51t206 -145t127 -227t43.5 -296zM1776 711
q0 127 -30 231t-88.5 178t-145 114t-199.5 40q-116 0 -203.5 -40t-146 -114t-87.5 -178t-29 -231t30 -232.5t88.5 -182t145 -119t200.5 -42.5q121 0 209 43t145 119.5t84 182.5t27 231z"" />
    <glyph glyph-name=""afii10049"" unicode=""&#x42f;"" horiz-adv-x=""1479""
d=""M96 0l400 607q-91 16 -156 55t-107 93t-61.5 119t-19.5 132q0 94 33 169t96 127t155.5 79.5t212.5 27.5h663v-1409h-191v585h-439l-366 -585h-220zM344 1004q0 -57 18.5 -106t57 -85t98 -56.5t142.5 -20.5h461v520h-453q-76 0 -136 -15.5t-102 -47t-64 -78.5t-22 -111z
"" />
    <glyph glyph-name=""afii10065"" unicode=""&#x430;""
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48z"" />
    <glyph glyph-name=""afii10066"" unicode=""&#x431;"" horiz-adv-x=""1173""
d=""M898 502q0 114 -19.5 189.5t-56 121t-88.5 64t-117 18.5q-69 0 -126 -19.5t-97.5 -65.5t-62.5 -121t-22 -187q0 -114 22 -189t60.5 -119.5t91 -62.5t114.5 -18q69 0 125 18t95 62t60 119.5t21 189.5zM655 1027q222 0 327 -130.5t105 -392.5q0 -265 -125 -394.5
t-363 -129.5q-113 0 -202 35t-150.5 113t-94 203t-32.5 305q0 192 29 331t93 235.5t167 154t250 85.5q57 11 107 19.5t95.5 15.5t88.5 13l86 12v-161q-86 -11 -166.5 -22.5t-171.5 -28.5q-78 -14 -140 -30.5t-109 -41.5t-80.5 -61.5t-55.5 -90.5t-33.5 -128.5t-13.5 -175.5
q19 55 52.5 103.5t82 84.5t111.5 56.5t143 20.5z"" />
    <glyph glyph-name=""afii10067"" unicode=""&#x432;"" horiz-adv-x=""1088""
d=""M564 1082q76 0 148 -12t128 -43t90 -83t34 -133q0 -53 -17.5 -93.5t-47.5 -69.5t-71 -47.5t-87 -27.5v-7q54 -7 101.5 -24.5t82 -48t54.5 -75.5t20 -106q0 -78 -30.5 -136.5t-85 -97.5t-130 -58.5t-166.5 -19.5h-445v1082h422zM322 133h236q69 0 116.5 10t77 32t43 55.5
t13.5 80.5q0 50 -14 85t-45.5 57t-81.5 32t-121 10h-224v-362zM322 945v-320h216q68 0 113.5 9.5t73 29t39 50t11.5 73.5q0 82 -51 120t-172 38h-230z"" />
    <glyph glyph-name=""afii10068"" unicode=""&#x433;"" horiz-adv-x=""747""
d=""M687 1082v-131h-365v-951h-180v1082h545z"" />
    <glyph glyph-name=""afii10069"" unicode=""&#x434;"" horiz-adv-x=""1195""
d=""M834 951h-306q-24 -177 -48.5 -308.5t-48.5 -228.5t-48 -165t-46 -118h497v820zM1160 -408h-163v408h-814v-408h-163v539h119q30 50 59 121.5t58 181.5t57.5 267.5t56.5 380.5h644v-951h146v-539z"" />
    <glyph glyph-name=""afii10070"" unicode=""&#x435;""
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584z"" />
    <glyph glyph-name=""afii10072"" unicode=""&#x436;"" horiz-adv-x=""1370""
d=""M595 477q-26 0 -58.5 6t-51.5 14l-278 -497h-200l353 592q-17 14 -50 56.5t-78 108.5l-216 325h188l148 -239q48 -77 80.5 -123t58.5 -71t50 -33t54 -8v474h180v-474q30 0 54 8t50 33t58.5 71t80.5 123l148 239h188l-216 -325q-45 -66 -78 -108.5t-50 -56.5l353 -592
h-200l-278 497q-19 -8 -51.5 -14t-58.5 -6v-477h-180v477z"" />
    <glyph glyph-name=""afii10073"" unicode=""&#x437;"" horiz-adv-x=""939""
d=""M458 -20q-167 0 -265.5 62.5t-143.5 191.5l159 44q25 -78 88 -121t166 -43q96 0 152.5 47t56.5 138q0 59 -27.5 98t-73.5 61.5t-106 31.5t-124 9v137q64 0 121 7.5t100 26.5t67.5 52.5t24.5 85.5q0 74 -49.5 117t-142.5 43q-35 0 -70 -7t-65 -23.5t-51 -44t-28 -69.5
l-162 20q12 68 43 117t79.5 80.5t112.5 46t142 14.5q85 0 154 -21t118 -59t75.5 -90t26.5 -115q0 -57 -22 -101t-57.5 -74.5t-79.5 -48.5t-89 -22v-2q56 -6 106 -26.5t87.5 -54t59 -80t21.5 -104.5q0 -69 -24.5 -128.5t-75 -103t-126.5 -68t-178 -24.5z"" />
    <glyph glyph-name=""afii10074"" unicode=""&#x438;"" horiz-adv-x=""1144""
d=""M316 1082v-592q0 -23 -1.5 -61.5t-3 -79.5t-3 -78t-2.5 -58l499 869h197v-1082h-172v660q0 19 1 47.5t2.5 58.5t3 58.5t3.5 48.5l-506 -873h-192v1082h174z"" />
    <glyph glyph-name=""afii10075"" unicode=""&#x439;"" horiz-adv-x=""1144""
d=""M316 1082v-592q0 -23 -1.5 -61.5t-3 -79.5t-3 -78t-2.5 -58l499 869h197v-1082h-172v660q0 19 1 47.5t2.5 58.5t3 58.5t3.5 48.5l-506 -873h-192v1082h174zM574 1200q-111 0 -181.5 28.5t-111 74t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164
q-2 -57 -18 -114.5t-56.5 -103t-111 -74t-181.5 -28.5z"" />
    <glyph glyph-name=""afii10076"" unicode=""&#x43a;"" horiz-adv-x=""896""
d=""M138 1082h180v-474q30 0 54 8t50 33t58.5 71t80.5 123l148 239h188l-216 -325q-45 -66 -78 -108.5t-50 -56.5l353 -592h-200l-278 497q-19 -8 -51.5 -14t-58.5 -6v-477h-180v1082z"" />
    <glyph glyph-name=""afii10077"" unicode=""&#x43b;"" horiz-adv-x=""1195""
d=""M872 0v951h-375q-25 -184 -46 -327.5t-43 -251.5t-47.5 -182.5t-61 -121t-82.5 -67.5t-112 -21q-29 0 -53 4t-41 9v129q11 -4 30 -6.5t38 -2.5q35 0 60.5 21t45.5 68t36.5 121.5t33.5 182.5t36 250.5t44 325.5h718v-1082h-181z"" />
    <glyph glyph-name=""afii10078"" unicode=""&#x43c;"" horiz-adv-x=""1408""
d=""M787 0h-153l-324 951q1 -26 2.5 -56t2 -60.5t1 -59t0.5 -51.5v-724h-174v1082h280l220 -661q23 -63 41.5 -138.5t26.5 -147.5q10 72 27.5 147.5t40.5 138.5l220 661h269v-1082h-173v724q0 22 0.5 52t2 62t2.5 62t3 53z"" />
    <glyph glyph-name=""afii10079"" unicode=""&#x43d;"" horiz-adv-x=""1131""
d=""M322 1082v-458h487v458h180v-1082h-180v493h-487v-493h-180v1082h180z"" />
    <glyph glyph-name=""afii10080"" unicode=""&#x43e;""
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209z"" />
    <glyph glyph-name=""afii10081"" unicode=""&#x43f;"" horiz-adv-x=""1109""
d=""M967 1082v-1082h-180v951h-465v-951h-180v1082h825z"" />
    <glyph glyph-name=""afii10082"" unicode=""&#x440;""
d=""M1053 546q0 -123 -20 -227t-66.5 -179t-123 -117.5t-188.5 -42.5q-116 0 -203 44t-133 144h-5q1 -2 1.5 -18t1 -40t1 -53.5t0.5 -58.5v-423h-180v1286q0 39 -0.5 75t-1.5 65.5t-2 50.5t-2 30h174q1 -3 2.5 -21t3 -43.5t3 -54.5t1.5 -55h4q25 52 57 88.5t73 60t91.5 34
t113.5 10.5q112 0 188.5 -40t123 -112.5t66.5 -175t20 -227.5zM864 542q0 100 -12 178t-41.5 132t-78.5 82t-123 28q-60 0 -113 -17t-92.5 -65t-62.5 -132.5t-23 -219.5q0 -115 19 -194.5t55.5 -128.5t90.5 -70.5t124 -21.5q75 0 124.5 29t79 84t41.5 134.5t12 181.5z"" />
    <glyph glyph-name=""afii10083"" unicode=""&#x441;"" horiz-adv-x=""1024""
d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5
q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183z"" />
    <glyph glyph-name=""afii10084"" unicode=""&#x442;"" horiz-adv-x=""938""
d=""M35 1082h868v-131h-344v-951h-180v951h-344v131z"" />
    <glyph glyph-name=""afii10085"" unicode=""&#x443;"" horiz-adv-x=""1024""
d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190z"" />
    <glyph glyph-name=""afii10086"" unicode=""&#x444;"" horiz-adv-x=""1685""
d=""M1598 546q0 -123 -19 -227t-62 -179t-113 -117.5t-171 -42.5q-105 0 -184 44t-121 144h-6q2 -35 3.5 -73.5t1.5 -96.5v-423h-170v423q0 54 1 95t4 81h-5q-46 -104 -120.5 -149t-185.5 -45q-186 0 -275.5 137.5t-89.5 418.5q0 284 92.5 425t272.5 141q112 0 186.5 -45
t119.5 -143h5q0 10 -1 30.5t-2 43.5t-1.5 44t-0.5 33v419h170v-420q0 -11 -0.5 -32.5t-1 -45t-1 -45t-0.5 -33.5h5q46 104 118 148.5t186 44.5q101 0 171 -40t113 -112.5t62 -175t19 -227.5zM275 542q0 -112 13 -192t41 -131.5t70.5 -75.5t102.5 -24t107 21.5t79.5 70.5
t49.5 127.5t19 191.5v24q0 115 -17 194.5t-49 128.5t-79 70.5t-108 21.5q-57 0 -100 -23t-71.5 -74t-43 -132.5t-14.5 -197.5zM1409 542q0 100 -11.5 178t-37.5 132t-70 82t-108 28q-53 0 -99 -17t-81 -65t-55 -132.5t-20 -219.5v-23q1 -108 18.5 -183t50 -121.5t78.5 -67
t106 -20.5q65 0 109 29t70.5 84t38 134.5t11.5 181.5z"" />
    <glyph glyph-name=""afii10087"" unicode=""&#x445;"" horiz-adv-x=""1024""
d=""M801 0l-291 444l-293 -444h-194l385 556l-367 526h199l270 -421l268 421h201l-367 -524l390 -558h-201z"" />
    <glyph glyph-name=""afii10088"" unicode=""&#x446;"" horiz-adv-x=""1173""
d=""M322 1082v-951h477v951h180v-951h147v-539h-163v408h-821v1082h180z"" />
    <glyph glyph-name=""afii10089"" unicode=""&#x447;"" horiz-adv-x=""1067""
d=""M302 1082v-402q0 -34 8 -63.5t27.5 -51.5t51.5 -34.5t79 -12.5q70 0 136 13t140 34v517h180v-1082h-180v461q-38 -15 -78.5 -30.5t-84 -27.5t-90 -20t-97.5 -8q-66 0 -116.5 20.5t-85 58.5t-52.5 93t-18 124v411h180z"" />
    <glyph glyph-name=""afii10090"" unicode=""&#x448;"" horiz-adv-x=""1643""
d=""M142 0v1082h180v-951h410v951h180v-951h409v951h180v-1082h-1359z"" />
    <glyph glyph-name=""afii10091"" unicode=""&#x449;"" horiz-adv-x=""1685""
d=""M142 0v1082h180v-951h405v951h180v-951h404v951h180v-951h147v-539h-163v408h-1333z"" />
    <glyph glyph-name=""afii10092"" unicode=""&#x44a;"" horiz-adv-x=""1280""
d=""M781 624q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-409v951h-328v131h508v-458h228zM553 127h202q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-203v-372z"" />
    <glyph glyph-name=""afii10093"" unicode=""&#x44b;"" horiz-adv-x=""1472""
d=""M550 624q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-409v1082h180v-458h228zM322 127h202q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-203v-372zM1150 0v1082h180v-1082h-180z"" />
    <glyph glyph-name=""afii10094"" unicode=""&#x44c;"" horiz-adv-x=""1067""
d=""M568 624q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-427v1082h180v-458h246zM322 127h220q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-221v-372z"" />
    <glyph glyph-name=""afii10095"" unicode=""&#x44d;"" horiz-adv-x=""1045""
d=""M55 315l182 12q16 -108 82.5 -160t166.5 -52q73 0 124.5 26.5t85.5 75t51 116t22 149.5h-413v131h413q-4 90 -21 156.5t-50.5 110.5t-85 66t-124.5 22q-109 0 -168 -52.5t-74 -143.5l-185 14q13 68 46 126t85.5 100t125 66t165.5 24q90 0 175 -26.5t152 -90.5t107.5 -172
t40.5 -271q0 -120 -25.5 -222.5t-82.5 -178t-148 -118.5t-221 -43q-99 0 -174.5 27t-128.5 73t-83.5 107t-39.5 128z"" />
    <glyph glyph-name=""afii10096"" unicode=""&#x44e;"" horiz-adv-x=""1536""
d=""M1450 542q0 -284 -117.5 -423t-340.5 -139q-102 0 -182.5 31t-138 95t-90 160t-37.5 227h-222v-493h-180v1082h180v-458h223q33 478 453 478q237 0 344.5 -140t107.5 -420zM1261 542q0 126 -17.5 208t-51 131t-82 68.5t-109.5 19.5q-63 0 -112.5 -20.5t-84.5 -70
t-53.5 -131.5t-18.5 -205q0 -126 19.5 -208.5t54.5 -131.5t82 -69t103 -20q62 0 112 19.5t85 68.5t54 132t19 209z"" />
    <glyph glyph-name=""afii10097"" unicode=""&#x44f;"" horiz-adv-x=""1109""
d=""M535 458l-315 -458h-203l344 471q-131 27 -190 108.5t-59 203.5q0 149 108 224t315 75h432v-1082h-180v458h-252zM787 955h-234q-130 0 -190 -46t-60 -139q0 -94 53.5 -140.5t177.5 -46.5h253v372z"" />
    <glyph glyph-name=""uni0450"" unicode=""&#x450;""
d=""M592 1218l-330 278v29h207l217 -287v-20h-94zM276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5
t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584z"" />
    <glyph glyph-name=""afii10071"" unicode=""&#x451;""
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM687 1219v184h163v-184h-163zM293 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""afii10099"" unicode=""&#x452;""
d=""M142 0v1206h-132v131h132v147h180v-147h300v-131h-300v-148q0 -33 -1 -66t-2.5 -61t-2.5 -47.5t-2 -26.5h3q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-815q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5
q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38 31.5t18.5 55t5 79.5v753q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-598h-180z"" />
    <glyph glyph-name=""afii10100"" unicode=""&#x453;"" horiz-adv-x=""747""
d=""M687 1082v-131h-365v-951h-180v1082h545zM288 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""afii10101"" unicode=""&#x454;"" horiz-adv-x=""1045""
d=""M564 -20q-130 0 -221 43t-148 118.5t-82.5 178t-25.5 222.5q0 163 40.5 271t107.5 172t152 90.5t175 26.5q93 0 165.5 -24t125 -66t85.5 -100t46 -126l-185 -14q-15 91 -74 143.5t-168 52.5q-73 0 -124.5 -22t-85 -66t-50.5 -110.5t-21 -156.5h412v-131h-413
q4 -82 21.5 -149.5t51.5 -116t85.5 -75t125.5 -26.5q100 0 166.5 51.5t82.5 160.5l182 -12q-9 -67 -39.5 -128t-83.5 -107t-128.5 -73t-174.5 -27z"" />
    <glyph glyph-name=""afii10102"" unicode=""&#x455;"" horiz-adv-x=""1024""
d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38
t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5
t44.5 -77t16.5 -102z"" />
    <glyph glyph-name=""afii10103"" unicode=""&#x456;"" horiz-adv-x=""455""
d=""M137 0v1082h180v-1082h-180zM137 1312v172h180v-172h-180z"" />
    <glyph glyph-name=""afii10104"" unicode=""&#x457;"" horiz-adv-x=""569""
d=""M194 0v1082h180v-1082h-180zM386 1219v184h163v-184h-163zM-8 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""afii10105"" unicode=""&#x458;"" horiz-adv-x=""455""
d=""M137 1312v172h180v-172h-180zM317 -134q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v1189h180v-1216z"" />
    <glyph glyph-name=""afii10106"" unicode=""&#x459;"" horiz-adv-x=""1856""
d=""M1357 624q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-450v951h-411q-25 -184 -46 -327.5t-43 -251.5t-47.5 -182.5t-61 -121t-82.5 -67.5t-112 -21q-29 0 -53 4t-41 9v129q11 -4 30 -6.5t38 -2.5q35 0 60.5 21t45.5 68t36.5 121.5
t33.5 182.5t36 250.5t44 325.5h754v-458h268zM1089 127h242q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-243v-372z"" />
    <glyph glyph-name=""afii10107"" unicode=""&#x45a;"" horiz-adv-x=""1664""
d=""M937 1082v-458h228q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-410v493h-434v-493h-180v1082h180v-458h434v458h181zM937 127h202q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-203v-372z"" />
    <glyph glyph-name=""afii10108"" unicode=""&#x45b;""
d=""M317 857q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-681h-181v646q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-598h-180v1206h-132v131h132v147h180v-147h300v-131h-300
v-148q0 -33 -1 -66t-2.5 -61t-2.5 -47.5t-2 -26.5h3z"" />
    <glyph glyph-name=""afii10109"" unicode=""&#x45c;"" horiz-adv-x=""896""
d=""M138 1082h180v-474q30 0 54 8t50 33t58.5 71t80.5 123l148 239h188l-216 -325q-45 -66 -78 -108.5t-50 -56.5l353 -592h-200l-278 497q-19 -8 -51.5 -14t-58.5 -6v-477h-180v1082zM391 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""uni045D"" unicode=""&#x45d;"" horiz-adv-x=""1144""
d=""M588 1201l-330 278v29h207l217 -287v-20h-94zM316 1082v-592q0 -23 -1.5 -61.5t-3 -79.5t-3 -78t-2.5 -58l499 869h197v-1082h-172v660q0 19 1 47.5t2.5 58.5t3 58.5t3.5 48.5l-506 -873h-192v1082h174z"" />
    <glyph glyph-name=""afii10110"" unicode=""&#x45e;"" horiz-adv-x=""1024""
d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM523 1200
q-111 0 -181.5 28.5t-111 74t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164q-2 -57 -18 -114.5t-56.5 -103t-111 -74t-181.5 -28.5z"" />
    <glyph glyph-name=""afii10193"" unicode=""&#x45f;"" horiz-adv-x=""1131""
d=""M142 0v1082h180v-951h487v951h180v-1082h-342v-408h-163v408h-342z"" />
    <glyph glyph-name=""afii10050"" unicode=""&#x490;"" horiz-adv-x=""1001""
d=""M774 1409v411h180v-567h-595v-1252h-191v1408h606z"" />
    <glyph glyph-name=""afii10098"" unicode=""&#x491;"" horiz-adv-x=""842""
d=""M322 0h-180v1082h473v402h163v-533h-456v-951z"" />
    <glyph glyph-name=""Wgrave"" unicode=""&#x1e80;"" horiz-adv-x=""1933""
d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183
l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199zM993 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""wgrave"" unicode=""&#x1e81;"" horiz-adv-x=""1479""
d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62
q8 -34 16 -69q8 38 16 74q7 31 14.5 64.5t14.5 59.5l191 735h176zM764 1201l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""Wacute"" unicode=""&#x1e82;"" horiz-adv-x=""1933""
d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183
l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199zM831 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""wacute"" unicode=""&#x1e83;"" horiz-adv-x=""1479""
d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62
q8 -34 16 -69q8 38 16 74q7 31 14.5 64.5t14.5 59.5l191 735h176zM622 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Wdieresis"" unicode=""&#x1e84;"" horiz-adv-x=""1933""
d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183
l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199zM1085 1530v184h163v-184h-163zM691 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""wdieresis"" unicode=""&#x1e85;"" horiz-adv-x=""1479""
d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62
q8 -34 16 -69q8 38 16 74q7 31 14.5 64.5t14.5 59.5l191 735h176zM856 1219v184h163v-184h-163zM462 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""Ygrave"" unicode=""&#x1ef2;"" horiz-adv-x=""1366""
d=""M777 584v-584h-190v584l-542 825h210l429 -671l427 671h210zM706 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""ygrave"" unicode=""&#x1ef3;"" horiz-adv-x=""1024""
d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM541 1201
l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""uni2010"" unicode=""&#x2010;"" horiz-adv-x=""682""
d=""M91 464v160h500v-160h-500z"" />
    <glyph glyph-name=""uni2011"" unicode=""&#x2011;"" horiz-adv-x=""682""
d=""M91 464v160h500v-160h-500z"" />
    <glyph glyph-name=""endash"" unicode=""&#x2013;""
d=""M0 451v137h1138v-137h-1138z"" />
    <glyph glyph-name=""emdash"" unicode=""&#x2014;"" horiz-adv-x=""2048""
d=""M0 451v137h2048v-137h-2048z"" />
    <glyph glyph-name=""afii00208"" unicode=""&#x2015;"" horiz-adv-x=""2048""
d=""M0 451v137h2048v-137h-2048z"" />
    <glyph glyph-name=""underscoredbl"" unicode=""&#x2017;"" horiz-adv-x=""1131""
d=""M-31 -434v130h1193v-130h-1193zM-31 -217v130h1193v-130h-1193z"" />
    <glyph glyph-name=""quoteleft"" unicode=""&#x2018;"" horiz-adv-x=""455""
d=""M127 952v146q0 52 5 95t15 80.5t25 70.5t35 65h121q-45 -65 -70 -131t-25 -131h89v-195h-195z"" />
    <glyph glyph-name=""quoteright"" unicode=""&#x2019;"" horiz-adv-x=""455""
d=""M328 1264q0 -53 -4.5 -96t-14.5 -80.5t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 129h-88v197h195v-145z"" />
    <glyph glyph-name=""quotesinglbase"" unicode=""&#x201a;"" horiz-adv-x=""455""
d=""M328 51q0 -53 -4.5 -96.5t-14.5 -81t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v195h195v-144z"" />
    <glyph glyph-name=""quotereversed"" unicode=""&#x201b;"" horiz-adv-x=""455""
d=""M321 1409v-197h-88q0 -63 24.5 -129t69.5 -131h-123q-20 32 -34.5 65t-24.5 70.5t-14.5 80.5t-4.5 96v145h195z"" />
    <glyph glyph-name=""quotedblleft"" unicode=""&#x201c;"" horiz-adv-x=""682""
d=""M407 952v146q0 52 5 95t14.5 80.5t24 70.5t34.5 65h122q-45 -65 -69.5 -131t-24.5 -131h88v-195h-194zM75 952v146q0 52 5 95t15 80.5t25 70.5t35 65h121q-45 -65 -70 -131t-25 -131h89v-195h-195z"" />
    <glyph glyph-name=""quotedblright"" unicode=""&#x201d;"" horiz-adv-x=""682""
d=""M607 1264q0 -53 -5 -96t-14.5 -80.5t-24.5 -70.5t-35 -65h-121q45 65 69.5 131t24.5 131h-88v195h194v-145zM276 1264q0 -53 -4.5 -96t-14.5 -80.5t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v195h195v-145z"" />
    <glyph glyph-name=""quotedblbase"" unicode=""&#x201e;"" horiz-adv-x=""682""
d=""M607 51q0 -53 -5 -96.5t-14.5 -81t-24.5 -70.5t-35 -65h-121q45 65 69.5 131t24.5 131h-88v195h194v-144zM276 51q0 -53 -4.5 -96.5t-14.5 -81t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v195h195v-144z"" />
    <glyph glyph-name=""dagger"" unicode=""&#x2020;""
d=""M649 1000l-22 -1138h-115l-22 1138l-352 -27v164l352 -29l-28 376h215l-28 -376l353 29v-164z"" />
    <glyph glyph-name=""daggerdbl"" unicode=""&#x2021;""
d=""M497 1000l-360 -27v164l360 -29l-16 376h175l-16 -376l361 29v-164l-361 27l-26 -330l26 -327l360 27v-164l-360 29l16 -376h-175l16 376l-361 -29v164l361 -27l26 327z"" />
    <glyph glyph-name=""bullet"" unicode=""&#x2022;"" horiz-adv-x=""717""
d=""M636 682q0 -58 -22.5 -109t-60.5 -89.5t-89 -60.5t-109 -22q-57 0 -106.5 22t-87 60.5t-59 89.5t-21.5 109q0 57 21.5 107t59 87t87 58.5t106.5 21.5q58 0 109 -21.5t89 -58.5t60.5 -87t22.5 -107z"" />
    <glyph glyph-name=""ellipsis"" unicode=""&#x2026;"" horiz-adv-x=""2048""
d=""M1576 0v219h194v-219h-194zM929 0v219h192v-219h-192zM278 0v219h195v-219h-195z"" />
    <glyph glyph-name=""perthousand"" unicode=""&#x2030;"" horiz-adv-x=""2048""
d=""M304 0h-155l922 1409h157zM356 1421q60 0 113.5 -16.5t93.5 -58t63 -111t23 -175.5q0 -102 -23 -172t-63.5 -113t-94.5 -62t-116 -19q-63 0 -117 18.5t-94 61.5t-63 113t-23 173q0 106 23 175.5t63.5 111t95.5 58t119 16.5zM502 1060q0 73 -9.5 122t-28 78t-46 41
t-62.5 12q-38 0 -67 -12t-48.5 -41.5t-29 -78t-9.5 -121.5q0 -71 10 -119.5t29.5 -78t47.5 -42.5t65 -13q34 0 61 13t46.5 42.5t30 78t10.5 119.5zM1044 716q60 0 113.5 -16.5t93.5 -58t63 -111t23 -175.5q0 -102 -23 -172t-63.5 -113t-94.5 -62t-116 -19q-63 0 -117 18.5
t-94 61.5t-63 113t-23 173q0 106 23 175.5t63.5 111t95.5 58t119 16.5zM1190 355q0 73 -9.5 122t-28 78t-46 41t-62.5 12q-38 0 -67 -12t-48.5 -41.5t-29 -78t-9.5 -121.5q0 -71 10 -119.5t29.5 -78t47.5 -42.5t65 -13q34 0 61 13t46.5 42.5t30 78t10.5 119.5zM1699 716
q60 0 113.5 -16.5t93.5 -58t63 -111t23 -175.5q0 -102 -23 -172t-63.5 -113t-94.5 -62t-116 -19q-63 0 -117 18.5t-94 61.5t-63 113t-23 173q0 106 23 175.5t63.5 111t95.5 58t119 16.5zM1845 355q0 73 -9.5 122t-28 78t-46 41t-62.5 12q-38 0 -67 -12t-48.5 -41.5t-29 -78
t-9.5 -121.5q0 -71 10 -119.5t29.5 -78t47.5 -42.5t65 -13q34 0 61 13t46.5 42.5t30 78t10.5 119.5z"" />
    <glyph glyph-name=""minute"" unicode=""&#x2032;"" horiz-adv-x=""384""
d=""M85 890l64 519h196l-158 -519h-102z"" />
    <glyph glyph-name=""second"" unicode=""&#x2033;"" horiz-adv-x=""725""
d=""M85 890l64 519h196l-158 -519h-102zM427 890l64 519h196l-158 -519h-102z"" />
    <glyph glyph-name=""guilsinglleft"" unicode=""&#x2039;"" horiz-adv-x=""682""
d=""M424 141l-336 365v63l336 371h167v-31l-335 -372l337 -367v-29h-169z"" />
    <glyph glyph-name=""guilsinglright"" unicode=""&#x203a;"" horiz-adv-x=""682""
d=""M257 141h-168v29l338 367l-336 372v31h166l337 -371v-63z"" />
    <glyph glyph-name=""exclamdbl"" unicode=""&#x203c;"" horiz-adv-x=""1024""
d=""M359 397h-148l-24 1012h196zM185 0v201h194v-201h-194zM815 397h-148l-24 1012h196zM641 0v201h194v-201h-194z"" />
    <glyph glyph-name=""uni203E"" unicode=""&#x203e;"" horiz-adv-x=""682""
d=""M747 1503h-811v117h811v-117z"" />
    <glyph glyph-name=""uni2215"" unicode=""&#x2044;"" horiz-adv-x=""342""
d=""M-268 0h-148l881 1409h145z"" />
    <glyph glyph-name=""uni2215"" unicode=""&#x2215;"" horiz-adv-x=""342""
d=""M-268 0h-148l881 1409h145z"" />
    <glyph glyph-name=""uni207F"" unicode=""&#x207f;"" horiz-adv-x=""747""
d=""M514 519v398q0 46 -6.5 76.5t-21 49t-38 26.5t-58.5 8q-72 0 -114.5 -50t-42.5 -144v-364h-128v511q0 20 -0.5 43t-1 43t-1.5 34.5t-1 18.5h119q0 -3 1 -16.5t2 -30.5t2 -34.5t1 -29.5h2q15 28 34 51t43.5 39t56.5 24.5t74 8.5q110 0 158.5 -54t48.5 -175v-433h-129z"" />
    <glyph glyph-name=""franc"" unicode=""&#x20a3;""
d=""M359 1254v-476h687v-157h-687v-213h402v-129h-402v-279h-180v279h-175v129h175v1001h891v-155h-711z"" />
    <glyph glyph-name=""lira"" unicode=""&#x20a4;""
d=""M1104 311q-9 -80 -37.5 -138.5t-73 -97t-102 -57t-124.5 -18.5h-698v154q89 46 132 126t43 201v25h-186v129h186v140h-186v129h186v130q0 92 24 165.5t73.5 124.5t125.5 78.5t179 27.5q70 0 131.5 -14.5t111 -43.5t85 -72t53.5 -100l-174 -57q-10 31 -29.5 57t-46 44
t-59 28t-68.5 10q-114 0 -170 -57.5t-56 -182.5v-138h408v-129h-408v-140h408v-129h-408v-7q0 -56 -11 -109t-33 -99t-53.5 -81.5t-71.5 -56.5h483q38 0 71.5 9.5t60 30.5t45 54.5t26.5 81.5z"" />
    <glyph glyph-name=""peseta"" unicode=""&#x20a7;"" horiz-adv-x=""2240""
d=""M954 985q0 -92 -30.5 -171.5t-91 -138t-151.5 -92.5t-212 -34h-130v-549h-181v1409h299q125 0 218 -30.5t155 -86t93 -134t31 -173.5zM772 983q0 134 -82 203.5t-246 69.5h-105v-556h113q165 0 242.5 73t77.5 210zM1407 8q-35 -11 -72 -17.5t-85 -6.5q-105 0 -151.5 61.5
t-46.5 183.5v453h-104v131h111l53 242h110v-242h157v-131h-157v-414q0 -78 20.5 -114.5t75.5 -36.5q23 0 43 4t46 10v-123zM2151 229q0 -120 -91.5 -184.5t-261.5 -64.5q-75 0 -135.5 12t-106.5 39t-76.5 71t-45.5 108l159 26q17 -61 66.5 -90t137.5 -29q40 0 74 5
t58.5 17.5t38 32.5t13.5 50t-17 50.5t-48 35t-74.5 26t-95.5 24.5q-49 12 -97 28t-86.5 42.5t-62 66t-23.5 98.5q0 112 84 171.5t245 59.5q141 0 223.5 -52.5t104.5 -168.5l-161 -17q-6 28 -21.5 47t-38 31t-49.5 17t-57 5q-155 0 -155 -85q0 -25 16 -43t44.5 -32t68.5 -25
t88 -22t98 -26.5t91 -42.5t67 -70.5t26 -110.5z"" />
    <glyph glyph-name=""Euro"" unicode=""&#x20ac;""
d=""M691 126q100 0 160 50t74 141l185 -14q-13 -68 -44.5 -127t-83 -102.5t-125 -68.5t-170.5 -25q-120 0 -208.5 38.5t-149 108t-95 165.5t-47.5 210h-171l40 129h120q-1 8 -2 31t-1 47q0 27 1 53.5t2 32.5h-160l40 127h129q15 122 51.5 216.5t98 159.5t148 98.5t201.5 33.5
q97 0 170.5 -25t125 -68.5t83 -102.5t44.5 -127l-185 -14q-14 91 -74.5 141t-166.5 50q-68 0 -121 -19.5t-92.5 -63t-64.5 -112t-36 -167.5h446l-40 -127h-413q-2 -16 -2.5 -39.5t-0.5 -46.5q0 -22 1 -40.5t3 -37.5h452l-40 -129h-404q9 -81 30 -150t59.5 -119t95.5 -78.5
t137 -28.5z"" />
    <glyph glyph-name=""afii61248"" unicode=""&#x2105;"" horiz-adv-x=""1813""
d=""M1744 434q0 -125 -25.5 -210.5t-69 -138t-101.5 -75t-124 -22.5t-123.5 22.5t-100 74.5t-67 137.5t-24.5 211.5q0 133 24 220t67 138.5t101.5 72t126.5 20.5q66 0 123.5 -20.5t100 -72t67.5 -138.5t25 -220zM523 0h-155l922 1409h157zM1596 434q0 99 -11 164.5
t-32.5 104.5t-53 55t-71.5 16q-42 0 -74 -16.5t-54 -55.5t-33 -104.5t-11 -163.5q0 -95 11.5 -159t33 -103.5t53 -56.5t72.5 -17q39 0 70.5 17t53.5 56.5t34 103.5t12 159zM215 975q0 -75 10 -137t33.5 -107t61 -70t91.5 -25q69 0 116 41t58 128l141 -9q-6 -54 -28.5 -103.5
t-61 -87.5t-94 -60.5t-127.5 -22.5q-94 0 -160 34.5t-107 95t-60 142.5t-19 178q0 130 29.5 216.5t78 138t110.5 72.5t127 21q68 0 121 -20t91 -55t62 -82t33 -102l-143 -11q-10 72 -51.5 114.5t-116.5 42.5q-108 0 -151.5 -82t-43.5 -250z"" />
    <glyph glyph-name=""afii61289"" unicode=""&#x2113;"" horiz-adv-x=""662""
d=""M433 78q51 0 85 52t51 161h69q-20 -154 -80 -232.5t-169 -78.5q-111 0 -174.5 79.5t-63.5 234.5v175q-32 -17 -65 -31t-67 -27v73q35 14 68 28.5t64 30.5v587q0 59 12.5 113t42 95.5t78.5 66t121 24.5q52 0 91.5 -21t66 -60t40 -94.5t13.5 -124.5q0 -99 -22 -189
t-61.5 -166t-94.5 -135t-121 -97v-244q0 -57 9.5 -98.5t25.5 -68.5t37 -40t44 -13zM525 1122q0 52 -7 94.5t-20.5 73t-33.5 47t-46 16.5q-32 0 -51.5 -18t-30.5 -48.5t-15 -71t-4 -86.5v-507q49 33 87.5 85t65.5 117.5t41 141t14 156.5z"" />
    <glyph glyph-name=""afii61352"" unicode=""&#x2116;"" horiz-adv-x=""2197""
d=""M1062 0l-720 1190q1 -44 3 -88q1 -38 2 -82.5t1 -83.5v-936h-160v1409h202l728 -1198q-2 40 -4 86q-2 39 -3 88t-1 100v924h162v-1409h-210zM2094 690q0 -188 -88 -289.5t-263 -101.5q-168 0 -256.5 100.5t-88.5 290.5q0 91 21.5 163.5t65 123t109 77t153.5 26.5
q93 0 158.5 -26.5t107.5 -76.5t61.5 -122.5t19.5 -164.5zM1935 690q0 81 -12 134.5t-35.5 85.5t-58 45t-79.5 13q-46 0 -81.5 -13.5t-59.5 -45.5t-36.5 -85.5t-12.5 -133.5q0 -82 13 -136t37 -85.5t57.5 -44.5t74.5 -13q46 0 82 13t61 44.5t37.5 85.5t12.5 136zM1439 0v146
h635v-146h-635z"" />
    <glyph glyph-name=""trademark"" unicode=""&#x2122;"" horiz-adv-x=""2048""
d=""M1691 634v425v194q-5 -11 -9 -22q-4 -9 -6.5 -18t-4.5 -14l-230 -565h-108l-163 413q-2 5 -14 37t-26 70q-17 44 -37 99q-1 -10 -1 -20q-1 -8 -1 -17v-15v-567h-128v775h190l223 -563q2 -4 4.5 -10.5t4.5 -13.5l6 -18q20 51 36 92q7 18 13.5 35t12 31t9 23t3.5 11
l168 413h184v-775h-126zM577 1298v-664h-134v664h-255v111h650v-111h-261z"" />
    <glyph glyph-name=""uni2126"" unicode=""&#x2126;"" horiz-adv-x=""1573""
d=""M786 1430q151 0 271.5 -43t204.5 -124t129 -198t45 -264q0 -106 -29.5 -201.5t-84 -179t-133 -152.5t-177.5 -123q42 2 81 5q33 2 68.5 4t58.5 2h244v-156h-589v224q96 51 165.5 114t114 134.5t65.5 151t21 164.5q0 116 -30.5 206.5t-88.5 152.5t-142.5 94.5t-192.5 32.5
q-109 0 -194 -32.5t-143 -94.5t-88.5 -152.5t-30.5 -206.5q0 -85 21 -164.5t65.5 -151t114 -134.5t165.5 -114v-224h-589v156h244q23 0 58.5 -2t68.5 -4q39 -3 81 -5q-99 54 -177.5 123t-133 152.5t-84 179t-29.5 201.5q0 147 45 264t129 198t204.5 124t271.5 43z"" />
    <glyph glyph-name=""estimated"" unicode=""&#x212e;"" horiz-adv-x=""1229""
d=""M619 -34q-130 0 -229 46.5t-166 125t-101.5 180.5t-34.5 213q0 147 47.5 253.5t123.5 176t170.5 102.5t189.5 33q112 0 209 -39.5t168 -112.5t111.5 -178t40.5 -235h-827v-356q22 -24 54 -46.5t71 -40t83 -27.5t90 -10q75 0 133 15.5t104.5 45.5t84.5 73.5t73 99.5
l72 -42q-36 -57 -78 -107t-96.5 -88t-126 -60t-166.5 -22zM917 616v277q-19 20 -48.5 41t-68 38t-84.5 28t-99 11q-51 0 -94.5 -9.5t-80.5 -25.5t-67 -37t-54 -45v-278h596z"" />
    <glyph glyph-name=""oneeighth"" unicode=""&#x215b;"" horiz-adv-x=""1708""
d=""M80 563v107h211v620l-202 -138v120l210 137h123v-739h215v-107h-557zM493 0h-148l881 1409h145zM1451 631q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32
t17 43.5t3.5 46zM1472 252q0 28 -6.5 54t-24 46t-48 32t-79.5 12q-45 0 -74.5 -12t-47.5 -32.5t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM1614 238q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5
t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62t54 42t62.5 21v3q-36 8 -63.5 26.5t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3
q36 -6 67.5 -21.5t54.5 -41.5t36 -62t13 -82z"" />
    <glyph glyph-name=""threeeighths"" unicode=""&#x215c;"" horiz-adv-x=""1708""
d=""M493 0h-148l881 1409h145zM1451 631q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32t17 43.5t3.5 46zM1472 252q0 28 -6.5 54t-24 46t-48 32t-79.5 12
q-45 0 -74.5 -12t-47.5 -32.5t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM1614 238q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62
t54 42t62.5 21v3q-36 8 -63.5 26.5t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3q36 -6 67.5 -21.5t54.5 -41.5t36 -62t13 -82zM676 795
q0 -116 -77.5 -180t-219.5 -64q-87 0 -145 19.5t-94.5 51.5t-54.5 72.5t-24 83.5l136 13q9 -67 53 -101.5t129 -34.5q77 0 118.5 36t41.5 112q0 45 -18.5 72t-46.5 41.5t-61.5 19t-62.5 4.5h-61v109h57q29 0 59.5 6.5t55.5 22t41 42t16 66.5q0 60 -37 94.5t-108 34.5
q-68 0 -110 -35t-48 -100l-135 12q7 58 32 101t64.5 71.5t90.5 42.5t110 14q69 0 121 -16.5t87 -46t52.5 -69t17.5 -85.5q0 -75 -43 -130t-133 -75v-2q52 -5 89.5 -23.5t61.5 -45.5t35 -61.5t11 -71.5z"" />
    <glyph glyph-name=""fiveeighths"" unicode=""&#x215d;"" horiz-adv-x=""1708""
d=""M493 0h-148l881 1409h145zM1451 631q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32t17 43.5t3.5 46zM1472 252q0 28 -6.5 54t-24 46t-48 32t-79.5 12
q-45 0 -74.5 -12t-47.5 -32.5t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM1614 238q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62
t54 42t62.5 21v3q-36 8 -63.5 26.5t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3q36 -6 67.5 -21.5t54.5 -41.5t36 -62t13 -82zM676 835
q0 -65 -19 -117t-55.5 -89t-90.5 -57t-124 -20q-66 0 -116.5 16.5t-87.5 46t-59 70t-31 88.5l133 15q5 -27 17 -50.5t31.5 -41.5t46.5 -28.5t63 -10.5q71 0 114 42.5t43 135.5q0 81 -40.5 123.5t-115.5 42.5q-51 0 -89.5 -18.5t-61.5 -41.5h-129l33 468h506v-113h-398
l-19 -245q29 26 74.5 42.5t99.5 16.5q67 0 118.5 -19.5t86 -55t52.5 -86.5t18 -114z"" />
    <glyph glyph-name=""seveneighths"" unicode=""&#x215e;"" horiz-adv-x=""1708""
d=""M433 0h-148l881 1409h145zM1451 631q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32t17 43.5t3.5 46zM1472 252q0 28 -6.5 54t-24 46t-48 32t-79.5 12
q-45 0 -74.5 -12t-47.5 -32.5t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM1614 238q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62
t54 42t62.5 21v3q-36 8 -63.5 26.5t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3q36 -6 67.5 -21.5t54.5 -41.5t36 -62t13 -82zM734 1308
q-64 -97 -117 -185t-91.5 -176t-60 -181.5t-21.5 -201.5h-133q0 102 23.5 196t63.5 183.5t93.5 177t113.5 175.5h-460v113h589v-101z"" />
    <glyph glyph-name=""arrowleft"" unicode=""&#x2190;"" horiz-adv-x=""2048""
d=""M641 551q29 -34 58.5 -83t60.5 -114h-72q-58 68 -123 124t-147 98v36q82 42 147 98t123 124h72q-31 -65 -60.5 -114t-58.5 -83h989v-86h-989z"" />
    <glyph glyph-name=""arrowup"" unicode=""&#x2191;"" horiz-adv-x=""1024""
d=""M469 928q-34 -29 -83 -58.5t-114 -60.5v72q68 58 124 123t98 147h36q42 -82 98 -147t124 -123v-72q-65 31 -114 60.5t-83 58.5v-989h-86v989z"" />
    <glyph glyph-name=""arrowright"" unicode=""&#x2192;"" horiz-adv-x=""2048""
d=""M1407 637q-29 34 -58.5 83t-60.5 114h72q58 -68 123 -124t147 -98v-36q-82 -42 -147 -98t-123 -124h-72q31 65 60.5 114t58.5 83h-989v86h989z"" />
    <glyph glyph-name=""arrowdown"" unicode=""&#x2193;"" horiz-adv-x=""1024""
d=""M555 162q34 29 83 58.5t114 60.5v-72q-68 -58 -124 -123t-98 -147h-36q-42 82 -98 147t-124 123v72q65 -31 114 -60.5t83 -58.5v989h86v-989z"" />
    <glyph glyph-name=""arrowboth"" unicode=""&#x2194;"" horiz-adv-x=""2048""
d=""M641 551q29 -34 58.5 -83t60.5 -114h-72q-58 68 -123 124t-147 98v36q82 42 147 98t123 124h72q-31 -65 -60.5 -114t-58.5 -83h766q-29 34 -58.5 83t-60.5 114h72q58 -68 123 -124t147 -98v-36q-82 -42 -147 -98t-123 -124h-72q31 65 60.5 114t58.5 83h-766z"" />
    <glyph glyph-name=""arrowupdn"" unicode=""&#x2195;"" horiz-adv-x=""1024""
d=""M469 928q-34 -29 -83 -58.5t-114 -60.5v72q68 58 124 123t98 147h36q42 -82 98 -147t124 -123v-72q-65 31 -114 60.5t-83 58.5v-766q34 29 83 58.5t114 60.5v-72q-68 -58 -124 -123t-98 -147h-36q-42 82 -98 147t-124 123v72q65 -31 114 -60.5t83 -58.5v766z"" />
    <glyph glyph-name=""arrowupdnbse"" unicode=""&#x21a8;"" horiz-adv-x=""1024""
d=""M272 -104h480v-80h-480v80zM469 928q-34 -29 -83 -58.5t-114 -60.5v72q68 58 124 123t98 147h36q42 -82 98 -147t124 -123v-72q-65 31 -114 60.5t-83 58.5v-766q34 29 83 58.5t114 60.5v-72q-68 -58 -124 -123t-98 -147h-36q-42 82 -98 147t-124 123v72q65 -31 114 -60.5
t83 -58.5v766z"" />
    <glyph glyph-name=""partialdiff"" unicode=""&#x2202;"" horiz-adv-x=""1012""
d=""M954 938q0 -46 -3.5 -98t-10 -105t-15.5 -106t-20 -101q-31 -128 -79 -231t-113 -175t-146 -110.5t-178 -38.5q-93 0 -156.5 31.5t-102.5 85t-56.5 122.5t-17.5 144q0 60 11 131.5t34.5 143.5t60 139t87.5 119t117 83.5t149 31.5q42 0 80.5 -13t70.5 -37t57 -57.5
t41 -75.5h4q1 25 2.5 54t1.5 63q0 196 -65 300.5t-194 104.5q-28 0 -57.5 -5.5t-58.5 -15t-56.5 -23.5t-49.5 -31l36 147q42 23 100 42.5t125 19.5q113 0 190 -44t124 -118.5t67.5 -172t20.5 -204.5zM743 680q-8 42 -26 79t-43.5 64.5t-57.5 43.5t-68 16q-53 0 -96 -25.5
t-76.5 -67.5t-58 -97t-40.5 -113t-23.5 -116t-7.5 -106q0 -53 10.5 -98.5t31.5 -79t53.5 -52.5t76.5 -19q66 0 120 49.5t95.5 130t69.5 183t40 208.5z"" />
    <glyph glyph-name=""uni2206"" unicode=""&#x2206;"" horiz-adv-x=""1253""
d=""M5 141l517 1268h217l510 -1268v-141h-1245zM1049 156l-338 862q-16 40 -30.5 81t-25.5 75.5t-18.5 58.5t-8.5 32q-2 -8 -9 -32.5t-18.5 -59.5t-25.5 -76t-30 -81l-339 -860h843z"" />
    <glyph glyph-name=""product"" unicode=""&#x220f;"" horiz-adv-x=""1686""
d=""M1268 -434v1681h-842v-1681h-191v1843h1217v-1843h-184z"" />
    <glyph glyph-name=""summation"" unicode=""&#x2211;"" horiz-adv-x=""1460""
d=""M154 -434v109l635 816l-619 812v106h1090v-152h-846l584 -764l-600 -775h930v-152h-1174z"" />
    <glyph glyph-name=""minus"" unicode=""&#x2212;"" horiz-adv-x=""1196""
d=""M101 608v146h995v-146h-995z"" />
    <glyph glyph-name=""radical"" unicode=""&#x221a;"" horiz-adv-x=""1124""
d=""M622 -14h-106l-283 792h-182v117h270l242 -690l430 1415h129z"" />
    <glyph glyph-name=""infinity"" unicode=""&#x221e;"" horiz-adv-x=""1460""
d=""M1373 590q0 -78 -22 -148.5t-63 -123.5t-98.5 -84t-127.5 -31q-97 0 -181 66.5t-154 215.5q-32 -63 -69.5 -114t-79.5 -87t-87 -55.5t-91 -19.5q-69 0 -126.5 27.5t-99 77.5t-64.5 121.5t-23 160.5q0 81 22 152t63 123t99 82t129 30q94 0 178 -67.5t151 -215.5
q31 62 68.5 113t79.5 87.5t89 56.5t98 20q69 0 126 -27.5t97.5 -78t63 -122t22.5 -159.5zM1040 846q-70 0 -129.5 -63t-115.5 -193q51 -128 110.5 -192t136.5 -64q43 0 78.5 20t61 55t39 82t13.5 101t-14.5 100t-40 80.5t-61 54t-78.5 19.5zM664 596q-51 128 -110.5 192
t-137.5 64q-43 0 -78 -20t-59.5 -55t-38 -82t-13.5 -101q0 -51 12.5 -97.5t36.5 -81t59.5 -55t82.5 -20.5q70 0 130 63t116 193z"" />
    <glyph glyph-name=""orthogonal"" unicode=""&#x221f;"" horiz-adv-x=""2005""
d=""M408 1223h94v-1129h1130v-94h-1224v1223z"" />
    <glyph glyph-name=""intersection"" unicode=""&#x2229;"" horiz-adv-x=""1472""
d=""M278 -2v512q0 116 34 212t95 165t144.5 107t181.5 38q99 0 183.5 -38t146 -107t96.5 -165t35 -212v-512h-103v514q0 98 -26.5 175.5t-74 131.5t-112.5 82.5t-143 28.5t-143 -28t-112 -82t-73 -132t-26 -178v-512h-103z"" />
    <glyph glyph-name=""integral"" unicode=""&#x222b;"" horiz-adv-x=""561""
d=""M36 -434q-36 0 -73.5 5.5t-60.5 13.5v147q20 -8 51 -16t66 -8q51 0 84 18.5t52.5 50.5t27.5 74t8 90l-2 1212q0 94 25 161t70 110t107.5 63t137.5 20q34 0 71.5 -4.5t59.5 -13.5v-148q-18 10 -48.5 18.5t-66.5 8.5q-51 0 -84 -20t-52.5 -52.5t-27.5 -74.5t-8 -86v-1214
q0 -94 -25 -161t-69.5 -110t-106.5 -63.5t-136 -20.5z"" />
    <glyph glyph-name=""approxequal"" unicode=""&#x2248;"" horiz-adv-x=""1124""
d=""M808 758q-69 0 -141.5 21.5t-145.5 47.5q-65 22 -118.5 33.5t-98.5 11.5q-38 0 -70.5 -6t-62.5 -17t-58 -27.5t-57 -37.5v144q50 37 116 60.5t147 23.5q40 0 80 -6.5t78.5 -17t76 -24t74.5 -26.5q21 -8 46 -15.5t50.5 -14.5t51 -11t48.5 -4q69 0 130.5 25.5t113.5 68.5
v-149q-32 -23 -61.5 -38t-60 -24.5t-64.5 -13.5t-74 -4zM808 336q-69 0 -141.5 22t-145.5 48q-65 23 -118.5 35t-98.5 12q-38 0 -70.5 -6t-62.5 -17.5t-58 -27.5t-57 -37v141q50 38 116 61t147 23q40 0 80 -6.5t78.5 -16.5t76 -23t74.5 -26q21 -8 46 -15.5t50.5 -14.5
t51 -11t48.5 -4q69 0 130.5 25t113.5 67v-147q-32 -23 -61.5 -39t-60 -25.5t-64.5 -13.5t-74 -4z"" />
    <glyph glyph-name=""notequal"" unicode=""&#x2260;"" horiz-adv-x=""1124""
d=""M448 344l-152 -289h-145l151 289h-237v148h311l190 364h-501v148h573l154 292h143l-152 -292h277v-148h-350l-191 -364h541v-148h-612z"" />
    <glyph glyph-name=""equivalence"" unicode=""&#x2261;"" horiz-adv-x=""1195""
d=""M100 956v148h995v-148h-995zM100 244v148h995v-148h-995zM100 600v148h995v-148h-995z"" />
    <glyph glyph-name=""lessequal"" unicode=""&#x2264;"" horiz-adv-x=""1124""
d=""M65 631v205l995 395v-154l-858 -344l858 -344v-153zM63 0v145h995v-145h-995z"" />
    <glyph glyph-name=""greaterequal"" unicode=""&#x2265;"" horiz-adv-x=""1124""
d=""M65 236v153l858 344l-858 344v154l995 -395v-205zM65 0v145h995v-145h-995z"" />
    <glyph glyph-name=""house"" unicode=""&#x2302;"" horiz-adv-x=""1237""
d=""M157 0v635l461 518l461 -518v-635h-922zM237 82h762v518l-381 426l-381 -426v-518z"" />
    <glyph glyph-name=""revlogicalnot"" unicode=""&#x2310;"" horiz-adv-x=""1196""
d=""M100 180v574h995v-146h-850v-428h-145z"" />
    <glyph glyph-name=""integraltp"" unicode=""&#x2320;"" horiz-adv-x=""1237""
d=""M693 -614h-147v1878q0 196 84 319q82 123 210 123q63 0 100.5 -31.5t37.5 -79.5q0 -40 -25.5 -66t-62.5 -26q-30 0 -43 10q-8 4 -21 16t-33 34q-33 39 -49 39q-36 0 -45 -39q-6 -35 -6 -140v-2037z"" />
    <glyph glyph-name=""integralbt"" unicode=""&#x2321;"" horiz-adv-x=""1237""
d=""M546 1706h147v-1880q0 -205 -90 -330q-40 -56 -91.5 -83t-113.5 -27q-30 0 -55 8t-43.5 22.5t-28.5 34t-10 43.5q0 20 7 37t18.5 29t27 19t33.5 7q33 0 59 -16q5 -2 15.5 -13.5t25.5 -31.5q31 -37 47 -37q37 0 45 41q7 31 7 137v2040z"" />
    <glyph glyph-name=""SF100000"" unicode=""&#x2500;"" horiz-adv-x=""1451""
d=""M-10 549v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF110000"" unicode=""&#x2502;"" horiz-adv-x=""1280""
d=""M472 1864h145v-2485h-145v2485z"" />
    <glyph glyph-name=""SF010000"" unicode=""&#x250c;"" horiz-adv-x=""1451""
d=""M653 694h808v-145h-663v-1170h-145v1315z"" />
    <glyph glyph-name=""SF030000"" unicode=""&#x2510;"" horiz-adv-x=""1451""
d=""M-10 549v145h808v-1315h-145v1170h-663z"" />
    <glyph glyph-name=""SF020000"" unicode=""&#x2514;"" horiz-adv-x=""1451""
d=""M653 1864h145v-1170h663v-145h-808v1315z"" />
    <glyph glyph-name=""SF040000"" unicode=""&#x2518;"" horiz-adv-x=""1451""
d=""M-10 549v145h663v1170h145v-1315h-808z"" />
    <glyph glyph-name=""SF080000"" unicode=""&#x251c;"" horiz-adv-x=""1451""
d=""M653 1864h145v-1170h663v-145h-663v-1170h-145v2485z"" />
    <glyph glyph-name=""SF090000"" unicode=""&#x2524;"" horiz-adv-x=""1451""
d=""M-10 549v145h663v1170h145v-2485h-145v1170h-663z"" />
    <glyph glyph-name=""SF060000"" unicode=""&#x252c;"" horiz-adv-x=""1451""
d=""M-10 549v145h1471v-145h-663v-1170h-145v1170h-663z"" />
    <glyph glyph-name=""SF070000"" unicode=""&#x2534;"" horiz-adv-x=""1451""
d=""M-10 549v145h663v1170h145v-1170h663v-145h-1471z"" />
    <glyph glyph-name=""SF050000"" unicode=""&#x253c;"" horiz-adv-x=""1451""
d=""M-10 549v145h663v1170h145v-1170h663v-145h-663v-1170h-145v1170h-663z"" />
    <glyph glyph-name=""SF430000"" unicode=""&#x2550;"" horiz-adv-x=""1451""
d=""M-10 729v145h1471v-145h-1471zM-10 369v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF240000"" unicode=""&#x2551;"" horiz-adv-x=""1451""
d=""M473 1864h145v-2485h-145v2485zM833 1864h145v-2485h-145v2485z"" />
    <glyph glyph-name=""SF510000"" unicode=""&#x2552;"" horiz-adv-x=""1451""
d=""M653 874h808v-145h-663v-215h663v-145h-663v-990h-145v1495z"" />
    <glyph glyph-name=""SF520000"" unicode=""&#x2553;"" horiz-adv-x=""1451""
d=""M1461 694v-145h-483v-1170h-145v1170h-215v-1170h-145v1315h988z"" />
    <glyph glyph-name=""SF390000"" unicode=""&#x2554;"" horiz-adv-x=""1451""
d=""M473 874h988v-145h-843v-1350h-145v1495zM833 514h628v-145h-483v-990h-145v1135z"" />
    <glyph glyph-name=""SF220000"" unicode=""&#x2555;"" horiz-adv-x=""1451""
d=""M-10 369v145h663v215h-663v145h808v-1495h-145v990h-663z"" />
    <glyph glyph-name=""SF210000"" unicode=""&#x2556;"" horiz-adv-x=""1451""
d=""M-10 549v145h988v-1315h-145v1170h-215v-1170h-145v1170h-483z"" />
    <glyph glyph-name=""SF250000"" unicode=""&#x2557;"" horiz-adv-x=""1451""
d=""M978 874v-1495h-145v1350h-843v145h988zM618 -621h-145v990h-483v145h628v-1135z"" />
    <glyph glyph-name=""SF500000"" unicode=""&#x2558;"" horiz-adv-x=""1451""
d=""M653 1864h145v-990h663v-145h-663v-215h663v-145h-808v1495z"" />
    <glyph glyph-name=""SF490000"" unicode=""&#x2559;"" horiz-adv-x=""1451""
d=""M833 1864h145v-1170h483v-145h-988v1315h145v-1170h215v1170z"" />
    <glyph glyph-name=""SF380000"" unicode=""&#x255a;"" horiz-adv-x=""1451""
d=""M473 1864h145v-1350h843v-145h-988v1495zM833 1864h145v-990h483v-145h-628v1135z"" />
    <glyph glyph-name=""SF280000"" unicode=""&#x255b;"" horiz-adv-x=""1451""
d=""M-10 369v145h663v215h-663v145h663v990h145v-1495h-808z"" />
    <glyph glyph-name=""SF270000"" unicode=""&#x255c;"" horiz-adv-x=""1451""
d=""M978 549h-988v145h483v1170h145v-1170h215v1170h145v-1315z"" />
    <glyph glyph-name=""SF260000"" unicode=""&#x255d;"" horiz-adv-x=""1451""
d=""M978 369h-988v145h843v1350h145v-1495zM473 1864h145v-1135h-628v145h483v990z"" />
    <glyph glyph-name=""SF360000"" unicode=""&#x255e;"" horiz-adv-x=""1451""
d=""M653 1864h145v-990h663v-145h-663v-215h663v-145h-663v-990h-145v2485z"" />
    <glyph glyph-name=""SF370000"" unicode=""&#x255f;"" horiz-adv-x=""1451""
d=""M833 1864h145v-1170h483v-145h-483v-1170h-145v2485zM473 1864h145v-2485h-145v2485z"" />
    <glyph glyph-name=""SF420000"" unicode=""&#x2560;"" horiz-adv-x=""1451""
d=""M618 -621h-145v2485h145v-2485zM833 514h628v-145h-483v-990h-145v1135zM833 1864h145v-990h483v-145h-628v1135z"" />
    <glyph glyph-name=""SF190000"" unicode=""&#x2561;"" horiz-adv-x=""1451""
d=""M-10 369v145h663v215h-663v145h663v990h145v-2485h-145v990h-663z"" />
    <glyph glyph-name=""SF200000"" unicode=""&#x2562;"" horiz-adv-x=""1451""
d=""M-10 549v145h483v1170h145v-2485h-145v1170h-483zM833 1864h145v-2485h-145v2485z"" />
    <glyph glyph-name=""SF230000"" unicode=""&#x2563;"" horiz-adv-x=""1451""
d=""M833 1864h145v-2485h-145v2485zM473 1864h145v-1135h-628v145h483v990zM618 -621h-145v990h-483v145h628v-1135z"" />
    <glyph glyph-name=""SF470000"" unicode=""&#x2564;"" horiz-adv-x=""1451""
d=""M-10 369v145h1471v-145h-663v-990h-145v990h-663zM-10 729v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF480000"" unicode=""&#x2565;"" horiz-adv-x=""1451""
d=""M-10 549v145h1471v-145h-483v-1170h-145v1170h-215v-1170h-145v1170h-483z"" />
    <glyph glyph-name=""SF410000"" unicode=""&#x2566;"" horiz-adv-x=""1451""
d=""M618 -621h-145v990h-483v145h628v-1135zM833 514h628v-145h-483v-990h-145v1135zM1461 874v-145h-1471v145h1471z"" />
    <glyph glyph-name=""SF450000"" unicode=""&#x2567;"" horiz-adv-x=""1451""
d=""M-10 729v145h663v990h145v-990h663v-145h-1471zM-10 369v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF460000"" unicode=""&#x2568;"" horiz-adv-x=""1451""
d=""M-10 549v145h483v1170h145v-1170h215v1170h145v-1170h483v-145h-1471z"" />
    <glyph glyph-name=""SF400000"" unicode=""&#x2569;"" horiz-adv-x=""1451""
d=""M833 1864h145v-990h483v-145h-628v1135zM473 1864h145v-1135h-628v145h483v990zM-10 369v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF540000"" unicode=""&#x256a;"" horiz-adv-x=""1451""
d=""M-10 369v145h663v215h-663v145h663v990h145v-990h663v-145h-663v-215h663v-145h-663v-990h-145v990h-663z"" />
    <glyph glyph-name=""SF530000"" unicode=""&#x256b;"" horiz-adv-x=""1451""
d=""M833 1864h145v-1170h483v-145h-483v-1170h-145v1170h-215v-1170h-145v1170h-483v145h483v1170h145v-1170h215v1170z"" />
    <glyph glyph-name=""SF440000"" unicode=""&#x256c;"" horiz-adv-x=""1451""
d=""M833 1864h145v-990h483v-145h-628v1135zM618 -621h-145v990h-483v145h628v-1135zM833 514h628v-145h-483v-990h-145v1135zM473 1864h145v-1135h-628v145h483v990z"" />
    <glyph glyph-name=""upblock"" unicode=""&#x2580;"" horiz-adv-x=""1451""
d=""M1451 621h-1451v1243h1451v-1243z"" />
    <glyph glyph-name=""dnblock"" unicode=""&#x2584;"" horiz-adv-x=""1451""
d=""M1451 -621h-1451v1242h1451v-1242z"" />
    <glyph glyph-name=""block"" unicode=""&#x2588;"" horiz-adv-x=""1451""
d=""M1451 -621h-1451v2485h1451v-2485z"" />
    <glyph glyph-name=""lfblock"" unicode=""&#x258c;"" horiz-adv-x=""1451""
d=""M726 -621h-726v2485h726v-2485z"" />
    <glyph glyph-name=""rtblock"" unicode=""&#x2590;"" horiz-adv-x=""1451""
d=""M1451 -621h-726v2485h726v-2485z"" />
    <glyph glyph-name=""ltshade"" unicode=""&#x2591;"" horiz-adv-x=""1451""
d=""M103 1314h104v-98h-104v98zM517 1314h104v-98h-104v98zM933 1314h103v-98h-103v98zM310 1119h104v-96h-104v96zM725 1119h104v-96h-104v96zM1140 1119h104v-96h-104v96zM933 927h103v-96h-103v96zM517 927h104v-96h-104v96zM103 927h104v-96h-104v96zM1140 732h104v-96
h-104v96zM725 732h104v-96h-104v96zM310 732h104v-96h-104v96zM103 540h104v-96h-104v96zM517 540h104v-96h-104v96zM933 540h103v-96h-103v96zM1140 345h104v-96h-104v96zM725 345h104v-96h-104v96zM310 345h104v-96h-104v96zM103 153h104v-97h-104v97zM517 153h104v-97
h-104v97zM933 153h103v-97h-103v97zM310 -42h104v-94h-104v94zM725 -42h104v-94h-104v94zM1140 -42h104v-94h-104v94zM933 -234h103v-97h-103v97zM517 -234h104v-97h-104v97zM103 -234h104v-97h-104v97zM310 -427h104v-96h-104v96zM725 -427h104v-96h-104v96zM1140 -427h104
v-96h-104v96zM310 1506h104v-98h-104v98zM725 1506h104v-98h-104v98zM1140 1506h104v-98h-104v98zM103 1699h104v-96h-104v96zM517 1699h104v-96h-104v96zM933 1699h103v-96h-103v96zM1347 1314h104v-98h-104v98zM1347 927h104v-96h-104v96zM1347 540h104v-96h-104v96z
M1347 153h104v-97h-104v97zM1347 -234h104v-97h-104v97zM1347 1699h104v-96h-104v96z"" />
    <glyph glyph-name=""shade"" unicode=""&#x2592;"" horiz-adv-x=""1451""
d=""M103 1314h104v-98h-104v98zM310 1314h104v-98h-104v98zM517 1314h104v-98h-104v98zM725 1314h104v-98h-104v98zM933 1314h104v-98h-104v98zM1140 1314h104v-98h-104v98zM0 1119h103v-96h-103v96zM207 1119h103v-96h-103v96zM414 1119h103v-96h-103v96zM621 1119h104v-96
h-104v96zM829 1119h104v-96h-104v96zM1037 1119h103v-96h-103v96zM103 927h104v-96h-104v96zM310 927h104v-96h-104v96zM517 927h104v-96h-104v96zM725 927h104v-96h-104v96zM933 927h104v-96h-104v96zM1140 927h104v-96h-104v96zM0 732h103v-96h-103v96zM207 732h103v-96
h-103v96zM414 732h103v-96h-103v96zM621 732h104v-96h-104v96zM829 732h104v-96h-104v96zM1037 732h103v-96h-103v96zM103 540h104v-96h-104v96zM310 540h104v-96h-104v96zM517 540h104v-96h-104v96zM725 540h104v-96h-104v96zM933 540h104v-96h-104v96zM1140 540h104v-96
h-104v96zM0 345h103v-96h-103v96zM414 345h103v-96h-103v96zM621 345h104v-96h-104v96zM829 345h104v-96h-104v96zM1037 345h103v-96h-103v96zM207 345h103v-96h-103v96zM1140 153h104v-97h-104v97zM933 153h104v-97h-104v97zM725 153h104v-97h-104v97zM517 153h104v-97
h-104v97zM310 153h104v-97h-104v97zM103 153h104v-97h-104v97zM0 -42h103v-94h-103v94zM207 -42h103v-94h-103v94zM414 -42h103v-94h-103v94zM621 -42h104v-94h-104v94zM829 -42h104v-94h-104v94zM1037 -42h103v-94h-103v94zM1140 -234h104v-97h-104v97zM933 -234h104v-97
h-104v97zM725 -234h104v-97h-104v97zM517 -234h104v-97h-104v97zM310 -234h104v-97h-104v97zM103 -234h104v-97h-104v97zM0 -427h103v-96h-103v96zM207 -427h103v-96h-103v96zM414 -427h103v-96h-103v96zM621 -427h104v-96h-104v96zM829 -427h104v-96h-104v96zM1037 -427
h103v-96h-103v96zM0 1506h103v-98h-103v98zM207 1506h103v-98h-103v98zM414 1506h103v-98h-103v98zM621 1506h104v-98h-104v98zM829 1506h104v-98h-104v98zM1037 1506h103v-98h-103v98zM103 1699h104v-96h-104v96zM310 1699h104v-96h-104v96zM517 1699h104v-96h-104v96z
M725 1699h104v-96h-104v96zM933 1699h104v-96h-104v96zM1140 1699h104v-96h-104v96zM1347 1314h104v-98h-104v98zM1244 1119h103v-96h-103v96zM1347 927h104v-96h-104v96zM1244 732h103v-96h-103v96zM1347 540h104v-96h-104v96zM1244 345h103v-96h-103v96zM1347 153h104v-97
h-104v97zM1244 -42h103v-94h-103v94zM1347 -234h104v-97h-104v97zM1244 -427h103v-96h-103v96zM1244 1506h103v-98h-103v98zM1347 1699h104v-96h-104v96z"" />
    <glyph glyph-name=""dkshade"" unicode=""&#x2593;"" horiz-adv-x=""1493""
d=""M1493 -621h-1493v290h106v97h-106v290h106v97h-106v291h106v96h-106v289h106v98h-106v289h106v98h-106v289h106v96h107v-96h106v96h107v-96h106v96h107v-96h107v96h107v-96h107v96h107v-96h106v96h107v-96h106v96h107v-193h-107v-98h107v-289h-107v-96h107v-291h-107v-96
h107v-291h-107v-96h107v-291h-107v-94h107v-291h-107v-96h107v-98zM106 1119v-96h107v96h-107zM319 1119v-96h107v96h-107zM532 1119v-96h107v96h-107zM746 1119v-96h107v96h-107zM960 927h-107v-98h107v98zM746 927h-107v-98h107v98zM532 927h-106v-98h106v98zM319 927
h-106v-98h106v98zM106 732v-96h107v96h-107zM319 732v-96h107v96h-107zM532 732v-96h107v96h-107zM746 732v-96h107v96h-107zM319 540h-106v-96h106v96zM426 540v-96h106v96h-106zM639 540v-96h107v96h-107zM853 540v-96h107v96h-107zM106 345v-96h107v96h-107zM532 345v-96
h107v96h-107zM426 249v96h-107v-96h107zM746 345v-96h107v96h-107zM960 56v97h-107v-97h107zM746 56v97h-107v-97h107zM532 56v97h-106v-97h106zM319 56v97h-106v-97h106zM106 -42v-94h107v94h-107zM319 -42v-94h107v94h-107zM532 -42v-94h107v94h-107zM746 -42v-94h107v94
h-107zM960 -331v97h-107v-97h107zM746 -331v97h-107v-97h107zM532 -331v97h-106v-97h106zM319 -331v97h-106v-97h106zM106 -427v-96h107v96h-107zM319 -427v-96h107v96h-107zM532 -427v-96h107v96h-107zM746 -427v-96h107v96h-107zM960 1314h-107v-98h107v98zM746 1314h-107
v-98h107v98zM532 1314h-106v-98h106v98zM319 1314h-106v-98h106v98zM853 1506h-107v-98h107v98zM639 1506h-107v-98h107v98zM426 1506h-107v-98h107v98zM213 1506h-107v-98h107v98zM960 1119v-96h107v96h-107zM1173 1119v-96h107v96h-107zM1386 927h-106v-98h106v98z
M1173 927h-106v-98h106v98zM960 732v-96h107v96h-107zM1173 732v-96h107v96h-107zM1173 540h-106v-96h106v96zM1280 540v-96h106v96h-106zM960 345v-96h107v96h-107zM1280 249v96h-107v-96h107zM1386 56v97h-106v-97h106zM1173 56v97h-106v-97h106zM960 -42v-94h107v94h-107
zM1173 -42v-94h107v94h-107zM1386 -331v97h-106v-97h106zM1173 -331v97h-106v-97h106zM960 -427v-96h107v96h-107zM1173 -427v-96h107v96h-107zM1386 1314h-106v-98h106v98zM1173 1314h-106v-98h106v98zM1280 1506h-107v-98h107v98zM1067 1506h-107v-98h107v98z"" />
    <glyph glyph-name=""filledbox"" unicode=""&#x25a0;"" horiz-adv-x=""1237""
d=""M123 1108h991v-991h-991v991z"" />
    <glyph glyph-name=""H22073"" unicode=""&#x25a1;"" horiz-adv-x=""1237""
d=""M6 1225h1225v-1225h-1225v1225zM82 1149v-1073h1073v1073h-1073z"" />
    <glyph glyph-name=""H18543"" unicode=""&#x25aa;"" horiz-adv-x=""726""
d=""M617 383h-508v508h508v-508z"" />
    <glyph glyph-name=""H18551"" unicode=""&#x25ab;"" horiz-adv-x=""726""
d=""M617 383h-508v508h508v-508zM541 459v354h-356v-354h356z"" />
    <glyph glyph-name=""filledrect"" unicode=""&#x25ac;"" horiz-adv-x=""2048""
d=""M0 616h2048v-616h-2048v616z"" />
    <glyph glyph-name=""triagup"" unicode=""&#x25b2;"" horiz-adv-x=""2027""
d=""M414 0l600 1198l598 -1198h-1198z"" />
    <glyph glyph-name=""triagrt"" unicode=""&#x25ba;"" horiz-adv-x=""2027""
d=""M401 1196l1225 -610l-1225 -613v1223z"" />
    <glyph glyph-name=""triagdn"" unicode=""&#x25bc;"" horiz-adv-x=""2027""
d=""M1612 1171l-598 -1198l-600 1198h1198z"" />
    <glyph glyph-name=""triaglf"" unicode=""&#x25c4;"" horiz-adv-x=""2027""
d=""M1626 1196v-1223l-1225 613z"" />
    <glyph glyph-name=""lozenge"" unicode=""&#x25ca;"" horiz-adv-x=""1012""
d=""M547 0h-82l-457 719l457 721h82l459 -719zM508 1286l-354 -565l354 -574l352 574z"" />
    <glyph glyph-name=""circle"" unicode=""&#x25cb;"" horiz-adv-x=""1237""
d=""M167 612q0 94 35 176.5t96 144t143 97t176 35.5t176.5 -35.5t144 -97t97 -144t35.5 -176.5t-35.5 -176t-97 -143t-144 -96t-176.5 -35t-176 35t-143 96t-96 143t-35 176zM253 612q0 -76 28.5 -142t77.5 -115.5t115.5 -78t142.5 -28.5t143 28.5t116.5 78t78.5 115.5
t29 142t-29 143t-78.5 116.5t-116.5 78.5t-143 29t-142.5 -29t-115.5 -78.5t-77.5 -116.5t-28.5 -143z"" />
    <glyph glyph-name=""H18533"" unicode=""&#x25cf;"" horiz-adv-x=""1237""
d=""M618 1018q110 0 217 -57q53 -28 94 -69t70 -93q29 -54 44.5 -109t15.5 -112q0 -183 -129 -312t-312 -129q-182 0 -311 129t-129 312q0 58 15 112.5t44 108.5q29 52 70.5 93t93.5 69q108 57 217 57z"" />
    <glyph glyph-name=""invbullet"" unicode=""&#x25d8;"" horiz-adv-x=""1237""
d=""M41 0v1155h1155v-1155h-1155zM176 577q0 -91 34.5 -171t94.5 -140t140 -94.5t171 -34.5t171.5 34.5t140.5 94.5t94.5 140t34.5 171t-34.5 171.5t-94.5 140.5t-140.5 94.5t-171.5 34.5t-171 -34.5t-140 -94.5t-94.5 -140.5t-34.5 -171.5z"" />
    <glyph glyph-name=""invcircle"" unicode=""&#x25d9;"" horiz-adv-x=""1237""
d=""M41 0v1155h1155v-1155h-1155zM253 577q0 75 29 141.5t78.5 116t116 78.5t141.5 29t141.5 -29t116 -78.5t78.5 -116t29 -141.5t-29 -141.5t-78.5 -116t-116 -78.5t-141.5 -29t-141.5 29t-116 78.5t-78.5 116t-29 141.5zM176 577q0 -91 34.5 -171t94.5 -140t140 -94.5
t171 -34.5t171.5 34.5t140.5 94.5t94.5 140t34.5 171t-34.5 171.5t-94.5 140.5t-140.5 94.5t-171.5 34.5t-171 -34.5t-140 -94.5t-94.5 -140.5t-34.5 -171.5z"" />
    <glyph glyph-name=""openbullet"" unicode=""&#x25e6;"" horiz-adv-x=""726""
d=""M611 637q0 -53 -18.5 -96t-55.5 -80q-37 -35 -80 -53.5t-94 -18.5q-101 0 -176 72q-35 37 -53.5 80t-18.5 96q0 102 72 174q74 74 176 74q103 0 174 -74q74 -71 74 -174zM535 637q0 70 -51 121t-121 51t-121 -51t-51 -121q0 -69 51 -123q49 -49 121 -49t121 49
q51 54 51 123z"" />
    <glyph glyph-name=""smileface"" unicode=""&#x263a;"" horiz-adv-x=""2091""
d=""M1657 584q0 -254 -180 -432q-179 -179 -432 -179t-432 179q-180 178 -180 432q0 128 45 235.5t135 198.5q178 178 432 178t432 -178q90 -91 135 -198.5t45 -235.5zM1567 584q0 217 -153 370q-151 154 -369 154t-369 -154q-153 -153 -153 -370q0 -216 153 -369
q152 -154 369 -154t369 154q153 153 153 369zM889 711q0 -32 -23 -55t-55 -23t-54.5 23t-22.5 55t22.5 54.5t54.5 22.5t55 -22.5t23 -54.5zM1356 711q0 -32 -22 -55t-54 -23t-55.5 23t-23.5 55t23.5 54.5t55.5 22.5t54 -22.5t22 -54.5zM822 422q76 -137 223 -137
q145 0 221 137l62 -35q-98 -186 -283 -186q-94 0 -164.5 47.5t-118.5 138.5z"" />
    <glyph glyph-name=""invsmileface"" unicode=""&#x263b;"" horiz-adv-x=""2155""
d=""M1689 584q0 -254 -180 -432q-179 -179 -432 -179t-432 179q-180 178 -180 432q0 128 45 235.5t135 198.5q178 178 432 178t432 -178q90 -91 135 -198.5t45 -235.5zM921 711q0 32 -23 54.5t-55 22.5t-54.5 -22.5t-22.5 -54.5t22.5 -55t54.5 -23t55 23t23 55zM1388 711
q0 32 -22 54.5t-54 22.5t-55.5 -22.5t-23.5 -54.5t23.5 -55t55.5 -23t54 23t22 55zM794 387q48 -91 118.5 -138.5t164.5 -47.5q185 0 283 186l-62 35q-76 -137 -221 -137q-147 0 -223 137z"" />
    <glyph glyph-name=""sun"" unicode=""&#x263c;"" horiz-adv-x=""1877""
d=""M905 1083h66v-217q32 -3 60.5 -9t55.5 -16.5t53.5 -26.5t55.5 -38l186 182l45 -45l-184 -184q45 -59 67 -115.5t25 -113.5h215v-62h-215q-8 -60 -30 -115t-62 -106l184 -188l-49 -43l-182 182q-31 -23 -58.5 -39t-50.5 -27q-24 -9 -53 -15t-63 -11v-217h-66v217
q-63 9 -118 32t-103 58l-188 -180l-43 45l182 184q-40 51 -63 106.5t-31 118.5h-215v62h215q12 128 92 223l-180 184l40 49l189 -182q57 40 113 62t110 28v217zM936 805q-69 0 -127.5 -25t-106.5 -73q-98 -100 -98 -236q0 -137 98 -235q48 -50 106.5 -73.5t127.5 -23.5
q139 0 235 97q99 97 99 235q0 137 -99 236q-49 48 -107.5 73t-127.5 25z"" />
    <glyph glyph-name=""female"" unicode=""&#x2640;"" horiz-adv-x=""1536""
d=""M732 578q-55 8 -100 31t-80 65q-71 80 -71 188q0 122 83 205q44 43 94.5 64.5t110.5 21.5q118 0 201 -86q86 -83 86 -205q0 -109 -72 -190q-72 -82 -178 -94v-166h256v-70h-256v-262h-74v262h-258v70h258v166zM767 1069q-83 0 -145 -59q-29 -31 -44.5 -66.5t-15.5 -79.5
q0 -43 15.5 -78.5t44.5 -66.5q62 -62 145 -62q87 0 146 62q61 61 61 145q0 44 -15 79.5t-44 66.5q-62 59 -148 59z"" />
    <glyph glyph-name=""male"" unicode=""&#x2642;"" horiz-adv-x=""1536""
d=""M1023 1024q-17 5 -44 14t-64 23q-28 11 -48 23t-34 26q-5 3 -6.5 8t-1.5 10q0 8 6 17q3 2 6 3t8 1t12.5 -1t20.5 -3q32 -8 63.5 -12.5t63.5 -4.5q46 0 78 3.5t51 9.5q36 12 49 12q16 0 16 -14q0 -9 -6 -27q-9 -34 -12.5 -73.5t-3.5 -84.5q0 -31 2 -63t10 -66q2 -11 3 -19
t1 -13t-1 -8.5t-3 -6.5q-9 -6 -14 -6q-21 0 -41 39q-22 42 -37.5 83t-26.5 83l-237 -238q84 -81 84 -190q0 -125 -86 -211q-87 -88 -205 -88t-205 84q-84 84 -84 201t84 204q85 86 207 86q71 0 154 -43zM628 750q-90 0 -152 -62q-61 -61 -61 -149q0 -91 61 -152
q64 -61 152 -61q89 0 149 61q62 62 62 152q0 87 -62 149q-60 62 -149 62z"" />
    <glyph glyph-name=""spade"" unicode=""&#x2660;"" horiz-adv-x=""1088""
d=""M544 1231q14 -54 34 -101.5t46 -91.5q28 -43 75.5 -95.5t116.5 -115.5q141 -126 176 -192q37 -67 37 -137q0 -95 -63 -158q-66 -66 -154 -66q-157 0 -256 191q3 -147 39 -234q38 -86 119.5 -135.5t218.5 -58.5l8 -37h-792l6 37q125 0 211 49q43 25 76 59.5t55 80t32 105
t9 134.5q-45 -96 -111 -143.5t-149 -47.5q-90 0 -156 66q-63 63 -63 154q0 74 30 133q23 42 62 84.5t96 89.5q69 59 124 115.5t93 113.5q56 83 80 201z"" />
    <glyph glyph-name=""club"" unicode=""&#x2663;"" horiz-adv-x=""1344""
d=""M1094 0h-842l8 35q84 17 138 33.5t81 33.5q41 25 73 62.5t58 87.5q52 100 52 209q0 8 -1 19t-1 28q-58 -121 -148 -180q-43 -28 -87 -43t-89 -15q-59 0 -107.5 21t-89.5 59q-79 83 -79 199q0 115 73 194q73 80 166 80q31 0 71 -12.5t91 -38.5q-20 34 -33.5 60t-21.5 45
q-5 17 -8 36t-3 39q0 115 78 193q40 38 88.5 58t108.5 20q116 0 196 -80q80 -78 80 -187q0 -86 -69 -184q84 40 100 43q14 5 29 6.5t32 1.5q51 0 94 -18.5t79 -59.5q73 -76 73 -192q0 -118 -80 -201q-80 -80 -192 -80q-62 0 -128 30t-116 81q-17 19 -38.5 49.5t-47.5 75.5
q3 -81 14.5 -143.5t34.5 -108.5q22 -45 55.5 -83t79.5 -69q61 -39 220 -69z"" />
    <glyph glyph-name=""heart"" unicode=""&#x2665;"" horiz-adv-x=""1216""
d=""M610 -23q-14 56 -35 106.5t-47 98.5q-28 50 -79.5 123.5t-127.5 175.5q-56 76 -90.5 122.5t-48.5 68.5q-43 65 -61.5 118t-18.5 109q0 103 68 174q70 70 172 70q98 0 176 -72q28 -28 51.5 -68t40.5 -94q34 119 105 177.5t159 58.5q50 0 92.5 -18t77.5 -52q70 -70 70 -164
q0 -86 -41 -174q-20 -45 -59 -104.5t-99 -134.5q-75 -96 -129 -172t-86 -131q-31 -54 -53 -109t-37 -109z"" />
    <glyph glyph-name=""diamond"" unicode=""&#x2666;"" horiz-adv-x=""1045""
d=""M519 1223q45 -78 101.5 -160.5t125.5 -175.5t127 -163.5t105 -123.5q-39 -40 -99 -115t-143 -186q-69 -93 -122 -172.5t-93 -151.5q-13 25 -30.5 54t-39.5 61q-38 57 -87 124.5t-109 147.5q-14 20 -61 79.5t-128 158.5q50 59 114 139t144 187q59 77 107 151t88 146z"" />
    <glyph glyph-name=""musicalnote"" unicode=""&#x266a;"" horiz-adv-x=""1024""
d=""M489 1153h76v-100l153 -193q51 -69 80 -150.5t29 -166.5q0 -78 -24 -145t-70 -126h-47q29 65 43 127t14 121q0 60 -14 109.5t-43 89.5q-57 81 -121 90v-506q0 -63 -18.5 -112t-55.5 -87q-72 -75 -180 -75q-57 0 -86 27t-29 73q0 73 60 133q63 60 143 60q44 0 90 -19v850z
"" />
    <glyph glyph-name=""musicalnotedbl"" unicode=""&#x266b;"" horiz-adv-x=""1536""
d=""M1263 324q0 -63 -18 -113.5t-56 -85.5q-37 -37 -81 -56.5t-95 -19.5q-57 0 -85.5 27t-28.5 74q0 76 57 133q62 59 143 59q48 0 90 -18v448l-550 -149v-394q0 -62 -18.5 -111t-53.5 -87q-74 -74 -180 -74q-57 0 -86 26.5t-29 71.5q0 76 59 133q60 60 144 60q45 0 90 -19
v752l698 178v-835zM639 750l550 149v117l-550 -152v-114z"" />
    <glyph glyph-name=""uniFB01"" unicode=""&#xf001;"" horiz-adv-x=""1024""
d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211zM706 1312v172h180v-172h-180zM706 0v1082h180v-1082h-180z
"" />
    <glyph glyph-name=""uniFB01"" unicode=""&#xfb01;"" horiz-adv-x=""1024""
d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211zM706 1312v172h180v-172h-180zM706 0v1082h180v-1082h-180z
"" />
    <glyph glyph-name=""uniFB02"" unicode=""&#xf002;"" horiz-adv-x=""1024""
d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211zM707 0v1484h180v-1484h-180z"" />
    <glyph glyph-name=""uniFB02"" unicode=""&#xfb02;"" horiz-adv-x=""1024""
d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211zM707 0v1484h180v-1484h-180z"" />
    <glyph glyph-name=""uniF005"" unicode=""&#xf005;"" horiz-adv-x=""682""
d=""M483 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l31 96h62q52 0 94 -9t72 -29.5t46 -52t16 -76.5z"" />
    <glyph glyph-name=""middot"" horiz-adv-x=""682""
d=""M243 446v220h195v-220h-195z"" />
    <glyph glyph-name=""uniF004"" horiz-adv-x=""682""
d=""M328 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""uni2074"" horiz-adv-x=""682""
d=""M551 741v-178h-131v178h-406v111l386 557h151v-555h111v-113h-111zM422 1276q-7 -13 -18 -31.5t-23 -38t-23 -37t-18 -28.5l-199 -287h279v289v33v38t0.5 36t1.5 26z"" />
    <glyph glyph-name=""uni2075"" horiz-adv-x=""682""
d=""M636 835q0 -65 -19 -117t-55.5 -89t-90.5 -57t-124 -20q-66 0 -116.5 16.5t-87.5 46t-59 70t-31 88.5l133 15q5 -27 17 -50.5t31.5 -41.5t46.5 -28.5t63 -10.5q71 0 114 42.5t43 135.5q0 81 -40.5 123.5t-115.5 42.5q-51 0 -89.5 -18.5t-61.5 -41.5h-129l33 468h506v-113
h-398l-19 -245q29 26 74.5 42.5t99.5 16.5q67 0 118.5 -19.5t86 -55t52.5 -86.5t18 -114z"" />
    <glyph glyph-name=""uni2077"" horiz-adv-x=""682""
d=""M632 1308q-64 -97 -117 -185t-91.5 -176t-60 -181.5t-21.5 -201.5h-133q0 102 23.5 196t63.5 183.5t93.5 177t113.5 175.5h-460v113h589v-101z"" />
    <glyph glyph-name=""uni2078"" horiz-adv-x=""682""
d=""M479 1193q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32t17 43.5t3.5 46zM500 814q0 28 -6.5 54t-24 46t-48 32t-79.5 12q-45 0 -74.5 -12t-47.5 -32.5
t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM642 800q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62t54 42t62.5 21v3q-36 8 -63.5 26.5
t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3q36 -6 67.5 -21.5t54.5 -41.5t36 -62t13 -82z"" />
    <glyph glyph-name=""glyph571"" horiz-adv-x=""682""
d=""M340 1200q-111 0 -181.5 28.5t-111 74t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164q-2 -57 -18 -114.5t-56.5 -103t-111 -74t-181.5 -28.5z"" />
    <glyph glyph-name=""glyph572"" horiz-adv-x=""455""
d=""M325 1303q0 -87 -22 -145.5t-62 -105.5h-117q45 48 69.5 96t24.5 94h-88v167h195v-106z"" />
    <glyph glyph-name=""glyph573"" horiz-adv-x=""455""
d=""M130 1317q0 87 22 145.5t62 105.5h117q-45 -48 -69.5 -96t-24.5 -94h88v-167h-195v106z"" />
    <glyph glyph-name=""glyph574"" horiz-adv-x=""602""
d=""M416 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""glyph575"" horiz-adv-x=""602""
d=""M72 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""glyph576"" horiz-adv-x=""664""
d=""M662 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""glyph577"" horiz-adv-x=""664""
d=""M438 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""glyph578"" horiz-adv-x=""647""
d=""M439 1530v184h163v-184h-163zM45 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""glyph579"" horiz-adv-x=""672""
d=""M492 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""glyph580"" horiz-adv-x=""815""
d=""M32 1530v20l197 227h207v-29l-310 -218h-94zM379 1530v20l197 227h207v-29l-310 -218h-94z"" />
    <glyph glyph-name=""glyph581"" horiz-adv-x=""584""
d=""M308 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" />
    <hkern u1=""&#x20;"" u2=""&#x3ab;"" k=""37"" />
    <hkern u1=""&#x20;"" u2=""&#x3a5;"" k=""37"" />
    <hkern u1=""&#x20;"" u2=""&#x3a4;"" k=""37"" />
    <hkern u1=""&#x20;"" u2=""&#x39b;"" k=""113"" />
    <hkern u1=""&#x20;"" u2=""&#x394;"" k=""113"" />
    <hkern u1=""&#x20;"" u2=""&#x391;"" k=""113"" />
    <hkern u1=""&#x20;"" u2=""&#x386;"" k=""113"" />
    <hkern u1=""&#x20;"" u2=""Y"" k=""37"" />
    <hkern u1=""&#x20;"" u2=""T"" k=""37"" />
    <hkern u1=""&#x20;"" u2=""A"" k=""113"" />
    <hkern u1=""&#x31;"" u2=""&#x31;"" k=""152"" />
    <hkern u1=""A"" u2=""&#x2019;"" k=""152"" />
    <hkern u1=""A"" u2=""y"" k=""37"" />
    <hkern u1=""A"" u2=""w"" k=""37"" />
    <hkern u1=""A"" u2=""v"" k=""37"" />
    <hkern u1=""A"" u2=""Y"" k=""152"" />
    <hkern u1=""A"" u2=""W"" k=""76"" />
    <hkern u1=""A"" u2=""V"" k=""152"" />
    <hkern u1=""A"" u2=""T"" k=""152"" />
    <hkern u1=""A"" u2=""&#x20;"" k=""113"" />
    <hkern u1=""F"" u2=""A"" k=""113"" />
    <hkern u1=""F"" u2=""&#x2e;"" k=""227"" />
    <hkern u1=""F"" u2=""&#x2c;"" k=""227"" />
    <hkern u1=""L"" u2=""&#x2019;"" k=""113"" />
    <hkern u1=""L"" u2=""y"" k=""76"" />
    <hkern u1=""L"" u2=""Y"" k=""152"" />
    <hkern u1=""L"" u2=""W"" k=""152"" />
    <hkern u1=""L"" u2=""V"" k=""152"" />
    <hkern u1=""L"" u2=""T"" k=""152"" />
    <hkern u1=""L"" u2=""&#x20;"" k=""76"" />
    <hkern u1=""P"" u2=""A"" k=""152"" />
    <hkern u1=""P"" u2=""&#x2e;"" k=""264"" />
    <hkern u1=""P"" u2=""&#x2c;"" k=""264"" />
    <hkern u1=""P"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""R"" u2=""Y"" k=""37"" />
    <hkern u1=""R"" u2=""W"" k=""37"" />
    <hkern u1=""R"" u2=""V"" k=""37"" />
    <hkern u1=""R"" u2=""T"" k=""37"" />
    <hkern u1=""T"" u2=""y"" k=""113"" />
    <hkern u1=""T"" u2=""w"" k=""113"" />
    <hkern u1=""T"" u2=""u"" k=""76"" />
    <hkern u1=""T"" u2=""s"" k=""227"" />
    <hkern u1=""T"" u2=""r"" k=""76"" />
    <hkern u1=""T"" u2=""o"" k=""227"" />
    <hkern u1=""T"" u2=""i"" k=""76"" />
    <hkern u1=""T"" u2=""e"" k=""227"" />
    <hkern u1=""T"" u2=""c"" k=""227"" />
    <hkern u1=""T"" u2=""a"" k=""227"" />
    <hkern u1=""T"" u2=""O"" k=""37"" />
    <hkern u1=""T"" u2=""A"" k=""152"" />
    <hkern u1=""T"" u2=""&#x3b;"" k=""227"" />
    <hkern u1=""T"" u2=""&#x3a;"" k=""227"" />
    <hkern u1=""T"" u2=""&#x2e;"" k=""227"" />
    <hkern u1=""T"" u2=""&#x2d;"" k=""113"" />
    <hkern u1=""T"" u2=""&#x2c;"" k=""227"" />
    <hkern u1=""T"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""V"" u2=""y"" k=""76"" />
    <hkern u1=""V"" u2=""u"" k=""76"" />
    <hkern u1=""V"" u2=""r"" k=""76"" />
    <hkern u1=""V"" u2=""o"" k=""113"" />
    <hkern u1=""V"" u2=""i"" k=""37"" />
    <hkern u1=""V"" u2=""e"" k=""113"" />
    <hkern u1=""V"" u2=""a"" k=""152"" />
    <hkern u1=""V"" u2=""A"" k=""152"" />
    <hkern u1=""V"" u2=""&#x3b;"" k=""76"" />
    <hkern u1=""V"" u2=""&#x3a;"" k=""76"" />
    <hkern u1=""V"" u2=""&#x2e;"" k=""188"" />
    <hkern u1=""V"" u2=""&#x2d;"" k=""113"" />
    <hkern u1=""V"" u2=""&#x2c;"" k=""188"" />
    <hkern u1=""W"" u2=""y"" k=""18"" />
    <hkern u1=""W"" u2=""u"" k=""37"" />
    <hkern u1=""W"" u2=""r"" k=""37"" />
    <hkern u1=""W"" u2=""o"" k=""37"" />
    <hkern u1=""W"" u2=""e"" k=""37"" />
    <hkern u1=""W"" u2=""a"" k=""76"" />
    <hkern u1=""W"" u2=""A"" k=""76"" />
    <hkern u1=""W"" u2=""&#x3b;"" k=""37"" />
    <hkern u1=""W"" u2=""&#x3a;"" k=""37"" />
    <hkern u1=""W"" u2=""&#x2e;"" k=""113"" />
    <hkern u1=""W"" u2=""&#x2d;"" k=""37"" />
    <hkern u1=""W"" u2=""&#x2c;"" k=""113"" />
    <hkern u1=""Y"" u2=""v"" k=""113"" />
    <hkern u1=""Y"" u2=""u"" k=""113"" />
    <hkern u1=""Y"" u2=""q"" k=""188"" />
    <hkern u1=""Y"" u2=""p"" k=""152"" />
    <hkern u1=""Y"" u2=""o"" k=""188"" />
    <hkern u1=""Y"" u2=""i"" k=""76"" />
    <hkern u1=""Y"" u2=""e"" k=""188"" />
    <hkern u1=""Y"" u2=""a"" k=""152"" />
    <hkern u1=""Y"" u2=""A"" k=""152"" />
    <hkern u1=""Y"" u2=""&#x3b;"" k=""133"" />
    <hkern u1=""Y"" u2=""&#x3a;"" k=""113"" />
    <hkern u1=""Y"" u2=""&#x2e;"" k=""264"" />
    <hkern u1=""Y"" u2=""&#x2d;"" k=""188"" />
    <hkern u1=""Y"" u2=""&#x2c;"" k=""264"" />
    <hkern u1=""Y"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""f"" u2=""&#x2019;"" k=""-37"" />
    <hkern u1=""f"" u2=""f"" k=""37"" />
    <hkern u1=""r"" u2=""&#x2019;"" k=""-76"" />
    <hkern u1=""r"" u2=""&#x2e;"" k=""113"" />
    <hkern u1=""r"" u2=""&#x2c;"" k=""113"" />
    <hkern u1=""v"" u2=""&#x2e;"" k=""152"" />
    <hkern u1=""v"" u2=""&#x2c;"" k=""152"" />
    <hkern u1=""w"" u2=""&#x2e;"" k=""113"" />
    <hkern u1=""w"" u2=""&#x2c;"" k=""113"" />
    <hkern u1=""y"" u2=""&#x2e;"" k=""152"" />
    <hkern u1=""y"" u2=""&#x2c;"" k=""152"" />
    <hkern u1=""&#x386;"" u2=""&#x3c7;"" k=""37"" />
    <hkern u1=""&#x386;"" u2=""&#x3bd;"" k=""37"" />
    <hkern u1=""&#x386;"" u2=""&#x3b3;"" k=""37"" />
    <hkern u1=""&#x386;"" u2=""&#x3ab;"" k=""152"" />
    <hkern u1=""&#x386;"" u2=""&#x3a6;"" k=""59"" />
    <hkern u1=""&#x386;"" u2=""&#x3a5;"" k=""152"" />
    <hkern u1=""&#x386;"" u2=""&#x3a4;"" k=""152"" />
    <hkern u1=""&#x386;"" u2=""&#x39f;"" k=""43"" />
    <hkern u1=""&#x386;"" u2=""&#x398;"" k=""43"" />
    <hkern u1=""&#x38c;"" u2=""&#x3a5;"" k=""66"" />
    <hkern u1=""&#x38e;"" u2=""&#x3cc;"" k=""186"" />
    <hkern u1=""&#x38e;"" u2=""&#x3ca;"" k=""-98"" />
    <hkern u1=""&#x38e;"" u2=""&#x3c6;"" k=""186"" />
    <hkern u1=""&#x38e;"" u2=""&#x3c3;"" k=""186"" />
    <hkern u1=""&#x38e;"" u2=""&#x3bf;"" k=""186"" />
    <hkern u1=""&#x38e;"" u2=""&#x3bc;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x3ba;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x3b9;"" k=""76"" />
    <hkern u1=""&#x38e;"" u2=""&#x3b7;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x3b1;"" k=""186"" />
    <hkern u1=""&#x38e;"" u2=""&#x3af;"" k=""76"" />
    <hkern u1=""&#x38e;"" u2=""&#x3ae;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x3a9;"" k=""98"" />
    <hkern u1=""&#x38e;"" u2=""&#x3a6;"" k=""115"" />
    <hkern u1=""&#x38e;"" u2=""&#x39f;"" k=""115"" />
    <hkern u1=""&#x38e;"" u2=""&#x39b;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x398;"" k=""115"" />
    <hkern u1=""&#x38e;"" u2=""&#x394;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x391;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x390;"" k=""-170"" />
    <hkern u1=""&#x38f;"" u2=""&#x3ab;"" k=""47"" />
    <hkern u1=""&#x38f;"" u2=""&#x3a5;"" k=""47"" />
    <hkern u1=""&#x391;"" u2=""&#x2019;"" k=""152"" />
    <hkern u1=""&#x391;"" u2=""&#x3c7;"" k=""37"" />
    <hkern u1=""&#x391;"" u2=""&#x3bd;"" k=""37"" />
    <hkern u1=""&#x391;"" u2=""&#x3b3;"" k=""37"" />
    <hkern u1=""&#x391;"" u2=""&#x3ab;"" k=""152"" />
    <hkern u1=""&#x391;"" u2=""&#x3a6;"" k=""59"" />
    <hkern u1=""&#x391;"" u2=""&#x3a5;"" k=""152"" />
    <hkern u1=""&#x391;"" u2=""&#x3a4;"" k=""152"" />
    <hkern u1=""&#x391;"" u2=""&#x39f;"" k=""43"" />
    <hkern u1=""&#x391;"" u2=""&#x398;"" k=""43"" />
    <hkern u1=""&#x391;"" u2=""&#x20;"" k=""113"" />
    <hkern u1=""&#x393;"" u2=""&#x3ca;"" k=""-88"" />
    <hkern u1=""&#x393;"" u2=""&#x3b9;"" k=""88"" />
    <hkern u1=""&#x393;"" u2=""&#x39b;"" k=""188"" />
    <hkern u1=""&#x393;"" u2=""&#x394;"" k=""188"" />
    <hkern u1=""&#x393;"" u2=""&#x391;"" k=""188"" />
    <hkern u1=""&#x393;"" u2=""&#x390;"" k=""-164"" />
    <hkern u1=""&#x393;"" u2=""&#x2e;"" k=""225"" />
    <hkern u1=""&#x393;"" u2=""&#x2c;"" k=""225"" />
    <hkern u1=""&#x394;"" u2=""&#x3ab;"" k=""152"" />
    <hkern u1=""&#x394;"" u2=""&#x3a5;"" k=""152"" />
    <hkern u1=""&#x394;"" u2=""&#x3a4;"" k=""119"" />
    <hkern u1=""&#x394;"" u2=""&#x39f;"" k=""43"" />
    <hkern u1=""&#x394;"" u2=""&#x398;"" k=""43"" />
    <hkern u1=""&#x394;"" u2=""&#x20;"" k=""113"" />
    <hkern u1=""&#x398;"" u2=""&#x3ab;"" k=""66"" />
    <hkern u1=""&#x398;"" u2=""&#x3a5;"" k=""66"" />
    <hkern u1=""&#x398;"" u2=""&#x39b;"" k=""37"" />
    <hkern u1=""&#x398;"" u2=""&#x394;"" k=""37"" />
    <hkern u1=""&#x398;"" u2=""&#x391;"" k=""37"" />
    <hkern u1=""&#x39a;"" u2=""&#x3ce;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3cc;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3c9;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3c6;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3c3;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3bf;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3be;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3b8;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3b6;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3b4;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3b1;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3ac;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3a6;"" k=""113"" />
    <hkern u1=""&#x39a;"" u2=""&#x39f;"" k=""63"" />
    <hkern u1=""&#x39a;"" u2=""&#x398;"" k=""63"" />
    <hkern u1=""&#x39b;"" u2=""&#x3ab;"" k=""152"" />
    <hkern u1=""&#x39b;"" u2=""&#x3a5;"" k=""152"" />
    <hkern u1=""&#x39b;"" u2=""&#x3a4;"" k=""152"" />
    <hkern u1=""&#x39b;"" u2=""&#x39f;"" k=""43"" />
    <hkern u1=""&#x39b;"" u2=""&#x398;"" k=""43"" />
    <hkern u1=""&#x39b;"" u2=""&#x20;"" k=""113"" />
    <hkern u1=""&#x39f;"" u2=""&#x3ab;"" k=""66"" />
    <hkern u1=""&#x39f;"" u2=""&#x3a5;"" k=""66"" />
    <hkern u1=""&#x39f;"" u2=""&#x39b;"" k=""37"" />
    <hkern u1=""&#x39f;"" u2=""&#x394;"" k=""43"" />
    <hkern u1=""&#x39f;"" u2=""&#x391;"" k=""37"" />
    <hkern u1=""&#x3a1;"" u2=""&#x39b;"" k=""152"" />
    <hkern u1=""&#x3a1;"" u2=""&#x394;"" k=""152"" />
    <hkern u1=""&#x3a1;"" u2=""&#x391;"" k=""152"" />
    <hkern u1=""&#x3a1;"" u2=""&#x2e;"" k=""262"" />
    <hkern u1=""&#x3a1;"" u2=""&#x2c;"" k=""262"" />
    <hkern u1=""&#x3a1;"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""&#x3a3;"" u2=""&#x3c4;"" k=""98"" />
    <hkern u1=""&#x3a3;"" u2=""&#x3c0;"" k=""98"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3cd;"" k=""178"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3cc;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3cb;"" k=""178"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3ca;"" k=""-188"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c8;"" k=""150"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c7;"" k=""113"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c6;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c5;"" k=""176"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c3;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3bf;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3bd;"" k=""113"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3bc;"" k=""150"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b9;"" k=""76"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b7;"" k=""150"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b5;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b3;"" k=""178"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b1;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b0;"" k=""178"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3ad;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3ac;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3a9;"" k=""37"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3a6;"" k=""37"" />
    <hkern u1=""&#x3a4;"" u2=""&#x39f;"" k=""37"" />
    <hkern u1=""&#x3a4;"" u2=""&#x39b;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x398;"" k=""37"" />
    <hkern u1=""&#x3a4;"" u2=""&#x394;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x391;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x390;"" k=""-188"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3a;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x2e;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x2c;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3cc;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3ca;"" k=""-121"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3c6;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3c3;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3bf;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3bc;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3ba;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b9;"" k=""76"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b7;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b3;"" k=""98"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b1;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3af;"" k=""76"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3ae;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3a9;"" k=""98"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3a6;"" k=""115"" />
    <hkern u1=""&#x3a5;"" u2=""&#x39f;"" k=""115"" />
    <hkern u1=""&#x3a5;"" u2=""&#x39b;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x398;"" k=""115"" />
    <hkern u1=""&#x3a5;"" u2=""&#x394;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x391;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x390;"" k=""-188"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b;"" k=""113"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3a;"" k=""113"" />
    <hkern u1=""&#x3a5;"" u2=""&#x2e;"" k=""262"" />
    <hkern u1=""&#x3a5;"" u2=""&#x2d;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x2c;"" k=""262"" />
    <hkern u1=""&#x3a5;"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""&#x3a6;"" u2=""&#x3ab;"" k=""66"" />
    <hkern u1=""&#x3a6;"" u2=""&#x3a5;"" k=""66"" />
    <hkern u1=""&#x3a6;"" u2=""&#x391;"" k=""59"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3ce;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3cc;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3c9;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3c6;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3c3;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3bf;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3b8;"" k=""39"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3b4;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3b1;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3ac;"" k=""78"" />
    <hkern u1=""&#x3a9;"" u2=""&#x3ab;"" k=""47"" />
    <hkern u1=""&#x3a9;"" u2=""&#x3a5;"" k=""47"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3cc;"" k=""186"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3ca;"" k=""-98"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3c6;"" k=""186"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3c3;"" k=""186"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3bf;"" k=""186"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3bc;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3ba;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3b9;"" k=""76"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3b7;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3b1;"" k=""186"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3af;"" k=""76"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3ae;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3a9;"" k=""98"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3a6;"" k=""115"" />
    <hkern u1=""&#x3ab;"" u2=""&#x39f;"" k=""115"" />
    <hkern u1=""&#x3ab;"" u2=""&#x39b;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x398;"" k=""115"" />
    <hkern u1=""&#x3ab;"" u2=""&#x394;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x391;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x390;"" k=""-170"" />
    <hkern u1=""&#x3ab;"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""&#x3b4;"" u2=""&#x3c7;"" k=""55"" />
    <hkern u1=""&#x3b4;"" u2=""&#x3c4;"" k=""29"" />
    <hkern u1=""&#x3b4;"" u2=""&#x3c0;"" k=""29"" />
    <hkern u1=""&#x3b4;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3ce;"" k=""137"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3cc;"" k=""137"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c9;"" k=""137"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c6;"" k=""137"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c4;"" k=""86"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c3;"" k=""137"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c0;"" k=""86"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3bf;"" k=""137"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3bd;"" k=""86"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3ba;"" k=""37"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b9;"" k=""37"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b8;"" k=""98"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b7;"" k=""37"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b4;"" k=""76"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b3;"" k=""86"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b1;"" k=""137"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3ae;"" k=""37"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3ac;"" k=""137"" />
    <hkern u1=""&#x3b8;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3ce;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3cc;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3c9;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3c6;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3c3;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3c2;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3bf;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3be;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3b8;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3b6;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3b4;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3b1;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3ac;"" k=""25"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3ce;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3cd;"" k=""49"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3cc;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c9;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c6;"" k=""37"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c5;"" k=""49"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c3;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c2;"" k=""47"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3bf;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3be;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3b4;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3b1;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3ac;"" k=""31"" />
    <hkern u1=""&#x3be;"" u2=""&#x3cc;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3c6;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3c3;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3c2;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3bf;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3be;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3b6;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3b4;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3b1;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3ac;"" k=""55"" />
    <hkern u1=""&#x3bf;"" u2=""&#x3c7;"" k=""55"" />
    <hkern u1=""&#x3bf;"" u2=""&#x3c4;"" k=""29"" />
    <hkern u1=""&#x3bf;"" u2=""&#x3c0;"" k=""29"" />
    <hkern u1=""&#x3bf;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3ce;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3c9;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3c6;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3c3;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3c2;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3bf;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3b6;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3b1;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3ac;"" k=""29"" />
    <hkern u1=""&#x3c1;"" u2=""&#x3c4;"" k=""29"" />
    <hkern u1=""&#x3c1;"" u2=""&#x3c0;"" k=""29"" />
    <hkern u1=""&#x3c1;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3ce;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3c9;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3c6;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3c3;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3c2;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3bf;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3b6;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3b4;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3b1;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3ac;"" k=""29"" />
    <hkern u1=""&#x3c6;"" u2=""&#x3c7;"" k=""55"" />
    <hkern u1=""&#x3c6;"" u2=""&#x3c4;"" k=""29"" />
    <hkern u1=""&#x3c6;"" u2=""&#x3c0;"" k=""29"" />
    <hkern u1=""&#x3c6;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3ce;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3cc;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3c9;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3c6;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3c3;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3c2;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3bf;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3b6;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3b4;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3b1;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3ac;"" k=""55"" />
    <hkern u1=""&#x3c9;"" u2=""&#x3c7;"" k=""55"" />
    <hkern u1=""&#x3c9;"" u2=""&#x3c4;"" k=""29"" />
    <hkern u1=""&#x3c9;"" u2=""&#x3c0;"" k=""29"" />
    <hkern u1=""&#x3c9;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x3cc;"" u2=""&#x3c7;"" k=""55"" />
    <hkern u1=""&#x3cc;"" u2=""&#x3c4;"" k=""29"" />
    <hkern u1=""&#x3cc;"" u2=""&#x3c0;"" k=""29"" />
    <hkern u1=""&#x3cc;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x3ce;"" u2=""&#x3c7;"" k=""55"" />
    <hkern u1=""&#x3ce;"" u2=""&#x3c4;"" k=""29"" />
    <hkern u1=""&#x3ce;"" u2=""&#x3c0;"" k=""29"" />
    <hkern u1=""&#x3ce;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x403;"" u2=""&#x2014;"" k=""45"" />
    <hkern u1=""&#x403;"" u2=""&#xbb;"" k=""137"" />
    <hkern u1=""&#x403;"" u2=""&#xab;"" k=""137"" />
    <hkern u1=""&#x403;"" u2=""&#x2e;"" k=""250"" />
    <hkern u1=""&#x403;"" u2=""&#x2c;"" k=""250"" />
    <hkern u1=""&#x409;"" u2=""&#x2019;"" k=""160"" />
    <hkern u1=""&#x40a;"" u2=""&#x2019;"" k=""137"" />
    <hkern u1=""&#x410;"" u2=""&#x2019;"" k=""115"" />
    <hkern u1=""&#x410;"" u2=""&#x44d;"" k=""-45"" />
    <hkern u1=""&#x410;"" u2=""&#x444;"" k=""-23"" />
    <hkern u1=""&#x410;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x410;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x410;"" u2=""&#x430;"" k=""-23"" />
    <hkern u1=""&#x410;"" u2=""&#x42d;"" k=""45"" />
    <hkern u1=""&#x410;"" u2=""&#x427;"" k=""160"" />
    <hkern u1=""&#x410;"" u2=""&#x424;"" k=""68"" />
    <hkern u1=""&#x410;"" u2=""&#x423;"" k=""90"" />
    <hkern u1=""&#x410;"" u2=""&#x422;"" k=""160"" />
    <hkern u1=""&#x410;"" u2=""&#x421;"" k=""45"" />
    <hkern u1=""&#x410;"" u2=""&#x41f;"" k=""23"" />
    <hkern u1=""&#x410;"" u2=""&#x41e;"" k=""45"" />
    <hkern u1=""&#x410;"" u2=""&#x41b;"" k=""-45"" />
    <hkern u1=""&#x410;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x410;"" u2=""&#x414;"" k=""-68"" />
    <hkern u1=""&#x411;"" u2=""&#x443;"" k=""45"" />
    <hkern u1=""&#x411;"" u2=""&#x43b;"" k=""23"" />
    <hkern u1=""&#x411;"" u2=""&#x42f;"" k=""23"" />
    <hkern u1=""&#x411;"" u2=""&#x42d;"" k=""23"" />
    <hkern u1=""&#x411;"" u2=""&#x42a;"" k=""68"" />
    <hkern u1=""&#x411;"" u2=""&#x427;"" k=""92"" />
    <hkern u1=""&#x411;"" u2=""&#x425;"" k=""45"" />
    <hkern u1=""&#x411;"" u2=""&#x424;"" k=""23"" />
    <hkern u1=""&#x411;"" u2=""&#x423;"" k=""47"" />
    <hkern u1=""&#x411;"" u2=""&#x422;"" k=""92"" />
    <hkern u1=""&#x411;"" u2=""&#x421;"" k=""23"" />
    <hkern u1=""&#x411;"" u2=""&#x41e;"" k=""23"" />
    <hkern u1=""&#x411;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x411;"" u2=""&#x410;"" k=""45"" />
    <hkern u1=""&#x412;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x412;"" u2=""&#x447;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x445;"" k=""23"" />
    <hkern u1=""&#x412;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x412;"" u2=""&#x442;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x43c;"" k=""23"" />
    <hkern u1=""&#x412;"" u2=""&#x434;"" k=""23"" />
    <hkern u1=""&#x412;"" u2=""&#x42f;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x42a;"" k=""115"" />
    <hkern u1=""&#x412;"" u2=""&#x427;"" k=""92"" />
    <hkern u1=""&#x412;"" u2=""&#x425;"" k=""90"" />
    <hkern u1=""&#x412;"" u2=""&#x424;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x423;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x422;"" k=""137"" />
    <hkern u1=""&#x412;"" u2=""&#x421;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x41e;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x41b;"" k=""23"" />
    <hkern u1=""&#x412;"" u2=""&#x417;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x416;"" k=""45"" />
    <hkern u1=""&#x412;"" u2=""&#x414;"" k=""45"" />
    <hkern u1=""&#x412;"" u2=""&#x410;"" k=""68"" />
    <hkern u1=""&#x413;"" u2=""&#x2014;"" k=""45"" />
    <hkern u1=""&#x413;"" u2=""&#x44f;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#x44e;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x44c;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x44b;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x443;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#x440;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x43e;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#x43d;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x43c;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x43b;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x438;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x435;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#x434;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#x432;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x430;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x42f;"" k=""68"" />
    <hkern u1=""&#x413;"" u2=""&#x421;"" k=""92"" />
    <hkern u1=""&#x413;"" u2=""&#x41e;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x41c;"" k=""47"" />
    <hkern u1=""&#x413;"" u2=""&#x41b;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x417;"" k=""45"" />
    <hkern u1=""&#x413;"" u2=""&#x414;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#x410;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#xbb;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#xab;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#x2e;"" k=""250"" />
    <hkern u1=""&#x413;"" u2=""&#x2c;"" k=""250"" />
    <hkern u1=""&#x414;"" u2=""&#x443;"" k=""-45"" />
    <hkern u1=""&#x414;"" u2=""&#x43e;"" k=""-23"" />
    <hkern u1=""&#x414;"" u2=""&#x437;"" k=""-68"" />
    <hkern u1=""&#x414;"" u2=""&#x427;"" k=""70"" />
    <hkern u1=""&#x414;"" u2=""&#x424;"" k=""45"" />
    <hkern u1=""&#x414;"" u2=""&#x423;"" k=""-23"" />
    <hkern u1=""&#x415;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x415;"" u2=""&#x417;"" k=""45"" />
    <hkern u1=""&#x416;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x416;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x416;"" u2=""&#x435;"" k=""25"" />
    <hkern u1=""&#x416;"" u2=""&#x430;"" k=""-23"" />
    <hkern u1=""&#x416;"" u2=""&#x42a;"" k=""-45"" />
    <hkern u1=""&#x416;"" u2=""&#x423;"" k=""-45"" />
    <hkern u1=""&#x416;"" u2=""&#x422;"" k=""-23"" />
    <hkern u1=""&#x416;"" u2=""&#x421;"" k=""23"" />
    <hkern u1=""&#x416;"" u2=""&#x41e;"" k=""45"" />
    <hkern u1=""&#x416;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x417;"" u2=""&#x42f;"" k=""23"" />
    <hkern u1=""&#x417;"" u2=""&#x427;"" k=""45"" />
    <hkern u1=""&#x417;"" u2=""&#x424;"" k=""23"" />
    <hkern u1=""&#x417;"" u2=""&#x423;"" k=""23"" />
    <hkern u1=""&#x417;"" u2=""&#x422;"" k=""45"" />
    <hkern u1=""&#x417;"" u2=""&#x421;"" k=""23"" />
    <hkern u1=""&#x417;"" u2=""&#x41e;"" k=""23"" />
    <hkern u1=""&#x417;"" u2=""&#x41b;"" k=""23"" />
    <hkern u1=""&#x41a;"" u2=""&#x424;"" k=""70"" />
    <hkern u1=""&#x41a;"" u2=""&#x423;"" k=""-23"" />
    <hkern u1=""&#x41a;"" u2=""&#x421;"" k=""23"" />
    <hkern u1=""&#x41a;"" u2=""&#x41e;"" k=""23"" />
    <hkern u1=""&#x41a;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x41b;"" u2=""&#x443;"" k=""-23"" />
    <hkern u1=""&#x41b;"" u2=""&#x431;"" k=""-23"" />
    <hkern u1=""&#x41b;"" u2=""&#x424;"" k=""23"" />
    <hkern u1=""&#x41c;"" u2=""&#x44d;"" k=""-23"" />
    <hkern u1=""&#x41c;"" u2=""&#x447;"" k=""23"" />
    <hkern u1=""&#x41c;"" u2=""&#x443;"" k=""-23"" />
    <hkern u1=""&#x41c;"" u2=""&#x441;"" k=""-23"" />
    <hkern u1=""&#x41c;"" u2=""&#x43e;"" k=""-23"" />
    <hkern u1=""&#x41c;"" u2=""&#x435;"" k=""-23"" />
    <hkern u1=""&#x41c;"" u2=""&#x430;"" k=""-23"" />
    <hkern u1=""&#x41c;"" u2=""&#x427;"" k=""23"" />
    <hkern u1=""&#x41c;"" u2=""&#x424;"" k=""23"" />
    <hkern u1=""&#x41e;"" u2=""&#x445;"" k=""23"" />
    <hkern u1=""&#x41e;"" u2=""&#x43b;"" k=""23"" />
    <hkern u1=""&#x41e;"" u2=""&#x434;"" k=""45"" />
    <hkern u1=""&#x41e;"" u2=""&#x42f;"" k=""45"" />
    <hkern u1=""&#x41e;"" u2=""&#x427;"" k=""45"" />
    <hkern u1=""&#x41e;"" u2=""&#x425;"" k=""92"" />
    <hkern u1=""&#x41e;"" u2=""&#x423;"" k=""45"" />
    <hkern u1=""&#x41e;"" u2=""&#x41b;"" k=""23"" />
    <hkern u1=""&#x41e;"" u2=""&#x416;"" k=""45"" />
    <hkern u1=""&#x41e;"" u2=""&#x414;"" k=""45"" />
    <hkern u1=""&#x41e;"" u2=""&#x410;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x44f;"" k=""68"" />
    <hkern u1=""&#x420;"" u2=""&#x44d;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x43e;"" k=""90"" />
    <hkern u1=""&#x420;"" u2=""&#x435;"" k=""90"" />
    <hkern u1=""&#x420;"" u2=""&#x434;"" k=""160"" />
    <hkern u1=""&#x420;"" u2=""&#x430;"" k=""68"" />
    <hkern u1=""&#x420;"" u2=""&#x42f;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x425;"" k=""92"" />
    <hkern u1=""&#x420;"" u2=""&#x424;"" k=""23"" />
    <hkern u1=""&#x420;"" u2=""&#x423;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x422;"" k=""92"" />
    <hkern u1=""&#x420;"" u2=""&#x421;"" k=""23"" />
    <hkern u1=""&#x420;"" u2=""&#x41e;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x41c;"" k=""23"" />
    <hkern u1=""&#x420;"" u2=""&#x41b;"" k=""115"" />
    <hkern u1=""&#x420;"" u2=""&#x417;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x416;"" k=""23"" />
    <hkern u1=""&#x420;"" u2=""&#x414;"" k=""137"" />
    <hkern u1=""&#x420;"" u2=""&#x410;"" k=""137"" />
    <hkern u1=""&#x420;"" u2=""&#xbb;"" k=""115"" />
    <hkern u1=""&#x420;"" u2=""&#x3b;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x3a;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x2e;"" k=""387"" />
    <hkern u1=""&#x420;"" u2=""&#x2c;"" k=""387"" />
    <hkern u1=""&#x421;"" u2=""&#x447;"" k=""23"" />
    <hkern u1=""&#x421;"" u2=""&#x436;"" k=""-45"" />
    <hkern u1=""&#x421;"" u2=""&#x430;"" k=""-23"" />
    <hkern u1=""&#x421;"" u2=""&#x42d;"" k=""23"" />
    <hkern u1=""&#x421;"" u2=""&#x42a;"" k=""70"" />
    <hkern u1=""&#x421;"" u2=""&#x427;"" k=""68"" />
    <hkern u1=""&#x421;"" u2=""&#x425;"" k=""115"" />
    <hkern u1=""&#x421;"" u2=""&#x423;"" k=""68"" />
    <hkern u1=""&#x421;"" u2=""&#x422;"" k=""68"" />
    <hkern u1=""&#x421;"" u2=""&#x41e;"" k=""45"" />
    <hkern u1=""&#x421;"" u2=""&#x41c;"" k=""23"" />
    <hkern u1=""&#x421;"" u2=""&#x41b;"" k=""68"" />
    <hkern u1=""&#x421;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x421;"" u2=""&#x414;"" k=""45"" />
    <hkern u1=""&#x421;"" u2=""&#x410;"" k=""45"" />
    <hkern u1=""&#x422;"" u2=""&#x2014;"" k=""45"" />
    <hkern u1=""&#x422;"" u2=""&#x44f;"" k=""115"" />
    <hkern u1=""&#x422;"" u2=""&#x44e;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x44c;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x44b;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x449;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x445;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x443;"" k=""115"" />
    <hkern u1=""&#x422;"" u2=""&#x441;"" k=""115"" />
    <hkern u1=""&#x422;"" u2=""&#x440;"" k=""115"" />
    <hkern u1=""&#x422;"" u2=""&#x43f;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x43e;"" k=""160"" />
    <hkern u1=""&#x422;"" u2=""&#x43c;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x43b;"" k=""92"" />
    <hkern u1=""&#x422;"" u2=""&#x43a;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x438;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x435;"" k=""115"" />
    <hkern u1=""&#x422;"" u2=""&#x432;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x430;"" k=""92"" />
    <hkern u1=""&#x422;"" u2=""&#x42f;"" k=""45"" />
    <hkern u1=""&#x422;"" u2=""&#x424;"" k=""68"" />
    <hkern u1=""&#x422;"" u2=""&#x41e;"" k=""92"" />
    <hkern u1=""&#x422;"" u2=""&#x41b;"" k=""45"" />
    <hkern u1=""&#x422;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x422;"" u2=""&#x416;"" k=""-23"" />
    <hkern u1=""&#x422;"" u2=""&#x414;"" k=""68"" />
    <hkern u1=""&#x422;"" u2=""&#x410;"" k=""68"" />
    <hkern u1=""&#x422;"" u2=""&#xbb;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#xab;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x2e;"" k=""227"" />
    <hkern u1=""&#x422;"" u2=""&#x2c;"" k=""227"" />
    <hkern u1=""&#x423;"" u2=""&#x2014;"" k=""23"" />
    <hkern u1=""&#x423;"" u2=""&#x44f;"" k=""137"" />
    <hkern u1=""&#x423;"" u2=""&#x44e;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x449;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x448;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x446;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x445;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x441;"" k=""137"" />
    <hkern u1=""&#x423;"" u2=""&#x440;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x43f;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x43e;"" k=""137"" />
    <hkern u1=""&#x423;"" u2=""&#x43d;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x43c;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x43b;"" k=""137"" />
    <hkern u1=""&#x423;"" u2=""&#x43a;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x439;"" k=""68"" />
    <hkern u1=""&#x423;"" u2=""&#x438;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x437;"" k=""115"" />
    <hkern u1=""&#x423;"" u2=""&#x436;"" k=""68"" />
    <hkern u1=""&#x423;"" u2=""&#x435;"" k=""137"" />
    <hkern u1=""&#x423;"" u2=""&#x434;"" k=""160"" />
    <hkern u1=""&#x423;"" u2=""&#x433;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x432;"" k=""115"" />
    <hkern u1=""&#x423;"" u2=""&#x431;"" k=""45"" />
    <hkern u1=""&#x423;"" u2=""&#x42f;"" k=""45"" />
    <hkern u1=""&#x423;"" u2=""&#x42d;"" k=""45"" />
    <hkern u1=""&#x423;"" u2=""&#x424;"" k=""68"" />
    <hkern u1=""&#x423;"" u2=""&#x41e;"" k=""68"" />
    <hkern u1=""&#x423;"" u2=""&#x41b;"" k=""68"" />
    <hkern u1=""&#x423;"" u2=""&#x417;"" k=""45"" />
    <hkern u1=""&#x423;"" u2=""&#x414;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x410;"" k=""137"" />
    <hkern u1=""&#x423;"" u2=""&#xbb;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#xab;"" k=""90"" />
    <hkern u1=""&#x423;"" u2=""&#x3b;"" k=""45"" />
    <hkern u1=""&#x423;"" u2=""&#x3a;"" k=""45"" />
    <hkern u1=""&#x423;"" u2=""&#x2e;"" k=""272"" />
    <hkern u1=""&#x423;"" u2=""&#x2c;"" k=""272"" />
    <hkern u1=""&#x424;"" u2=""&#x43b;"" k=""68"" />
    <hkern u1=""&#x424;"" u2=""&#x42f;"" k=""70"" />
    <hkern u1=""&#x424;"" u2=""&#x427;"" k=""45"" />
    <hkern u1=""&#x424;"" u2=""&#x423;"" k=""92"" />
    <hkern u1=""&#x424;"" u2=""&#x422;"" k=""115"" />
    <hkern u1=""&#x424;"" u2=""&#x41b;"" k=""68"" />
    <hkern u1=""&#x424;"" u2=""&#x414;"" k=""68"" />
    <hkern u1=""&#x424;"" u2=""&#x410;"" k=""45"" />
    <hkern u1=""&#x425;"" u2=""&#x443;"" k=""45"" />
    <hkern u1=""&#x425;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x425;"" u2=""&#x42d;"" k=""70"" />
    <hkern u1=""&#x425;"" u2=""&#x424;"" k=""68"" />
    <hkern u1=""&#x425;"" u2=""&#x421;"" k=""68"" />
    <hkern u1=""&#x425;"" u2=""&#x41e;"" k=""68"" />
    <hkern u1=""&#x425;"" u2=""&#x417;"" k=""45"" />
    <hkern u1=""&#x426;"" u2=""&#x430;"" k=""-45"" />
    <hkern u1=""&#x426;"" u2=""&#x41e;"" k=""45"" />
    <hkern u1=""&#x429;"" u2=""&#x443;"" k=""-45"" />
    <hkern u1=""&#x429;"" u2=""&#x430;"" k=""-23"" />
    <hkern u1=""&#x42a;"" u2=""&#x2019;"" k=""137"" />
    <hkern u1=""&#x42a;"" u2=""&#x42f;"" k=""68"" />
    <hkern u1=""&#x42c;"" u2=""&#x2019;"" k=""160"" />
    <hkern u1=""&#x42c;"" u2=""&#x42f;"" k=""92"" />
    <hkern u1=""&#x42c;"" u2=""&#x42d;"" k=""23"" />
    <hkern u1=""&#x42c;"" u2=""&#x427;"" k=""160"" />
    <hkern u1=""&#x42c;"" u2=""&#x425;"" k=""92"" />
    <hkern u1=""&#x42c;"" u2=""&#x422;"" k=""205"" />
    <hkern u1=""&#x42c;"" u2=""&#x421;"" k=""45"" />
    <hkern u1=""&#x42c;"" u2=""&#x41e;"" k=""45"" />
    <hkern u1=""&#x42c;"" u2=""&#x41c;"" k=""45"" />
    <hkern u1=""&#x42c;"" u2=""&#x41b;"" k=""70"" />
    <hkern u1=""&#x42c;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x42c;"" u2=""&#x416;"" k=""68"" />
    <hkern u1=""&#x42c;"" u2=""&#x414;"" k=""45"" />
    <hkern u1=""&#x42c;"" u2=""&#x410;"" k=""45"" />
    <hkern u1=""&#x42d;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x42d;"" u2=""&#x43c;"" k=""23"" />
    <hkern u1=""&#x42d;"" u2=""&#x43b;"" k=""68"" />
    <hkern u1=""&#x42d;"" u2=""&#x436;"" k=""-23"" />
    <hkern u1=""&#x42d;"" u2=""&#x434;"" k=""68"" />
    <hkern u1=""&#x42d;"" u2=""&#x42f;"" k=""45"" />
    <hkern u1=""&#x42d;"" u2=""&#x425;"" k=""70"" />
    <hkern u1=""&#x42d;"" u2=""&#x41b;"" k=""68"" />
    <hkern u1=""&#x42d;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x42d;"" u2=""&#x416;"" k=""25"" />
    <hkern u1=""&#x42d;"" u2=""&#x414;"" k=""68"" />
    <hkern u1=""&#x42e;"" u2=""&#x43c;"" k=""23"" />
    <hkern u1=""&#x42e;"" u2=""&#x43b;"" k=""92"" />
    <hkern u1=""&#x42e;"" u2=""&#x434;"" k=""92"" />
    <hkern u1=""&#x42e;"" u2=""&#x427;"" k=""68"" />
    <hkern u1=""&#x42e;"" u2=""&#x425;"" k=""92"" />
    <hkern u1=""&#x42e;"" u2=""&#x422;"" k=""115"" />
    <hkern u1=""&#x42e;"" u2=""&#x421;"" k=""23"" />
    <hkern u1=""&#x42e;"" u2=""&#x41e;"" k=""23"" />
    <hkern u1=""&#x42e;"" u2=""&#x41b;"" k=""92"" />
    <hkern u1=""&#x42e;"" u2=""&#x416;"" k=""45"" />
    <hkern u1=""&#x42e;"" u2=""&#x414;"" k=""90"" />
    <hkern u1=""&#x42e;"" u2=""&#x410;"" k=""68"" />
    <hkern u1=""&#x430;"" u2=""&#x447;"" k=""45"" />
    <hkern u1=""&#x430;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x430;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x430;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x431;"" u2=""&#x44f;"" k=""45"" />
    <hkern u1=""&#x431;"" u2=""&#x44d;"" k=""23"" />
    <hkern u1=""&#x431;"" u2=""&#x44a;"" k=""68"" />
    <hkern u1=""&#x431;"" u2=""&#x447;"" k=""68"" />
    <hkern u1=""&#x431;"" u2=""&#x445;"" k=""68"" />
    <hkern u1=""&#x431;"" u2=""&#x444;"" k=""23"" />
    <hkern u1=""&#x431;"" u2=""&#x443;"" k=""45"" />
    <hkern u1=""&#x431;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x431;"" u2=""&#x43c;"" k=""45"" />
    <hkern u1=""&#x431;"" u2=""&#x43b;"" k=""92"" />
    <hkern u1=""&#x431;"" u2=""&#x437;"" k=""45"" />
    <hkern u1=""&#x431;"" u2=""&#x436;"" k=""23"" />
    <hkern u1=""&#x431;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x431;"" u2=""&#x434;"" k=""92"" />
    <hkern u1=""&#x431;"" u2=""&#x430;"" k=""47"" />
    <hkern u1=""&#x432;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x44a;"" k=""68"" />
    <hkern u1=""&#x432;"" u2=""&#x447;"" k=""92"" />
    <hkern u1=""&#x432;"" u2=""&#x444;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x443;"" k=""45"" />
    <hkern u1=""&#x432;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x432;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x43c;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x43b;"" k=""47"" />
    <hkern u1=""&#x432;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x436;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x434;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x431;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x430;"" k=""23"" />
    <hkern u1=""&#x433;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x433;"" u2=""&#x441;"" k=""45"" />
    <hkern u1=""&#x433;"" u2=""&#x43e;"" k=""45"" />
    <hkern u1=""&#x433;"" u2=""&#x43b;"" k=""45"" />
    <hkern u1=""&#x433;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x433;"" u2=""&#x435;"" k=""45"" />
    <hkern u1=""&#x433;"" u2=""&#x434;"" k=""92"" />
    <hkern u1=""&#x433;"" u2=""&#x430;"" k=""45"" />
    <hkern u1=""&#x433;"" u2=""&#x2e;"" k=""250"" />
    <hkern u1=""&#x433;"" u2=""&#x2c;"" k=""250"" />
    <hkern u1=""&#x434;"" u2=""&#x44d;"" k=""-23"" />
    <hkern u1=""&#x434;"" u2=""&#x44a;"" k=""45"" />
    <hkern u1=""&#x435;"" u2=""&#x447;"" k=""68"" />
    <hkern u1=""&#x435;"" u2=""&#x445;"" k=""45"" />
    <hkern u1=""&#x435;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x435;"" u2=""&#x442;"" k=""68"" />
    <hkern u1=""&#x435;"" u2=""&#x43b;"" k=""68"" />
    <hkern u1=""&#x435;"" u2=""&#x437;"" k=""45"" />
    <hkern u1=""&#x435;"" u2=""&#x436;"" k=""23"" />
    <hkern u1=""&#x435;"" u2=""&#x434;"" k=""45"" />
    <hkern u1=""&#x435;"" u2=""&#x431;"" k=""23"" />
    <hkern u1=""&#x436;"" u2=""&#x44a;"" k=""-45"" />
    <hkern u1=""&#x436;"" u2=""&#x447;"" k=""23"" />
    <hkern u1=""&#x436;"" u2=""&#x443;"" k=""-23"" />
    <hkern u1=""&#x436;"" u2=""&#x431;"" k=""-23"" />
    <hkern u1=""&#x437;"" u2=""&#x44a;"" k=""45"" />
    <hkern u1=""&#x437;"" u2=""&#x447;"" k=""68"" />
    <hkern u1=""&#x437;"" u2=""&#x444;"" k=""23"" />
    <hkern u1=""&#x437;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x437;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x437;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x437;"" u2=""&#x43b;"" k=""23"" />
    <hkern u1=""&#x437;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x437;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x437;"" u2=""&#x434;"" k=""45"" />
    <hkern u1=""&#x437;"" u2=""&#x431;"" k=""23"" />
    <hkern u1=""&#x43a;"" u2=""&#x44d;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x443;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x442;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x441;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x43e;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x43b;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x437;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x435;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x431;"" k=""-45"" />
    <hkern u1=""&#x43a;"" u2=""&#x430;"" k=""-45"" />
    <hkern u1=""&#x43b;"" u2=""&#x447;"" k=""45"" />
    <hkern u1=""&#x43b;"" u2=""&#x43e;"" k=""-23"" />
    <hkern u1=""&#x43c;"" u2=""&#x443;"" k=""-23"" />
    <hkern u1=""&#x43c;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x43c;"" u2=""&#x431;"" k=""23"" />
    <hkern u1=""&#x43e;"" u2=""&#x447;"" k=""45"" />
    <hkern u1=""&#x43e;"" u2=""&#x445;"" k=""23"" />
    <hkern u1=""&#x43e;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x43e;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x43e;"" u2=""&#x43b;"" k=""45"" />
    <hkern u1=""&#x43e;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x43e;"" u2=""&#x436;"" k=""23"" />
    <hkern u1=""&#x43e;"" u2=""&#x434;"" k=""45"" />
    <hkern u1=""&#x440;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x440;"" u2=""&#x447;"" k=""45"" />
    <hkern u1=""&#x440;"" u2=""&#x445;"" k=""23"" />
    <hkern u1=""&#x440;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x440;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x440;"" u2=""&#x43b;"" k=""70"" />
    <hkern u1=""&#x440;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x440;"" u2=""&#x434;"" k=""47"" />
    <hkern u1=""&#x441;"" u2=""&#x44d;"" k=""-23"" />
    <hkern u1=""&#x441;"" u2=""&#x447;"" k=""23"" />
    <hkern u1=""&#x441;"" u2=""&#x43e;"" k=""-23"" />
    <hkern u1=""&#x441;"" u2=""&#x436;"" k=""-23"" />
    <hkern u1=""&#x442;"" u2=""&#x443;"" k=""-23"" />
    <hkern u1=""&#x442;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x442;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x442;"" u2=""&#x43b;"" k=""45"" />
    <hkern u1=""&#x442;"" u2=""&#x436;"" k=""-68"" />
    <hkern u1=""&#x442;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x442;"" u2=""&#x434;"" k=""68"" />
    <hkern u1=""&#x442;"" u2=""&#x430;"" k=""23"" />
    <hkern u1=""&#x442;"" u2=""&#x2e;"" k=""227"" />
    <hkern u1=""&#x442;"" u2=""&#x2c;"" k=""227"" />
    <hkern u1=""&#x443;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#x44d;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#x444;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#x440;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#x43e;"" k=""25"" />
    <hkern u1=""&#x443;"" u2=""&#x43c;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#x43b;"" k=""45"" />
    <hkern u1=""&#x443;"" u2=""&#x436;"" k=""-23"" />
    <hkern u1=""&#x443;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#x434;"" k=""68"" />
    <hkern u1=""&#x443;"" u2=""&#x431;"" k=""-23"" />
    <hkern u1=""&#x443;"" u2=""&#x430;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#xbb;"" k=""-23"" />
    <hkern u1=""&#x443;"" u2=""&#x2e;"" k=""205"" />
    <hkern u1=""&#x443;"" u2=""&#x2c;"" k=""205"" />
    <hkern u1=""&#x444;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x444;"" u2=""&#x447;"" k=""45"" />
    <hkern u1=""&#x444;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x444;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x444;"" u2=""&#x43b;"" k=""45"" />
    <hkern u1=""&#x444;"" u2=""&#x434;"" k=""45"" />
    <hkern u1=""&#x444;"" u2=""&#x431;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x447;"" k=""45"" />
    <hkern u1=""&#x445;"" u2=""&#x444;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x442;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x431;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x430;"" k=""23"" />
    <hkern u1=""&#x446;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x446;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x446;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x446;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x449;"" u2=""&#x443;"" k=""-23"" />
    <hkern u1=""&#x449;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x449;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x44c;"" u2=""&#x447;"" k=""137"" />
    <hkern u1=""&#x44c;"" u2=""&#x442;"" k=""160"" />
    <hkern u1=""&#x44d;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x44d;"" u2=""&#x445;"" k=""23"" />
    <hkern u1=""&#x44d;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x44d;"" u2=""&#x43e;"" k=""-23"" />
    <hkern u1=""&#x44d;"" u2=""&#x43b;"" k=""45"" />
    <hkern u1=""&#x44d;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x44d;"" u2=""&#x435;"" k=""-23"" />
    <hkern u1=""&#x44d;"" u2=""&#x434;"" k=""45"" />
    <hkern u1=""&#x44e;"" u2=""&#x447;"" k=""45"" />
    <hkern u1=""&#x44e;"" u2=""&#x445;"" k=""23"" />
    <hkern u1=""&#x44e;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x44e;"" u2=""&#x43c;"" k=""23"" />
    <hkern u1=""&#x44e;"" u2=""&#x43b;"" k=""45"" />
    <hkern u1=""&#x44e;"" u2=""&#x436;"" k=""23"" />
    <hkern u1=""&#x44e;"" u2=""&#x434;"" k=""45"" />
    <hkern u1=""&#x45e;"" u2=""&#x2e;"" k=""205"" />
    <hkern u1=""&#x45e;"" u2=""&#x2c;"" k=""205"" />
    <hkern u1=""&#x490;"" u2=""&#x2014;"" k=""45"" />
    <hkern u1=""&#x490;"" u2=""&#xbb;"" k=""160"" />
    <hkern u1=""&#x490;"" u2=""&#xab;"" k=""160"" />
    <hkern u1=""&#x490;"" u2=""&#x3b;"" k=""45"" />
    <hkern u1=""&#x490;"" u2=""&#x3a;"" k=""45"" />
    <hkern u1=""&#x490;"" u2=""&#x2e;"" k=""250"" />
    <hkern u1=""&#x490;"" u2=""&#x2c;"" k=""250"" />
    <hkern u1=""&#x2018;"" u2=""&#x2018;"" k=""37"" />
    <hkern u1=""&#x2019;"" u2=""&#x2019;"" k=""37"" />
    <hkern u1=""&#x2019;"" u2=""s"" k=""37"" />
    <hkern u1=""&#x2019;"" u2=""&#x20;"" k=""76"" />
    <hkern u1=""&#x201e;"" u2=""&#x42a;"" k=""68"" />
    <hkern u1=""&#x201e;"" u2=""&#x427;"" k=""68"" />
    <hkern u1=""&#x201e;"" u2=""&#x422;"" k=""160"" />
    <hkern u1=""&#x201e;"" u2=""&#x40b;"" k=""160"" />
    <hkern u1=""&#x201e;"" u2=""&#x402;"" k=""160"" />
  </font>
</defs></svg>";
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Font\StyledTypeFace.cs
using MatterHackers.Agg.Image;
using MatterHackers.Agg.Transform;
using MatterHackers.Agg.VertexSource;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007-2011
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
//
// Class StyledTypeFace.cs
//
//----------------------------------------------------------------------------
using System;
using System.Collections.Generic;

namespace MatterHackers.Agg.Font
{
	public class GlyphWithUnderline : VertexSourceLegacySupport
	{
		private IVertexSource underline;
		private IVertexSource glyph;

		public GlyphWithUnderline(IVertexSource glyph, int advanceForCharacter, int Underline_position, int Underline_thickness)
		{
			underline = new RoundedRect(new RectangleDouble(0, Underline_position, advanceForCharacter, Underline_position + Underline_thickness), 0);
			this.glyph = glyph;
		}

		public override IEnumerable<VertexData> Vertices()
		{
			// return all the data for the glyph
			foreach (VertexData vertexData in glyph.Vertices())
			{
				if (ShapePath.IsStop(vertexData.Command))
				{
					break;
				}
				yield return vertexData;
			}

			// then the underline
			foreach (VertexData vertexData in underline.Vertices())
			{
				yield return vertexData;
			}
		}
	}

	public class StyledTypeFaceImageCache
	{
		private static StyledTypeFaceImageCache instance;

        // Keys: TypeFace, Color, FontSize, Character
        private Dictionary<TypeFace, Dictionary<Color, Dictionary<double, Dictionary<char, ImageBuffer>>>> typeFaceImageCache = new Dictionary<TypeFace, Dictionary<Color, Dictionary<double, Dictionary<char, ImageBuffer>>>>();

		// private so you can't use it by accident (it is a singleton)
		private StyledTypeFaceImageCache()
		{
		}

		public static Dictionary<char, ImageBuffer> GetCorrectCache(TypeFace typeFace, Color color, double emSizeInPoints)
		{
			lock (typeFace)
			{
				// TODO: check if the cache is getting too big and if so prune it (or just delete it and start over).

				Dictionary<Color, Dictionary<double, Dictionary<char, ImageBuffer>>> foundTypeFaceColor;
				if (!Instance.typeFaceImageCache.TryGetValue(typeFace, out foundTypeFaceColor))
				{
					// add in the type face
					foundTypeFaceColor = new Dictionary<Color, Dictionary<double, Dictionary<char, ImageBuffer>>>();
					Instance.typeFaceImageCache.Add(typeFace, foundTypeFaceColor);
				}

				Dictionary<double, Dictionary<char, ImageBuffer>> foundTypeFaceSizes;
				if (!foundTypeFaceColor.TryGetValue(color, out foundTypeFaceSizes))
				{
					// add in the type face
					foundTypeFaceSizes = new Dictionary<double, Dictionary<char, ImageBuffer>>();
					foundTypeFaceColor.Add(color, foundTypeFaceSizes);
				}

				Dictionary<char, ImageBuffer> foundTypeFaceSize;
				if (!foundTypeFaceSizes.TryGetValue(emSizeInPoints, out foundTypeFaceSize))
				{
					// add in the point size
					foundTypeFaceSize = new Dictionary<char, ImageBuffer>();
					foundTypeFaceSizes.Add(emSizeInPoints, foundTypeFaceSize);
				}

				return foundTypeFaceSize;
			}
		}

		private static StyledTypeFaceImageCache Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new StyledTypeFaceImageCache();
				}

				return instance;
			}
		}
	}

	public class StyledTypeFace
	{
		public TypeFace TypeFace { get; private set; }

		public const int PointsPerInch = 72;
		public const int PixelsPerInch = 96;

		private double emSizeInPixels;
		private double currentEmScaling;
		private bool flattenCurves = true;

		public StyledTypeFace(TypeFace typeFace, double emSizeInPoints, bool underline = false, bool flattenCurves = true)
		{
			this.TypeFace = typeFace;
			emSizeInPixels = emSizeInPoints / PointsPerInch * PixelsPerInch;
			currentEmScaling = emSizeInPixels / typeFace.UnitsPerEm;
			DoUnderline = underline;
			FlattenCurves = flattenCurves;
		}

		public bool DoUnderline { get; set; }

		/// <summary>
		/// <para>If true the font will have it's curves flattened to the current point size when retrieved.</para>
		/// <para>You may want to disable this so you can flatten the curve after other transforms have been applied,</para>
		/// <para>such as skewing or scaling.  Rotation and Translation will not alter how a curve is flattened.</para>
		/// </summary>
		public bool FlattenCurves
		{
			get => flattenCurves;
			set => flattenCurves = value;
		}

		/// <summary>
		/// Sets the Em size for the font in pixels.
		/// </summary>
		public double EmSizeInPixels => emSizeInPixels;

		/// <summary>
		/// Sets the Em size for the font assuming there are 72 points per inch and there are 96 pixels per inch.
		/// </summary>
		public double EmSizeInPoints => emSizeInPixels / PixelsPerInch * PointsPerInch;

		public double AscentInPixels => TypeFace.Ascent * currentEmScaling;

		public double DescentInPixels => TypeFace.Descent * currentEmScaling;

		public double XHeightInPixels => TypeFace.X_height * currentEmScaling;

		public double CapHeightInPixels => TypeFace.Cap_height * currentEmScaling;

		public RectangleDouble BoundingBoxInPixels
		{
			get
			{
				RectangleDouble pixelBounds = new RectangleDouble(TypeFace.BoundingBox);
				pixelBounds *= currentEmScaling;
				return pixelBounds;
			}
		}

		public double UnderlineThicknessInPixels => TypeFace.Underline_thickness * currentEmScaling;

		public double UnderlinePositionInPixels => TypeFace.Underline_position * currentEmScaling;

		public ImageBuffer GetImageForCharacter(char character, double xFraction, double yFraction, Color color)
		{
			if (xFraction > 1 || xFraction < 0 || yFraction > 1 || yFraction < 0)
			{
				throw new ArgumentException("The x and y fractions must both be between 0 and 1.");
			}

			var characterImageCache = StyledTypeFaceImageCache.GetCorrectCache(this.TypeFace, color, emSizeInPixels);
			characterImageCache.TryGetValue(character, out ImageBuffer imageForCharacter);
			if (imageForCharacter != null)
			{
				return imageForCharacter;
			}

			IVertexSource glyphForCharacter = GetGlyphForCharacter(character, 1);
			if (glyphForCharacter == null)
			{
				return null;
			}

			var bounds = glyphForCharacter.GetBounds();

			var charImage = new ImageBuffer(
				Math.Max((int)(bounds.Right + .5), 1) + 1,
				Math.Max((int)Math.Ceiling(EmSizeInPixels + (-DescentInPixels) + .5), 1) + 1,
				32,
				new BlenderPreMultBGRA());

			var graphics = charImage.NewGraphics2D();
			graphics.Render(glyphForCharacter, xFraction, yFraction + (-DescentInPixels) + 1, color);
			characterImageCache[character] = charImage;

			return charImage;
		}

		public IVertexSource GetGlyphForCharacter(char character, double resolutionScale = 1)
		{
			// scale it to the correct size.
			IVertexSource sourceGlyph = TypeFace.GetGlyphForCharacter(character);
			if (sourceGlyph != null)
			{
				if (DoUnderline)
				{
					sourceGlyph = new GlyphWithUnderline(sourceGlyph, TypeFace.GetAdvanceForCharacter(character), TypeFace.Underline_position, TypeFace.Underline_thickness);
				}

				var glyphTransform = Affine.NewIdentity();
				glyphTransform *= Affine.NewScaling(currentEmScaling);
				IVertexSource characterGlyph = new VertexSourceApplyTransform(sourceGlyph, glyphTransform);

				if (FlattenCurves)
				{
					characterGlyph = new FlattenCurves(characterGlyph)
					{
						ResolutionScale = resolutionScale
					};
				}

				return characterGlyph;
			}

			return null;
		}

		public double GetAdvanceForCharacter(string line, int characterIndex)
		{
			if (characterIndex < line.Length - 1)
			{
				// pass the next char so the typeFaceStyle can do kerning if it needs to.
				return GetAdvanceForCharacter(line[characterIndex], line[characterIndex + 1]);
			}
			else
			{
				return GetAdvanceForCharacter(line[characterIndex]);
			}
		}

		public double GetAdvanceForCharacter(char character, char nextCharacterToKernWith)
		{
			return TypeFace.GetAdvanceForCharacter(character, nextCharacterToKernWith) * currentEmScaling;
		}

		public double GetAdvanceForCharacter(char character)
		{
			return TypeFace.GetAdvanceForCharacter(character) * currentEmScaling;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Font\TextWrapping.cs
using MatterHackers.Agg.Platform;
using System;
using System.Collections.Generic;
using System.Text;

namespace MatterHackers.Agg.Font
{
	abstract public class TextWrapping
	{
		protected StyledTypeFace styledTypeFace;

		// you can't
		public TextWrapping(StyledTypeFace styledTypeFace)
		{
			this.styledTypeFace = styledTypeFace;
		}

		public string InsertCRs(string textToWrap, double maxPixelWidth, int wrappingIndentSpaces = 0)
		{
			StringBuilder textWithCRs = new StringBuilder();
			List<string> lines = WrapText(textToWrap, maxPixelWidth, wrappingIndentSpaces);
			for (int i = 0; i < lines.Count; i++)
			{
				string line = lines[i];
				if (i > 0)
				{
					// add a newline and the right number of spaces
					textWithCRs.Append("\n");
				}

				textWithCRs.Append(line);
			}

			return textWithCRs.ToString();
		}

		public List<string> WrapText(string textToWrap, double maxPixelWidth, int wrappingIndentSpaces = 0)
		{
			List<string> finalLines = new List<string>();
			string[] splitOnNL = textToWrap.Split('\n');
			foreach (string line in splitOnNL)
			{
				List<string> linesFromWidth = WrapSingleLineOnWidth(line, maxPixelWidth);
				var first = true;
				foreach (var lineFromWidth in linesFromWidth)
				{
					if (first)
					{
						first = false;
						finalLines.Add(lineFromWidth);
					}
					else
                    {
                        finalLines.Add(new string(' ', wrappingIndentSpaces) + lineFromWidth);
                    }
				}
			}

			return finalLines;
		}

		abstract public List<string> WrapSingleLineOnWidth(string originalTextToWrap, double maxPixelWidth);
	}

	public class EnglishTextWrapping : TextWrapping
	{
		public EnglishTextWrapping(StyledTypeFace styledTypeFace)
			: base(styledTypeFace)
		{
		}

		public EnglishTextWrapping(double pointSize)
			: base(new StyledTypeFace(AggContext.DefaultFont, pointSize))
		{
		}

		bool HasSpaceBeforeIndex(string stringToCheck, int endOfChecking)
		{
			for (int i = Math.Min(endOfChecking, stringToCheck.Length - 1); i >= 0; i--)
			{
				if (stringToCheck[i] == ' ')
				{
					return true;
				}
			}

			return false;
		}

		public override List<string> WrapSingleLineOnWidth(string originalTextToWrap, double maxPixelWidth)
		{
			List<string> lines = new List<string>();

			if (maxPixelWidth > 0
				&& originalTextToWrap.Length > 0)
			{
				string textToWrap = originalTextToWrap;
				TypeFacePrinter printer = new TypeFacePrinter(textToWrap, styledTypeFace);
				while (textToWrap.Length > 0)
				{
					printer.Text = textToWrap;
					int countBeforeWrap;

					double currentLength = 0;
					for (countBeforeWrap = 0; countBeforeWrap < printer.Text.Length; countBeforeWrap++)
					{
						if (currentLength > maxPixelWidth)
						{
							break;
						}
						currentLength += printer.TypeFaceStyle.GetAdvanceForCharacter(textToWrap, countBeforeWrap);
					}

					while (printer.GetOffsetLeftOfCharacterIndex(countBeforeWrap).X > maxPixelWidth
						&& countBeforeWrap > 1)
					{
						// now trim back to the last break
						countBeforeWrap--;
						while (countBeforeWrap > 1
							&& HasSpaceBeforeIndex(textToWrap, countBeforeWrap)
							&& textToWrap[countBeforeWrap] != ' ')
						{
							countBeforeWrap--;
						}
					}

					if (countBeforeWrap >= 0)
					{
						lines.Add(textToWrap.Substring(0, countBeforeWrap));
					}

					// check if we wrapped because of too long or a '\n'. If '\n' we only trim a leading space if too long.
					if (countBeforeWrap > 1 // we have more than 2 characters left
						&& textToWrap.Length > countBeforeWrap // we are longer than the remaining text
						&& textToWrap[countBeforeWrap] == ' ' // the first new character is a space
						&& textToWrap[countBeforeWrap - 1] != '\n') // the character before the space was not a cr (wrapped because of length)
					{
						textToWrap = textToWrap.Substring(countBeforeWrap + 1);
					}
					else
					{
						textToWrap = textToWrap.Substring(countBeforeWrap);
					}
				}
			}
			else
			{
				lines.Add(originalTextToWrap);
			}

			return lines;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Font\TypeFace.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007-2011
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using MatterHackers.Agg.SvgTools;
using MatterHackers.Agg.Transform;
using MatterHackers.Agg.VertexSource;
using MatterHackers.VectorMath;

namespace MatterHackers.Agg.Font
{
	public class TypeFace
	{
		private class Glyph
		{
			public int horiz_adv_x;
			public int unicode;
			public string glyphName;
			public IVertexSource glyphData = new VertexStorage();
		}

		private class Panos_1
		{
			// these are defined in the order in which they are present in the panos-1 attribute.
			private enum Family { Any, No_Fit, Latin_Text_and_Display, Latin_Script, Latin_Decorative, Latin_Pictorial };

			private enum Serif_Style { Any, No_Fit, Cove, Obtuse_Cove, Square_Cove, Obtuse_Square_Cove, Square, Thin, Bone, Exaggerated, Triangle, Normal_Sans, Obtuse_Sans, Perp_Sans, Flared, Rounded };

			private enum Weight { Any, No_Fit, Very_Light_100, Light_200, Thin_300, Book_400_same_as_CSS1_normal, Medium_500, Demi_600, Bold_700_same_as_CSS1_bold, Heavy_800, Black_900, Extra_Black_Nord_900_force_mapping_to_CSS1_100_900_scale };

			private enum Proportion { Any, No_Fit, Old_Style, Modern, Even_Width, Expanded, Condensed, Very_Expanded, Very_Condensed, Monospaced };

			private enum Contrast { Any, No_Fit, None, Very_Low, Low, Medium_Low, Medium, Medium_High, High, Very_High };

			private enum Stroke_Variation { Any, No_Fit, No_Variation, Gradual_Diagonal, Gradual_Transitional, Gradual_Vertical, Gradual_Horizontal, Rapid_Vertical, Rapid_Horizontal, Instant_Horizontal, Instant_Vertical };

			private enum Arm_Style { Any, No_Fit, Straight_Arms_Horizontal, Straight_Arms_Wedge, Straight_Arms_Vertical, Straight_Arms_Single_Serif, Straight_Arms_Double_Serif, Non_Straight_Arms_Horizontal, Non_Straight_Arms_Wedge, Non_Straight_Arms_Vertical_90, Non_Straight_Arms_Single_Serif, Non_Straight_Arms_Double_Serif };

			private enum Letterform { Any, No_Fit, Normal_Contact, Normal_Weighted, Normal_Boxed, Normal_Flattened, Normal_Rounded, Normal_Off_Center, Normal_Square, Oblique_Contact, Oblique_Weighted, Oblique_Boxed, Oblique_Flattened, Oblique_Rounded, Oblique_Off_Center, Oblique_Square };

			private enum Midline { Any, No_Fit, Standard_Trimmed, Standard_Pointed, Standard_Serifed, High_Trimmed, High_Pointed, High_Serifed, Constant_Trimmed, Constant_Pointed, Constant_Serifed, Low_Trimmed, Low_Pointed, Low_Serifed };

			private enum XHeight { Any, No_Fit, Constant_Small, Constant_Standard, Constant_Large, Ducking_Small, Ducking_Standard, Ducking_Large };

			private Family family;
			private Serif_Style serifStyle;
			private Weight weight;
			private Proportion proportion;
			private Contrast contrast;
			private Stroke_Variation strokeVariation;
			private Arm_Style armStyle;
			private Letterform letterform;
			private Midline midline;
			private XHeight xHeight;

			public Panos_1(string SVGPanos1String)
			{
				int tempInt;
				string[] valuesString = SVGPanos1String.Split(' ');
				if (int.TryParse(valuesString[0], out tempInt))
					family = (Family)tempInt;
				if (int.TryParse(valuesString[1], out tempInt))
					serifStyle = (Serif_Style)tempInt;
				if (int.TryParse(valuesString[2], out tempInt))
					weight = (Weight)tempInt;
				if (int.TryParse(valuesString[3], out tempInt))
					proportion = (Proportion)tempInt;
				if (int.TryParse(valuesString[4], out tempInt))
					contrast = (Contrast)tempInt;
				if (int.TryParse(valuesString[5], out tempInt))
					strokeVariation = (Stroke_Variation)tempInt;
				if (int.TryParse(valuesString[6], out tempInt))
					armStyle = (Arm_Style)tempInt;
				if (int.TryParse(valuesString[7], out tempInt))
					letterform = (Letterform)tempInt;
				if (int.TryParse(valuesString[8], out tempInt))
					midline = (Midline)tempInt;
				if (int.TryParse(valuesString[0], out tempInt))
					xHeight = (XHeight)tempInt;
			}
		}


		Typography.OpenFont.Typeface _ofTypeface;

		private string fontId;
		private int horiz_adv_x;
		private string fontFamily;
		private int font_weight;
		private string font_stretch;
		private int unitsPerEm;
		private Panos_1 panose_1;
		private int ascent;

		public int Ascent { get { return ascent; } }

		private int descent;

		public int Descent { get { return descent; } }

		private int x_height;

		public int X_height { get { return x_height; } }

		private int cap_height;

		public int Cap_height { get { return cap_height; } }

		private RectangleInt boundingBox;

		public RectangleInt BoundingBox { get { return boundingBox; } }

		private int underline_thickness;

		public int Underline_thickness { get { return underline_thickness; } }

		private int underline_position;

		public int Underline_position { get { return underline_position; } }

		private string unicode_range;

		private Glyph missingGlyph;

		private Dictionary<int, Glyph> glyphs = new Dictionary<int, Glyph>(); // a glyph is indexed by the string it represents, usually one character, but sometimes multiple
		private Dictionary<char, Dictionary<char, int>> HKerns = new Dictionary<char, Dictionary<char, int>>();

		public int UnitsPerEm
		{
			get
			{
				return unitsPerEm;
			}
		}

		private static string GetSubString(string source, string start, string end)
		{
			int startIndex = 0;
			return GetSubString(source, start, end, ref startIndex);
		}

		private static string GetSubString(string source, string start, string end, ref int startIndex)
		{
			int startPos = source.IndexOf(start, startIndex);
			if (startPos >= 0)
			{
				int endPos = source.IndexOf(end, startPos + start.Length);

				int length = endPos - (startPos + start.Length);
				startIndex = endPos + end.Length; // advance our start position to the last position used
				return source.Substring(startPos + start.Length, length);
			}

			return null;
		}

		private static string GetStringValue(string source, string name)
		{
			string element = GetSubString(source, name + "=\"", "\"");
			return element;
		}

		private static bool GetIntValue(string source, string name, out int outValue, ref int startIndex)
		{
			string element = GetSubString(source, name + "=\"", "\"", ref startIndex);
			if (int.TryParse(element, NumberStyles.Number, null, out outValue))
			{
				return true;
			}

			return false;
		}

		private static bool GetIntValue(string source, string name, out int outValue)
		{
			int startIndex = 0;
			return GetIntValue(source, name, out outValue, ref startIndex);
		}

		public static TypeFace LoadFrom(string content)
		{
			var fontUnderConstruction = new TypeFace();
			fontUnderConstruction.ReadSVG(content);

			return fontUnderConstruction;
		}

		public void LoadTTF(string filename)
		{
			using (var fs = new FileStream(filename, FileMode.Open))
			{
				LoadTTF(fs);
			}
		}

		public bool LoadTTF(Stream stream)
		{
			var reader = new Typography.OpenFont.OpenFontReader();
			_ofTypeface = reader.Read(stream);
			if (_ofTypeface != null)
			{
				this.ascent = _ofTypeface.Ascender;
				this.descent = _ofTypeface.Descender;
				this.unitsPerEm = _ofTypeface.UnitsPerEm;
				this.underline_position = _ofTypeface.UnderlinePosition;
				var bounds = _ofTypeface.Bounds;
				this.boundingBox = new RectangleInt(bounds.XMin, bounds.YMin, bounds.XMax, bounds.YMax);
				return true;
			}

			return false;
		}

		public static TypeFace LoadSVG(string filename)
		{
			var fontUnderConstruction = new TypeFace();

			string svgContent = "";
			using (var fileStream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
			{
				using (var reader = new StreamReader(fileStream))
				{
					svgContent = reader.ReadToEnd();
				}
			}
			fontUnderConstruction.ReadSVG(svgContent);

			return fontUnderConstruction;
		}

		private Glyph CreateGlyphFromSVGGlyphData(string SVGGlyphData)
		{
			var newGlyph = new Glyph();
			if (!GetIntValue(SVGGlyphData, "horiz-adv-x", out newGlyph.horiz_adv_x))
			{
				newGlyph.horiz_adv_x = horiz_adv_x;
			}

			newGlyph.glyphName = GetStringValue(SVGGlyphData, "glyph-name");
			string unicodeString = GetStringValue(SVGGlyphData, "unicode");

			if (unicodeString != null)
			{
				if (unicodeString.Length == 1)
				{
					newGlyph.unicode = (int)unicodeString[0];
				}
				else
				{
					if (unicodeString.Split(';').Length > 1 && unicodeString.Split(';')[1].Length > 0)
					{
						throw new NotImplementedException("We do not currently support glyphs longer than one character.  You need to write the search so that it will find them if you want to support this");
					}

					if (int.TryParse(unicodeString, NumberStyles.Number, null, out newGlyph.unicode) == false)
					{
						// see if it is a unicode
						string hexNumber = GetSubString(unicodeString, "&#x", ";");
						int.TryParse(hexNumber, NumberStyles.HexNumber, null, out newGlyph.unicode);
					}
				}
			}

			string dString = GetStringValue(SVGGlyphData, "d");

			if (dString == null || dString.Length == 0)
			{
				return newGlyph;
			}

			if (newGlyph.glyphData is VertexStorage storage)
			{
                storage.ParseSvgDString(dString);
			}

			return newGlyph;
		}

		public void ReadSVG(string svgContent)
		{
			int startIndex = 0;
			string fontElementString = GetSubString(svgContent, "<font", ">", ref startIndex);
			fontId = GetStringValue(fontElementString, "id");
			GetIntValue(fontElementString, "horiz-adv-x", out horiz_adv_x);

			string fontFaceString = GetSubString(svgContent, "<font-face", "/>", ref startIndex);
			fontFamily = GetStringValue(fontFaceString, "font-family");
			GetIntValue(fontFaceString, "font-weight", out font_weight);
			font_stretch = GetStringValue(fontFaceString, "font-stretch");
			GetIntValue(fontFaceString, "units-per-em", out unitsPerEm);
			panose_1 = new Panos_1(GetStringValue(fontFaceString, "panose-1"));
			GetIntValue(fontFaceString, "ascent", out ascent);
			GetIntValue(fontFaceString, "descent", out descent);
			GetIntValue(fontFaceString, "x-height", out x_height);
			GetIntValue(fontFaceString, "cap-height", out cap_height);

			String bboxString = GetStringValue(fontFaceString, "bbox");
			String[] valuesString = bboxString.Split(' ');
			int.TryParse(valuesString[0], out boundingBox.Left);
			int.TryParse(valuesString[1], out boundingBox.Bottom);
			int.TryParse(valuesString[2], out boundingBox.Right);
			int.TryParse(valuesString[3], out boundingBox.Top);

			GetIntValue(fontFaceString, "underline-thickness", out underline_thickness);
			GetIntValue(fontFaceString, "underline-position", out underline_position);
			unicode_range = GetStringValue(fontFaceString, "unicode-range");

			string missingGlyphString = GetSubString(svgContent, "<missing-glyph", "/>", ref startIndex);
			missingGlyph = CreateGlyphFromSVGGlyphData(missingGlyphString);

			string nextGlyphString = GetSubString(svgContent, "<glyph", "/>", ref startIndex);
			while (nextGlyphString != null)
			{
				// get the data and put it in the glyph dictionary
				Glyph newGlyph = CreateGlyphFromSVGGlyphData(nextGlyphString);
				if (newGlyph.unicode > 0)
				{
					glyphs.Add(newGlyph.unicode, newGlyph);
				}

				nextGlyphString = GetSubString(svgContent, "<glyph", "/>", ref startIndex);
			}
		}

		internal IVertexSource GetGlyphForCharacter(char character)
		{
			if (_ofTypeface != null)
			{
				// TODO: MAKE SURE THIS IS OFF!!!!!!! It is un-needed and only for debugging
				//glyphs.Clear();
			}

			// TODO: check for multi character glyphs (we don't currently support them in the reader).
			return GetGlyph(character)?.glyphData;
		}

		private Glyph GetGlyph(char character)
		{
			Glyph glyph;

			lock (glyphs)
			{
				if (!glyphs.TryGetValue(character, out glyph))
				{
					// if we have a loaded ttf try to create the glyph data
					if (_ofTypeface != null)
					{
						var storage = new VertexStorage();
						var translator = new VertexSourceGlyphTranslator(storage);
						var glyphIndex = _ofTypeface.GetGlyphIndex(character);
						var ttfGlyph = _ofTypeface.GetGlyph(glyphIndex);
						//
						Typography.OpenFont.IGlyphReaderExtensions.Read(translator, ttfGlyph.GlyphPoints, ttfGlyph.EndPoints);

						//
						glyph = new Glyph();
						glyph.unicode = character;
						glyph.horiz_adv_x = _ofTypeface.GetHAdvanceWidthFromGlyphIndex(glyphIndex);

						glyphs.Add(character, glyph);

						// Wrap glyph data with ClosedLoopGlyphData to ensure all loops are correctly closed
						glyph.glyphData = new ClosedLoopGlyphData(storage);
					}
				}
			}

			return glyph;
		}

		/// <summary>
		/// Ensure all MoveTo operations are preceded by ClosePolygon commands
		/// </summary>
		private class ClosedLoopGlyphData : IVertexSource
		{
			private VertexStorage storage;

			public ClosedLoopGlyphData(VertexStorage source)
			{
				storage = new VertexStorage();

				var vertexData = source.Vertices().Where(v => v.Command != FlagsAndCommand.FlagNone).ToArray();

				var previous = default(VertexData);

				for (var i = 0; i < vertexData.Length; i++)
				{
					var current = vertexData[i];

					// All MoveTo operations should be preceded by ClosePolygon 
					if (i > 0 &&
						current.IsMoveTo
						&& ShapePath.IsVertex(previous.Command))
					{
						storage.ClosePolygon();
					}

					// Add original VertexData
					storage.Add(current.Position.X, current.Position.Y, current.Command);

					// Hold prior item
					previous = current;
				}

				// Ensure closed
				storage.ClosePolygon();
			}

            public ulong GetLongHashCode(ulong hash = 14695981039346656037)
            {
                foreach (var vertex in this.Vertices())
                {
                    hash = vertex.GetLongHashCode(hash);
                }

                return hash;
            }

            public void Rewind(int pathId = 0)
			{
				storage.Rewind(pathId);
			}

			public FlagsAndCommand Vertex(out double x, out double y)
			{
				return storage.Vertex(out x, out y);
			}

			public IEnumerable<VertexData> Vertices()
			{
				return storage.Vertices();
			}
		}

		internal int GetAdvanceForCharacter(char character, char nextCharacterToKernWith)
		{
			// TODO: check for kerning and adjust
			Glyph glyph = GetGlyph(character);
			if (glyph != null)
			{
				return glyph.horiz_adv_x;
			}

			return 0;
		}

		internal int GetAdvanceForCharacter(char character)
		{
			Glyph glyph = GetGlyph(character);
			if (glyph != null)
			{
				return glyph.horiz_adv_x;
			}

			return 0;
		}

		public void ShowDebugInfo(Graphics2D graphics2D)
		{
			Color boundingBoxColor = new Color(0, 0, 0);
			var typeFaceNameStyle = new StyledTypeFace(this, 50);
			var fontNamePrinter = new TypeFacePrinter(this.fontFamily + " - 50 point", typeFaceNameStyle);

			double x = 30 + typeFaceNameStyle.EmSizeInPoints * 1.5;
			double y = 40 - typeFaceNameStyle.DescentInPixels;
			int width = 150;
			var originColor = new Color(0, 0, 0);
			var ascentColor = new Color(255, 0, 0);
			var descentColor = new Color(255, 0, 0);
			var xHeightColor = new Color(12, 25, 200);
			var capHeightColor = new Color(12, 25, 200);
			var underlineColor = new Color(0, 150, 55);

			// the origin
			RectangleDouble bounds = typeFaceNameStyle.BoundingBoxInPixels;
			graphics2D.Rectangle(x + bounds.Left, y + bounds.Bottom, x + bounds.Right, y + bounds.Top, boundingBoxColor);
			graphics2D.Line(x - 10, y, x + width / 2, y, originColor);

			double temp = typeFaceNameStyle.AscentInPixels;
			graphics2D.Line(x, y + temp, x + width, y + temp, ascentColor);

			temp = typeFaceNameStyle.DescentInPixels;
			graphics2D.Line(x, y + temp, x + width, y + temp, descentColor);

			temp = typeFaceNameStyle.XHeightInPixels;
			graphics2D.Line(x, y + temp, x + width, y + temp, xHeightColor);

			temp = typeFaceNameStyle.CapHeightInPixels;
			graphics2D.Line(x, y + temp, x + width, y + temp, capHeightColor);

			temp = typeFaceNameStyle.UnderlinePositionInPixels;
			graphics2D.Line(x, y + temp, x + width, y + temp, underlineColor);

			Affine textTransform;
			textTransform = Affine.NewIdentity();
			textTransform *= Affine.NewTranslation(x, y);

			var transformedText = new VertexSourceApplyTransform(textTransform);
			fontNamePrinter.Render(graphics2D, Color.Black, transformedText);

			graphics2D.Render(transformedText, Color.Black);

			// render the legend
			var legendFont = new StyledTypeFace(this, 12);
			var textPos = new Vector2(x + width / 2, y + typeFaceNameStyle.EmSizeInPixels * 1.5);
			graphics2D.Render(new TypeFacePrinter("Bounding Box"), textPos, boundingBoxColor);
			textPos.Y += legendFont.EmSizeInPixels;
			graphics2D.Render(new TypeFacePrinter("Descent"), textPos, descentColor);
			textPos.Y += legendFont.EmSizeInPixels;
			graphics2D.Render(new TypeFacePrinter("Underline"), textPos, underlineColor);
			textPos.Y += legendFont.EmSizeInPixels;
			graphics2D.Render(new TypeFacePrinter("Origin"), textPos, originColor);
			textPos.Y += legendFont.EmSizeInPixels;
			graphics2D.Render(new TypeFacePrinter("X Height"), textPos, xHeightColor);
			textPos.Y += legendFont.EmSizeInPixels;
			graphics2D.Render(new TypeFacePrinter("CapHeight"), textPos, capHeightColor);
			textPos.Y += legendFont.EmSizeInPixels;
			graphics2D.Render(new TypeFacePrinter("Ascent"), textPos, ascentColor);
			textPos.Y += legendFont.EmSizeInPixels;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Font\TypeFacePrinter.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007-2011
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
//
// Class StringPrinter.cs
//
// Class to output the vertex source of a string as a run of glyphs.
//----------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using MatterHackers.Agg.Image;
using MatterHackers.Agg.Platform;
using MatterHackers.Agg.VertexSource;
using MatterHackers.VectorMath;

namespace MatterHackers.Agg.Font
{
	public enum Justification
	{
		Left,
		Center,
		Right
	}

	public enum Baseline
	{
		BoundsTop,
		BoundsCenter,
		TextCenter,
		Text,
		BoundsBottom
	}

	public class TypeFacePrinter : VertexSourceLegacySupport
	{
		private string text = "";

		private Vector2 totalSizeCache;

		public Justification Justification { get; set; }

		public Baseline Baseline { get; set; }

		public bool DrawFromHintedCache { get; set; }

		private StyledTypeFace typeFaceStyle;

		public StyledTypeFace TypeFaceStyle
		{
			get
			{
				return typeFaceStyle;
			}

			set
			{
				if (value != typeFaceStyle)
				{
					typeFaceStyle = value;
					totalSizeCache = default(Vector2);
				}
			}
		}

		public string Text
		{
			get
			{
				return text;
			}

			set
			{
				if (text != value)
				{
					totalSizeCache.X = 0;
					text = value;
				}
			}
		}

		public Vector2 Origin { get; set; }

		public double ResolutionScale { get; set; } = 1;

		public TypeFacePrinter(string text = "", double pointSize = 12, Vector2 origin = default(Vector2), Justification justification = Justification.Left, Baseline baseline = Baseline.Text, bool bold = false)
			: this(text,
				  bold ? new StyledTypeFace(AggContext.DefaultFontBold, pointSize) : new StyledTypeFace(AggContext.DefaultFont, pointSize),
				  origin,
				  justification,
				  baseline)
		{
		}

		public TypeFacePrinter(string text, StyledTypeFace typeFaceStyle, Vector2 origin = default(Vector2), Justification justification = Justification.Left, Baseline baseline = Baseline.Text)
		{
			this.TypeFaceStyle = typeFaceStyle;
			this.text = text;
			this.Justification = justification;
			this.Origin = origin;
			this.Baseline = baseline;
		}

		public TypeFacePrinter(string text, TypeFacePrinter copyPropertiesFrom)
			: this(text, copyPropertiesFrom.TypeFaceStyle, copyPropertiesFrom.Origin, copyPropertiesFrom.Justification, copyPropertiesFrom.Baseline)
		{
		}

		public RectangleDouble LocalBounds
		{
			get
			{
				Vector2 size = GetSize();
				RectangleDouble bounds;

				switch (Justification)
				{
					case Justification.Left:
						bounds = new RectangleDouble(0, TypeFaceStyle.DescentInPixels, size.X, size.Y + TypeFaceStyle.DescentInPixels);
						break;

					case Justification.Center:
						bounds = new RectangleDouble(-size.X / 2, TypeFaceStyle.DescentInPixels, size.X / 2, size.Y + TypeFaceStyle.DescentInPixels);
						break;

					case Justification.Right:
						bounds = new RectangleDouble(-size.X, TypeFaceStyle.DescentInPixels, 0, size.Y + TypeFaceStyle.DescentInPixels);
						break;

					default:
						throw new NotImplementedException();
				}

				switch (Baseline)
				{
					case Font.Baseline.BoundsCenter:
						bounds.Offset(0, -TypeFaceStyle.AscentInPixels / 2);
						break;

					default:
						break;
				}

				bounds.Offset(Origin);
				return bounds;
			}
		}

		public void Render(Graphics2D graphics2D, Color color, IVertexSourceProxy vertexSourceToApply)
		{
			vertexSourceToApply.VertexSource = this;
			Rewind(0);
			if (DrawFromHintedCache)
			{
				// TODO: make this work
				graphics2D.Render(vertexSourceToApply, color);
			}
			else
			{
				graphics2D.Render(vertexSourceToApply, color);
			}
		}

		public void Render(Graphics2D graphics2D, Color color)
		{
			if (DrawFromHintedCache)
			{
				RenderFromCache(graphics2D, color);
			}
			else
			{
				Rewind(0);
				graphics2D.Render(this, color);
			}
		}

		private void RenderFromCache(Graphics2D graphics2D, Color color)
		{
			if (text != null && text.Length > 0)
			{
				Vector2 currentOffset = Vector2.Zero;

				currentOffset = GetBaseline(currentOffset);
				// remove the decent and 1 pixel that were put into the cache image to give space for descenders
				currentOffset.Y += Origin.Y + TypeFaceStyle.DescentInPixels - 1;

				string[] lines = text.Split('\n');
				var transformX = graphics2D.GetTransform().tx;
                foreach (string line in lines)
				{
					currentOffset = GetXPositionForLineBasedOnJustification(currentOffset, line);
					currentOffset.X += Origin.X;

					for (int currentChar = 0; currentChar < line.Length; currentChar++)
					{
						ImageBuffer currentGlyphImage = TypeFaceStyle.GetImageForCharacter(line[currentChar], 0, 0, color);

						if (currentGlyphImage != null)
						{
							if (transformX + currentOffset.X < graphics2D.Width)
							{
								graphics2D.Render(currentGlyphImage, currentOffset);
							}
						}

						// get the advance for the next character
						currentOffset.X += TypeFaceStyle.GetAdvanceForCharacter(line, currentChar);
					}

					// before we go onto the next line we need to move down a line
					currentOffset.X = 0;
					currentOffset.Y -= TypeFaceStyle.EmSizeInPixels;
				}
			}
		}

		public override IEnumerable<VertexData> Vertices()
		{
			if (text != null && text.Length > 0)
			{
				var currentOffset = new Vector2(0, 0);

				currentOffset = GetBaseline(currentOffset);

				string[] lines = text.Split('\n');
				foreach (string line in lines)
				{
					currentOffset = GetXPositionForLineBasedOnJustification(currentOffset, line);

					for (int currentChar = 0; currentChar < line.Length; currentChar++)
					{
						IVertexSource currentGlyph = TypeFaceStyle.GetGlyphForCharacter(line[currentChar], ResolutionScale);

						if (currentGlyph != null)
						{
							foreach (VertexData vertexData in currentGlyph.Vertices())
							{
								if (vertexData.Command != FlagsAndCommand.Stop)
								{
									var offsetVertex = new VertexData(vertexData.Command, vertexData.Position + currentOffset + Origin);
									yield return offsetVertex;
								}
							}
						}

						// get the advance for the next character
						currentOffset.X += TypeFaceStyle.GetAdvanceForCharacter(line, currentChar);
					}

					// before we go onto the next line we need to move down a line
					currentOffset.X = 0;
					currentOffset.Y -= TypeFaceStyle.EmSizeInPixels;
				}
			}

			var endVertex = new VertexData(FlagsAndCommand.Stop, Vector2.Zero);
			yield return endVertex;
		}

		private Vector2 GetXPositionForLineBasedOnJustification(Vector2 currentOffset, string line)
		{
			Vector2 size = GetSize(line);
			switch (Justification)
			{
				case Justification.Left:
					currentOffset.X = 0;
					break;

				case Justification.Center:
					currentOffset.X = -size.X / 2;
					break;

				case Justification.Right:
					currentOffset.X = -size.X;
					break;

				default:
					throw new NotImplementedException();
			}

			return currentOffset;
		}

		private Vector2 GetBaseline(Vector2 currentOffset)
		{
			switch (Baseline)
			{
				case Baseline.Text:
					currentOffset.Y = 0;
					break;

				case Baseline.BoundsTop:
					currentOffset.Y = -TypeFaceStyle.AscentInPixels;
					break;

				case Baseline.BoundsCenter:
					currentOffset.Y = -TypeFaceStyle.AscentInPixels / 2;
					break;

				default:
					throw new NotImplementedException();
			}

			return currentOffset;
		}

		public Vector2 GetSize(string text = null)
		{
			if (text == null)
			{
				text = this.text;
			}

			if (text != this.text)
			{
				GetSize(0, Math.Max(0, text.Length - 1), out Vector2 calculatedSize, text);
				return calculatedSize;
			}

			if (totalSizeCache.X == 0
				&& text != null)
			{
				GetSize(0, Math.Max(0, text.Length - 1), out Vector2 calculatedSize, text);
				totalSizeCache = calculatedSize;
			}

			return totalSizeCache;
		}

		public void GetSize(int characterToMeasureStartIndexInclusive, int characterToMeasureEndIndexInclusive, out Vector2 offset, string text = null)
		{
			if (text == null)
			{
				text = this.text;
			}

			offset.X = 0;
			offset.Y = TypeFaceStyle.EmSizeInPixels;

			double currentLineX = 0;

			for (int i = characterToMeasureStartIndexInclusive; i < characterToMeasureEndIndexInclusive; i++)
			{
				if (text[i] == '\n')
				{
					if (i + 1 < characterToMeasureEndIndexInclusive && (text[i + 1] == '\n') && text[i] != text[i + 1])
					{
						i++;
					}

					currentLineX = 0;
					offset.Y += TypeFaceStyle.EmSizeInPixels;
				}
				else
				{
					currentLineX += TypeFaceStyle.GetAdvanceForCharacter(text, i);

					if (currentLineX > offset.X)
					{
						offset.X = currentLineX;
					}
				}
			}

			if (text.Length > characterToMeasureEndIndexInclusive)
			{
				if (text[characterToMeasureEndIndexInclusive] == '\n')
				{
					offset.Y += TypeFaceStyle.EmSizeInPixels;
				}
				else
				{
					offset.X += TypeFaceStyle.GetAdvanceForCharacter(text, characterToMeasureEndIndexInclusive);
				}
			}
		}

		public int NumLines()
		{
			int characterToMeasureStartIndexInclusive = 0;
			int characterToMeasureEndIndexInclusive = text.Length - 1;
			return NumLines(characterToMeasureStartIndexInclusive, characterToMeasureEndIndexInclusive);
		}

		public int NumLines(int characterToMeasureStartIndexInclusive, int characterToMeasureEndIndexInclusive)
		{
			int numLines = 1;

			characterToMeasureStartIndexInclusive = Math.Max(0, Math.Min(characterToMeasureStartIndexInclusive, text.Length - 1));
			characterToMeasureEndIndexInclusive = Math.Max(-1, Math.Min(characterToMeasureEndIndexInclusive, text.Length - 1));
			for (int i = characterToMeasureStartIndexInclusive; i <= characterToMeasureEndIndexInclusive; i++)
			{
				if (text[i] == '\n')
				{
					numLines++;
				}
			}

			return numLines;
		}

		private Dictionary<char, double> fastAdvance = new Dictionary<char, double>();

		public void GetOffset(int characterToMeasureStartIndexInclusive, int characterToMeasureEndIndexInclusive, out Vector2 offset)
		{
			offset = Vector2.Zero;

			characterToMeasureEndIndexInclusive = Math.Min(text.Length - 1, characterToMeasureEndIndexInclusive);

			var startIndex = characterToMeasureStartIndexInclusive;
			// find the first '\n' before the characterIndex
			for (int i = characterToMeasureStartIndexInclusive; i <= characterToMeasureEndIndexInclusive; i++)
			{
				if (text[i] == '\n')
				{
					startIndex = i + 1;
					offset.Y -= TypeFaceStyle.EmSizeInPixels;
				}
			}
			characterToMeasureStartIndexInclusive = startIndex;

			for (int index = characterToMeasureStartIndexInclusive; index <= characterToMeasureEndIndexInclusive; index++)
			{
				if (text[index] == '\n')
				{
					offset.X = 0;
					offset.Y -= TypeFaceStyle.EmSizeInPixels;
				}
				else
				{
					if (!fastAdvance.ContainsKey(text[index]))
					{
						fastAdvance[text[index]] = TypeFaceStyle.GetAdvanceForCharacter(text, index);
					}

					offset.X += fastAdvance[text[index]];
				}
			}
		}

		// this will return the position to the left of the requested character.
		public Vector2 GetOffsetLeftOfCharacterIndex(int characterIndex)
		{
			GetOffset(0, characterIndex - 1, out Vector2 offset);
			return offset;
		}

		// If the Text is "TEXT" and the position is less than half the distance to the center
		// of "T" the return value will be 0 if it is between the center of 'T' and the center of 'E'
		// it will be 1 and so on.
		public int GetCharacterIndexToStartBefore(Vector2 position)
		{
			int clostestIndex = -1;
			double clostestXDistSquared = double.MaxValue;
			double clostestYDistSquared = double.MaxValue;
			var offset = new Vector2(0, TypeFaceStyle.EmSizeInPixels * NumLines() - TypeFaceStyle.EmSizeInPixels * .5);
			int characterToMeasureStartIndexInclusive = 0;
			int characterToMeasureEndIndexInclusive = text.Length - 1;
			if (text.Length > 0)
			{
				characterToMeasureStartIndexInclusive = Math.Max(0, Math.Min(characterToMeasureStartIndexInclusive, text.Length - 1));
				characterToMeasureEndIndexInclusive = Math.Max(0, Math.Min(characterToMeasureEndIndexInclusive, text.Length - 1));
				for (int i = characterToMeasureStartIndexInclusive; i <= characterToMeasureEndIndexInclusive; i++)
				{
					CheckForBetterClickPosition(ref position, ref clostestIndex, ref clostestXDistSquared, ref clostestYDistSquared, ref offset, i);

					if (text[i] == '\r')
					{
						throw new Exception("All \\r's should have been converted to \\n's.");
					}

					if (text[i] == '\n')
					{
						offset.X = 0;
						offset.Y -= TypeFaceStyle.EmSizeInPixels;
					}
					else
					{
						GetOffset(i, i, out Vector2 nextSize);

						offset.X += nextSize.X;
					}
				}

				CheckForBetterClickPosition(ref position, ref clostestIndex, ref clostestXDistSquared, ref clostestYDistSquared, ref offset, characterToMeasureEndIndexInclusive + 1);
			}

			return clostestIndex;
		}

		private static void CheckForBetterClickPosition(ref Vector2 position, ref int clostestIndex, ref double clostestXDistSquared, ref double clostestYDistSquared, ref Vector2 offset, int i)
		{
			Vector2 delta = position - offset;
			double deltaYLengthSquared = delta.Y * delta.Y;
			if (deltaYLengthSquared < clostestYDistSquared)
			{
				clostestYDistSquared = deltaYLengthSquared;
				clostestXDistSquared = delta.X * delta.X;
				clostestIndex = i;
			}
			else if (deltaYLengthSquared == clostestYDistSquared)
			{
				double deltaXLengthSquared = delta.X * delta.X;
				if (deltaXLengthSquared < clostestXDistSquared)
				{
					clostestXDistSquared = deltaXLengthSquared;
					clostestIndex = i;
				}
			}
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Font\VertexSourceGlyphTranslator.cs
using MatterHackers.Agg.VertexSource;
using MatterHackers.VectorMath;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007-2011
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
//
// Class TypeFace.cs
//
//----------------------------------------------------------------------------
using Typography.OpenFont;

namespace MatterHackers.Agg.Font
{
	public class VertexSourceGlyphTranslator : IGlyphTranslator
	{
		private int polygonStartIndex = 0;
		private VertexStorage vertexStorage;
		Vector2 curve3Control = new Vector2(double.MinValue, double.MinValue);

		public VertexSourceGlyphTranslator(VertexStorage vertexStorage)
		{
			this.vertexStorage = vertexStorage;
		}

		public void BeginRead(int contourCount)
		{
		}

		private void CheckForOpenCurve3()
		{
			if (curve3Control.X != double.MinValue)
			{
				// we started this polygon with a control point so add the required curve3
				var vertex = vertexStorage.Vertex(polygonStartIndex, out var x, out var y);
				vertexStorage.Curve3(curve3Control.X, curve3Control.Y, x, y);

				// reset the curve3Control point to unitialized
				curve3Control = new Vector2(double.MinValue, double.MinValue);
			}
		}

		public void CloseContour()
		{
			CheckForOpenCurve3();

			//vertexStorage.ClosePolygon();
			if (vertexStorage.Count > polygonStartIndex)
			{
				vertexStorage.InvertPolygon(polygonStartIndex);
			}
			polygonStartIndex = vertexStorage.Count;
		}

		public void Curve3(float xControl, float yControl, float x, float y)
		{
			if (polygonStartIndex == vertexStorage.Count)
			{
				// we have not started the polygon so there is no point to curve3 from
				// store this control point and add it at the end of the polygon
				curve3Control = new Vector2(xControl, yControl);
				// then move to the end of this curve
				vertexStorage.MoveTo(x, y);
			}
			else
			{
				vertexStorage.Curve3(xControl, yControl, x, y);
			}
		}

		public void Curve4(float x1, float y1, float x2, float y2, float x3, float y3)
		{
			vertexStorage.Curve4(x1, y1, x2, y2, x3, y3);
		}

		public void EndRead()
		{
		}

		public void LineTo(float x, float y)
		{
			vertexStorage.LineTo(x, y);
		}

		public void MoveTo(float x, float y)
		{
			CheckForOpenCurve3();
			polygonStartIndex = vertexStorage.Count;
			vertexStorage.MoveTo(x, y);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\GammaLookUpTable.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------

//#ifndef AGG_GAMMA_LUT_INCLUDED
//#define AGG_GAMMA_LUT_INCLUDED

//#include <math.h>
//#include "agg_basics.h"

using System;

namespace MatterHackers.Agg
{
	public class GammaLookUpTable
	{
		private double m_gamma;
		private byte[] m_dir_gamma;
		private byte[] m_inv_gamma;

		private enum gamma_scale_e
		{
			gamma_shift = 8,
			gamma_size = 1 << gamma_shift,
			gamma_mask = gamma_size - 1
		};

		public GammaLookUpTable()
		{
			m_gamma = (1.0);
			m_dir_gamma = new byte[(int)gamma_scale_e.gamma_size];
			m_inv_gamma = new byte[(int)gamma_scale_e.gamma_size];
		}

		public GammaLookUpTable(double gamma)
		{
			m_gamma = gamma;
			m_dir_gamma = new byte[(int)gamma_scale_e.gamma_size];
			m_inv_gamma = new byte[(int)gamma_scale_e.gamma_size];
			SetGamma(m_gamma);
		}

		public void SetGamma(double g)
		{
			m_gamma = g;

			for (uint i = 0; i < (uint)gamma_scale_e.gamma_size; i++)
			{
				m_dir_gamma[i] = (byte)Util.uround(Math.Pow(i / (double)gamma_scale_e.gamma_mask, m_gamma) * (double)gamma_scale_e.gamma_mask);
			}

			double inv_g = 1.0 / g;
			for (uint i = 0; i < (uint)gamma_scale_e.gamma_size; i++)
			{
				m_inv_gamma[i] = (byte)Util.uround(Math.Pow(i / (double)gamma_scale_e.gamma_mask, inv_g) * (double)gamma_scale_e.gamma_mask);
			}
		}

		public double GetGamma()
		{
			return m_gamma;
		}

		public byte dir(int v)
		{
			return m_dir_gamma[v];
		}

		public byte inv(int v)
		{
			return m_inv_gamma[v];
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Graphics2D.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using MatterHackers.Agg.Font;
using MatterHackers.Agg.Image;
using MatterHackers.Agg.Platform;
using MatterHackers.Agg.Transform;
using MatterHackers.Agg.VertexSource;
using MatterHackers.VectorMath;
using System;
using System.Collections.Generic;

namespace MatterHackers.Agg
{
    public record ColoredVertexSource(IVertexSource VertexSource, Color Color);

    public interface IStyleHandler
    {
        Color color(int style);

        void GenerateSpan(Color[] span, int spanIndex, int x, int y, int len, int style);

        bool IsSolid(int style);
    };

    public abstract class Graphics2D
    {
        protected Stack<Affine> affineTransformStack = new Stack<Affine>();
        protected IImageByte destImageByte;
        protected IImageFloat destImageFloat;
        protected ScanlineRasterizer rasterizer;
        protected Stroke StrockedText;
        private const int cover_full = 255;

        public Graphics2D()
        {
            affineTransformStack.Push(Affine.NewIdentity());
        }

        public Graphics2D(IImageByte destImage, ScanlineRasterizer rasterizer)
            : this()
        {
            Initialize(destImage, rasterizer);
        }

        public enum Alignment
        {
            Left,
            Center,
            Right
        }

        public enum TransformQuality
        {
            Fastest,
            Best
        }

        public IImageByte DestImage
        {
            get
            {
                return destImageByte;
            }
        }

        public IImageFloat DestImageFloat
        {
            get
            {
                return destImageFloat;
            }
        }

        public double DeviceScale { get; set; } = 1;
        public abstract int Height { get; }
        public TransformQuality ImageRenderQuality { get; set; } = TransformQuality.Fastest;

        public ScanlineRasterizer Rasterizer
        {
            get { return rasterizer; }
        }

        public abstract IScanlineCache ScanlineCache
        {
            get;
            set;
        }

        public int TransformStackCount
        {
            get { return affineTransformStack.Count; }
        }

        public abstract int Width { get; }

        public static void AssertDebugNotDefined()
        {
#if DEBUG
            throw new Exception("DEBUG is defined and should not be!");
#endif
        }

        public static double GetScallingBaseOnMaxSize(ImageBuffer image, Vector2 maxSize, out Vector2 size)
        {
            double ratio = 1;
            size = new Vector2(image.Width, image.Height);
            if (size.X > maxSize.X)
            {
                size.X = maxSize.X;
                ratio = size.X / image.Width;
                size.Y = image.Height * ratio;
            }

            if (size.Y > maxSize.Y)
            {
                size.Y = maxSize.Y;
                ratio = size.Y / image.Height;
                size.X = image.Width * ratio;
            }

            return ratio;
        }

        public void Circle(Vector2 origin, double radius, Color color)
        {
            Circle(origin.X, origin.Y, radius, color);
        }

        public void Circle(double x, double y, double radius, Color color)
        {
            Ellipse elipse = new Ellipse(x, y, radius, radius);
            Render(elipse, color);
        }

        public abstract void Clear(IColorType color);

        public abstract void Clear(RectangleDouble rect, IColorType color);

        /// <summary>
        /// Draws an arc representing a portion of an ellipse specified by a Rectangle structure.
        /// </summary>
        /// <param name="color">The color to draw in.</param>
        /// <param name="rect">Structure that defines the boundaries of the ellipse.</param>
        /// <param name="startAngle">Angle in degrees measured clockwise from the x-axis to the starting point of the arc.</param>
        /// <param name="sweepAngle">Angle in degrees measured clockwise from the startAngle parameter to ending point of the arc.</param>
        public void DrawArc(Color color, RectangleDouble rect, int startAngle, int sweepAngle)
        {
            throw new NotImplementedException();
        }

        public void DrawLine(Color color, Vector2 start, Vector2 end)
        {
            Line(start, end, color);
        }

        public void DrawString(string text,
            Vector2 position,
            double pointSize = 12,
            Justification justification = Justification.Left,
            Baseline baseline = Baseline.Text,
            Color color = default,
            bool drawFromHintedCach = false,
            Color backgroundColor = default,
            bool bold = false)
        {
            DrawString(text, position.X, position.Y, pointSize, justification, baseline, color, drawFromHintedCach, backgroundColor, bold);
        }

        /// <summary>
        /// Draws a string on a typeface printer object with various optional styling parameters.
        /// </summary>
        /// <param name="text">The string text to be drawn.</param>
        /// <param name="x">The x-coordinate where the string starts.</param>
        /// <param name="y">The y-coordinate where the string starts.</param>
        /// <param name="pointSize">The size of the point in pixels. Default is 12.</param>
        /// <param name="justification">Defines the justification of the string, i.e., the alignment of the text. It can be left, right, or center. Default is 'Left'.</param>
        /// <param name="baseline">Defines the baseline alignment of the text, i.e., the vertical alignment of the text. It can be 'Text', 'Ideographic', etc. Default is 'Text'.</param>
        /// <param name="color">Defines the color of the text. Default is 'Black' if not specified.</param>
        /// <param name="drawFromHintedCach">A boolean flag to indicate if the rendered string should be drawn from hinted cache. Default is 'false'.</param>
        /// <param name="backgroundColor">Defines the background color of the text. No background color is applied if not specified.</param>
        /// <param name="bold">A boolean flag to indicate if the text should be bold. Default is 'false'.</param>
        /// <returns>Returns a TypeFacePrinter object that holds the rendered string and drawing settings.</returns>
        /// <example>
        /// TypeFacePrinter printer = DrawString("Hello World", 50, 50, 14, Justification.Center, Baseline.Text, Color.Red, true, Color.White, true);
        /// </example>
        /// <remarks>
        /// If the 'color' parameter's alpha value is zero, the function will interpret it as the color black.
        /// If the 'backgroundColor' parameter's alpha value is not zero, a rectangle of that color will be drawn as a background behind the string.
        /// </remarks>
        public TypeFacePrinter DrawString(string text,
            double x,
            double y,
            double pointSize = 12,
            Justification justification = Justification.Left,
            Baseline baseline = Baseline.Text,
            Color color = default,
            bool drawFromHintedCach = false,
            Color backgroundColor = default,
            bool bold = false)
        {
            TypeFacePrinter stringPrinter = new TypeFacePrinter(text, pointSize, new Vector2(x, y), justification, baseline, bold);
            if (color.Alpha0To255 == 0)
            {
                color = Color.Black;
            }

            if (backgroundColor.Alpha0To255 != 0)
            {
                FillRectangle(stringPrinter.LocalBounds, backgroundColor);
            }

            stringPrinter.DrawFromHintedCache = drawFromHintedCach;
            stringPrinter.Render(this, color);

            return stringPrinter;
        }

        public void FillRectangle(RectangleDouble rect, IColorType fillColor)
        {
            FillRectangle(rect.Left, rect.Bottom, rect.Right, rect.Top, fillColor);
        }

        public void FillRectangle(RectangleInt rect, IColorType fillColor)
        {
            FillRectangle(rect.Left, rect.Bottom, rect.Right, rect.Top, fillColor);
        }

        public void FillRectangle(Vector2 leftBottom, Vector2 rightTop, IColorType fillColor)
        {
            FillRectangle(leftBottom.X, leftBottom.Y, rightTop.X, rightTop.Y, fillColor);
        }

        public abstract void FillRectangle(double left, double bottom, double right, double top, IColorType fillColor);

        public abstract RectangleDouble GetClippingRect();

        public Affine GetTransform()
        {
            return affineTransformStack.Peek();
        }

        public void Initialize(IImageByte destImage, ScanlineRasterizer rasterizer)
        {
            destImageByte = destImage;
            destImageFloat = null;
            this.rasterizer = rasterizer;
        }

        public void Initialize(IImageFloat destImage, ScanlineRasterizer rasterizer)
        {
            destImageByte = null;
            destImageFloat = destImage;
            this.rasterizer = rasterizer;
        }

        /// <summary>
        /// Render a line
        /// </summary>
        /// <param name="start">start position</param>
        /// <param name="end">end position</param>
        /// <param name="color">line color</param>
        /// <param name="strokeWidth">The width in pixels, -1 will render 1 pixel scaled to device units</param>
        public void Line(Vector2 start, Vector2 end, Color color, double strokeWidth = -1)
        {
            if (strokeWidth == -1)
            {
                strokeWidth = 1 * DeviceScale;
            }

            Line(start.X, start.Y, end.X, end.Y, color, strokeWidth);
        }
        
        public IVertexSource GetLine(double x1, double y1, double x2, double y2, double strokeWidth = -1)
        {
            if (strokeWidth == -1)
            {
                strokeWidth = 1 * DeviceScale;
            }

            var lineToDraw = new VertexStorage();
            lineToDraw.Clear();
            lineToDraw.MoveTo(x1, y1);
            lineToDraw.LineTo(x2, y2);

            return new Stroke(lineToDraw, strokeWidth);
        }

        /// <summary>
        /// Render a line
        /// </summary>
        /// <param name="x1">x start</param>
        /// <param name="y1">y start</param>
        /// <param name="x2">x end</param>
        /// <param name="y2">y end</param>
        /// <param name="color">color of the line</param>
        /// <param name="strokeWidth">The width in pixels, -1 will render 1 pixel scaled to device units</param>
        public virtual void Line(double x1, double y1, double x2, double y2, Color color, double strokeWidth = -1)
        {
            this.Render(GetLine(x1, y1, x2, y2, strokeWidth), color);
        }

        public Affine PopTransform()
        {
            if (affineTransformStack.Count == 1)
            {
                throw new System.Exception("You cannot remove the last transform from the stack.");
            }

            return affineTransformStack.Pop();
        }

        public void PushTransform()
        {
            if (affineTransformStack.Count > 1000)
            {
                throw new System.Exception("You seem to be leaking transforms.  You should be popping some of them at some point.");
            }

            affineTransformStack.Push(affineTransformStack.Peek());
        }

        public abstract void Rectangle(double left, double bottom, double right, double top, Color color, double strokeWidth = -1);

        public void Rectangle(RectangleDouble rect, Color color, double strokeWidth = -1)
        {
            if (strokeWidth == -1)
            {
                strokeWidth = 1 * DeviceScale;
            }

            Rectangle(rect.Left, rect.Bottom, rect.Right, rect.Top, color, strokeWidth);
        }

        public void Rectangle(RectangleInt rect, Color color)
        {
            Rectangle(rect.Left, rect.Bottom, rect.Right, rect.Top, color);
        }

        public abstract void Render(IVertexSource vertexSource, IColorType colorType);

        public void Render(IImageByte imageSource, Point2D position)
        {
            Render(imageSource, position.x, position.y);
        }

        public void Render(IImageByte imageSource, Vector2 position)
        {
            Render(imageSource, position.X, position.Y);
        }

        public void Render(IImageByte imageSource, Vector2 position, double width, double height)
        {
            Render(imageSource, position.X, position.Y, width, height);
        }

        public void Render(IImageByte imageSource, double x, double y)
        {
            Render(imageSource, x, y, 0, 1, 1);
        }

        public void Render(IImageByte imageSource, double x, double y, double width, double height)
        {
            Render(imageSource, x, y, 0, width / imageSource.Width, height / imageSource.Height);
        }

        public abstract void Render(IImageByte imageSource,
            double x,
            double y,
            double angleRadians,
            double scaleX,
            double scaleY);

        public abstract void Render(IImageFloat imageSource,
            double x,
            double y,
            double angleRadians,
            double scaleX,
            double scaleY);

        public void Render(IVertexSource vertexSource, double x, double y, IColorType color)
        {
            Render(new VertexSourceApplyTransform(vertexSource, Affine.NewTranslation(x, y)), color);
        }

        public void Render(IVertexSource vertexSource, Vector2 position, IColorType color)
        {
            Render(new VertexSourceApplyTransform(vertexSource, Affine.NewTranslation(position.X, position.Y)), color);
        }

        public void RenderMaxSize(ImageBuffer image, Vector2 position, Vector2 maxSize)
        {
            var zero = Vector2.Zero;
            RenderMaxSize(image, position, maxSize, ref zero, out _);
        }

        public void RenderMaxSize(ImageBuffer image, Vector2 position, Vector2 maxSize, ref Vector2 origin)
        {
            RenderMaxSize(image, position, maxSize, ref origin, out _);
        }

        /// <summary>
        /// Renders the given image at the given position scaling down if bigger than maxSize
        /// </summary>
        /// <param name="image">The image to render</param>
        /// <param name="position">The postion to render it at</param>
        /// <param name="maxSize">The max size to allow it to render to. Will be scaled down to fit.</param>
        /// <param name="origin">The postion in the sourc to hold at the 'positon'</param>
        /// <param name="size"></param>
        public void RenderMaxSize(ImageBuffer image, Vector2 position, Vector2 maxSize, ref Vector2 origin, out Vector2 size)
        {
            var ratio = GetScallingBaseOnMaxSize(image, maxSize, out size);
            origin *= ratio;

            if (size.X != image.Width)
            {
                this.Render(image.CreateScaledImage(size.X / image.Width), position.X - origin.X, position.Y - origin.Y, size.X, size.Y);
            }
            else
            {
                this.Render(image, position - origin);
            }
        }

        public void RenderInRect(string text,
            double pointSize,
            RectangleDouble fitRect,
            out RectangleDouble renderedBounds,
            double xPositionRatio = 0,
            double yPositionRatio = 0,
            double debugBoundsWidth = 0)
        {
            RenderInRect(text, AggContext.DefaultFont, pointSize, fitRect, out renderedBounds, xPositionRatio, yPositionRatio, debugBoundsWidth);
        }

        public void RenderInRect(string text,
            TypeFace font,
            double pointSize,
            RectangleDouble fitRect,
            out RectangleDouble renderedBounds,
            double xPositionRatio = 0,
            double yPositionRatio = 0,
            double debugBoundsWidth = 0)
        {
            var styledTypeFace = new StyledTypeFace(font, pointSize * 300 / 72);
            var typeFacePrinter = new TypeFacePrinter(text, styledTypeFace);
            RenderInRect(new ColoredVertexSource[] { new ColoredVertexSource(typeFacePrinter, Color.Black) }, fitRect, out renderedBounds, xPositionRatio, yPositionRatio, debugBoundsWidth);
        }

        /// <summary>
        /// Renders the given vector source making scaled to fit the given rect. Scalling will remain proportional.
        /// If the vector source is smaller in one dimension it will be offset based on the position ratio
        /// </summary>
        /// <param name="source">The vector source to render</param>
        /// <param name="fitRect">The rect to scale to fit within</param>
        /// <param name="xPositionRatio">The ratio of the width to offset in x if not fully utilized</param>
        /// <param name="yPositionRatio">The ratio of the height to offset in y if not fully utilized</param>
        /// <param name="debugShowBounds">Render an outline of the total rectangle</param>
        public void RenderInRect(IEnumerable<ColoredVertexSource> source,
            RectangleDouble fitRect,
            out RectangleDouble renderedBounds,
            double xPositionRatio = 0,
            double yPositionRatio = 0,
            double debugBoundsWidth = 0)
        {
            renderedBounds = RectangleDouble.ZeroIntersection;

            xPositionRatio = Math.Max(0, Math.Min(1, xPositionRatio));
            yPositionRatio = Math.Max(0, Math.Min(1, yPositionRatio));

            RectangleDouble totalBounds = RectangleDouble.ZeroIntersection;
            foreach (var colorVertices in source)
            {
                var bounds = colorVertices.VertexSource.GetBounds();
                totalBounds.ExpandToInclude(bounds);
            }
            
            foreach (var colorVertices in source)
            {
                double scale;
                if (totalBounds.Width > fitRect.Width
                    || totalBounds.Height > fitRect.Height)
                {
                    // we need to scale down
                    scale = Math.Min(fitRect.Width / totalBounds.Width, fitRect.Height / totalBounds.Height);
                }
                else
                {
                    // we need to scale up
                    scale = Math.Min(fitRect.Width / totalBounds.Width, fitRect.Height / totalBounds.Height);
                }

                // zero out the offset
                var transform = Affine.NewTranslation(-totalBounds.Left, -totalBounds.Bottom);
                // scale
                transform *= Affine.NewScaling(scale);
                // offset to the fit rect
                transform *= Affine.NewTranslation(fitRect.Left, fitRect.Bottom);

                // do we need to move it to account for position ratios
                var scaledBounds = totalBounds * scale;
                transform *= Affine.NewTranslation((fitRect.Width - scaledBounds.Width) * xPositionRatio, (fitRect.Height - scaledBounds.Height) * yPositionRatio);
                var flattened = new FlattenCurves(new VertexSourceApplyTransform(colorVertices.VertexSource, transform));
                renderedBounds.ExpandToInclude(flattened.GetBounds());

                this.Render(flattened, colorVertices.Color);
            }

            if (debugBoundsWidth > 0)
            {
                this.Rectangle(fitRect, Color.Red, debugBoundsWidth);
            }
        }

        public void RenderScale(IImageByte image, double x, double y, double sizeX)
        {
            var ratio = sizeX / image.Width;
            var sizeY = image.Height * ratio;
            this.Render(image, x, y, sizeX, sizeY);
        }

        public abstract void SetClippingRect(RectangleDouble rect_d);

        public void SetTransform(Affine value)
        {
            affineTransformStack.Pop();
            affineTransformStack.Push(value);
        }
    }

    public static class ColoredVertexSourceExtensions
    {
        public static RectangleDouble GetBounds(this IEnumerable<ColoredVertexSource> source)
        {
            RectangleDouble totalBounds = RectangleDouble.ZeroIntersection;
            foreach (var colorVertices in source)
            {
                var bounds = colorVertices.VertexSource.GetBounds();
                totalBounds.ExpandToInclude(bounds);
            }

            return totalBounds;
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Helpers\DumpCallStackIfSlow.cs
/*
Copyright (c) 2015, Lars Brubaker
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using System.Diagnostics;

namespace MatterHackers.Agg
{
	public class DumpCallStackIfSlow : IDisposable
	{
		private int millisecondsToReportIfOver = 0;
		private Stopwatch timeToCallOnDrawFunction;
		private string startMessage;

		public DumpCallStackIfSlow(double maxSecondsBeforePrintCallStack, string startMessage)
		{
			this.startMessage = startMessage;
			millisecondsToReportIfOver = (int)(maxSecondsBeforePrintCallStack * 1000);
			timeToCallOnDrawFunction = Stopwatch.StartNew();
		}

		public void Dispose()
		{
			timeToCallOnDrawFunction.Stop();
			if (timeToCallOnDrawFunction.ElapsedMilliseconds > millisecondsToReportIfOver)
			{
				Debug.Write("{0} [{1}ms]\n{2}\n".FormatWith(startMessage, timeToCallOnDrawFunction.ElapsedMilliseconds, Environment.StackTrace));
			}
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Helpers\HashGenerator.cs
/*
Copyright (c) 2018, John Lewin
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using System.IO;

namespace MatterHackers.Agg
{
	public static class HashGenerator
	{
		public static string ComputeSHA1(Stream stream)
		{
			using (var sha1 = System.Security.Cryptography.SHA1.Create())
			{
				byte[] hash = sha1.ComputeHash(stream);
				return BitConverter.ToString(hash).Replace("-", string.Empty);
			}
		}

		public static string ComputeFileSHA1(string filePath)
		{
			using (var stream = new BufferedStream(File.OpenRead(filePath), 1<<16))
			{
				return HashGenerator.ComputeSHA1(stream);
			}
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Helpers\Parallel.cs
/*
Copyright (c) 2020, Lars Brubaker
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace MatterHackers.Agg
{
    public static class Parallel
    {
        public static bool Sequential { get; set; }

        public static void ForEach<T>(IEnumerable<T> source, Action<T> action)
        {
            if (Sequential)
            {
                foreach (T v in source)
                {
                    action(v);
                }
            }
            else
            {
                System.Threading.Tasks.Parallel.ForEach<T>(source, action);
            }
        }

        public static void For(int startInclusive, int endExclusive, Action<int> action)
        {
            if (Sequential)
            {
                for (int i = startInclusive; i < endExclusive; i++)
                {
                    action(i);
                }
            }
            else
            {
                System.Threading.Tasks.Parallel.For(startInclusive, endExclusive, action);
            }
        }

        public static void For<T>(int startInclusive, int endExclusive, Func<T> action, Func<int, ParallelLoopState, T, T> p2, Action<T> p3)
        {
            System.Threading.Tasks.Parallel.For(startInclusive, endExclusive, action, p2, p3);
        }
    }
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Helpers\PluginFinder.cs
/*
Copyright (c) 2018, Lars Brubaker, John Lewin
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace MatterHackers.Agg
{
	public static class PluginFinder
	{
		private static Dictionary<Assembly, List<Type>> assemblyAndTypes = new Dictionary<Assembly, List<Type>>();

		private static HashSet<string> AssembliesToIgnore = new HashSet<string>
		{
            "Microsoft.Testing.Platform.MSBuild",
            "Microsoft.VisualStudio.TestPlatform.MSTest.TestAdapter",
            "Microsoft.VisualStudio.TestPlatform.MSTestAdapter.PlatformServices",
            "Microsoft.VisualStudio.TestPlatform.TestFramework.Extensions"
        };


        public static void LoadTypesFromAssembly(Assembly assembly)
		{
			if (assembly == null || assemblyAndTypes.ContainsKey(assembly) || AssembliesToIgnore.Contains(assembly.GetName().Name))
			{
				return;
            }

            var assemblyTypes = new List<Type>();

			foreach (var type in assembly.GetTypes())
			{
				try
				{
					if (type == null || !type.IsClass || !type.IsPublic)
					{
						continue;
					}

					assemblyTypes.Add(type);
				}
				catch (Exception ex)
				{
					System.Diagnostics.Debug.WriteLine("Error adding type: " + ex.Message);
				}
			}

			if (!assemblyAndTypes.ContainsKey(assembly))
			{
				assemblyAndTypes.Add(assembly, assemblyTypes);
			}
		}

		public static IEnumerable<Type> FindTypes<T>()
		{
			Type targetType = typeof(T);

			return assemblyAndTypes?.SelectMany(kvp => kvp.Value)
						.Where(type => targetType.IsAssignableFrom(type));
		}

		public static List<T> CreateInstancesOf<T>()
		{
			List<T> constructedTypes = new List<T>();
			foreach (var keyValue in assemblyAndTypes)
			{
				try
				{
					Type targetType = typeof(T);

					foreach (var type in keyValue.Value)
					{
						if (targetType.IsInterface && targetType.IsAssignableFrom(type) 
							|| type.BaseType == typeof(T))
						{
							constructedTypes.Add((T)Activator.CreateInstance(type));
						}
					}
				}
				//catch (ReflectionTypeLoadException)	{ }
				//catch (BadImageFormatException) { }
				//catch (NotSupportedException) {	}
				catch(Exception ex)
				{
					System.Diagnostics.Debug.WriteLine("Error loading types: " + ex.Message);
				}
			}

			return constructedTypes;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Helpers\QuickTimer.cs
/*
Copyright (c) 2025, Lars Brubaker, Kevin Pope
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using System.Diagnostics;

namespace MatterHackers.Agg
{
    /// <summary>
    /// A tiny class to allow for the quick timing of a block of code in the debugger.
    /// </summary>
    /// /// <example> 
    /// This sample shows how to use QuickTimer.
    /// <code>
    /// class SampleProgram
    /// {
    ///     static int Main() 
    ///     {
    ///			// some code we want to time
    ///			using(new QuickTimer("Time To Get Cookies")
    ///			{
    ///				GetCookies();
    ///			}
    ///			
    ///         return 1;
    ///     }
    /// }
    /// </code>
    /// </example>
    public unsafe class QuickTimer : IDisposable
    {
        private double minTimeToReport;
        private string name;
        private Stopwatch quickTimerTime = Stopwatch.StartNew();
        private double startTime;
        private double* outSeconds; // Pointer to store the address of the out parameter

        public QuickTimer(string name, double minTimeToReport = 0)
        {
            this.minTimeToReport = minTimeToReport;
            this.name = name;
            startTime = quickTimerTime.Elapsed.TotalMilliseconds;
            this.outSeconds = null;
        }

        public QuickTimer(string name, out double seconds, double minTimeToReport = 0)
        {
            this.minTimeToReport = minTimeToReport;
            this.name = name;
            startTime = quickTimerTime.Elapsed.TotalMilliseconds;

            // Store the address of the out parameter
            fixed (double* p = &seconds)
            {
                this.outSeconds = p;
            }
        }

        public void Dispose()
        {
            double totalTime = (quickTimerTime.Elapsed.TotalMilliseconds - startTime) / 1000.0;

            // Update the out parameter if it was provided
            if (outSeconds != null)
            {
                *outSeconds = totalTime;
            }

            if (totalTime > minTimeToReport)
            {
                Debug.WriteLine(name + ": {0:0.0}s".FormatWith(totalTime));
            }
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Helpers\ReportTimer.cs
/*
Copyright (c) 2025, Lars Brubaker, Kevin Pope
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace MatterHackers.Agg
{
    public class ReportTimer : IDisposable
    {
        private string name;
        private int group;
        private static readonly Stopwatch all_stopwatch = Stopwatch.StartNew();
        private double startTime;

        private class TimerInfo
        {
            public double TotalTime { get; set; }
            public int CallCount { get; set; }
        }

        private static readonly Dictionary<(int group, string name), TimerInfo> timers = new Dictionary<(int group, string name), TimerInfo>();

        public ReportTimer(string name, int group = 0)
        {
            this.name = name;
            this.group = group;

            var key = (group, name);
            lock (timers)
            {
                if (!timers.ContainsKey(key))
                {
                    timers.Add(key, new TimerInfo { CallCount = 1 });
                }
                else
                {
                    timers[key].CallCount++;
                }
            }
            startTime = all_stopwatch.Elapsed.TotalSeconds;
        }

        public void Dispose()
        {
            double elapsedTime = all_stopwatch.Elapsed.TotalSeconds - startTime;
            var key = (group, name);
            lock (timers)
            {
                if (timers.ContainsKey(key))
                {
                    timers[key].TotalTime += elapsedTime;
                }
            }
        }

        public static void Report(int group = 0)
        {
            Dictionary<(int group, string name), TimerInfo> timersCopy;
            lock (timers)
            {
                timersCopy = new Dictionary<(int group, string name), TimerInfo>(timers);
            }

            var sb = new StringBuilder();

            if (group != 0)
            {
                var groupTimers = timersCopy.Where(t => t.Key.group == group);
                ReportGroup(sb, groupTimers, group);
            }
            else
            {
                // Group the timers by their group number
                var groupedTimers = timersCopy.GroupBy(t => t.Key.group);
                foreach (var grouping in groupedTimers.OrderBy(g => g.Key))
                {
                    ReportGroup(sb, grouping, grouping.Key);
                }
            }

            Debug.WriteLine(sb.ToString());
        }

        private static void ReportGroup(StringBuilder sb, IEnumerable<KeyValuePair<(int group, string name), TimerInfo>> groupTimers, int groupNum)
        {
            sb.AppendLine($"Function Timing Report - Group {groupNum}:");
            sb.AppendLine("----------------------");

            double totalTime = groupTimers.Sum(t => t.Value.TotalTime);

            foreach (var timer in groupTimers.OrderByDescending(t => t.Value.TotalTime))
            {
                double percentage = (timer.Value.TotalTime / totalTime) * 100;
                sb.AppendLine(
                    $"{timer.Key.name} ({timer.Value.CallCount} calls): " +
                    $"{timer.Value.TotalTime:0.000}s ({percentage:0.0}%) " +
                    $"[{timer.Value.TotalTime / timer.Value.CallCount:0.000}s avg per call]"
                );
            }
            sb.AppendLine();
        }

        public static void ReportAndRestart(int group = 0)
        {
            Report(group);
            Restart(group);
        }

        public static void ReportAndRestart(Graphics2D drawTo, double x, double y, int group = 0)
        {
            Dictionary<(int group, string name), TimerInfo> timersCopy;
            lock (timers)
            {
                timersCopy = new Dictionary<(int group, string name), TimerInfo>(timers);
            }

            var sb = new StringBuilder();

            if (group != 0)
            {
                var groupTimers = timersCopy.Where(t => t.Key.group == group);
                ReportGroup(sb, groupTimers, group);
            }
            else
            {
                var groupedTimers = timersCopy.GroupBy(t => t.Key.group);
                foreach (var grouping in groupedTimers.OrderBy(g => g.Key))
                {
                    ReportGroup(sb, grouping, grouping.Key);
                }
            }

            string[] lines = sb.ToString().TrimEnd().Split('\n');
            foreach (var line in lines)
            {
                drawTo.DrawString(line, x, y, backgroundColor: Color.White.WithAlpha(210), drawFromHintedCach: true);
                y -= 18;
            }

            Restart(group);
        }

        public static void Restart(int group = 0)
        {
            lock (timers)
            {
                if (group != 0)
                {
                    // Remove only timers for the specified group
                    var keysToRemove = timers.Keys.Where(k => k.group == group).ToList();
                    foreach (var key in keysToRemove)
                    {
                        timers.Remove(key);
                    }
                }
                else
                {
                    timers.Clear();
                }
            }
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Helpers\RootedObjectEventHandler.cs
using System;
using System.Collections.Generic;

namespace MatterHackers.Agg
{
	public class RootedObjectEventHandler
	{
		private EventHandler internalEvent;

		public void RegisterEvent(EventHandler functionToCallOnEvent, ref EventHandler unregisterEvents)
		{
			internalEvent += functionToCallOnEvent;

			unregisterEvents += (sender, e) =>
			{
				internalEvent -= functionToCallOnEvent;
			};
		}

		public void UnregisterEvent(EventHandler functionToCallOnEvent, ref EventHandler unregisterEvents)
		{
			internalEvent -= functionToCallOnEvent;
			// After we remove it, it will still be removed again in the unregisterEvents
			// But it is valid to attempt remove more than once.
		}

		public void CallEvents(Object sender, EventArgs e)
		{
			internalEvent?.Invoke(sender, e);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Helpers\StatisticsTracker.cs
/*
Copyright (c) 2015, Lars Brubaker
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using System.Collections.Generic;
using System.Linq;

namespace MatterHackers.Agg
{
    public class StatisticsTracker
    {
        private List<double> data = new List<double>();

        #region Median
        #endregion
        public double Median
        {
            get
            {
                if (data.Count > 0)
                {
                    if ((data.Count % 2) == 0)
                    {
                        return data[data.Count / 2 - 1] + data[data.Count / 2];
                    }
                    else
                    {
                        return data[data.Count / 2];
                    }
                }

                return 0;
            }
        }

        #region Mode

            private double cachedMode = 0;
        private int countModeCalculatedOn = 0;

        public double Mode
        {
            get
            {
                if (countModeCalculatedOn != data.Count)
                {
                    var groups = data.GroupBy(v => v);
                    int maxCount = groups.Max(g => g.Count());

                    countModeCalculatedOn = data.Count;
                    cachedMode = groups.First(g => g.Count() == maxCount).Key;
                }

                return cachedMode;
            }
        }

        #endregion Mode

        #region Mean Function and cache data

        private double cachedMean = 0;
        private int countMeanCalculatedOn = 0;

        public double Mean
        {
            get
            {
                if (countMeanCalculatedOn != data.Count)
                {
                    double total = 0;
                    foreach (double value in data)
                    {
                        total += value;
                    }

                    countMeanCalculatedOn = data.Count;
                    cachedMean = total / data.Count;
                }

                return cachedMean;
            }
        }

        #endregion Mean Function and cache data

        #region Variance Function and cache data

        private double cachedVariance = 0;
        private int countVarianceCalculatedOn = 0;

		public string Name
		{
			get; private set;
		}

		public StatisticsTracker(string name)
		{
			this.Name = name;
		}

        public double Variance
        {
            get
            {
                if (data.Count > 1
                    && countVarianceCalculatedOn != data.Count)
                {
                    List<double> dataMinusMean_Squared = new List<double>();
                    foreach (double value in data)
                    {
                        double diffFromMean = value - Mean;
                        dataMinusMean_Squared.Add(diffFromMean * diffFromMean);
                    }

                    double total = 0;
                    foreach (double value in dataMinusMean_Squared)
                    {
                        total += value;
                    }

                    countVarianceCalculatedOn = data.Count;
                    cachedVariance = total / (data.Count-1);
                }

                return cachedVariance;
            }
        }

        #endregion Variance Function and cache data

        public double StandardDeviation
        {
            get
            {
                if (data.Count > 0)
                {
                    return Math.Sqrt(Variance);
                }
                return 0;
            }
        }

        public int Count { get { return data.Count; } }

        public void AddValue(double value)
        {
            data.Add(value);
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Helpers\StringHelper.cs
/*
Copyright (c) 2014, Lars Brubaker
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using System.Text.RegularExpressions;

namespace MatterHackers.Agg
{
	public static class StringHelper
	{
		public static string FormatWith(this string format, params object[] args)
		{
			if (format == null)
				throw new ArgumentNullException("format");

			return string.Format(format, args);
		}

		public static string FormatWith(this string format, IFormatProvider provider, params object[] args)
		{
			if (format == null)
				throw new ArgumentNullException("format");

			return string.Format(provider, format, args);
		}

		public static string SplitCamelCase(this string str)
		{
			return Regex.Replace(
				Regex.Replace(
					str,
					@"(\P{Ll})(\P{Ll}\p{Ll})",
					"$1 $2"
				),
				@"(\p{Ll})(\P{Ll})",
				"$1 $2"
			).Replace("_", " ");
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Helpers\TraceTiming.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MatterHackers.Agg
{
	public static class TraceTiming
	{
		private static Dictionary<string, Stopwatch> timers = new Dictionary<string, Stopwatch>();

		[Conditional("TRACE")]
		public static void StartTracking(string section)
		{
			Trace.WriteLine("TimerStarted: " + section);
			timers.Add(section, Stopwatch.StartNew());
		}

		[Conditional("TRACE")]
		public static void ReportAndRestart(string section, string task)
		{
			Stopwatch timer;
			if (timers.TryGetValue(section, out timer))
			{
				Trace.WriteLine($"TimerElapsed: {section}.MsTo{task}:{timer.ElapsedMilliseconds}");
				timer.Restart();
			}
		}

		[Conditional("TRACE")]
		public static void Restart(string section)
		{
			Stopwatch timer;
			if (timers.TryGetValue(section, out timer))
			{
				timer.Restart();
			}
		}

		[Conditional("TRACE")]
		public static void Report(string section, string task)
		{
			Stopwatch timer;
			if (timers.TryGetValue(section, out timer))
			{
				Trace.WriteLine($"TimerElapsed: {section}.MsTo{task}:{timer.ElapsedMilliseconds}");
			}
		}

		[Conditional("TRACE")]
		public static void ReportAndStop(string section, string task)
		{
			Stopwatch timer;
			if (timers.TryGetValue(section, out timer))
			{
				Trace.WriteLine($"TimerStopped: {section}.MsTo{task}:{timer.ElapsedMilliseconds}");
				timers.Remove(section);
				timer.Stop();
			}
		}
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\agg_alpha_mask_u8.cs
using MatterHackers.Agg.Image;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// scanline_u8 class
//
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg
{
	public interface IAlphaMask
	{
		byte pixel(int x, int y);

		byte combine_pixel(int x, int y, byte val);

		void fill_hspan(int x, int y, byte[] dst, int dstIndex, int num_pix);

		void fill_vspan(int x, int y, byte[] dst, int dstIndex, int num_pix);

		void combine_hspanFullCover(int x, int y, byte[] dst, int dstIndex, int num_pix);

		void combine_hspan(int x, int y, byte[] dst, int dstIndex, int num_pix);

		void combine_vspan(int x, int y, byte[] dst, int dstIndex, int num_pix);
	};

	public sealed class AlphaMaskByteUnclipped : IAlphaMask
	{
		private IImageByte m_rbuf;
		private uint m_Step;
		private uint m_Offset;

		public static readonly int cover_shift = 8;
		public static readonly int cover_none = 0;
		public static readonly int cover_full = 255;

		public AlphaMaskByteUnclipped(IImageByte rbuf, uint Step, uint Offset)
		{
			m_Step = Step;
			m_Offset = Offset;
			m_rbuf = rbuf;
		}

		public void attach(IImageByte rbuf)
		{
			m_rbuf = rbuf;
		}

		//--------------------------------------------------------------------
		public byte pixel(int x, int y)
		{
			int bufferIndex = m_rbuf.GetBufferOffsetXY(x, y);
			byte[] buffer = m_rbuf.GetBuffer();
			return buffer[bufferIndex];
		}

		//--------------------------------------------------------------------
		public byte combine_pixel(int x, int y, byte val)
		{
			unchecked
			{
				int bufferIndex = m_rbuf.GetBufferOffsetXY(x, y);
				byte[] buffer = m_rbuf.GetBuffer();
				return (byte)((255 + val * buffer[bufferIndex]) >> 8);
			}
		}

		public void fill_hspan(int x, int y, byte[] dst, int dstIndex, int num_pix)
		{
			throw new NotImplementedException();
#if false
            byte[] mask = m_rbuf.GetPixelPointerY(y) + x * m_Step + m_Offset;
            do
            {
                *dst++ = *mask;
                mask += m_Step;
            }
            while (--num_pix != 0);
#endif
		}

		public void combine_hspanFullCover(int x, int y, byte[] covers, int coversIndex, int count)
		{
			int maskIndex = m_rbuf.GetBufferOffsetXY(x, y);
			byte[] mask = m_rbuf.GetBuffer();
			do
			{
				covers[coversIndex++] = mask[maskIndex++];
			}
			while (--count != 0);
		}

		public void combine_hspan(int x, int y, byte[] covers, int coversIndex, int count)
		{
			int maskIndex = m_rbuf.GetBufferOffsetXY(x, y);
			byte[] mask = m_rbuf.GetBuffer();
			do
			{
				covers[coversIndex] = (byte)((255 + (covers[coversIndex]) * mask[maskIndex]) >> 8);
				coversIndex++;
				maskIndex++;
			}
			while (--count != 0);
		}

		public void fill_vspan(int x, int y, byte[] buffer, int bufferIndex, int num_pix)
		{
			throw new NotImplementedException();
#if false
            byte[] mask = m_rbuf.GetPixelPointerY(y) + x * m_Step + m_Offset;
            do
            {
                *dst++ = *mask;
                mask += m_rbuf.StrideInBytes();
            }
            while (--num_pix != 0);
#endif
		}

		public void combine_vspan(int x, int y, byte[] dst, int dstIndex, int num_pix)
		{
			throw new NotImplementedException();
#if false
            byte[] mask = m_rbuf.GetPixelPointerY(y) + x * m_Step + m_Offset;
            do
            {
                *dst = (byte)((cover_full + (*dst) * (*mask)) >> cover_shift);
                ++dst;
                mask += m_rbuf.StrideInBytes();
            }
            while (--num_pix != 0);
#endif
		}
	};

	public sealed class AlphaMaskByteClipped : IAlphaMask
	{
		private IImageByte m_rbuf;
		private uint m_Step;
		private uint m_Offset;

		public static readonly int cover_shift = 8;
		public static readonly int cover_none = 0;
		public static readonly int cover_full = 255;

		public AlphaMaskByteClipped(IImageByte rbuf, uint Step, uint Offset)
		{
			m_Step = Step;
			m_Offset = Offset;
			m_rbuf = rbuf;
		}

		public void attach(IImageByte rbuf)
		{
			m_rbuf = rbuf;
		}

		//--------------------------------------------------------------------
		public byte pixel(int x, int y)
		{
			unchecked
			{
				if ((uint)x < (uint)m_rbuf.Width
					&& (uint)y < (uint)m_rbuf.Height)
				{
					int bufferIndex = m_rbuf.GetBufferOffsetXY(x, y);
					byte[] buffer = m_rbuf.GetBuffer();
					return buffer[bufferIndex];
				}
			}

			return 0;
		}

		public byte combine_pixel(int x, int y, byte val)
		{
			unchecked
			{
				if ((uint)x < (uint)m_rbuf.Width
					&& (uint)y < (uint)m_rbuf.Height)
				{
					int bufferIndex = m_rbuf.GetBufferOffsetXY(x, y);
					byte[] buffer = m_rbuf.GetBuffer();
					return (byte)((val * buffer[bufferIndex] + 255) >> 8);
				}
			}
			return 0;
		}

		public void fill_hspan(int x, int y, byte[] dst, int dstIndex, int num_pix)
		{
			throw new NotImplementedException();
#if false
            int xmax = (int)m_rbuf.Width() - 1;
            int ymax = (int)m_rbuf.Height() - 1;

            int count = num_pix;
            byte[] covers = dst;

            if (y < 0 || y > ymax)
            {
                agg_basics.MemClear(dst, num_pix);
                return;
            }

            if (x < 0)
            {
                count += x;
                if (count <= 0)
                {
                    agg_basics.MemClear(dst, num_pix);
                    return;
                }
                agg_basics.MemClear(covers, -x);
                covers -= x;
                x = 0;
            }

            if (x + count > xmax)
            {
                int rest = x + count - xmax - 1;
                count -= rest;
                if (count <= 0)
                {
                    agg_basics.MemClear(dst, num_pix);
                    return;
                }
                agg_basics.MemClear(covers + count, rest);
            }

            byte[] mask = m_rbuf.GetPixelPointerY(y) + x * m_Step + m_Offset;
            do
            {
                *covers++ = *(mask);
                mask += m_Step;
            }
            while (--count != 0);
#endif
		}

		public void combine_hspanFullCover(int x, int y, byte[] covers, int coversIndex, int num_pix)
		{
			int xmax = (int)m_rbuf.Width - 1;
			int ymax = (int)m_rbuf.Height - 1;

			int count = num_pix;

			if (y < 0 || y > ymax)
			{
				Util.MemClear(covers, coversIndex, num_pix);
				return;
			}

			if (x < 0)
			{
				count += x;
				if (count <= 0)
				{
					Util.MemClear(covers, coversIndex, num_pix);
					return;
				}
				Util.MemClear(covers, coversIndex, -x);
				coversIndex -= x;
				x = 0;
			}

			if (x + count > xmax)
			{
				int rest = x + count - xmax - 1;
				count -= rest;
				if (count <= 0)
				{
					Util.MemClear(covers, coversIndex, num_pix);
					return;
				}
				Util.MemClear(covers, coversIndex + count, rest);
			}

			int maskIndex = m_rbuf.GetBufferOffsetXY(x, y);
			byte[] mask = m_rbuf.GetBuffer();
			do
			{
				covers[coversIndex++] = mask[maskIndex++];
			}
			while (--count != 0);
		}

		public void combine_hspan(int x, int y, byte[] buffer, int bufferIndex, int num_pix)
		{
			int xmax = (int)m_rbuf.Width - 1;
			int ymax = (int)m_rbuf.Height - 1;

			int count = num_pix;
			byte[] covers = buffer;
			int coversIndex = bufferIndex;

			if (y < 0 || y > ymax)
			{
				Util.MemClear(buffer, bufferIndex, num_pix);
				return;
			}

			if (x < 0)
			{
				count += x;
				if (count <= 0)
				{
					Util.MemClear(buffer, bufferIndex, num_pix);
					return;
				}
				Util.MemClear(covers, coversIndex, -x);
				coversIndex -= x;
				x = 0;
			}

			if (x + count > xmax)
			{
				int rest = x + count - xmax - 1;
				count -= rest;
				if (count <= 0)
				{
					Util.MemClear(buffer, bufferIndex, num_pix);
					return;
				}
				Util.MemClear(covers, coversIndex + count, rest);
			}

			int maskIndex = m_rbuf.GetBufferOffsetXY(x, y);
			byte[] mask = m_rbuf.GetBuffer();
			do
			{
				covers[coversIndex] = (byte)(((covers[coversIndex]) * mask[maskIndex] + 255) >> 8);
				coversIndex++;
				maskIndex++;
			}
			while (--count != 0);
		}

		public void fill_vspan(int x, int y, byte[] buffer, int bufferIndex, int num_pix)
		{
			throw new NotImplementedException();
#if false
            int xmax = (int)m_rbuf.Width() - 1;
            int ymax = (int)m_rbuf.Height() - 1;

            int count = num_pix;
            byte[] covers = dst;

            if (x < 0 || x > xmax)
            {
                agg_basics.MemClear(dst, num_pix);
                return;
            }

            if (y < 0)
            {
                count += y;
                if (count <= 0)
                {
                    agg_basics.MemClear(dst, num_pix);
                    return;
                }
                agg_basics.MemClear(covers, -y);
                covers -= y;
                y = 0;
            }

            if (y + count > ymax)
            {
                int rest = y + count - ymax - 1;
                count -= rest;
                if (count <= 0)
                {
                    agg_basics.MemClear(dst, num_pix);
                    return;
                }
                agg_basics.MemClear(covers + count, rest);
            }

            byte[] mask = m_rbuf.GetPixelPointerY(y) + x * m_Step + m_Offset;
            do
            {
                *covers++ = *mask;
                mask += m_rbuf.StrideInBytes();
            }
            while (--count != 0);
#endif
		}

		public void combine_vspan(int x, int y, byte[] buffer, int bufferIndex, int num_pix)
		{
			throw new NotImplementedException();
#if false
            int xmax = (int)m_rbuf.Width() - 1;
            int ymax = (int)m_rbuf.Height() - 1;

            int count = num_pix;
            byte[] covers = dst;

            if (x < 0 || x > xmax)
            {
                agg_basics.MemClear(dst, num_pix);
                return;
            }

            if (y < 0)
            {
                count += y;
                if (count <= 0)
                {
                    agg_basics.MemClear(dst, num_pix);
                    return;
                }
                agg_basics.MemClear(covers, -y);
                covers -= y;
                y = 0;
            }

            if (y + count > ymax)
            {
                int rest = y + count - ymax - 1;
                count -= rest;
                if (count <= 0)
                {
                    agg_basics.MemClear(dst, num_pix);
                    return;
                }
                agg_basics.MemClear(covers + count, rest);
            }

            byte[] mask = m_rbuf.GetPixelPointerY(y) + x * m_Step + m_Offset;
            do
            {
                *covers = (byte)((cover_full + (*covers) * (*mask)) >> cover_shift);
                ++covers;
                mask += m_rbuf.StrideInBytes();
            }
            while (--count != 0);
#endif
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\AlphaMaskAdaptor.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg.Image
{
	//==================================================pixfmt_amask_adaptor
	public sealed class AlphaMaskAdaptor : ImageProxy
	{
		private IAlphaMask m_mask;
		private ArrayPOD<byte> m_span;

		private enum span_extra_tail_e { span_extra_tail = 256 };

		private static readonly byte cover_full = 255;

		private void realloc_span(int len)
		{
			if (len > m_span.Size())
			{
				m_span.Resize(len + (int)span_extra_tail_e.span_extra_tail);
			}
		}

		private void init_span(int len)
		{
			init_span(len, cover_full);
		}

		private void init_span(int len, byte cover)
		{
			realloc_span(len);
			Util.memset(m_span.Array, 0, cover, len);
		}

		private void init_span(int len, byte[] covers, int coversIndex)
		{
			realloc_span(len);
			byte[] array = m_span.Array;
			for (int i = 0; i < (int)len; i++)
			{
				array[i] = covers[coversIndex + i];
			}
		}

		public AlphaMaskAdaptor(IImageByte image, IAlphaMask mask)
			: base(image)
		{
			linkedImage = image;
			m_mask = mask;
			m_span = new ArrayPOD<byte>(255);
		}

		public void AttachImage(IImageByte image)
		{
			linkedImage = image;
		}

		public void attach_alpha_mask(IAlphaMask mask)
		{
			m_mask = mask;
		}

		public void copy_pixel(int x, int y, Color c)
		{
			linkedImage.BlendPixel(x, y, c, m_mask.pixel(x, y));
		}

		public override void copy_hline(int x, int y, int len, Color c)
		{
			throw new NotImplementedException();
			/*
						realloc_span((int)len);
						unsafe
						{
							fixed (byte* pBuffer = m_span.Array)
							{
								m_mask.fill_hspan(x, y, pBuffer, (int)len);
								m_LinkedImage.blend_solid_hspan(x, y, len, c, pBuffer);
							}
						}
			 */
		}

		public override void blend_hline(int x1, int y, int x2, Color c, byte cover)
		{
			int len = x2 - x1 + 1;
			if (cover == cover_full)
			{
				realloc_span(len);
				m_mask.combine_hspanFullCover(x1, y, m_span.Array, 0, (int)len);
				linkedImage.blend_solid_hspan(x1, y, (int)len, c, m_span.Array, 0);
			}
			else
			{
				init_span(len, cover);
				m_mask.combine_hspan(x1, y, m_span.Array, 0, (int)len);
				linkedImage.blend_solid_hspan(x1, y, (int)len, c, m_span.Array, 0);
			}
		}

		public override void copy_vline(int x, int y, int len, Color c)
		{
			throw new NotImplementedException(); /*
            realloc_span((int)len);
            unsafe
            {
                fixed (byte* pBuffer = m_span.Array)
                {
                    m_mask.fill_vspan(x, y, pBuffer, (int)len);
                    m_LinkedImage.blend_solid_vspan(x, y, len, c, pBuffer);
                }
            }
                                                  */
		}

		public override void blend_vline(int x, int y1, int y2, Color c, byte cover)
		{
			throw new NotImplementedException(); /*
            int len = y2 - y1 + 1;
            init_span(len, cover);
            unsafe
            {
                fixed (byte* pBuffer = m_span.Array)
                {
                    m_mask.combine_vspan(x, y1, pBuffer, len);
                    throw new System.NotImplementedException("blend_solid_vspan does not take a y2 yet");
                    //m_pixf.blend_solid_vspan(x, y1, y2, c, pBuffer);
                }
            }
                                                  */
		}

		public override void blend_solid_hspan(int x, int y, int len, Color color, byte[] covers, int coversIndex)
		{
			byte[] buffer = m_span.Array;
			m_mask.combine_hspan(x, y, covers, coversIndex, len);
			linkedImage.blend_solid_hspan(x, y, len, color, covers, coversIndex);
		}

		public override void blend_solid_vspan(int x, int y, int len, Color c, byte[] covers, int coversIndex)
		{
			throw new System.NotImplementedException();
#if false
            init_span((int)len, covers);
            unsafe
            {
                fixed (byte* pBuffer = m_span.Array)
                {
                    m_mask.combine_vspan(x, y, pBuffer, (int)len);
                    m_LinkedImage.blend_solid_vspan(x, y, len, c, pBuffer);
                }
            }
#endif
		}

		public override void copy_color_hspan(int x, int y, int len, Color[] colors, int colorsIndex)
		{
			throw new System.NotImplementedException();
#if false
            realloc_span((int)len);
            unsafe
            {
                fixed (byte* pBuffer = m_span.GetArray())
                {
                    m_mask.fill_hspan(x, y, pBuffer, (int)len);
                    m_pixf.blend_color_hspan(x, y, len, colors, pBuffer, cover_full);
                }
            }
#endif
		}

		public override void copy_color_vspan(int x, int y, int len, Color[] colors, int colorsIndex)
		{
			throw new System.NotImplementedException();
#if false
            realloc_span((int)len);
            unsafe
            {
                fixed (byte* pBuffer = m_span.GetArray())
                {
                    m_mask.fill_vspan(x, y, pBuffer, (int)len);
                    m_pixf.blend_color_vspan(x, y, len, colors, pBuffer, cover_full);
                }
            }
#endif
		}

		public override void blend_color_hspan(int x, int y, int len, Color[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			throw new System.NotImplementedException();
#if false
            unsafe
            {
                fixed (byte* pBuffer = m_span.GetArray())
                {
                    if (covers != null)
                    {
                        init_span((int)len, covers);
                        m_mask.combine_hspan(x, y, pBuffer, (int)len);
                    }
                    else
                    {
                        realloc_span((int)len);
                        m_mask.fill_hspan(x, y, pBuffer, (int)len);
                    }
                    m_pixf.blend_color_hspan(x, y, len, colors, pBuffer, cover);
                }
            }
#endif
		}

		public override void blend_color_vspan(int x, int y, int len, Color[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			throw new System.NotImplementedException();
#if false
            unsafe
            {
                fixed (byte* pBuffer = m_span.GetArray())
                {
                    if (covers != null)
                    {
                        init_span((int)len, covers);
                        m_mask.combine_vspan(x, y, pBuffer, (int)len);
                    }
                    else
                    {
                        realloc_span((int)len);
                        m_mask.fill_vspan(x, y, pBuffer, (int)len);
                    }
                    m_pixf.blend_color_vspan(x, y, len, colors, pBuffer, cover);
                }
            }
#endif
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\BlenderBase8888.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------

namespace MatterHackers.Agg.Image
{
    public class BlenderBase8888
	{
		public int NumPixelBits { get { return 32; } }

		public const byte base_mask = 255;
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\BlenderBaseBGRAFloat.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------

namespace MatterHackers.Agg.Image
{
    public class BlenderBaseBGRAFloat
	{
		public int NumPixelBits { get { return 128; } }

		public const byte base_mask = 255;
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\BlenderBGRA.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------

namespace MatterHackers.Agg.Image
{
    public sealed class BlenderBGRA : BlenderBase8888, IRecieveBlenderByte
	{
		public Color PixelToColor(byte[] buffer, int bufferOffset)
		{
			return new Color(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderA]);
		}

		public void CopyPixels(byte[] buffer, int bufferOffset, Color sourceColor, int count)
		{
			do
			{
				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
				bufferOffset += 4;
			}
			while (--count != 0);
		}

		public void BlendPixel(byte[] buffer, int bufferOffset, Color sourceColor)
		{
			//unsafe
			{
				unchecked
				{
					if (sourceColor.alpha == 255)
					{
						buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
						buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
						buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
						buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
					}
					else
					{
						int r = buffer[bufferOffset + ImageBuffer.OrderR];
						int g = buffer[bufferOffset + ImageBuffer.OrderG];
						int b = buffer[bufferOffset + ImageBuffer.OrderB];
						int a = buffer[bufferOffset + ImageBuffer.OrderA];
						buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(((sourceColor.red - r) * sourceColor.alpha + (r << Color.base_shift)) >> Color.base_shift);
						buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(((sourceColor.green - g) * sourceColor.alpha + (g << Color.base_shift)) >> Color.base_shift);
						buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << Color.base_shift)) >> Color.base_shift);
						buffer[bufferOffset + ImageBuffer.OrderA] = (byte)((sourceColor.alpha + a) - ((sourceColor.alpha * a + base_mask) >> Color.base_shift));
					}
				}
			}
		}

		public void BlendPixels(byte[] destBuffer, int bufferOffset,
			Color[] sourceColors, int sourceColorsOffset,
			byte[] covers, int coversIndex, bool firstCoverForAll, int count)
		{
			if (firstCoverForAll)
			{
				int cover = covers[coversIndex];
				if (cover == 255)
				{
					do
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
						bufferOffset += 4;
					}
					while (--count != 0);
				}
				else
				{
					do
					{
						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
						bufferOffset += 4;
						++sourceColorsOffset;
					}
					while (--count != 0);
				}
			}
			else
			{
				do
				{
					int cover = covers[coversIndex++];
					if (cover == 255)
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
					}
					else
					{
						Color color = sourceColors[sourceColorsOffset];
						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, color);
					}
					bufferOffset += 4;
					++sourceColorsOffset;
				}
				while (--count != 0);
			}
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\BlenderBGRAExactCopy.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
namespace MatterHackers.Agg.Image
{
    public sealed class BlenderBGRAExactCopy : BlenderBase8888, IRecieveBlenderByte
	{
		public Color PixelToColor(byte[] buffer, int bufferOffset)
		{
			return new Color(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderA]);
		}

		public void CopyPixels(byte[] buffer, int bufferOffset, Color sourceColor, int count)
		{
			do
			{
				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
				bufferOffset += 4;
			}
			while (--count != 0);
		}

		public void BlendPixel(byte[] buffer, int bufferOffset, Color sourceColor)
		{
			CopyPixels(buffer, bufferOffset, sourceColor, 1);
		}

		public void BlendPixels(byte[] destBuffer, int bufferOffset,
			Color[] sourceColors, int sourceColorsOffset,
			byte[] covers, int coversIndex, bool firstCoverForAll, int count)
		{
			if (firstCoverForAll)
			{
				int cover = covers[coversIndex];
				if (cover == 255)
				{
					do
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
						bufferOffset += 4;
					}
					while (--count != 0);
				}
				else
				{
					do
					{
						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
						bufferOffset += 4;
						++sourceColorsOffset;
					}
					while (--count != 0);
				}
			}
			else
			{
				do
				{
					int cover = covers[coversIndex++];
					if (cover == 255)
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
					}
					else
					{
						Color color = sourceColors[sourceColorsOffset];
						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, color);
					}
					bufferOffset += 4;
					++sourceColorsOffset;
				}
				while (--count != 0);
			}
		}
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\BlenderBGRAFloat.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg.Image
{
    public sealed class BlenderBGRAFloat : BlenderBaseBGRAFloat, IRecieveBlenderFloat
	{
		public ColorF PixelToColorRGBA_Floats(float[] buffer, int bufferOffset)
		{
			return new ColorF(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderA]);
		}

		public void CopyPixels(float[] buffer, int bufferOffset, ColorF sourceColor, int count)
		{
			do
			{
				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
				bufferOffset += 4;
			}
			while (--count != 0);
		}

		public void BlendPixel(float[] buffer, int bufferOffset, ColorF sourceColor)
		{
			if (sourceColor.alpha == 1)
			{
				buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(sourceColor.red);
				buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(sourceColor.green);
				buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(sourceColor.blue);
				buffer[bufferOffset + ImageBuffer.OrderA] = (byte)(sourceColor.alpha);
			}
			else
			{
				float r = buffer[bufferOffset + ImageBuffer.OrderR];
				float g = buffer[bufferOffset + ImageBuffer.OrderG];
				float b = buffer[bufferOffset + ImageBuffer.OrderB];
				float a = buffer[bufferOffset + ImageBuffer.OrderA];
				buffer[bufferOffset + ImageBuffer.OrderR] = (sourceColor.red - r) * sourceColor.alpha + r;
				buffer[bufferOffset + ImageBuffer.OrderG] = (sourceColor.green - g) * sourceColor.alpha + g;
				buffer[bufferOffset + ImageBuffer.OrderB] = (sourceColor.blue - b) * sourceColor.alpha + b;
				buffer[bufferOffset + ImageBuffer.OrderA] = (sourceColor.alpha + a) - sourceColor.alpha * a;
			}
		}

		public void BlendPixels(float[] destBuffer, int bufferOffset,
			ColorF[] sourceColors, int sourceColorsOffset,
			byte[] covers, int coversIndex, bool firstCoverForAll, int count)
		{
			throw new NotImplementedException();
		}
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\BlenderBGRAHalfHalf.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
namespace MatterHackers.Agg.Image
{
    public sealed class BlenderBGRAHalfHalf : BlenderBase8888, IRecieveBlenderByte
	{
		public Color PixelToColor(byte[] buffer, int bufferOffset)
		{
			return new Color(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderA]);
		}

		public void CopyPixels(byte[] buffer, int bufferOffset, Color sourceColor, int count)
		{
			do
			{
				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
				bufferOffset += 4;
			}
			while (--count != 0);
		}

		public void BlendPixel(byte[] buffer, int bufferOffset, Color sourceColor)
		{
			//unsafe
			{
				unchecked
				{
					if (sourceColor.alpha == 255)
					{
						buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
						buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
						buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
						buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
					}
					else
					{
						int r = buffer[bufferOffset + ImageBuffer.OrderR];
						int g = buffer[bufferOffset + ImageBuffer.OrderG];
						int b = buffer[bufferOffset + ImageBuffer.OrderB];
						int a = buffer[bufferOffset + ImageBuffer.OrderA];
						buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(((sourceColor.red - r) * sourceColor.alpha + (r << Color.base_shift)) >> Color.base_shift);
						buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(((sourceColor.green - g) * sourceColor.alpha + (g << Color.base_shift)) >> Color.base_shift);
						buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << Color.base_shift)) >> Color.base_shift);
						//buffer[bufferOffset + ImageBuffer.OrderR] = (byte)((sourceColor.red + r) / 2);
						//buffer[bufferOffset + ImageBuffer.OrderG] = (byte)((sourceColor.green + g) / 2);
						//buffer[bufferOffset + ImageBuffer.OrderB] = (byte)((sourceColor.blue + b) / 2);
						buffer[bufferOffset + ImageBuffer.OrderA] = (byte)((sourceColor.alpha + a) / 2);
					}
				}
			}
		}

		public void BlendPixels(byte[] destBuffer, int bufferOffset,
			Color[] sourceColors, int sourceColorsOffset,
			byte[] covers, int coversIndex, bool firstCoverForAll, int count)
		{
			if (firstCoverForAll)
			{
				int cover = covers[coversIndex];
				if (cover == 255)
				{
					do
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
						bufferOffset += 4;
					}
					while (--count != 0);
				}
				else
				{
					do
					{
						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
						bufferOffset += 4;
						++sourceColorsOffset;
					}
					while (--count != 0);
				}
			}
			else
			{
				do
				{
					int cover = covers[coversIndex++];
					if (cover == 255)
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
					}
					else
					{
						Color color = sourceColors[sourceColorsOffset];
						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, color);
					}
					bufferOffset += 4;
					++sourceColorsOffset;
				}
				while (--count != 0);
			}
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\BlenderExtensions.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
namespace MatterHackers.Agg.Image
{
    public static class BlenderExtensions
	{
		// Compute a fixed color from a source and a target alpha
		public static Color Blend(this IRecieveBlenderByte blender, Color start, Color blend)
		{
			var result = new byte[] { start.blue, start.green, start.red, start.alpha };
			blender.BlendPixel(result, 0, blend);

			return new Color(result[2], result[1], result[0], result[3]);
		}
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\BlenderGammaBGRA.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg.Image
{
    public sealed class BlenderGammaBGRA : BlenderBase8888, IRecieveBlenderByte
	{
		private GammaLookUpTable m_gamma;

		public BlenderGammaBGRA()
		{
			m_gamma = new GammaLookUpTable();
		}

		public BlenderGammaBGRA(GammaLookUpTable g)
		{
			m_gamma = g;
		}

		public void gamma(GammaLookUpTable g)
		{
			m_gamma = g;
		}

		public Color PixelToColor(byte[] buffer, int bufferOffset)
		{
			return new Color(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderA]);
		}

		public void CopyPixels(byte[] buffer, int bufferOffset, Color sourceColor, int count)
		{
			do
			{
				buffer[bufferOffset + ImageBuffer.OrderR] = m_gamma.inv(sourceColor.red);
				buffer[bufferOffset + ImageBuffer.OrderG] = m_gamma.inv(sourceColor.green);
				buffer[bufferOffset + ImageBuffer.OrderB] = m_gamma.inv(sourceColor.blue);
				buffer[bufferOffset + ImageBuffer.OrderA] = m_gamma.inv(sourceColor.alpha);
				bufferOffset += 4;
			}
			while (--count != 0);
		}

		public void BlendPixel(byte[] buffer, int bufferOffset, Color sourceColor)
		{
			unchecked
			{
				int r = buffer[bufferOffset + ImageBuffer.OrderR];
				int g = buffer[bufferOffset + ImageBuffer.OrderG];
				int b = buffer[bufferOffset + ImageBuffer.OrderB];
				int a = buffer[bufferOffset + ImageBuffer.OrderA];
				buffer[bufferOffset + ImageBuffer.OrderR] = m_gamma.inv((byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)Color.base_shift)) >> (int)Color.base_shift));
				buffer[bufferOffset + ImageBuffer.OrderG] = m_gamma.inv((byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)Color.base_shift)) >> (int)Color.base_shift));
				buffer[bufferOffset + ImageBuffer.OrderB] = m_gamma.inv((byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)Color.base_shift)) >> (int)Color.base_shift));
				buffer[ImageBuffer.OrderA] = (byte)((sourceColor.alpha + a) - ((sourceColor.alpha * a + base_mask) >> (int)Color.base_shift));
			}
		}

		public void BlendPixels(byte[] buffer, int bufferOffset,
			Color[] sourceColors, int sourceColorsOffset,
			byte[] sourceCovers, int sourceCoversOffset, bool firstCoverForAll, int count)
		{
			throw new NotImplementedException();
		}
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\BlenderPolyColorPreMultBGRA.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg.Image
{
    public sealed class BlenderPolyColorPreMultBGRA : BlenderBase8888, IRecieveBlenderByte
	{
		private static int[] m_Saturate9BitToByte = new int[1 << 9];
		private Color polyColor;

		public BlenderPolyColorPreMultBGRA(Color polyColor)
		{
			this.polyColor = polyColor;

			if (m_Saturate9BitToByte[2] == 0)
			{
				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)
				{
					m_Saturate9BitToByte[i] = Math.Min(i, 255);
				}
			}
		}

		public Color PixelToColor(byte[] buffer, int bufferOffset)
		{
			return new Color(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderA]);
		}

		public void CopyPixels(byte[] buffer, int bufferOffset, Color sourceColor, int count)
		{
			for (int i = 0; i < count; i++)
			{
				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
				bufferOffset += 4;
			}
		}

		public void BlendPixel(byte[] pDestBuffer, int bufferOffset, Color sourceColor)
		{
			//unsafe
			{
				int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);
				int oneOverAlpha = base_mask - sourceA;
				unchecked
				{
					int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);
					int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);
					int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);

					int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];
					int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];
					int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];
					// TODO: calculated the correct dest alpha
					//int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];

					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;
					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;
					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;
					//pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);
				}
			}
		}

		public void BlendPixels(byte[] pDestBuffer, int bufferOffset,
			Color[] sourceColors, int sourceColorsOffset,
			byte[] sourceCovers, int sourceCoversOffset, bool firstCoverForAll, int count)
		{
			if (firstCoverForAll)
			{
				//unsafe
				{
					if (sourceCovers[sourceCoversOffset] == 255)
					{
						for (int i = 0; i < count; i++)
						{
							BlendPixel(pDestBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
							sourceColorsOffset++;
							bufferOffset += 4;
						}
					}
					else
					{
						throw new NotImplementedException("need to consider the polyColor");
#if false
                        for (int i = 0; i < count; i++)
                        {
                            RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];
                            int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;
                            if (alpha == 0)
                            {
                                continue;
                            }
                            else if (alpha == 255)
                            {
                                pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;
                            }
                            else
                            {
                                int OneOverAlpha = base_mask - alpha;
                                unchecked
                                {
                                    int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];
                                    int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];
                                    int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];
                                    int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(OneOverAlpha * (base_mask - a) + 255) >> 8]);
                                }
                            }
                            sourceColorsOffset++;
                            bufferOffset += 4;
                        }
#endif
					}
				}
			}
			else
			{
				throw new NotImplementedException("need to consider the polyColor");
#if false
                for (int i = 0; i < count; i++)
                {
                    RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];
                    int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;
                    if (alpha == 255)
                    {
                        pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;
                        pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;
                        pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;
                        pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;
                    }
                    else if (alpha > 0)
                    {
                        int OneOverAlpha = base_mask - alpha;
                        unchecked
                        {
                            int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];
                            int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];
                            int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];
                            int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];
                            pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;
                            pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;
                            pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;
                            pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(OneOverAlpha * (base_mask - a) + 255) >> 8]);
                        }
                    }
                    sourceColorsOffset++;
                    sourceCoversOffset++;
                    bufferOffset += 4;
                }
#endif
			}
		}
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\BlenderPreMultBGRA.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg.Image
{
    public sealed class BlenderPreMultBGRA : BlenderBase8888, IRecieveBlenderByte
	{
		private static int[] m_Saturate9BitToByte = new int[1 << 9];

		public BlenderPreMultBGRA()
		{
			if (m_Saturate9BitToByte[2] == 0)
			{
				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)
				{
					m_Saturate9BitToByte[i] = Math.Min(i, 255);
				}
			}
		}

		public Color PixelToColor(byte[] buffer, int bufferOffset)
		{
			return new Color(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderA]);
		}

		public void CopyPixels(byte[] buffer, int bufferOffset, Color sourceColor, int count)
		{
			for (int i = 0; i < count; i++)
			{
				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
				bufferOffset += 4;
			}
		}

		public void BlendPixel(byte[] pDestBuffer, int bufferOffset, Color sourceColor)
		{
			int oneOverAlpha = base_mask - sourceColor.alpha;
			unchecked
			{
				int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceColor.red];
				int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceColor.green];
				int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceColor.blue];
				int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];
				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;
				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;
				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;
				pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);
			}
		}

		public void BlendPixels(byte[] pDestBuffer, int bufferOffset,
			Color[] sourceColors, int sourceColorsOffset,
			byte[] sourceCovers, int sourceCoversOffset, bool firstCoverForAll, int count)
		{
			if (firstCoverForAll)
			{
				if (sourceCovers[sourceCoversOffset] == 255)
				{
					for (int i = 0; i < count; i++)
					{
						Color sourceColor = sourceColors[sourceColorsOffset];
						if (sourceColor.alpha == 255)
						{
							CopyOpaquePixel(pDestBuffer, bufferOffset, sourceColor);
						}
						else
						{
							BlendPixel(pDestBuffer, bufferOffset, sourceColor);
						}

						sourceColorsOffset++;
						bufferOffset += 4;
					}
				}
				else
				{
					for (int i = 0; i < count; i++)
					{
						Color sourceColor = sourceColors[sourceColorsOffset];
						int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;
						if (alpha == 0)
						{
							continue;
						}
						else if (alpha == 255)
						{
							CopyOpaquePixel(pDestBuffer, bufferOffset, sourceColor);
						}
						else
						{
							BlendPixel(pDestBuffer, bufferOffset, sourceColor);
						}
						sourceColorsOffset++;
						bufferOffset += 4;
					}
				}
			}
			else
			{
				for (int i = 0; i < count; i++)
				{
					Color sourceColor = sourceColors[sourceColorsOffset];
					int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;
					if (alpha == 255)
					{
						CopyOpaquePixel(pDestBuffer, bufferOffset, sourceColor);
					}
					else if (alpha > 0)
					{
						BlendPixel(pDestBuffer, bufferOffset, sourceColor);
					}
					sourceColorsOffset++;
					sourceCoversOffset++;
					bufferOffset += 4;
				}
			}
		}

		private static void CopyOpaquePixel(byte[] pDestBuffer, int bufferOffset, Color sourceColor)
		{
			pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;
			pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;
			pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;
			pDestBuffer[bufferOffset + ImageBuffer.OrderA] = 255;
		}
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\BlenderPreMultBGRAFloat.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg.Image
{
    public sealed class BlenderPreMultBGRAFloat : BlenderBaseBGRAFloat, IRecieveBlenderFloat
	{
		public ColorF PixelToColorRGBA_Floats(float[] buffer, int bufferOffset)
		{
			throw new NotImplementedException();
			//return new RGBA_(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderA]);
		}

		public void SetPixels(float[] buffer, int bufferOffset, ColorF sourceColor, int count)
		{
			do
			{
				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
				bufferOffset += 4;
			}
			while (--count != 0);
		}

		public void CopyPixels(float[] buffer, int bufferOffset, ColorF[] sourceColors, int sourceColorsOffset, int count)
		{
			throw new NotImplementedException();
		}

		public void CopyPixels(float[] buffer, int bufferOffset, ColorF sourceColor, int count)
		{
			do
			{
				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
				bufferOffset += 4;
			}
			while (--count != 0);
		}

		public void BlendPixel(float[] buffer, int bufferOffset, ColorF sourceColor)
		{
			if (sourceColor.alpha == 1)
			{
				buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(sourceColor.red);
				buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(sourceColor.green);
				buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(sourceColor.blue);
				buffer[bufferOffset + ImageBuffer.OrderA] = (byte)(sourceColor.alpha);
			}
			else
			{
				float r = buffer[bufferOffset + ImageBuffer.OrderR];
				float g = buffer[bufferOffset + ImageBuffer.OrderG];
				float b = buffer[bufferOffset + ImageBuffer.OrderB];
				float a = buffer[bufferOffset + ImageBuffer.OrderA];
				buffer[bufferOffset + ImageBuffer.OrderR] = (sourceColor.red - r) * sourceColor.alpha + r;
				buffer[bufferOffset + ImageBuffer.OrderG] = (sourceColor.green - g) * sourceColor.alpha + g;
				buffer[bufferOffset + ImageBuffer.OrderB] = (sourceColor.blue - b) * sourceColor.alpha + b;
				buffer[bufferOffset + ImageBuffer.OrderA] = (sourceColor.alpha + a) - sourceColor.alpha * a;
			}
		}

		public void BlendPixels(float[] pDestBuffer, int bufferOffset,
			ColorF[] sourceColors, int sourceColorsOffset, int count)
		{
		}

		public void BlendPixels(float[] pDestBuffer, int bufferOffset,
			ColorF[] sourceColors, int sourceColorsOffset,
			byte sourceCovers, int count)
		{
		}

		public void BlendPixels(float[] pDestBuffer, int bufferOffset,
			ColorF[] sourceColors, int sourceColorsOffset,
			byte[] sourceCovers, int sourceCoversOffset, int count)
		{
		}

		public void BlendPixels(float[] pDestBuffer, int bufferOffset,
			ColorF[] sourceColors, int sourceColorsOffset,
			byte[] sourceCovers, int sourceCoversOffset, bool firstCoverForAll, int count)
		{
			if (firstCoverForAll)
			{
				//unsafe
				{
					if (sourceCovers[sourceCoversOffset] == 255)
					{
						for (int i = 0; i < count; i++)
						{
							BlendPixel(pDestBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
							sourceColorsOffset++;
							bufferOffset += 4;
						}
					}
					else
					{
						for (int i = 0; i < count; i++)
						{
							ColorF sourceColor = sourceColors[sourceColorsOffset];
							float alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;
							if (alpha == 0)
							{
								continue;
							}
							else if (alpha == 255)
							{
								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;
								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;
								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;
								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;
							}
							else
							{
								float OneOverAlpha = base_mask - alpha;
								unchecked
								{
									float r = pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + sourceColor.red;
									float g = pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + sourceColor.green;
									float b = pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + sourceColor.blue;
									float a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];
									pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;
									pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;
									pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;
									pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (1.0f - ((OneOverAlpha * (1.0f - a))));
								}
							}
							sourceColorsOffset++;
							bufferOffset += 4;
						}
					}
				}
			}
			else
			{
				for (int i = 0; i < count; i++)
				{
					ColorF sourceColor = sourceColors[sourceColorsOffset];
					if (sourceColor.alpha == 1 && sourceCovers[sourceCoversOffset] == 255)
					{
						pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
						pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
						pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
						pDestBuffer[bufferOffset + ImageBuffer.OrderA] = 1;
					}
					else
					{
						// the cover is known to be less than opaque
						float coverFloat = (sourceCovers[sourceCoversOffset] * (1.0f / 255.0f));
						float alpha = sourceColor.alpha * coverFloat;
						if (coverFloat > 0 && alpha > 0)
						{
							float OneOverAlpha = 1.0f - alpha;
							unchecked
							{
								// the color is already pre multiplied by the alpha but not by the cover value so we only need to multiply the color by the cover
								float r = (pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha) + sourceColor.red * coverFloat;
								float g = (pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha) + sourceColor.green * coverFloat;
								float b = (pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha) + sourceColor.blue * coverFloat;

								float destAlpha = pDestBuffer[bufferOffset + ImageBuffer.OrderA];
								float a = (destAlpha + (1.0f - destAlpha) * sourceColor.alpha * coverFloat);
								pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;
								pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;
								pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;
								pDestBuffer[bufferOffset + ImageBuffer.OrderA] = a;
							}
						}
					}
					sourceColorsOffset++;
					sourceCoversOffset++;
					bufferOffset += 4;
				}
			}
		}
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\BlenderRGBA.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
namespace MatterHackers.Agg.Image
{
    public sealed class BlenderRGBA : BlenderBase8888, IRecieveBlenderByte
	{
		public Color PixelToColor(byte[] buffer, int bufferOffset)
		{
			return new Color(buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderA]);
		}

		public void CopyPixels(byte[] buffer, int bufferOffset, Color sourceColor, int count)
		{
			do
			{
				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.red;
				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.blue;
				buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
				bufferOffset += 4;
			}
			while (--count != 0);
		}

		public void BlendPixel(byte[] buffer, int bufferOffset, Color sourceColor)
		{
			//unsafe
			{
				unchecked
				{
					if (sourceColor.alpha == 255)
					{
						buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(sourceColor.red);
						buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(sourceColor.green);
						buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(sourceColor.blue);
						buffer[bufferOffset + ImageBuffer.OrderA] = (byte)(sourceColor.alpha);
					}
					else
					{
						int r = buffer[bufferOffset + ImageBuffer.OrderB];
						int g = buffer[bufferOffset + ImageBuffer.OrderG];
						int b = buffer[bufferOffset + ImageBuffer.OrderR];
						int a = buffer[bufferOffset + ImageBuffer.OrderA];
						buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)Color.base_shift)) >> (int)Color.base_shift);
						buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)Color.base_shift)) >> (int)Color.base_shift);
						buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)Color.base_shift)) >> (int)Color.base_shift);
						buffer[bufferOffset + ImageBuffer.OrderA] = (byte)((sourceColor.alpha + a) - ((sourceColor.alpha * a + base_mask) >> (int)Color.base_shift));
					}
				}
			}
		}

		public void BlendPixels(byte[] destBuffer, int bufferOffset,
			Color[] sourceColors, int sourceColorsOffset,
			byte[] covers, int coversIndex, bool firstCoverForAll, int count)
		{
			if (firstCoverForAll)
			{
				int cover = covers[coversIndex];
				if (cover == 255)
				{
					do
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
						bufferOffset += 4;
					}
					while (--count != 0);
				}
				else
				{
					do
					{
						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
						bufferOffset += 4;
						++sourceColorsOffset;
					}
					while (--count != 0);
				}
			}
			else
			{
				do
				{
					int cover = covers[coversIndex++];
					if (cover == 255)
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
					}
					else
					{
						Color color = sourceColors[sourceColorsOffset];
						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, color);
					}
					bufferOffset += 4;
					++sourceColorsOffset;
				}
				while (--count != 0);
			}
		}
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\Gray.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg.Image
{
	public class blender_gray : IRecieveBlenderByte
	{
		public int NumPixelBits { get { return 8; } }

		public const byte base_mask = 255;
		private const int base_shift = 8;

		private static int[] m_Saturate9BitToByte = new int[1 << 9];

		private int bytesBetweenPixelsInclusive;

		public blender_gray(int bytesBetweenPixelsInclusive)
		{
			this.bytesBetweenPixelsInclusive = bytesBetweenPixelsInclusive;

			if (m_Saturate9BitToByte[2] == 0)
			{
				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)
				{
					m_Saturate9BitToByte[i] = Math.Min(i, 255);
				}
			}
		}

		public Color PixelToColor(byte[] buffer, int bufferOffset)
		{
			int value = buffer[bufferOffset];
			return new Color(value, value, value, 255);
		}

		public void CopyPixels(byte[] pDestBuffer, int bufferOffset, Color sourceColor, int count)
		{
			do
			{
				int y = (sourceColor.red * 77) + (sourceColor.green * 151) + (sourceColor.blue * 28);
				int gray = (y >> 8);
				pDestBuffer[bufferOffset] = (byte)gray;
				bufferOffset += bytesBetweenPixelsInclusive;
			}
			while (--count != 0);
		}

		public void BlendPixel(byte[] pDestBuffer, int bufferOffset, Color sourceColor)
		{
			int OneOverAlpha = base_mask - sourceColor.alpha;
			unchecked
			{
				int y = (sourceColor.red * 77) + (sourceColor.green * 151) + (sourceColor.blue * 28);
				int gray = (y >> 8);
				gray = (byte)((((gray - (int)(pDestBuffer[bufferOffset])) * sourceColor.alpha) + ((int)(pDestBuffer[bufferOffset]) << base_shift)) >> base_shift);
				pDestBuffer[bufferOffset] = (byte)gray;
			}
		}

		public void BlendPixels(byte[] destBuffer, int bufferOffset,
			Color[] sourceColors, int sourceColorsOffset,
			byte[] covers, int coversIndex, bool firstCoverForAll, int count)
		{
			if (firstCoverForAll)
			{
				int cover = covers[coversIndex];
				if (cover == 255)
				{
					do
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
						bufferOffset += bytesBetweenPixelsInclusive;
					}
					while (--count != 0);
				}
				else
				{
					do
					{
						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
						bufferOffset += bytesBetweenPixelsInclusive;
						++sourceColorsOffset;
					}
					while (--count != 0);
				}
			}
			else
			{
				do
				{
					int cover = covers[coversIndex++];
					if (cover == 255)
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
					}
					else
					{
						Color color = sourceColors[sourceColorsOffset];
						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, color);
					}
					bufferOffset += bytesBetweenPixelsInclusive;
					++sourceColorsOffset;
				}
				while (--count != 0);
			}
		}
	}

	public class blenderGrayFromRed : IRecieveBlenderByte
	{
		public int NumPixelBits { get { return 8; } }

		public const byte base_mask = 255;
		private const int base_shift = 8;

		private static int[] m_Saturate9BitToByte = new int[1 << 9];

		private int bytesBetweenPixelsInclusive;

		public blenderGrayFromRed(int bytesBetweenPixelsInclusive)
		{
			this.bytesBetweenPixelsInclusive = bytesBetweenPixelsInclusive;

			if (m_Saturate9BitToByte[2] == 0)
			{
				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)
				{
					m_Saturate9BitToByte[i] = Math.Min(i, 255);
				}
			}
		}

		public Color PixelToColor(byte[] buffer, int bufferOffset)
		{
			int value = buffer[bufferOffset];
			return new Color(value, value, value, 255);
		}

		public void CopyPixels(byte[] pDestBuffer, int bufferOffset, Color sourceColor, int count)
		{
			do
			{
				pDestBuffer[bufferOffset] = sourceColor.red;
				bufferOffset += bytesBetweenPixelsInclusive;
			}
			while (--count != 0);
		}

		public void BlendPixel(byte[] pDestBuffer, int bufferOffset, Color sourceColor)
		{
			int OneOverAlpha = base_mask - sourceColor.alpha;
			unchecked
			{
				byte gray = (byte)((((sourceColor.red - (int)(pDestBuffer[bufferOffset])) * sourceColor.alpha) + ((int)(pDestBuffer[bufferOffset]) << base_shift)) >> base_shift);
				pDestBuffer[bufferOffset] = (byte)gray;
			}
		}

		public void BlendPixels(byte[] destBuffer, int bufferOffset,
			Color[] sourceColors, int sourceColorsOffset,
			byte[] covers, int coversIndex, bool firstCoverForAll, int count)
		{
			if (firstCoverForAll)
			{
				int cover = covers[coversIndex];
				if (cover == 255)
				{
					do
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
						bufferOffset += bytesBetweenPixelsInclusive;
					}
					while (--count != 0);
				}
				else
				{
					do
					{
						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
						bufferOffset += bytesBetweenPixelsInclusive;
						++sourceColorsOffset;
					}
					while (--count != 0);
				}
			}
			else
			{
				do
				{
					int cover = covers[coversIndex++];
					if (cover == 255)
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
					}
					else
					{
						Color color = sourceColors[sourceColorsOffset];
						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, color);
					}
					bufferOffset += bytesBetweenPixelsInclusive;
					++sourceColorsOffset;
				}
				while (--count != 0);
			}
		}
	}

	public class blenderGrayClampedMax : IRecieveBlenderByte
	{
		public int NumPixelBits { get { return 8; } }

		public const byte base_mask = 255;
		private const int base_shift = 8;

		private static int[] m_Saturate9BitToByte = new int[1 << 9];

		private int bytesBetweenPixelsInclusive;

		public blenderGrayClampedMax(int bytesBetweenPixelsInclusive)
		{
			this.bytesBetweenPixelsInclusive = bytesBetweenPixelsInclusive;

			if (m_Saturate9BitToByte[2] == 0)
			{
				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)
				{
					m_Saturate9BitToByte[i] = Math.Min(i, 255);
				}
			}
		}

		public Color PixelToColor(byte[] buffer, int bufferOffset)
		{
			int value = buffer[bufferOffset];
			return new Color(value, value, value, 255);
		}

		public void CopyPixels(byte[] pDestBuffer, int bufferOffset, Color sourceColor, int count)
		{
			do
			{
				byte clampedMax = Math.Min(Math.Max(sourceColor.red, Math.Max(sourceColor.green, sourceColor.blue)), (byte)255);
				pDestBuffer[bufferOffset] = clampedMax;
				bufferOffset += bytesBetweenPixelsInclusive;
			}
			while (--count != 0);
		}

		public void BlendPixel(byte[] pDestBuffer, int bufferOffset, Color sourceColor)
		{
			int OneOverAlpha = base_mask - sourceColor.alpha;
			unchecked
			{
				byte clampedMax = Math.Min(Math.Max(sourceColor.red, Math.Max(sourceColor.green, sourceColor.blue)), (byte)255);
				byte gray = (byte)((((clampedMax - (int)(pDestBuffer[bufferOffset])) * sourceColor.alpha) + ((int)(pDestBuffer[bufferOffset]) << base_shift)) >> base_shift);
				pDestBuffer[bufferOffset] = (byte)gray;
			}
		}

		public void BlendPixels(byte[] destBuffer, int bufferOffset,
			Color[] sourceColors, int sourceColorsOffset,
			byte[] covers, int coversIndex, bool firstCoverForAll, int count)
		{
			if (firstCoverForAll)
			{
				int cover = covers[coversIndex];
				if (cover == 255)
				{
					do
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
						bufferOffset += bytesBetweenPixelsInclusive;
					}
					while (--count != 0);
				}
				else
				{
					do
					{
						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
						bufferOffset += bytesBetweenPixelsInclusive;
						++sourceColorsOffset;
					}
					while (--count != 0);
				}
			}
			else
			{
				do
				{
					int cover = covers[coversIndex++];
					if (cover == 255)
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
					}
					else
					{
						Color color = sourceColors[sourceColorsOffset];
						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, color);
					}
					bufferOffset += bytesBetweenPixelsInclusive;
					++sourceColorsOffset;
				}
				while (--count != 0);
			}
		}
	}

	/*

	//======================================================blender_gray_pre
	//template<class ColorT>
	struct blender_gray_pre
	{
		typedef ColorT color_type;
		typedef typename color_type::value_type value_type;
		typedef typename color_type::calc_type calc_type;
		enum base_scale_e { base_shift = color_type::base_shift };

		static void blend_pix(value_type* p, int cv,
										 int alpha, int cover)
		{
			alpha = color_type::base_mask - alpha;
			cover = (cover + 1) << (base_shift - 8);
			*p = (value_type)((*p * alpha + cv * cover) >> base_shift);
		}

		static void blend_pix(value_type* p, int cv,
										 int alpha)
		{
			*p = (value_type)(((*p * (color_type::base_mask - alpha)) >> base_shift) + cv);
		}
	};

	//=====================================================apply_gamma_dir_gray
	//template<class ColorT, class GammaLut>
	class apply_gamma_dir_gray
	{
	public:
		typedef typename ColorT::value_type value_type;

		apply_gamma_dir_gray(GammaLut& gamma) : m_gamma(gamma) {}

		void operator () (byte* p)
		{
			*p = m_gamma.dir(*p);
		}

	private:
		GammaLut& m_gamma;
	};

	//=====================================================apply_gamma_inv_gray
	//template<class ColorT, class GammaLut>
	class apply_gamma_inv_gray
	{
	public:
		typedef typename ColorT::value_type value_type;

		apply_gamma_inv_gray(GammaLut& gamma) : m_gamma(gamma) {}

		void operator () (byte* p)
		{
			*p = m_gamma.inv(*p);
		}

	private:
		GammaLut& m_gamma;
	};

	 */
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\IRecieveBlenderByte.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
namespace MatterHackers.Agg.Image
{
    public interface IRecieveBlenderByte
	{
		int NumPixelBits { get; }

		Color PixelToColor(byte[] buffer, int bufferOffset);

		void CopyPixels(byte[] buffer, int bufferOffset, Color sourceColor, int count);

		void BlendPixel(byte[] buffer, int bufferOffset, Color sourceColor);

		void BlendPixels(byte[] buffer, int bufferOffset, Color[] sourceColors, int sourceColorsOffset, byte[] sourceCovers, int sourceCoversOffset, bool firstCoverForAll, int count);
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\IRecieveBlenderFloat.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
namespace MatterHackers.Agg.Image
{
    public interface IRecieveBlenderFloat
	{
		int NumPixelBits { get; }

		ColorF PixelToColorRGBA_Floats(float[] buffer, int bufferOffset);

		void CopyPixels(float[] buffer, int bufferOffset, ColorF sourceColor, int count);

		void BlendPixel(float[] buffer, int bufferOffset, ColorF sourceColor);

		void BlendPixels(float[] buffer, int bufferOffset,
			ColorF[] sourceColors, int sourceColorsOffset,
			byte[] sourceCovers, int sourceCoversOffset, bool firstCoverForAll, int count);
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\rgb.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg.Image
{
	/*
		//=========================================================multiplier_rgba
		template<class ColorT, class Order> struct multiplier_rgba
		{
			typedef typename ColorT::value_type value_type;
			typedef typename ColorT::calc_type calc_type;

			//--------------------------------------------------------------------
			static void premultiply(value_type* p)
			{
				calc_type a = p[Order::A];
				if(a < ColorT::base_mask)
				{
					if(a == 0)
					{
						p[Order::R] = p[Order::G] = p[Order::B] = 0;
						return;
					}
					p[Order::R] = value_type((p[Order::R] * a + ColorT::base_mask) >> ColorT::base_shift);
					p[Order::G] = value_type((p[Order::G] * a + ColorT::base_mask) >> ColorT::base_shift);
					p[Order::B] = value_type((p[Order::B] * a + ColorT::base_mask) >> ColorT::base_shift);
				}
			}

			//--------------------------------------------------------------------
			static void demultiply(value_type* p)
			{
				calc_type a = p[Order::A];
				if(a < ColorT::base_mask)
				{
					if(a == 0)
					{
						p[Order::R] = p[Order::G] = p[Order::B] = 0;
						return;
					}
					calc_type r = (calc_type(p[Order::R]) * ColorT::base_mask) / a;
					calc_type g = (calc_type(p[Order::G]) * ColorT::base_mask) / a;
					calc_type b = (calc_type(p[Order::B]) * ColorT::base_mask) / a;
					p[Order::R] = value_type((r > ColorT::base_mask) ? ColorT::base_mask : r);
					p[Order::G] = value_type((g > ColorT::base_mask) ? ColorT::base_mask : g);
					p[Order::B] = value_type((b > ColorT::base_mask) ? ColorT::base_mask : b);
				}
			}
		};

		//=====================================================apply_gamma_dir_rgba
		template<class ColorT, class Order, class GammaLut> class apply_gamma_dir_rgba
		{
		public:
			typedef typename ColorT::value_type value_type;

			apply_gamma_dir_rgba(const GammaLut& gamma) : m_gamma(gamma) {}

			void operator () (value_type* p)
			{
				p[Order::R] = m_gamma.dir(p[Order::R]);
				p[Order::G] = m_gamma.dir(p[Order::G]);
				p[Order::B] = m_gamma.dir(p[Order::B]);
			}

		private:
			const GammaLut& m_gamma;
		};

		//=====================================================apply_gamma_inv_rgba
		template<class ColorT, class Order, class GammaLut> class apply_gamma_inv_rgba
		{
		public:
			typedef typename ColorT::value_type value_type;

			apply_gamma_inv_rgba(const GammaLut& gamma) : m_gamma(gamma) {}

			void operator () (value_type* p)
			{
				p[Order::R] = m_gamma.inv(p[Order::R]);
				p[Order::G] = m_gamma.inv(p[Order::G]);
				p[Order::B] = m_gamma.inv(p[Order::B]);
			}

		private:
			const GammaLut& m_gamma;
		};

	   //=============================================================blender_rgba
		template<class ColorT, class Order> struct blender_rgba
		{
			typedef ColorT color_type;
			typedef Order order_type;
			typedef typename color_type::value_type value_type;
			typedef typename color_type::calc_type calc_type;
			enum base_scale_e
			{
				base_shift = color_type::base_shift,
				base_mask  = color_type::base_mask
			};

			//--------------------------------------------------------------------
			static void blend_pix(value_type* p,
											 int cr, int cg, int cb,
											 int alpha,
											 int cover=0)
			{
				calc_type r = p[Order::R];
				calc_type g = p[Order::G];
				calc_type b = p[Order::B];
				calc_type a = p[Order::A];
				p[Order::R] = (value_type)(((cr - r) * alpha + (r << base_shift)) >> base_shift);
				p[Order::G] = (value_type)(((cg - g) * alpha + (g << base_shift)) >> base_shift);
				p[Order::B] = (value_type)(((cb - b) * alpha + (b << base_shift)) >> base_shift);
				p[Order::A] = (value_type)((alpha + a) - ((alpha * a + base_mask) >> base_shift));
			}
		};
	 */

	public class BlenderBaseBGR
	{
		public int NumPixelBits { get { return 24; } }

		public const byte base_mask = 255;
	};

	public sealed class BlenderBGR : BlenderBaseBGR, IRecieveBlenderByte
	{
		public Color PixelToColor(byte[] buffer, int bufferOffset)
		{
			return new Color(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], 255);
		}

		public void CopyPixels(byte[] buffer, int bufferOffset, Color sourceColor, int count)
		{
			do
			{
				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
				bufferOffset += 3;
			}
			while (--count != 0);
		}

		public void BlendPixel(byte[] buffer, int bufferOffset, Color sourceColor)
		{
			unchecked
			{
				int r = buffer[bufferOffset + ImageBuffer.OrderR];
				int g = buffer[bufferOffset + ImageBuffer.OrderG];
				int b = buffer[bufferOffset + ImageBuffer.OrderB];
				buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)Color.base_shift)) >> (int)Color.base_shift);
				buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)Color.base_shift)) >> (int)Color.base_shift);
				buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)Color.base_shift)) >> (int)Color.base_shift);
			}
		}

		public void BlendPixels(byte[] destBuffer, int bufferOffset,
			Color[] sourceColors, int sourceColorsOffset,
			byte[] covers, int coversIndex, bool firstCoverForAll, int count)
		{
			if (firstCoverForAll)
			{
				int cover = covers[coversIndex];
				if (cover == 255)
				{
					do
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
						bufferOffset += 3;
					}
					while (--count != 0);
				}
				else
				{
					do
					{
						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
						bufferOffset += 3;
						++sourceColorsOffset;
					}
					while (--count != 0);
				}
			}
			else
			{
				do
				{
					int cover = covers[coversIndex++];
					if (cover == 255)
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
					}
					else
					{
						Color color = sourceColors[sourceColorsOffset];
						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, color);
					}
					bufferOffset += 3;
					++sourceColorsOffset;
				}
				while (--count != 0);
			}
		}
	};

	public sealed class BlenderGammaBGR : BlenderBaseBGR, IRecieveBlenderByte
	{
		private GammaLookUpTable m_gamma;

		public BlenderGammaBGR()
		{
			m_gamma = new GammaLookUpTable();
		}

		public BlenderGammaBGR(GammaLookUpTable g)
		{
			m_gamma = g;
		}

		public void gamma(GammaLookUpTable g)
		{
			m_gamma = g;
		}

		public Color PixelToColor(byte[] buffer, int bufferOffset)
		{
			return new Color(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], 255);
		}

		public void CopyPixels(byte[] buffer, int bufferOffset, Color sourceColor, int count)
		{
			buffer[bufferOffset + ImageBuffer.OrderR] = m_gamma.inv(sourceColor.red);
			buffer[bufferOffset + ImageBuffer.OrderG] = m_gamma.inv(sourceColor.green);
			buffer[bufferOffset + ImageBuffer.OrderB] = m_gamma.inv(sourceColor.blue);
		}

		public void BlendPixel(byte[] buffer, int bufferOffset, Color sourceColor)
		{
			unchecked
			{
				int r = buffer[bufferOffset + ImageBuffer.OrderR];
				int g = buffer[bufferOffset + ImageBuffer.OrderG];
				int b = buffer[bufferOffset + ImageBuffer.OrderB];
				buffer[bufferOffset + ImageBuffer.OrderR] = m_gamma.inv((byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)Color.base_shift)) >> (int)Color.base_shift));
				buffer[bufferOffset + ImageBuffer.OrderG] = m_gamma.inv((byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)Color.base_shift)) >> (int)Color.base_shift));
				buffer[bufferOffset + ImageBuffer.OrderB] = m_gamma.inv((byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)Color.base_shift)) >> (int)Color.base_shift));
			}
		}

		public void BlendPixels(byte[] buffer, int bufferOffset,
			Color[] sourceColors, int sourceColorsOffset,
			byte[] sourceCovers, int sourceCoversOffset, bool firstCoverForAll, int count)
		{
			throw new NotImplementedException();
		}
	};

	public sealed class BlenderPreMultBGR : BlenderBaseBGR, IRecieveBlenderByte
	{
		private static int[] m_Saturate9BitToByte = new int[1 << 9];

		public BlenderPreMultBGR()
		{
			if (m_Saturate9BitToByte[2] == 0)
			{
				for (int i = 0; i < m_Saturate9BitToByte.Length; i++)
				{
					m_Saturate9BitToByte[i] = Math.Min(i, 255);
				}
			}
		}

		public Color PixelToColor(byte[] buffer, int bufferOffset)
		{
			return new Color(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], 255);
		}

		public void CopyPixels(byte[] buffer, int bufferOffset, Color sourceColor, int count)
		{
			do
			{
				buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
				buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
				buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
				bufferOffset += 3;
			}
			while (--count != 0);
		}

		public void BlendPixel(byte[] pDestBuffer, int bufferOffset, Color sourceColor)
		{
			if (sourceColor.alpha == 255)
			{
				pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
				pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
				pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
			}
			else
			{
				int OneOverAlpha = base_mask - sourceColor.alpha;
				unchecked
				{
					int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];
					int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];
					int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];
					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;
					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;
					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;
				}
			}
		}

		public void BlendPixels(byte[] destBuffer, int bufferOffset,
			Color[] sourceColors, int sourceColorsOffset,
			byte[] covers, int coversIndex, bool firstCoverForAll, int count)
		{
			if (firstCoverForAll)
			{
				int cover = covers[coversIndex];
				if (cover == 255)
				{
					do
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
						bufferOffset += 3;
					}
					while (--count != 0);
				}
				else
				{
					do
					{
						sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
						bufferOffset += 3;
						++sourceColorsOffset;
					}
					while (--count != 0);
				}
			}
			else
			{
				do
				{
					int cover = covers[coversIndex++];
					if (cover == 255)
					{
						BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
					}
					else
					{
						Color color = sourceColors[sourceColorsOffset];
						color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
						BlendPixel(destBuffer, bufferOffset, color);
					}
					bufferOffset += 3;
					++sourceColorsOffset;
				}
				while (--count != 0);
			}
		}
	};

	/*
//======================================================blender_rgba_plain
template<class ColorT, class Order> struct blender_rgba_plain
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e { base_shift = color_type::base_shift };

	//--------------------------------------------------------------------
	static void blend_pix(value_type* p,
									 int cr, int cg, int cb,
									 int alpha,
									 int cover=0)
	{
		if(alpha == 0) return;
		calc_type a = p[Order::A];
		calc_type r = p[Order::R] * a;
		calc_type g = p[Order::G] * a;
		calc_type b = p[Order::B] * a;
		a = ((alpha + a) << base_shift) - alpha * a;
		p[Order::A] = (value_type)(a >> base_shift);
		p[Order::R] = (value_type)((((cr << base_shift) - r) * alpha + (r << base_shift)) / a);
		p[Order::G] = (value_type)((((cg << base_shift) - g) * alpha + (g << base_shift)) / a);
		p[Order::B] = (value_type)((((cb << base_shift) - b) * alpha + (b << base_shift)) / a);
	}
};

//=========================================================comp_op_rgba_clear
template<class ColorT, class Order> struct comp_op_rgba_clear
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(value_type* p,
									 int, int, int, int,
									 int cover)
	{
		if(cover < 255)
		{
			cover = 255 - cover;
			p[Order::R] = (value_type)((p[Order::R] * cover + 255) >> rgba8.base_shift);
			p[Order::G] = (value_type)((p[Order::G] * cover + 255) >> rgba8.base_shift);
			p[Order::B] = (value_type)((p[Order::B] * cover + 255) >> rgba8.base_shift);
			p[Order::A] = (value_type)((p[Order::A] * cover + 255) >> rgba8.base_shift);
		}
		else
		{
			p[0] = p[1] = p[2] = p[3] = 0;
		}
	}
};

//===========================================================comp_op_rgba_src
template<class ColorT, class Order> struct comp_op_rgba_src
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;

	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			int alpha = 255 - cover;
			p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((sr * cover + 255) >> 8));
			p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((sg * cover + 255) >> 8));
			p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((sb * cover + 255) >> 8));
			p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((sa * cover + 255) >> 8));
		}
		else
		{
			p[Order::R] = sr;
			p[Order::G] = sg;
			p[Order::B] = sb;
			p[Order::A] = sa;
		}
	}
};

//===========================================================comp_op_rgba_dst
template<class ColorT, class Order> struct comp_op_rgba_dst
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;

	static void blend_pix(value_type*,
									 int, int, int,
									 int, int)
	{
	}
};

//======================================================comp_op_rgba_src_over
template<class ColorT, class Order> struct comp_op_rgba_src_over
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	//   Dca' = Sca + Dca.(1 - Sa)
	//   Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		calc_type s1a = base_mask - sa;
		p[Order::R] = (value_type)(sr + ((p[Order::R] * s1a + base_mask) >> base_shift));
		p[Order::G] = (value_type)(sg + ((p[Order::G] * s1a + base_mask) >> base_shift));
		p[Order::B] = (value_type)(sb + ((p[Order::B] * s1a + base_mask) >> base_shift));
		p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
	}
};

//======================================================comp_op_rgba_dst_over
template<class ColorT, class Order> struct comp_op_rgba_dst_over
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Dca + Sca.(1 - Da)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		calc_type d1a = base_mask - p[Order::A];
		p[Order::R] = (value_type)(p[Order::R] + ((sr * d1a + base_mask) >> base_shift));
		p[Order::G] = (value_type)(p[Order::G] + ((sg * d1a + base_mask) >> base_shift));
		p[Order::B] = (value_type)(p[Order::B] + ((sb * d1a + base_mask) >> base_shift));
		p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
	}
};

//======================================================comp_op_rgba_src_in
template<class ColorT, class Order> struct comp_op_rgba_src_in
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca.Da
	// Da'  = Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		calc_type da = p[Order::A];
		if(cover < 255)
		{
			int alpha = 255 - cover;
			p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((((sr * da + base_mask) >> base_shift) * cover + 255) >> 8));
			p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((((sg * da + base_mask) >> base_shift) * cover + 255) >> 8));
			p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((((sb * da + base_mask) >> base_shift) * cover + 255) >> 8));
			p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((((sa * da + base_mask) >> base_shift) * cover + 255) >> 8));
		}
		else
		{
			p[Order::R] = (value_type)((sr * da + base_mask) >> base_shift);
			p[Order::G] = (value_type)((sg * da + base_mask) >> base_shift);
			p[Order::B] = (value_type)((sb * da + base_mask) >> base_shift);
			p[Order::A] = (value_type)((sa * da + base_mask) >> base_shift);
		}
	}
};

//======================================================comp_op_rgba_dst_in
template<class ColorT, class Order> struct comp_op_rgba_dst_in
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Dca.Sa
	// Da'  = Sa.Da
	static void blend_pix(value_type* p,
									 int, int, int,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sa = base_mask - ((cover * (base_mask - sa) + 255) >> 8);
		}
		p[Order::R] = (value_type)((p[Order::R] * sa + base_mask) >> base_shift);
		p[Order::G] = (value_type)((p[Order::G] * sa + base_mask) >> base_shift);
		p[Order::B] = (value_type)((p[Order::B] * sa + base_mask) >> base_shift);
		p[Order::A] = (value_type)((p[Order::A] * sa + base_mask) >> base_shift);
	}
};

//======================================================comp_op_rgba_src_out
template<class ColorT, class Order> struct comp_op_rgba_src_out
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca.(1 - Da)
	// Da'  = Sa.(1 - Da)
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		calc_type da = base_mask - p[Order::A];
		if(cover < 255)
		{
			int alpha = 255 - cover;
			p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((((sr * da + base_mask) >> base_shift) * cover + 255) >> 8));
			p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((((sg * da + base_mask) >> base_shift) * cover + 255) >> 8));
			p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((((sb * da + base_mask) >> base_shift) * cover + 255) >> 8));
			p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((((sa * da + base_mask) >> base_shift) * cover + 255) >> 8));
		}
		else
		{
			p[Order::R] = (value_type)((sr * da + base_mask) >> base_shift);
			p[Order::G] = (value_type)((sg * da + base_mask) >> base_shift);
			p[Order::B] = (value_type)((sb * da + base_mask) >> base_shift);
			p[Order::A] = (value_type)((sa * da + base_mask) >> base_shift);
		}
	}
};

//======================================================comp_op_rgba_dst_out
template<class ColorT, class Order> struct comp_op_rgba_dst_out
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Dca.(1 - Sa)
	// Da'  = Da.(1 - Sa)
	static void blend_pix(value_type* p,
									 int, int, int,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sa = (sa * cover + 255) >> 8;
		}
		sa = base_mask - sa;
		p[Order::R] = (value_type)((p[Order::R] * sa + base_shift) >> base_shift);
		p[Order::G] = (value_type)((p[Order::G] * sa + base_shift) >> base_shift);
		p[Order::B] = (value_type)((p[Order::B] * sa + base_shift) >> base_shift);
		p[Order::A] = (value_type)((p[Order::A] * sa + base_shift) >> base_shift);
	}
};

//=====================================================comp_op_rgba_src_atop
template<class ColorT, class Order> struct comp_op_rgba_src_atop
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca.Da + Dca.(1 - Sa)
	// Da'  = Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		calc_type da = p[Order::A];
		sa = base_mask - sa;
		p[Order::R] = (value_type)((sr * da + p[Order::R] * sa + base_mask) >> base_shift);
		p[Order::G] = (value_type)((sg * da + p[Order::G] * sa + base_mask) >> base_shift);
		p[Order::B] = (value_type)((sb * da + p[Order::B] * sa + base_mask) >> base_shift);
	}
};

//=====================================================comp_op_rgba_dst_atop
template<class ColorT, class Order> struct comp_op_rgba_dst_atop
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Dca.Sa + Sca.(1 - Da)
	// Da'  = Sa
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		calc_type da = base_mask - p[Order::A];
		if(cover < 255)
		{
			int alpha = 255 - cover;
			sr = (p[Order::R] * sa + sr * da + base_mask) >> base_shift;
			sg = (p[Order::G] * sa + sg * da + base_mask) >> base_shift;
			sb = (p[Order::B] * sa + sb * da + base_mask) >> base_shift;
			p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((sr * cover + 255) >> 8));
			p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((sg * cover + 255) >> 8));
			p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((sb * cover + 255) >> 8));
			p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((sa * cover + 255) >> 8));
		}
		else
		{
			p[Order::R] = (value_type)((p[Order::R] * sa + sr * da + base_mask) >> base_shift);
			p[Order::G] = (value_type)((p[Order::G] * sa + sg * da + base_mask) >> base_shift);
			p[Order::B] = (value_type)((p[Order::B] * sa + sb * da + base_mask) >> base_shift);
			p[Order::A] = (value_type)sa;
		}
	}
};

//=========================================================comp_op_rgba_xor
template<class ColorT, class Order> struct comp_op_rgba_xor
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca.(1 - Da) + Dca.(1 - Sa)
	// Da'  = Sa + Da - 2.Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type s1a = base_mask - sa;
			calc_type d1a = base_mask - p[Order::A];
			p[Order::R] = (value_type)((p[Order::R] * s1a + sr * d1a + base_mask) >> base_shift);
			p[Order::G] = (value_type)((p[Order::G] * s1a + sg * d1a + base_mask) >> base_shift);
			p[Order::B] = (value_type)((p[Order::B] * s1a + sb * d1a + base_mask) >> base_shift);
			p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask/2) >> (base_shift - 1)));
		}
	}
};

//=========================================================comp_op_rgba_plus
template<class ColorT, class Order> struct comp_op_rgba_plus
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca + Dca
	// Da'  = Sa + Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type dr = p[Order::R] + sr;
			calc_type dg = p[Order::G] + sg;
			calc_type db = p[Order::B] + sb;
			calc_type da = p[Order::A] + sa;
			p[Order::R] = (dr > base_mask) ? (value_type)base_mask : dr;
			p[Order::G] = (dg > base_mask) ? (value_type)base_mask : dg;
			p[Order::B] = (db > base_mask) ? (value_type)base_mask : db;
			p[Order::A] = (da > base_mask) ? (value_type)base_mask : da;
		}
	}
};

//========================================================comp_op_rgba_minus
template<class ColorT, class Order> struct comp_op_rgba_minus
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Dca - Sca
	// Da' = 1 - (1 - Sa).(1 - Da)
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type dr = p[Order::R] - sr;
			calc_type dg = p[Order::G] - sg;
			calc_type db = p[Order::B] - sb;
			p[Order::R] = (dr > base_mask) ? 0 : dr;
			p[Order::G] = (dg > base_mask) ? 0 : dg;
			p[Order::B] = (db > base_mask) ? 0 : db;
			p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
			//p[Order::A] = (value_type)(base_mask - (((base_mask - sa) * (base_mask - p[Order::A]) + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_multiply
template<class ColorT, class Order> struct comp_op_rgba_multiply
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca.Dca + Sca.(1 - Da) + Dca.(1 - Sa)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type s1a = base_mask - sa;
			calc_type d1a = base_mask - p[Order::A];
			calc_type dr = p[Order::R];
			calc_type dg = p[Order::G];
			calc_type db = p[Order::B];
			p[Order::R] = (value_type)((sr * dr + sr * d1a + dr * s1a + base_mask) >> base_shift);
			p[Order::G] = (value_type)((sg * dg + sg * d1a + dg * s1a + base_mask) >> base_shift);
			p[Order::B] = (value_type)((sb * db + sb * d1a + db * s1a + base_mask) >> base_shift);
			p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_screen
template<class ColorT, class Order> struct comp_op_rgba_screen
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca + Dca - Sca.Dca
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type dr = p[Order::R];
			calc_type dg = p[Order::G];
			calc_type db = p[Order::B];
			calc_type da = p[Order::A];
			p[Order::R] = (value_type)(sr + dr - ((sr * dr + base_mask) >> base_shift));
			p[Order::G] = (value_type)(sg + dg - ((sg * dg + base_mask) >> base_shift));
			p[Order::B] = (value_type)(sb + db - ((sb * db + base_mask) >> base_shift));
			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_overlay
template<class ColorT, class Order> struct comp_op_rgba_overlay
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// if 2.Dca < Da
	//   Dca' = 2.Sca.Dca + Sca.(1 - Da) + Dca.(1 - Sa)
	// otherwise
	//   Dca' = Sa.Da - 2.(Da - Dca).(Sa - Sca) + Sca.(1 - Da) + Dca.(1 - Sa)
	//
	// Da' = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type d1a  = base_mask - p[Order::A];
			calc_type s1a  = base_mask - sa;
			calc_type dr   = p[Order::R];
			calc_type dg   = p[Order::G];
			calc_type db   = p[Order::B];
			calc_type da   = p[Order::A];
			calc_type sada = sa * p[Order::A];

			p[Order::R] = (value_type)(((2*dr < da) ?
				2*sr*dr + sr*d1a + dr*s1a :
				sada - 2*(da - dr)*(sa - sr) + sr*d1a + dr*s1a + base_mask) >> base_shift);

			p[Order::G] = (value_type)(((2*dg < da) ?
				2*sg*dg + sg*d1a + dg*s1a :
				sada - 2*(da - dg)*(sa - sg) + sg*d1a + dg*s1a + base_mask) >> base_shift);

			p[Order::B] = (value_type)(((2*db < da) ?
				2*sb*db + sb*d1a + db*s1a :
				sada - 2*(da - db)*(sa - sb) + sb*d1a + db*s1a + base_mask) >> base_shift);

			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

template<class T> inline T sd_min(T a, T b) { return (a < b) ? a : b; }
template<class T> inline T sd_max(T a, T b) { return (a > b) ? a : b; }

//=====================================================comp_op_rgba_darken
template<class ColorT, class Order> struct comp_op_rgba_darken
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = min(Sca.Da, Dca.Sa) + Sca.(1 - Da) + Dca.(1 - Sa)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type d1a = base_mask - p[Order::A];
			calc_type s1a = base_mask - sa;
			calc_type dr  = p[Order::R];
			calc_type dg  = p[Order::G];
			calc_type db  = p[Order::B];
			calc_type da  = p[Order::A];

			p[Order::R] = (value_type)((sd_min(sr * da, dr * sa) + sr * d1a + dr * s1a + base_mask) >> base_shift);
			p[Order::G] = (value_type)((sd_min(sg * da, dg * sa) + sg * d1a + dg * s1a + base_mask) >> base_shift);
			p[Order::B] = (value_type)((sd_min(sb * da, db * sa) + sb * d1a + db * s1a + base_mask) >> base_shift);
			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_lighten
template<class ColorT, class Order> struct comp_op_rgba_lighten
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = max(Sca.Da, Dca.Sa) + Sca.(1 - Da) + Dca.(1 - Sa)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type d1a = base_mask - p[Order::A];
			calc_type s1a = base_mask - sa;
			calc_type dr  = p[Order::R];
			calc_type dg  = p[Order::G];
			calc_type db  = p[Order::B];
			calc_type da  = p[Order::A];

			p[Order::R] = (value_type)((sd_max(sr * da, dr * sa) + sr * d1a + dr * s1a + base_mask) >> base_shift);
			p[Order::G] = (value_type)((sd_max(sg * da, dg * sa) + sg * d1a + dg * s1a + base_mask) >> base_shift);
			p[Order::B] = (value_type)((sd_max(sb * da, db * sa) + sb * d1a + db * s1a + base_mask) >> base_shift);
			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_color_dodge
template<class ColorT, class Order> struct comp_op_rgba_color_dodge
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// if Sca.Da + Dca.Sa >= Sa.Da
	//   Dca' = Sa.Da + Sca.(1 - Da) + Dca.(1 - Sa)
	// otherwise
	//   Dca' = Dca.Sa/(1-Sca/Sa) + Sca.(1 - Da) + Dca.(1 - Sa)
	//
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type d1a  = base_mask - p[Order::A];
			calc_type s1a  = base_mask - sa;
			calc_type dr   = p[Order::R];
			calc_type dg   = p[Order::G];
			calc_type db   = p[Order::B];
			calc_type da   = p[Order::A];
			long_type drsa = dr * sa;
			long_type dgsa = dg * sa;
			long_type dbsa = db * sa;
			long_type srda = sr * da;
			long_type sgda = sg * da;
			long_type sbda = sb * da;
			long_type sada = sa * da;

			p[Order::R] = (value_type)((srda + drsa >= sada) ?
				(sada + sr * d1a + dr * s1a + base_mask) >> base_shift :
				drsa / (base_mask - (sr << base_shift) / sa) + ((sr * d1a + dr * s1a + base_mask) >> base_shift));

			p[Order::G] = (value_type)((sgda + dgsa >= sada) ?
				(sada + sg * d1a + dg * s1a + base_mask) >> base_shift :
				dgsa / (base_mask - (sg << base_shift) / sa) + ((sg * d1a + dg * s1a + base_mask) >> base_shift));

			p[Order::B] = (value_type)((sbda + dbsa >= sada) ?
				(sada + sb * d1a + db * s1a + base_mask) >> base_shift :
				dbsa / (base_mask - (sb << base_shift) / sa) + ((sb * d1a + db * s1a + base_mask) >> base_shift));

			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_color_burn
template<class ColorT, class Order> struct comp_op_rgba_color_burn
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// if Sca.Da + Dca.Sa <= Sa.Da
	//   Dca' = Sca.(1 - Da) + Dca.(1 - Sa)
	// otherwise
	//   Dca' = Sa.(Sca.Da + Dca.Sa - Sa.Da)/Sca + Sca.(1 - Da) + Dca.(1 - Sa)
	//
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type d1a  = base_mask - p[Order::A];
			calc_type s1a  = base_mask - sa;
			calc_type dr   = p[Order::R];
			calc_type dg   = p[Order::G];
			calc_type db   = p[Order::B];
			calc_type da   = p[Order::A];
			long_type drsa = dr * sa;
			long_type dgsa = dg * sa;
			long_type dbsa = db * sa;
			long_type srda = sr * da;
			long_type sgda = sg * da;
			long_type sbda = sb * da;
			long_type sada = sa * da;

			p[Order::R] = (value_type)(((srda + drsa <= sada) ?
				sr * d1a + dr * s1a :
				sa * (srda + drsa - sada) / sr + sr * d1a + dr * s1a + base_mask) >> base_shift);

			p[Order::G] = (value_type)(((sgda + dgsa <= sada) ?
				sg * d1a + dg * s1a :
				sa * (sgda + dgsa - sada) / sg + sg * d1a + dg * s1a + base_mask) >> base_shift);

			p[Order::B] = (value_type)(((sbda + dbsa <= sada) ?
				sb * d1a + db * s1a :
				sa * (sbda + dbsa - sada) / sb + sb * d1a + db * s1a + base_mask) >> base_shift);

			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_hard_light
template<class ColorT, class Order> struct comp_op_rgba_hard_light
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// if 2.Sca < Sa
	//    Dca' = 2.Sca.Dca + Sca.(1 - Da) + Dca.(1 - Sa)
	// otherwise
	//    Dca' = Sa.Da - 2.(Da - Dca).(Sa - Sca) + Sca.(1 - Da) + Dca.(1 - Sa)
	//
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type d1a  = base_mask - p[Order::A];
			calc_type s1a  = base_mask - sa;
			calc_type dr   = p[Order::R];
			calc_type dg   = p[Order::G];
			calc_type db   = p[Order::B];
			calc_type da   = p[Order::A];
			calc_type sada = sa * da;

			p[Order::R] = (value_type)(((2*sr < sa) ?
				2*sr*dr + sr*d1a + dr*s1a :
				sada - 2*(da - dr)*(sa - sr) + sr*d1a + dr*s1a + base_mask) >> base_shift);

			p[Order::G] = (value_type)(((2*sg < sa) ?
				2*sg*dg + sg*d1a + dg*s1a :
				sada - 2*(da - dg)*(sa - sg) + sg*d1a + dg*s1a + base_mask) >> base_shift);

			p[Order::B] = (value_type)(((2*sb < sa) ?
				2*sb*db + sb*d1a + db*s1a :
				sada - 2*(da - db)*(sa - sb) + sb*d1a + db*s1a + base_mask) >> base_shift);

			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_soft_light
template<class ColorT, class Order> struct comp_op_rgba_soft_light
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// if 2.Sca < Sa
	//   Dca' = Dca.(Sa + (1 - Dca/Da).(2.Sca - Sa)) + Sca.(1 - Da) + Dca.(1 - Sa)
	// otherwise if 8.Dca <= Da
	//   Dca' = Dca.(Sa + (1 - Dca/Da).(2.Sca - Sa).(3 - 8.Dca/Da)) + Sca.(1 - Da) + Dca.(1 - Sa)
	// otherwise
	//   Dca' = (Dca.Sa + ((Dca/Da)^(0.5).Da - Dca).(2.Sca - Sa)) + Sca.(1 - Da) + Dca.(1 - Sa)
	//
	// Da'  = Sa + Da - Sa.Da

	static void blend_pix(value_type* p,
									 int r, int g, int b,
									 int a, int cover)
	{
		double sr = double(r * cover) / (base_mask * 255);
		double sg = double(g * cover) / (base_mask * 255);
		double sb = double(b * cover) / (base_mask * 255);
		double sa = double(a * cover) / (base_mask * 255);
		if(sa > 0)
		{
			double dr = double(p[Order::R]) / base_mask;
			double dg = double(p[Order::G]) / base_mask;
			double db = double(p[Order::B]) / base_mask;
			double da = double(p[Order::A] ? p[Order::A] : 1) / base_mask;
			if(cover < 255)
			{
				a = (a * cover + 255) >> 8;
			}

			if(2*sr < sa)       dr = dr*(sa + (1 - dr/da)*(2*sr - sa)) + sr*(1 - da) + dr*(1 - sa);
			else if(8*dr <= da) dr = dr*(sa + (1 - dr/da)*(2*sr - sa)*(3 - 8*dr/da)) + sr*(1 - da) + dr*(1 - sa);
			else                dr = (dr*sa + (sqrt(dr/da)*da - dr)*(2*sr - sa)) + sr*(1 - da) + dr*(1 - sa);

			if(2*sg < sa)       dg = dg*(sa + (1 - dg/da)*(2*sg - sa)) + sg*(1 - da) + dg*(1 - sa);
			else if(8*dg <= da) dg = dg*(sa + (1 - dg/da)*(2*sg - sa)*(3 - 8*dg/da)) + sg*(1 - da) + dg*(1 - sa);
			else                dg = (dg*sa + (sqrt(dg/da)*da - dg)*(2*sg - sa)) + sg*(1 - da) + dg*(1 - sa);

			if(2*sb < sa)       db = db*(sa + (1 - db/da)*(2*sb - sa)) + sb*(1 - da) + db*(1 - sa);
			else if(8*db <= da) db = db*(sa + (1 - db/da)*(2*sb - sa)*(3 - 8*db/da)) + sb*(1 - da) + db*(1 - sa);
			else                db = (db*sa + (sqrt(db/da)*da - db)*(2*sb - sa)) + sb*(1 - da) + db*(1 - sa);

			p[Order::R] = (value_type)uround(dr * base_mask);
			p[Order::G] = (value_type)uround(dg * base_mask);
			p[Order::B] = (value_type)uround(db * base_mask);
			p[Order::A] = (value_type)(a + p[Order::A] - ((a * p[Order::A] + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_difference
template<class ColorT, class Order> struct comp_op_rgba_difference
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_scale = color_type::base_scale,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca + Dca - 2.min(Sca.Da, Dca.Sa)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type dr = p[Order::R];
			calc_type dg = p[Order::G];
			calc_type db = p[Order::B];
			calc_type da = p[Order::A];
			p[Order::R] = (value_type)(sr + dr - ((2 * sd_min(sr*da, dr*sa) + base_mask) >> base_shift));
			p[Order::G] = (value_type)(sg + dg - ((2 * sd_min(sg*da, dg*sa) + base_mask) >> base_shift));
			p[Order::B] = (value_type)(sb + db - ((2 * sd_min(sb*da, db*sa) + base_mask) >> base_shift));
			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_exclusion
template<class ColorT, class Order> struct comp_op_rgba_exclusion
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = (Sca.Da + Dca.Sa - 2.Sca.Dca) + Sca.(1 - Da) + Dca.(1 - Sa)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type d1a = base_mask - p[Order::A];
			calc_type s1a = base_mask - sa;
			calc_type dr = p[Order::R];
			calc_type dg = p[Order::G];
			calc_type db = p[Order::B];
			calc_type da = p[Order::A];
			p[Order::R] = (value_type)((sr*da + dr*sa - 2*sr*dr + sr*d1a + dr*s1a + base_mask) >> base_shift);
			p[Order::G] = (value_type)((sg*da + dg*sa - 2*sg*dg + sg*d1a + dg*s1a + base_mask) >> base_shift);
			p[Order::B] = (value_type)((sb*da + db*sa - 2*sb*db + sb*d1a + db*s1a + base_mask) >> base_shift);
			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_contrast
template<class ColorT, class Order> struct comp_op_rgba_contrast
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		long_type dr = p[Order::R];
		long_type dg = p[Order::G];
		long_type db = p[Order::B];
		int       da = p[Order::A];
		long_type d2a = da >> 1;
		int s2a = sa >> 1;

		int r = (int)((((dr - d2a) * int((sr - s2a)*2 + base_mask)) >> base_shift) + d2a);
		int g = (int)((((dg - d2a) * int((sg - s2a)*2 + base_mask)) >> base_shift) + d2a);
		int b = (int)((((db - d2a) * int((sb - s2a)*2 + base_mask)) >> base_shift) + d2a);

		r = (r < 0) ? 0 : r;
		g = (g < 0) ? 0 : g;
		b = (b < 0) ? 0 : b;

		p[Order::R] = (value_type)((r > da) ? da : r);
		p[Order::G] = (value_type)((g > da) ? da : g);
		p[Order::B] = (value_type)((b > da) ? da : b);
	}
};

//=====================================================comp_op_rgba_invert
template<class ColorT, class Order> struct comp_op_rgba_invert
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = (Da - Dca) * Sa + Dca.(1 - Sa)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		sa = (sa * cover + 255) >> 8;
		if(sa)
		{
			calc_type da = p[Order::A];
			calc_type dr = ((da - p[Order::R]) * sa + base_mask) >> base_shift;
			calc_type dg = ((da - p[Order::G]) * sa + base_mask) >> base_shift;
			calc_type db = ((da - p[Order::B]) * sa + base_mask) >> base_shift;
			calc_type s1a = base_mask - sa;
			p[Order::R] = (value_type)(dr + ((p[Order::R] * s1a + base_mask) >> base_shift));
			p[Order::G] = (value_type)(dg + ((p[Order::G] * s1a + base_mask) >> base_shift));
			p[Order::B] = (value_type)(db + ((p[Order::B] * s1a + base_mask) >> base_shift));
			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=================================================comp_op_rgba_invert_rgb
template<class ColorT, class Order> struct comp_op_rgba_invert_rgb
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = (Da - Dca) * Sca + Dca.(1 - Sa)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type da = p[Order::A];
			calc_type dr = ((da - p[Order::R]) * sr + base_mask) >> base_shift;
			calc_type dg = ((da - p[Order::G]) * sg + base_mask) >> base_shift;
			calc_type db = ((da - p[Order::B]) * sb + base_mask) >> base_shift;
			calc_type s1a = base_mask - sa;
			p[Order::R] = (value_type)(dr + ((p[Order::R] * s1a + base_mask) >> base_shift));
			p[Order::G] = (value_type)(dg + ((p[Order::G] * s1a + base_mask) >> base_shift));
			p[Order::B] = (value_type)(db + ((p[Order::B] * s1a + base_mask) >> base_shift));
			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//======================================================comp_op_table_rgba
template<class ColorT, class Order> struct comp_op_table_rgba
{
	typedef typename ColorT::value_type value_type;
	typedef void (*comp_op_func_type)(value_type* p,
									  int cr,
									  int cg,
									  int cb,
									  int ca,
									  int cover);
	static comp_op_func_type g_comp_op_func[];
};

//==========================================================g_comp_op_func
template<class ColorT, class Order>
typename comp_op_table_rgba<ColorT, Order>::comp_op_func_type
comp_op_table_rgba<ColorT, Order>::g_comp_op_func[] =
{
	comp_op_rgba_clear      <ColorT,Order>::blend_pix,
	comp_op_rgba_src        <ColorT,Order>::blend_pix,
	comp_op_rgba_dst        <ColorT,Order>::blend_pix,
	comp_op_rgba_src_over   <ColorT,Order>::blend_pix,
	comp_op_rgba_dst_over   <ColorT,Order>::blend_pix,
	comp_op_rgba_src_in     <ColorT,Order>::blend_pix,
	comp_op_rgba_dst_in     <ColorT,Order>::blend_pix,
	comp_op_rgba_src_out    <ColorT,Order>::blend_pix,
	comp_op_rgba_dst_out    <ColorT,Order>::blend_pix,
	comp_op_rgba_src_atop   <ColorT,Order>::blend_pix,
	comp_op_rgba_dst_atop   <ColorT,Order>::blend_pix,
	comp_op_rgba_xor        <ColorT,Order>::blend_pix,
	comp_op_rgba_plus       <ColorT,Order>::blend_pix,
	comp_op_rgba_minus      <ColorT,Order>::blend_pix,
	comp_op_rgba_multiply   <ColorT,Order>::blend_pix,
	comp_op_rgba_screen     <ColorT,Order>::blend_pix,
	comp_op_rgba_overlay    <ColorT,Order>::blend_pix,
	comp_op_rgba_darken     <ColorT,Order>::blend_pix,
	comp_op_rgba_lighten    <ColorT,Order>::blend_pix,
	comp_op_rgba_color_dodge<ColorT,Order>::blend_pix,
	comp_op_rgba_color_burn <ColorT,Order>::blend_pix,
	comp_op_rgba_hard_light <ColorT,Order>::blend_pix,
	comp_op_rgba_soft_light <ColorT,Order>::blend_pix,
	comp_op_rgba_difference <ColorT,Order>::blend_pix,
	comp_op_rgba_exclusion  <ColorT,Order>::blend_pix,
	comp_op_rgba_contrast   <ColorT,Order>::blend_pix,
	comp_op_rgba_invert     <ColorT,Order>::blend_pix,
	comp_op_rgba_invert_rgb <ColorT,Order>::blend_pix,
	0
};

//==============================================================comp_op_e
enum comp_op_e
{
	comp_op_clear,         //----comp_op_clear
	comp_op_src,           //----comp_op_src
	comp_op_dst,           //----comp_op_dst
	comp_op_src_over,      //----comp_op_src_over
	comp_op_dst_over,      //----comp_op_dst_over
	comp_op_src_in,        //----comp_op_src_in
	comp_op_dst_in,        //----comp_op_dst_in
	comp_op_src_out,       //----comp_op_src_out
	comp_op_dst_out,       //----comp_op_dst_out
	comp_op_src_atop,      //----comp_op_src_atop
	comp_op_dst_atop,      //----comp_op_dst_atop
	comp_op_xor,           //----comp_op_xor
	comp_op_plus,          //----comp_op_plus
	comp_op_minus,         //----comp_op_minus
	comp_op_multiply,      //----comp_op_multiply
	comp_op_screen,        //----comp_op_screen
	comp_op_overlay,       //----comp_op_overlay
	comp_op_darken,        //----comp_op_darken
	comp_op_lighten,       //----comp_op_lighten
	comp_op_color_dodge,   //----comp_op_color_dodge
	comp_op_color_burn,    //----comp_op_color_burn
	comp_op_hard_light,    //----comp_op_hard_light
	comp_op_soft_light,    //----comp_op_soft_light
	comp_op_difference,    //----comp_op_difference
	comp_op_exclusion,     //----comp_op_exclusion
	comp_op_contrast,      //----comp_op_contrast
	comp_op_invert,        //----comp_op_invert
	comp_op_invert_rgb,    //----comp_op_invert_rgb

	end_of_comp_op_e
};

//====================================================comp_op_adaptor_rgba
template<class ColorT, class Order> struct comp_op_adaptor_rgba
{
	typedef Order  order_type;
	typedef ColorT color_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(int op, value_type* p,
									 int cr, int cg, int cb,
									 int ca,
									 int cover)
	{
		comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op]
			(p, (cr * ca + base_mask) >> base_shift,
				(cg * ca + base_mask) >> base_shift,
				(cb * ca + base_mask) >> base_shift,
				 ca, cover);
	}
};

//=========================================comp_op_adaptor_clip_to_dst_rgba
template<class ColorT, class Order> struct comp_op_adaptor_clip_to_dst_rgba
{
	typedef Order  order_type;
	typedef ColorT color_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(int op, value_type* p,
									 int cr, int cg, int cb,
									 int ca,
									 int cover)
	{
		cr = (cr * ca + base_mask) >> base_shift;
		cg = (cg * ca + base_mask) >> base_shift;
		cb = (cb * ca + base_mask) >> base_shift;
		int da = p[Order::A];
		comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op]
			(p, (cr * da + base_mask) >> base_shift,
				(cg * da + base_mask) >> base_shift,
				(cb * da + base_mask) >> base_shift,
				(ca * da + base_mask) >> base_shift,
				cover);
	}
};

//================================================comp_op_adaptor_rgba_pre
template<class ColorT, class Order> struct comp_op_adaptor_rgba_pre
{
	typedef Order  order_type;
	typedef ColorT color_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(int op, value_type* p,
									 int cr, int cg, int cb,
									 int ca,
									 int cover)
	{
		comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op](p, cr, cg, cb, ca, cover);
	}
};

//=====================================comp_op_adaptor_clip_to_dst_rgba_pre
template<class ColorT, class Order> struct comp_op_adaptor_clip_to_dst_rgba_pre
{
	typedef Order  order_type;
	typedef ColorT color_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(int op, value_type* p,
									 int cr, int cg, int cb,
									 int ca,
									 int cover)
	{
		int da = p[Order::A];
		comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op]
			(p, (cr * da + base_mask) >> base_shift,
				(cg * da + base_mask) >> base_shift,
				(cb * da + base_mask) >> base_shift,
				(ca * da + base_mask) >> base_shift,
				cover);
	}
};

//=======================================================comp_adaptor_rgba
template<class BlenderPre> struct comp_adaptor_rgba
{
	typedef typename BlenderPre::order_type order_type;
	typedef typename BlenderPre::color_type color_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(int op, value_type* p,
									 int cr, int cg, int cb,
									 int ca,
									 int cover)
	{
		BlenderPre::blend_pix(p,
							  (cr * ca + base_mask) >> base_shift,
							  (cg * ca + base_mask) >> base_shift,
							  (cb * ca + base_mask) >> base_shift,
							  ca, cover);
	}
};

//==========================================comp_adaptor_clip_to_dst_rgba
template<class BlenderPre> struct comp_adaptor_clip_to_dst_rgba
{
	typedef typename BlenderPre::order_type order_type;
	typedef typename BlenderPre::color_type color_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(int op, value_type* p,
									 int cr, int cg, int cb,
									 int ca,
									 int cover)
	{
		cr = (cr * ca + base_mask) >> base_shift;
		cg = (cg * ca + base_mask) >> base_shift;
		cb = (cb * ca + base_mask) >> base_shift;
		int da = p[OrderA];
		BlenderPre::blend_pix(p,
							  (cr * da + base_mask) >> base_shift,
							  (cg * da + base_mask) >> base_shift,
							  (cb * da + base_mask) >> base_shift,
							  (ca * da + base_mask) >> base_shift,
							  cover);
	}
};

//======================================comp_adaptor_clip_to_dst_rgba_pre
template<class BlenderPre> struct comp_adaptor_clip_to_dst_rgba_pre
{
	typedef typename BlenderPre::order_type order_type;
	typedef typename BlenderPre::color_type color_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(int op, value_type* p,
									 int cr, int cg, int cb,
									 int ca,
									 int cover)
	{
		int da = p[OrderA];
		BlenderPre::blend_pix(p,
							  (cr * da + base_mask) >> base_shift,
							  (cg * da + base_mask) >> base_shift,
							  (cb * da + base_mask) >> base_shift,
							  (ca * da + base_mask) >> base_shift,
							  cover);
	}
};

*/
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Blenders\rgba.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
namespace MatterHackers.Agg.Image
{
    /*
		//=========================================================multiplier_rgba
		template<class ColorT, class Order> struct multiplier_rgba
		{
			typedef typename ColorT::value_type value_type;
			typedef typename ColorT::calc_type calc_type;

			//--------------------------------------------------------------------
			static void premultiply(value_type* p)
			{
				calc_type a = p[Order::A];
				if(a < ColorT::base_mask)
				{
					if(a == 0)
					{
						p[Order::R] = p[Order::G] = p[Order::B] = 0;
						return;
					}
					p[Order::R] = value_type((p[Order::R] * a + ColorT::base_mask) >> ColorT::base_shift);
					p[Order::G] = value_type((p[Order::G] * a + ColorT::base_mask) >> ColorT::base_shift);
					p[Order::B] = value_type((p[Order::B] * a + ColorT::base_mask) >> ColorT::base_shift);
				}
			}

			//--------------------------------------------------------------------
			static void demultiply(value_type* p)
			{
				calc_type a = p[Order::A];
				if(a < ColorT::base_mask)
				{
					if(a == 0)
					{
						p[Order::R] = p[Order::G] = p[Order::B] = 0;
						return;
					}
					calc_type r = (calc_type(p[Order::R]) * ColorT::base_mask) / a;
					calc_type g = (calc_type(p[Order::G]) * ColorT::base_mask) / a;
					calc_type b = (calc_type(p[Order::B]) * ColorT::base_mask) / a;
					p[Order::R] = value_type((r > ColorT::base_mask) ? ColorT::base_mask : r);
					p[Order::G] = value_type((g > ColorT::base_mask) ? ColorT::base_mask : g);
					p[Order::B] = value_type((b > ColorT::base_mask) ? ColorT::base_mask : b);
				}
			}
		};

		//=====================================================apply_gamma_dir_rgba
		template<class ColorT, class Order, class GammaLut> class apply_gamma_dir_rgba
		{
		public:
			typedef typename ColorT::value_type value_type;

			apply_gamma_dir_rgba(const GammaLut& gamma) : m_gamma(gamma) {}

			void operator () (value_type* p)
			{
				p[Order::R] = m_gamma.dir(p[Order::R]);
				p[Order::G] = m_gamma.dir(p[Order::G]);
				p[Order::B] = m_gamma.dir(p[Order::B]);
			}

		private:
			const GammaLut& m_gamma;
		};

		//=====================================================apply_gamma_inv_rgba
		template<class ColorT, class Order, class GammaLut> class apply_gamma_inv_rgba
		{
		public:
			typedef typename ColorT::value_type value_type;

			apply_gamma_inv_rgba(const GammaLut& gamma) : m_gamma(gamma) {}

			void operator () (value_type* p)
			{
				p[Order::R] = m_gamma.inv(p[Order::R]);
				p[Order::G] = m_gamma.inv(p[Order::G]);
				p[Order::B] = m_gamma.inv(p[Order::B]);
			}

		private:
			const GammaLut& m_gamma;
		};

		//=============================================================blender_rgba
		template<class ColorT, class Order> struct blender_rgba
		{
			typedef ColorT color_type;
			typedef Order order_type;
			typedef typename color_type::value_type value_type;
			typedef typename color_type::calc_type calc_type;
			enum base_scale_e
			{
				base_shift = color_type::base_shift,
				base_mask  = color_type::base_mask
			};

			//--------------------------------------------------------------------
			static void blend_pix(value_type* p,
											 int cr, int cg, int cb,
											 int alpha,
											 int cover=0)
			{
				calc_type r = p[Order::R];
				calc_type g = p[Order::G];
				calc_type b = p[Order::B];
				calc_type a = p[Order::A];
				p[Order::R] = (value_type)(((cr - r) * alpha + (r << base_shift)) >> base_shift);
				p[Order::G] = (value_type)(((cg - g) * alpha + (g << base_shift)) >> base_shift);
				p[Order::B] = (value_type)(((cb - b) * alpha + (b << base_shift)) >> base_shift);
				p[Order::A] = (value_type)((alpha + a) - ((alpha * a + base_mask) >> base_shift));
			}
		};

//======================================================blender_rgba_plain
template<class ColorT, class Order> struct blender_rgba_plain
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e { base_shift = color_type::base_shift };

	//--------------------------------------------------------------------
	static void blend_pix(value_type* p,
									 int cr, int cg, int cb,
									 int alpha,
									 int cover=0)
	{
		if(alpha == 0) return;
		calc_type a = p[Order::A];
		calc_type r = p[Order::R] * a;
		calc_type g = p[Order::G] * a;
		calc_type b = p[Order::B] * a;
		a = ((alpha + a) << base_shift) - alpha * a;
		p[Order::A] = (value_type)(a >> base_shift);
		p[Order::R] = (value_type)((((cr << base_shift) - r) * alpha + (r << base_shift)) / a);
		p[Order::G] = (value_type)((((cg << base_shift) - g) * alpha + (g << base_shift)) / a);
		p[Order::B] = (value_type)((((cb << base_shift) - b) * alpha + (b << base_shift)) / a);
	}
};

//=========================================================comp_op_rgba_clear
template<class ColorT, class Order> struct comp_op_rgba_clear
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(value_type* p,
									 int, int, int, int,
									 int cover)
	{
		if(cover < 255)
		{
			cover = 255 - cover;
			p[Order::R] = (value_type)((p[Order::R] * cover + 255) >> 8);
			p[Order::G] = (value_type)((p[Order::G] * cover + 255) >> 8);
			p[Order::B] = (value_type)((p[Order::B] * cover + 255) >> 8);
			p[Order::A] = (value_type)((p[Order::A] * cover + 255) >> 8);
		}
		else
		{
			p[0] = p[1] = p[2] = p[3] = 0;
		}
	}
};

//===========================================================comp_op_rgba_src
template<class ColorT, class Order> struct comp_op_rgba_src
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;

	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			int alpha = 255 - cover;
			p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((sr * cover + 255) >> 8));
			p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((sg * cover + 255) >> 8));
			p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((sb * cover + 255) >> 8));
			p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((sa * cover + 255) >> 8));
		}
		else
		{
			p[Order::R] = sr;
			p[Order::G] = sg;
			p[Order::B] = sb;
			p[Order::A] = sa;
		}
	}
};

//===========================================================comp_op_rgba_dst
template<class ColorT, class Order> struct comp_op_rgba_dst
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;

	static void blend_pix(value_type*,
									 int, int, int,
									 int, int)
	{
	}
};

//======================================================comp_op_rgba_src_over
template<class ColorT, class Order> struct comp_op_rgba_src_over
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	//   Dca' = Sca + Dca.(1 - Sa)
	//   Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		calc_type s1a = base_mask - sa;
		p[Order::R] = (value_type)(sr + ((p[Order::R] * s1a + base_mask) >> base_shift));
		p[Order::G] = (value_type)(sg + ((p[Order::G] * s1a + base_mask) >> base_shift));
		p[Order::B] = (value_type)(sb + ((p[Order::B] * s1a + base_mask) >> base_shift));
		p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
	}
};

//======================================================comp_op_rgba_dst_over
template<class ColorT, class Order> struct comp_op_rgba_dst_over
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Dca + Sca.(1 - Da)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		calc_type d1a = base_mask - p[Order::A];
		p[Order::R] = (value_type)(p[Order::R] + ((sr * d1a + base_mask) >> base_shift));
		p[Order::G] = (value_type)(p[Order::G] + ((sg * d1a + base_mask) >> base_shift));
		p[Order::B] = (value_type)(p[Order::B] + ((sb * d1a + base_mask) >> base_shift));
		p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
	}
};

//======================================================comp_op_rgba_src_in
template<class ColorT, class Order> struct comp_op_rgba_src_in
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca.Da
	// Da'  = Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		calc_type da = p[Order::A];
		if(cover < 255)
		{
			int alpha = 255 - cover;
			p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((((sr * da + base_mask) >> base_shift) * cover + 255) >> 8));
			p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((((sg * da + base_mask) >> base_shift) * cover + 255) >> 8));
			p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((((sb * da + base_mask) >> base_shift) * cover + 255) >> 8));
			p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((((sa * da + base_mask) >> base_shift) * cover + 255) >> 8));
		}
		else
		{
			p[Order::R] = (value_type)((sr * da + base_mask) >> base_shift);
			p[Order::G] = (value_type)((sg * da + base_mask) >> base_shift);
			p[Order::B] = (value_type)((sb * da + base_mask) >> base_shift);
			p[Order::A] = (value_type)((sa * da + base_mask) >> base_shift);
		}
	}
};

//======================================================comp_op_rgba_dst_in
template<class ColorT, class Order> struct comp_op_rgba_dst_in
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Dca.Sa
	// Da'  = Sa.Da
	static void blend_pix(value_type* p,
									 int, int, int,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sa = base_mask - ((cover * (base_mask - sa) + 255) >> 8);
		}
		p[Order::R] = (value_type)((p[Order::R] * sa + base_mask) >> base_shift);
		p[Order::G] = (value_type)((p[Order::G] * sa + base_mask) >> base_shift);
		p[Order::B] = (value_type)((p[Order::B] * sa + base_mask) >> base_shift);
		p[Order::A] = (value_type)((p[Order::A] * sa + base_mask) >> base_shift);
	}
};

//======================================================comp_op_rgba_src_out
template<class ColorT, class Order> struct comp_op_rgba_src_out
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca.(1 - Da)
	// Da'  = Sa.(1 - Da)
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		calc_type da = base_mask - p[Order::A];
		if(cover < 255)
		{
			int alpha = 255 - cover;
			p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((((sr * da + base_mask) >> base_shift) * cover + 255) >> 8));
			p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((((sg * da + base_mask) >> base_shift) * cover + 255) >> 8));
			p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((((sb * da + base_mask) >> base_shift) * cover + 255) >> 8));
			p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((((sa * da + base_mask) >> base_shift) * cover + 255) >> 8));
		}
		else
		{
			p[Order::R] = (value_type)((sr * da + base_mask) >> base_shift);
			p[Order::G] = (value_type)((sg * da + base_mask) >> base_shift);
			p[Order::B] = (value_type)((sb * da + base_mask) >> base_shift);
			p[Order::A] = (value_type)((sa * da + base_mask) >> base_shift);
		}
	}
};

//======================================================comp_op_rgba_dst_out
template<class ColorT, class Order> struct comp_op_rgba_dst_out
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Dca.(1 - Sa)
	// Da'  = Da.(1 - Sa)
	static void blend_pix(value_type* p,
									 int, int, int,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sa = (sa * cover + 255) >> 8;
		}
		sa = base_mask - sa;
		p[Order::R] = (value_type)((p[Order::R] * sa + base_shift) >> base_shift);
		p[Order::G] = (value_type)((p[Order::G] * sa + base_shift) >> base_shift);
		p[Order::B] = (value_type)((p[Order::B] * sa + base_shift) >> base_shift);
		p[Order::A] = (value_type)((p[Order::A] * sa + base_shift) >> base_shift);
	}
};

//=====================================================comp_op_rgba_src_atop
template<class ColorT, class Order> struct comp_op_rgba_src_atop
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca.Da + Dca.(1 - Sa)
	// Da'  = Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		calc_type da = p[Order::A];
		sa = base_mask - sa;
		p[Order::R] = (value_type)((sr * da + p[Order::R] * sa + base_mask) >> base_shift);
		p[Order::G] = (value_type)((sg * da + p[Order::G] * sa + base_mask) >> base_shift);
		p[Order::B] = (value_type)((sb * da + p[Order::B] * sa + base_mask) >> base_shift);
	}
};

//=====================================================comp_op_rgba_dst_atop
template<class ColorT, class Order> struct comp_op_rgba_dst_atop
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Dca.Sa + Sca.(1 - Da)
	// Da'  = Sa
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		calc_type da = base_mask - p[Order::A];
		if(cover < 255)
		{
			int alpha = 255 - cover;
			sr = (p[Order::R] * sa + sr * da + base_mask) >> base_shift;
			sg = (p[Order::G] * sa + sg * da + base_mask) >> base_shift;
			sb = (p[Order::B] * sa + sb * da + base_mask) >> base_shift;
			p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((sr * cover + 255) >> 8));
			p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((sg * cover + 255) >> 8));
			p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((sb * cover + 255) >> 8));
			p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((sa * cover + 255) >> 8));
		}
		else
		{
			p[Order::R] = (value_type)((p[Order::R] * sa + sr * da + base_mask) >> base_shift);
			p[Order::G] = (value_type)((p[Order::G] * sa + sg * da + base_mask) >> base_shift);
			p[Order::B] = (value_type)((p[Order::B] * sa + sb * da + base_mask) >> base_shift);
			p[Order::A] = (value_type)sa;
		}
	}
};

//=========================================================comp_op_rgba_xor
template<class ColorT, class Order> struct comp_op_rgba_xor
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca.(1 - Da) + Dca.(1 - Sa)
	// Da'  = Sa + Da - 2.Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type s1a = base_mask - sa;
			calc_type d1a = base_mask - p[Order::A];
			p[Order::R] = (value_type)((p[Order::R] * s1a + sr * d1a + base_mask) >> base_shift);
			p[Order::G] = (value_type)((p[Order::G] * s1a + sg * d1a + base_mask) >> base_shift);
			p[Order::B] = (value_type)((p[Order::B] * s1a + sb * d1a + base_mask) >> base_shift);
			p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask/2) >> (base_shift - 1)));
		}
	}
};

//=========================================================comp_op_rgba_plus
template<class ColorT, class Order> struct comp_op_rgba_plus
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca + Dca
	// Da'  = Sa + Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type dr = p[Order::R] + sr;
			calc_type dg = p[Order::G] + sg;
			calc_type db = p[Order::B] + sb;
			calc_type da = p[Order::A] + sa;
			p[Order::R] = (dr > base_mask) ? (value_type)base_mask : dr;
			p[Order::G] = (dg > base_mask) ? (value_type)base_mask : dg;
			p[Order::B] = (db > base_mask) ? (value_type)base_mask : db;
			p[Order::A] = (da > base_mask) ? (value_type)base_mask : da;
		}
	}
};

//========================================================comp_op_rgba_minus
template<class ColorT, class Order> struct comp_op_rgba_minus
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Dca - Sca
	// Da' = 1 - (1 - Sa).(1 - Da)
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type dr = p[Order::R] - sr;
			calc_type dg = p[Order::G] - sg;
			calc_type db = p[Order::B] - sb;
			p[Order::R] = (dr > base_mask) ? 0 : dr;
			p[Order::G] = (dg > base_mask) ? 0 : dg;
			p[Order::B] = (db > base_mask) ? 0 : db;
			p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
			//p[Order::A] = (value_type)(base_mask - (((base_mask - sa) * (base_mask - p[Order::A]) + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_multiply
template<class ColorT, class Order> struct comp_op_rgba_multiply
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca.Dca + Sca.(1 - Da) + Dca.(1 - Sa)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type s1a = base_mask - sa;
			calc_type d1a = base_mask - p[Order::A];
			calc_type dr = p[Order::R];
			calc_type dg = p[Order::G];
			calc_type db = p[Order::B];
			p[Order::R] = (value_type)((sr * dr + sr * d1a + dr * s1a + base_mask) >> base_shift);
			p[Order::G] = (value_type)((sg * dg + sg * d1a + dg * s1a + base_mask) >> base_shift);
			p[Order::B] = (value_type)((sb * db + sb * d1a + db * s1a + base_mask) >> base_shift);
			p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_screen
template<class ColorT, class Order> struct comp_op_rgba_screen
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca + Dca - Sca.Dca
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type dr = p[Order::R];
			calc_type dg = p[Order::G];
			calc_type db = p[Order::B];
			calc_type da = p[Order::A];
			p[Order::R] = (value_type)(sr + dr - ((sr * dr + base_mask) >> base_shift));
			p[Order::G] = (value_type)(sg + dg - ((sg * dg + base_mask) >> base_shift));
			p[Order::B] = (value_type)(sb + db - ((sb * db + base_mask) >> base_shift));
			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_overlay
template<class ColorT, class Order> struct comp_op_rgba_overlay
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// if 2.Dca < Da
	//   Dca' = 2.Sca.Dca + Sca.(1 - Da) + Dca.(1 - Sa)
	// otherwise
	//   Dca' = Sa.Da - 2.(Da - Dca).(Sa - Sca) + Sca.(1 - Da) + Dca.(1 - Sa)
	//
	// Da' = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type d1a  = base_mask - p[Order::A];
			calc_type s1a  = base_mask - sa;
			calc_type dr   = p[Order::R];
			calc_type dg   = p[Order::G];
			calc_type db   = p[Order::B];
			calc_type da   = p[Order::A];
			calc_type sada = sa * p[Order::A];

			p[Order::R] = (value_type)(((2*dr < da) ?
				2*sr*dr + sr*d1a + dr*s1a :
				sada - 2*(da - dr)*(sa - sr) + sr*d1a + dr*s1a + base_mask) >> base_shift);

			p[Order::G] = (value_type)(((2*dg < da) ?
				2*sg*dg + sg*d1a + dg*s1a :
				sada - 2*(da - dg)*(sa - sg) + sg*d1a + dg*s1a + base_mask) >> base_shift);

			p[Order::B] = (value_type)(((2*db < da) ?
				2*sb*db + sb*d1a + db*s1a :
				sada - 2*(da - db)*(sa - sb) + sb*d1a + db*s1a + base_mask) >> base_shift);

			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

template<class T> inline T sd_min(T a, T b) { return (a < b) ? a : b; }
template<class T> inline T sd_max(T a, T b) { return (a > b) ? a : b; }

//=====================================================comp_op_rgba_darken
template<class ColorT, class Order> struct comp_op_rgba_darken
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = min(Sca.Da, Dca.Sa) + Sca.(1 - Da) + Dca.(1 - Sa)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type d1a = base_mask - p[Order::A];
			calc_type s1a = base_mask - sa;
			calc_type dr  = p[Order::R];
			calc_type dg  = p[Order::G];
			calc_type db  = p[Order::B];
			calc_type da  = p[Order::A];

			p[Order::R] = (value_type)((sd_min(sr * da, dr * sa) + sr * d1a + dr * s1a + base_mask) >> base_shift);
			p[Order::G] = (value_type)((sd_min(sg * da, dg * sa) + sg * d1a + dg * s1a + base_mask) >> base_shift);
			p[Order::B] = (value_type)((sd_min(sb * da, db * sa) + sb * d1a + db * s1a + base_mask) >> base_shift);
			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_lighten
template<class ColorT, class Order> struct comp_op_rgba_lighten
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = max(Sca.Da, Dca.Sa) + Sca.(1 - Da) + Dca.(1 - Sa)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type d1a = base_mask - p[Order::A];
			calc_type s1a = base_mask - sa;
			calc_type dr  = p[Order::R];
			calc_type dg  = p[Order::G];
			calc_type db  = p[Order::B];
			calc_type da  = p[Order::A];

			p[Order::R] = (value_type)((sd_max(sr * da, dr * sa) + sr * d1a + dr * s1a + base_mask) >> base_shift);
			p[Order::G] = (value_type)((sd_max(sg * da, dg * sa) + sg * d1a + dg * s1a + base_mask) >> base_shift);
			p[Order::B] = (value_type)((sd_max(sb * da, db * sa) + sb * d1a + db * s1a + base_mask) >> base_shift);
			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_color_dodge
template<class ColorT, class Order> struct comp_op_rgba_color_dodge
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// if Sca.Da + Dca.Sa >= Sa.Da
	//   Dca' = Sa.Da + Sca.(1 - Da) + Dca.(1 - Sa)
	// otherwise
	//   Dca' = Dca.Sa/(1-Sca/Sa) + Sca.(1 - Da) + Dca.(1 - Sa)
	//
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type d1a  = base_mask - p[Order::A];
			calc_type s1a  = base_mask - sa;
			calc_type dr   = p[Order::R];
			calc_type dg   = p[Order::G];
			calc_type db   = p[Order::B];
			calc_type da   = p[Order::A];
			long_type drsa = dr * sa;
			long_type dgsa = dg * sa;
			long_type dbsa = db * sa;
			long_type srda = sr * da;
			long_type sgda = sg * da;
			long_type sbda = sb * da;
			long_type sada = sa * da;

			p[Order::R] = (value_type)((srda + drsa >= sada) ?
				(sada + sr * d1a + dr * s1a + base_mask) >> base_shift :
				drsa / (base_mask - (sr << base_shift) / sa) + ((sr * d1a + dr * s1a + base_mask) >> base_shift));

			p[Order::G] = (value_type)((sgda + dgsa >= sada) ?
				(sada + sg * d1a + dg * s1a + base_mask) >> base_shift :
				dgsa / (base_mask - (sg << base_shift) / sa) + ((sg * d1a + dg * s1a + base_mask) >> base_shift));

			p[Order::B] = (value_type)((sbda + dbsa >= sada) ?
				(sada + sb * d1a + db * s1a + base_mask) >> base_shift :
				dbsa / (base_mask - (sb << base_shift) / sa) + ((sb * d1a + db * s1a + base_mask) >> base_shift));

			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_color_burn
template<class ColorT, class Order> struct comp_op_rgba_color_burn
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// if Sca.Da + Dca.Sa <= Sa.Da
	//   Dca' = Sca.(1 - Da) + Dca.(1 - Sa)
	// otherwise
	//   Dca' = Sa.(Sca.Da + Dca.Sa - Sa.Da)/Sca + Sca.(1 - Da) + Dca.(1 - Sa)
	//
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type d1a  = base_mask - p[Order::A];
			calc_type s1a  = base_mask - sa;
			calc_type dr   = p[Order::R];
			calc_type dg   = p[Order::G];
			calc_type db   = p[Order::B];
			calc_type da   = p[Order::A];
			long_type drsa = dr * sa;
			long_type dgsa = dg * sa;
			long_type dbsa = db * sa;
			long_type srda = sr * da;
			long_type sgda = sg * da;
			long_type sbda = sb * da;
			long_type sada = sa * da;

			p[Order::R] = (value_type)(((srda + drsa <= sada) ?
				sr * d1a + dr * s1a :
				sa * (srda + drsa - sada) / sr + sr * d1a + dr * s1a + base_mask) >> base_shift);

			p[Order::G] = (value_type)(((sgda + dgsa <= sada) ?
				sg * d1a + dg * s1a :
				sa * (sgda + dgsa - sada) / sg + sg * d1a + dg * s1a + base_mask) >> base_shift);

			p[Order::B] = (value_type)(((sbda + dbsa <= sada) ?
				sb * d1a + db * s1a :
				sa * (sbda + dbsa - sada) / sb + sb * d1a + db * s1a + base_mask) >> base_shift);

			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_hard_light
template<class ColorT, class Order> struct comp_op_rgba_hard_light
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// if 2.Sca < Sa
	//    Dca' = 2.Sca.Dca + Sca.(1 - Da) + Dca.(1 - Sa)
	// otherwise
	//    Dca' = Sa.Da - 2.(Da - Dca).(Sa - Sca) + Sca.(1 - Da) + Dca.(1 - Sa)
	//
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type d1a  = base_mask - p[Order::A];
			calc_type s1a  = base_mask - sa;
			calc_type dr   = p[Order::R];
			calc_type dg   = p[Order::G];
			calc_type db   = p[Order::B];
			calc_type da   = p[Order::A];
			calc_type sada = sa * da;

			p[Order::R] = (value_type)(((2*sr < sa) ?
				2*sr*dr + sr*d1a + dr*s1a :
				sada - 2*(da - dr)*(sa - sr) + sr*d1a + dr*s1a + base_mask) >> base_shift);

			p[Order::G] = (value_type)(((2*sg < sa) ?
				2*sg*dg + sg*d1a + dg*s1a :
				sada - 2*(da - dg)*(sa - sg) + sg*d1a + dg*s1a + base_mask) >> base_shift);

			p[Order::B] = (value_type)(((2*sb < sa) ?
				2*sb*db + sb*d1a + db*s1a :
				sada - 2*(da - db)*(sa - sb) + sb*d1a + db*s1a + base_mask) >> base_shift);

			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_soft_light
template<class ColorT, class Order> struct comp_op_rgba_soft_light
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// if 2.Sca < Sa
	//   Dca' = Dca.(Sa + (1 - Dca/Da).(2.Sca - Sa)) + Sca.(1 - Da) + Dca.(1 - Sa)
	// otherwise if 8.Dca <= Da
	//   Dca' = Dca.(Sa + (1 - Dca/Da).(2.Sca - Sa).(3 - 8.Dca/Da)) + Sca.(1 - Da) + Dca.(1 - Sa)
	// otherwise
	//   Dca' = (Dca.Sa + ((Dca/Da)^(0.5).Da - Dca).(2.Sca - Sa)) + Sca.(1 - Da) + Dca.(1 - Sa)
	//
	// Da'  = Sa + Da - Sa.Da

	static void blend_pix(value_type* p,
									 int r, int g, int b,
									 int a, int cover)
	{
		double sr = double(r * cover) / (base_mask * 255);
		double sg = double(g * cover) / (base_mask * 255);
		double sb = double(b * cover) / (base_mask * 255);
		double sa = double(a * cover) / (base_mask * 255);
		if(sa > 0)
		{
			double dr = double(p[Order::R]) / base_mask;
			double dg = double(p[Order::G]) / base_mask;
			double db = double(p[Order::B]) / base_mask;
			double da = double(p[Order::A] ? p[Order::A] : 1) / base_mask;
			if(cover < 255)
			{
				a = (a * cover + 255) >> 8;
			}

			if(2*sr < sa)       dr = dr*(sa + (1 - dr/da)*(2*sr - sa)) + sr*(1 - da) + dr*(1 - sa);
			else if(8*dr <= da) dr = dr*(sa + (1 - dr/da)*(2*sr - sa)*(3 - 8*dr/da)) + sr*(1 - da) + dr*(1 - sa);
			else                dr = (dr*sa + (sqrt(dr/da)*da - dr)*(2*sr - sa)) + sr*(1 - da) + dr*(1 - sa);

			if(2*sg < sa)       dg = dg*(sa + (1 - dg/da)*(2*sg - sa)) + sg*(1 - da) + dg*(1 - sa);
			else if(8*dg <= da) dg = dg*(sa + (1 - dg/da)*(2*sg - sa)*(3 - 8*dg/da)) + sg*(1 - da) + dg*(1 - sa);
			else                dg = (dg*sa + (sqrt(dg/da)*da - dg)*(2*sg - sa)) + sg*(1 - da) + dg*(1 - sa);

			if(2*sb < sa)       db = db*(sa + (1 - db/da)*(2*sb - sa)) + sb*(1 - da) + db*(1 - sa);
			else if(8*db <= da) db = db*(sa + (1 - db/da)*(2*sb - sa)*(3 - 8*db/da)) + sb*(1 - da) + db*(1 - sa);
			else                db = (db*sa + (sqrt(db/da)*da - db)*(2*sb - sa)) + sb*(1 - da) + db*(1 - sa);

			p[Order::R] = (value_type)uround(dr * base_mask);
			p[Order::G] = (value_type)uround(dg * base_mask);
			p[Order::B] = (value_type)uround(db * base_mask);
			p[Order::A] = (value_type)(a + p[Order::A] - ((a * p[Order::A] + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_difference
template<class ColorT, class Order> struct comp_op_rgba_difference
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_scale = color_type::base_scale,
		base_mask  = color_type::base_mask
	};

	// Dca' = Sca + Dca - 2.min(Sca.Da, Dca.Sa)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type dr = p[Order::R];
			calc_type dg = p[Order::G];
			calc_type db = p[Order::B];
			calc_type da = p[Order::A];
			p[Order::R] = (value_type)(sr + dr - ((2 * sd_min(sr*da, dr*sa) + base_mask) >> base_shift));
			p[Order::G] = (value_type)(sg + dg - ((2 * sd_min(sg*da, dg*sa) + base_mask) >> base_shift));
			p[Order::B] = (value_type)(sb + db - ((2 * sd_min(sb*da, db*sa) + base_mask) >> base_shift));
			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_exclusion
template<class ColorT, class Order> struct comp_op_rgba_exclusion
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = (Sca.Da + Dca.Sa - 2.Sca.Dca) + Sca.(1 - Da) + Dca.(1 - Sa)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type d1a = base_mask - p[Order::A];
			calc_type s1a = base_mask - sa;
			calc_type dr = p[Order::R];
			calc_type dg = p[Order::G];
			calc_type db = p[Order::B];
			calc_type da = p[Order::A];
			p[Order::R] = (value_type)((sr*da + dr*sa - 2*sr*dr + sr*d1a + dr*s1a + base_mask) >> base_shift);
			p[Order::G] = (value_type)((sg*da + dg*sa - 2*sg*dg + sg*d1a + dg*s1a + base_mask) >> base_shift);
			p[Order::B] = (value_type)((sb*da + db*sa - 2*sb*db + sb*d1a + db*s1a + base_mask) >> base_shift);
			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=====================================================comp_op_rgba_contrast
template<class ColorT, class Order> struct comp_op_rgba_contrast
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		long_type dr = p[Order::R];
		long_type dg = p[Order::G];
		long_type db = p[Order::B];
		int       da = p[Order::A];
		long_type d2a = da >> 1;
		int s2a = sa >> 1;

		int r = (int)((((dr - d2a) * int((sr - s2a)*2 + base_mask)) >> base_shift) + d2a);
		int g = (int)((((dg - d2a) * int((sg - s2a)*2 + base_mask)) >> base_shift) + d2a);
		int b = (int)((((db - d2a) * int((sb - s2a)*2 + base_mask)) >> base_shift) + d2a);

		r = (r < 0) ? 0 : r;
		g = (g < 0) ? 0 : g;
		b = (b < 0) ? 0 : b;

		p[Order::R] = (value_type)((r > da) ? da : r);
		p[Order::G] = (value_type)((g > da) ? da : g);
		p[Order::B] = (value_type)((b > da) ? da : b);
	}
};

//=====================================================comp_op_rgba_invert
template<class ColorT, class Order> struct comp_op_rgba_invert
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = (Da - Dca) * Sa + Dca.(1 - Sa)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		sa = (sa * cover + 255) >> 8;
		if(sa)
		{
			calc_type da = p[Order::A];
			calc_type dr = ((da - p[Order::R]) * sa + base_mask) >> base_shift;
			calc_type dg = ((da - p[Order::G]) * sa + base_mask) >> base_shift;
			calc_type db = ((da - p[Order::B]) * sa + base_mask) >> base_shift;
			calc_type s1a = base_mask - sa;
			p[Order::R] = (value_type)(dr + ((p[Order::R] * s1a + base_mask) >> base_shift));
			p[Order::G] = (value_type)(dg + ((p[Order::G] * s1a + base_mask) >> base_shift));
			p[Order::B] = (value_type)(db + ((p[Order::B] * s1a + base_mask) >> base_shift));
			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//=================================================comp_op_rgba_invert_rgb
template<class ColorT, class Order> struct comp_op_rgba_invert_rgb
{
	typedef ColorT color_type;
	typedef Order order_type;
	typedef typename color_type::value_type value_type;
	typedef typename color_type::calc_type calc_type;
	typedef typename color_type::long_type long_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	// Dca' = (Da - Dca) * Sca + Dca.(1 - Sa)
	// Da'  = Sa + Da - Sa.Da
	static void blend_pix(value_type* p,
									 int sr, int sg, int sb,
									 int sa, int cover)
	{
		if(cover < 255)
		{
			sr = (sr * cover + 255) >> 8;
			sg = (sg * cover + 255) >> 8;
			sb = (sb * cover + 255) >> 8;
			sa = (sa * cover + 255) >> 8;
		}
		if(sa)
		{
			calc_type da = p[Order::A];
			calc_type dr = ((da - p[Order::R]) * sr + base_mask) >> base_shift;
			calc_type dg = ((da - p[Order::G]) * sg + base_mask) >> base_shift;
			calc_type db = ((da - p[Order::B]) * sb + base_mask) >> base_shift;
			calc_type s1a = base_mask - sa;
			p[Order::R] = (value_type)(dr + ((p[Order::R] * s1a + base_mask) >> base_shift));
			p[Order::G] = (value_type)(dg + ((p[Order::G] * s1a + base_mask) >> base_shift));
			p[Order::B] = (value_type)(db + ((p[Order::B] * s1a + base_mask) >> base_shift));
			p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
		}
	}
};

//======================================================comp_op_table_rgba
template<class ColorT, class Order> struct comp_op_table_rgba
{
	typedef typename ColorT::value_type value_type;
	typedef void (*comp_op_func_type)(value_type* p,
									  int cr,
									  int cg,
									  int cb,
									  int ca,
									  int cover);
	static comp_op_func_type g_comp_op_func[];
};

//==========================================================g_comp_op_func
template<class ColorT, class Order>
typename comp_op_table_rgba<ColorT, Order>::comp_op_func_type
comp_op_table_rgba<ColorT, Order>::g_comp_op_func[] =
{
	comp_op_rgba_clear      <ColorT,Order>::blend_pix,
	comp_op_rgba_src        <ColorT,Order>::blend_pix,
	comp_op_rgba_dst        <ColorT,Order>::blend_pix,
	comp_op_rgba_src_over   <ColorT,Order>::blend_pix,
	comp_op_rgba_dst_over   <ColorT,Order>::blend_pix,
	comp_op_rgba_src_in     <ColorT,Order>::blend_pix,
	comp_op_rgba_dst_in     <ColorT,Order>::blend_pix,
	comp_op_rgba_src_out    <ColorT,Order>::blend_pix,
	comp_op_rgba_dst_out    <ColorT,Order>::blend_pix,
	comp_op_rgba_src_atop   <ColorT,Order>::blend_pix,
	comp_op_rgba_dst_atop   <ColorT,Order>::blend_pix,
	comp_op_rgba_xor        <ColorT,Order>::blend_pix,
	comp_op_rgba_plus       <ColorT,Order>::blend_pix,
	comp_op_rgba_minus      <ColorT,Order>::blend_pix,
	comp_op_rgba_multiply   <ColorT,Order>::blend_pix,
	comp_op_rgba_screen     <ColorT,Order>::blend_pix,
	comp_op_rgba_overlay    <ColorT,Order>::blend_pix,
	comp_op_rgba_darken     <ColorT,Order>::blend_pix,
	comp_op_rgba_lighten    <ColorT,Order>::blend_pix,
	comp_op_rgba_color_dodge<ColorT,Order>::blend_pix,
	comp_op_rgba_color_burn <ColorT,Order>::blend_pix,
	comp_op_rgba_hard_light <ColorT,Order>::blend_pix,
	comp_op_rgba_soft_light <ColorT,Order>::blend_pix,
	comp_op_rgba_difference <ColorT,Order>::blend_pix,
	comp_op_rgba_exclusion  <ColorT,Order>::blend_pix,
	comp_op_rgba_contrast   <ColorT,Order>::blend_pix,
	comp_op_rgba_invert     <ColorT,Order>::blend_pix,
	comp_op_rgba_invert_rgb <ColorT,Order>::blend_pix,
	0
};

//==============================================================comp_op_e
enum comp_op_e
{
	comp_op_clear,         //----comp_op_clear
	comp_op_src,           //----comp_op_src
	comp_op_dst,           //----comp_op_dst
	comp_op_src_over,      //----comp_op_src_over
	comp_op_dst_over,      //----comp_op_dst_over
	comp_op_src_in,        //----comp_op_src_in
	comp_op_dst_in,        //----comp_op_dst_in
	comp_op_src_out,       //----comp_op_src_out
	comp_op_dst_out,       //----comp_op_dst_out
	comp_op_src_atop,      //----comp_op_src_atop
	comp_op_dst_atop,      //----comp_op_dst_atop
	comp_op_xor,           //----comp_op_xor
	comp_op_plus,          //----comp_op_plus
	comp_op_minus,         //----comp_op_minus
	comp_op_multiply,      //----comp_op_multiply
	comp_op_screen,        //----comp_op_screen
	comp_op_overlay,       //----comp_op_overlay
	comp_op_darken,        //----comp_op_darken
	comp_op_lighten,       //----comp_op_lighten
	comp_op_color_dodge,   //----comp_op_color_dodge
	comp_op_color_burn,    //----comp_op_color_burn
	comp_op_hard_light,    //----comp_op_hard_light
	comp_op_soft_light,    //----comp_op_soft_light
	comp_op_difference,    //----comp_op_difference
	comp_op_exclusion,     //----comp_op_exclusion
	comp_op_contrast,      //----comp_op_contrast
	comp_op_invert,        //----comp_op_invert
	comp_op_invert_rgb,    //----comp_op_invert_rgb

	end_of_comp_op_e
};

//====================================================comp_op_adaptor_rgba
template<class ColorT, class Order> struct comp_op_adaptor_rgba
{
	typedef Order  order_type;
	typedef ColorT color_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(int op, value_type* p,
									 int cr, int cg, int cb,
									 int ca,
									 int cover)
	{
		comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op]
			(p, (cr * ca + base_mask) >> base_shift,
				(cg * ca + base_mask) >> base_shift,
				(cb * ca + base_mask) >> base_shift,
				 ca, cover);
	}
};

//=========================================comp_op_adaptor_clip_to_dst_rgba
template<class ColorT, class Order> struct comp_op_adaptor_clip_to_dst_rgba
{
	typedef Order  order_type;
	typedef ColorT color_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(int op, value_type* p,
									 int cr, int cg, int cb,
									 int ca,
									 int cover)
	{
		cr = (cr * ca + base_mask) >> base_shift;
		cg = (cg * ca + base_mask) >> base_shift;
		cb = (cb * ca + base_mask) >> base_shift;
		int da = p[Order::A];
		comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op]
			(p, (cr * da + base_mask) >> base_shift,
				(cg * da + base_mask) >> base_shift,
				(cb * da + base_mask) >> base_shift,
				(ca * da + base_mask) >> base_shift,
				cover);
	}
};

//================================================comp_op_adaptor_rgba_pre
template<class ColorT, class Order> struct comp_op_adaptor_rgba_pre
{
	typedef Order  order_type;
	typedef ColorT color_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(int op, value_type* p,
									 int cr, int cg, int cb,
									 int ca,
									 int cover)
	{
		comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op](p, cr, cg, cb, ca, cover);
	}
};

//=====================================comp_op_adaptor_clip_to_dst_rgba_pre
template<class ColorT, class Order> struct comp_op_adaptor_clip_to_dst_rgba_pre
{
	typedef Order  order_type;
	typedef ColorT color_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(int op, value_type* p,
									 int cr, int cg, int cb,
									 int ca,
									 int cover)
	{
		int da = p[Order::A];
		comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op]
			(p, (cr * da + base_mask) >> base_shift,
				(cg * da + base_mask) >> base_shift,
				(cb * da + base_mask) >> base_shift,
				(ca * da + base_mask) >> base_shift,
				cover);
	}
};

//=======================================================comp_adaptor_rgba
template<class BlenderPre> struct comp_adaptor_rgba
{
	typedef typename BlenderPre::order_type order_type;
	typedef typename BlenderPre::color_type color_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(int op, value_type* p,
									 int cr, int cg, int cb,
									 int ca,
									 int cover)
	{
		BlenderPre::blend_pix(p,
							  (cr * ca + base_mask) >> base_shift,
							  (cg * ca + base_mask) >> base_shift,
							  (cb * ca + base_mask) >> base_shift,
							  ca, cover);
	}
};

//==========================================comp_adaptor_clip_to_dst_rgba
template<class BlenderPre> struct comp_adaptor_clip_to_dst_rgba
{
	typedef typename BlenderPre::order_type order_type;
	typedef typename BlenderPre::color_type color_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(int op, value_type* p,
									 int cr, int cg, int cb,
									 int ca,
									 int cover)
	{
		cr = (cr * ca + base_mask) >> base_shift;
		cg = (cg * ca + base_mask) >> base_shift;
		cb = (cb * ca + base_mask) >> base_shift;
		int da = p[ImageBuffer.OrderA];
		BlenderPre::blend_pix(p,
							  (cr * da + base_mask) >> base_shift,
							  (cg * da + base_mask) >> base_shift,
							  (cb * da + base_mask) >> base_shift,
							  (ca * da + base_mask) >> base_shift,
							  cover);
	}
};

//======================================comp_adaptor_clip_to_dst_rgba_pre
template<class BlenderPre> struct comp_adaptor_clip_to_dst_rgba_pre
{
	typedef typename BlenderPre::order_type order_type;
	typedef typename BlenderPre::color_type color_type;
	typedef typename color_type::value_type value_type;
	enum base_scale_e
	{
		base_shift = color_type::base_shift,
		base_mask  = color_type::base_mask
	};

	static void blend_pix(int op, value_type* p,
									 int cr, int cg, int cb,
									 int ca,
									 int cover)
	{
		int da = p[ImageBuffer.OrderA];
		BlenderPre::blend_pix(p,
							  (cr * da + base_mask) >> base_shift,
							  (cg * da + base_mask) >> base_shift,
							  (cb * da + base_mask) >> base_shift,
							  (ca * da + base_mask) >> base_shift,
							  cover);
	}
};

		//================================================pixfmt_custom_blend_rgba
		template<class Blender, class RenBuf> class pixfmt_custom_blend_rgba
		{
		public:
			//typedef RenBuf   rbuf_type;
			//typedef typename rbuf_type::row_data row_data;
			typedef Blender  blender_type;
			typedef typename blender_type::color_type color_type;
			typedef typename blender_type::order_type order_type;
			typedef typename color_type::value_type value_type;
			typedef typename color_type::calc_type calc_type;
			enum base_scale_e
			{
				base_shift = color_type::base_shift,
				base_scale = color_type::base_scale,
				base_mask  = color_type::base_mask,
				pix_width  = sizeof(value_type) * 4
			};

			//--------------------------------------------------------------------
			pixfmt_custom_blend_rgba() : m_rbuf(0), m_comp_op(3) {}
			explicit pixfmt_custom_blend_rgba(rendering_buffer rb, int comp_op=3) :
				m_rbuf(&rb),
				m_comp_op(comp_op)
			{}
			void attach(rendering_buffer rb) { m_rbuf = &rb; }

			//--------------------------------------------------------------------
			template<class PixFmt>
			bool attach(PixFmt& pixf, int x1, int y1, int x2, int y2)
			{
				rect_i r(x1, y1, x2, y2);
				if(r.clip(rect_i(0, 0, pixf.width()-1, pixf.height()-1)))
				{
					int stride = pixf.stride();
					m_rbuf->attach(pixf.pix_ptr(r.x1, stride < 0 ? r.y2 : r.y1),
								   (r.x2 - r.x1) + 1,
								   (r.y2 - r.y1) + 1,
								   stride);
					return true;
				}
				return false;
			}

			//--------------------------------------------------------------------
			int width()  const { return m_rbuf->width();  }
			int height() const { return m_rbuf->height(); }
			int      stride() const { return m_rbuf->stride(); }

			//--------------------------------------------------------------------
				  byte* row_ptr(int y)       { return m_rbuf->row_ptr(y); }
			const byte* row_ptr(int y) const { return m_rbuf->row_ptr(y); }
			row_data     row(int y)     const { return m_rbuf->row(y); }

			//--------------------------------------------------------------------
			byte* pix_ptr(int x, int y)
			{
				return m_rbuf->row_ptr(y) + x * pix_width;
			}

			const byte* pix_ptr(int x, int y) const
			{
				return m_rbuf->row_ptr(y) + x * pix_width;
			}

			//--------------------------------------------------------------------
			void comp_op(int op) { m_comp_op = op; }
			int comp_op() const  { return m_comp_op; }

			//--------------------------------------------------------------------
			static void make_pix(byte* p, const color_type& c)
			{
				((value_type*)p)[ImageBuffer.OrderR] = c.r;
				((value_type*)p)[ImageBuffer.OrderG] = c.g;
				((value_type*)p)[ImageBuffer.OrderB] = c.b;
				((value_type*)p)[ImageBuffer.OrderA] = c.a;
			}

			//--------------------------------------------------------------------
			color_type pixel(int x, int y) const
			{
				const value_type* p = (value_type*)m_rbuf->row_ptr(y) + (x << 2);
				return color_type(p[ImageBuffer.OrderR],
								  p[ImageBuffer.OrderG],
								  p[ImageBuffer.OrderB],
								  p[ImageBuffer.OrderA]);
			}

			//--------------------------------------------------------------------
			unsafe void copy_pixel(int x, int y, byte* c)
			{
				blender_type::blend_pix(
					m_comp_op,
					(value_type*)m_rbuf->row_ptr(x, y, 1) + (x << 2),
					c.r, c.g, c.b, c.a, 255);
			}

			//--------------------------------------------------------------------
			void blend_pixel(int x, int y, const color_type& c, byte cover)
			{
				blender_type::blend_pix(
					m_comp_op,
					(value_type*)m_rbuf->row_ptr(x, y, 1) + (x << 2),
					c.r, c.g, c.b, c.a,
					cover);
			}

			//--------------------------------------------------------------------
			void copy_hline(int x, int y, int len, const color_type& c)
			{
				value_type* p = (value_type*)m_rbuf->row_ptr(x, y, len) + (x << 2);
				do
				{
					blender_type::blend_pix(m_comp_op, p, c.r, c.g, c.b, c.a, 255);
					p += 4;
				}
				while(--len);
			}

			//--------------------------------------------------------------------
			void copy_vline(int x, int y, int len, const color_type& c)
			{
				do
				{
					blender_type::blend_pix(
						m_comp_op,
						(value_type*)m_rbuf->row_ptr(x, y++, 1) + (x << 2),
						c.r, c.g, c.b, c.a, 255);
				}
				while(--len);
			}

			//--------------------------------------------------------------------
			void blend_hline(int x, int y, int len,
							 const color_type& c, byte cover)
			{
				value_type* p = (value_type*)m_rbuf->row_ptr(x, y, len) + (x << 2);
				do
				{
					blender_type::blend_pix(m_comp_op, p, c.r, c.g, c.b, c.a, cover);
					p += 4;
				}
				while(--len);
			}

			//--------------------------------------------------------------------
			void blend_vline(int x, int y, int len,
							 const color_type& c, byte cover)
			{
				do
				{
					blender_type::blend_pix(
						m_comp_op,
						(value_type*)m_rbuf->row_ptr(x, y++, 1) + (x << 2),
						c.r, c.g, c.b, c.a,
						cover);
				}
				while(--len);
			}

			//--------------------------------------------------------------------
			void blend_solid_hspan(int x, int y, int len,
								   const color_type& c, const byte* covers)
			{
				value_type* p = (value_type*)m_rbuf->row_ptr(x, y, len) + (x << 2);
				do
				{
					blender_type::blend_pix(m_comp_op,
											p, c.r, c.g, c.b, c.a,
											*covers++);
					p += 4;
				}
				while(--len);
			}

			//--------------------------------------------------------------------
			void blend_solid_vspan(int x, int y, int len,
								   const color_type& c, const byte* covers)
			{
				do
				{
					blender_type::blend_pix(
						m_comp_op,
						(value_type*)m_rbuf->row_ptr(x, y++, 1) + (x << 2),
						c.r, c.g, c.b, c.a,
						*covers++);
				}
				while(--len);
			}

			//--------------------------------------------------------------------
			void copy_color_hspan(int x, int y,
								  int len,
								  const color_type* colors)
			{
				value_type* p = (value_type*)m_rbuf->row_ptr(x, y, len) + (x << 2);
				do
				{
					p[ImageBuffer.OrderR] = colors->r;
					p[ImageBuffer.OrderG] = colors->g;
					p[ImageBuffer.OrderB] = colors->b;
					p[ImageBuffer.OrderA] = colors->a;
					++colors;
					p += 4;
				}
				while(--len);
			}

			//--------------------------------------------------------------------
			void copy_color_vspan(int x, int y,
								  int len,
								  const color_type* colors)
			{
				do
				{
					value_type* p = (value_type*)m_rbuf->row_ptr(x, y++, 1) + (x << 2);
					p[ImageBuffer.OrderR] = colors->r;
					p[ImageBuffer.OrderG] = colors->g;
					p[ImageBuffer.OrderB] = colors->b;
					p[ImageBuffer.OrderA] = colors->a;
					++colors;
				}
				while(--len);
			}

			//--------------------------------------------------------------------
			void blend_color_hspan(int x, int y, int len,
								   const color_type* colors,
								   const byte* covers)
			{
				value_type* p = (value_type*)m_rbuf->row_ptr(x, y, len) + (x << 2);
				do
				{
					blender_type::blend_pix(m_comp_op,
											p,
											colors->r,
											colors->g,
											colors->b,
											colors->a,
											covers ? *covers++ : cover);
					p += 4;
					++colors;
				}
				while(--len);
			}

			//--------------------------------------------------------------------
			void blend_color_vspan(int x, int y, int len,
								   const color_type* colors,
								   const byte* covers,
								   byte cover)
			{
				do
				{
					blender_type::blend_pix(
						m_comp_op,
						(value_type*)m_rbuf->row_ptr(x, y++, 1) + (x << 2),
						colors->r,
						colors->g,
						colors->b,
						colors->a,
						covers ? *covers++ : cover);
					++colors;
				}
				while(--len);
			}

			//--------------------------------------------------------------------
			template<class Function> void for_each_pixel(Function f)
			{
				int y;
				for(y = 0; y < height(); ++y)
				{
					row_data r = m_rbuf->row(y);
					if(r.ptr)
					{
						int len = r.x2 - r.x1 + 1;
						value_type* p =
							(value_type*)m_rbuf->row_ptr(r.x1, y, len) + (r.x1 << 2);
						do
						{
							f(p);
							p += 4;
						}
						while(--len);
					}
				}
			}

			//--------------------------------------------------------------------
			void premultiply()
			{
				for_each_pixel(multiplier_rgba<color_type, order_type>::premultiply);
			}

			//--------------------------------------------------------------------
			void demultiply()
			{
				for_each_pixel(multiplier_rgba<color_type, order_type>::demultiply);
			}

			//--------------------------------------------------------------------
			template<class GammaLut> void apply_gamma_dir(const GammaLut& g)
			{
				for_each_pixel(apply_gamma_dir_rgba<color_type, order_type, GammaLut>(g));
			}

			//--------------------------------------------------------------------
			template<class GammaLut> void apply_gamma_inv(const GammaLut& g)
			{
				for_each_pixel(apply_gamma_inv_rgba<color_type, order_type, GammaLut>(g));
			}

			//--------------------------------------------------------------------
			template<class RenBuf2> void copy_from(const RenBuf2& from,
												   int xdst, int ydst,
												   int xsrc, int ysrc,
												   int len)
			{
				const byte* p = from.row_ptr(ysrc);
				if(p)
				{
					memmove(m_rbuf->row_ptr(xdst, ydst, len) + xdst * pix_width,
							p + xsrc * pix_width,
							len * pix_width);
				}
			}

			//--------------------------------------------------------------------
			template<class SrcPixelFormatRenderer>
			void blend_from(const SrcPixelFormatRenderer& from,
							int xdst, int ydst,
							int xsrc, int ysrc,
							int len,
							byte cover)
			{
				typedef typename SrcPixelFormatRenderer::order_type src_order;
				const value_type* psrc = (const value_type*)from.row_ptr(ysrc);
				if(psrc)
				{
					psrc += xsrc << 2;
					value_type* pdst =
						(value_type*)m_rbuf->row_ptr(xdst, ydst, len) + (xdst << 2);

					int incp = 4;
					if(xdst > xsrc)
					{
						psrc += (len-1) << 2;
						pdst += (len-1) << 2;
						incp = -4;
					}

					do
					{
						blender_type::blend_pix(m_comp_op,
												pdst,
												psrc[src_order::R],
												psrc[src_order::G],
												psrc[src_order::B],
												psrc[src_order::A],
												cover);
						psrc += incp;
						pdst += incp;
					}
					while(--len);
				}
			}

			//--------------------------------------------------------------------
			template<class SrcPixelFormatRenderer>
			void blend_from_color(const SrcPixelFormatRenderer& from,
								  const color_type& color,
								  int xdst, int ydst,
								  int xsrc, int ysrc,
								  int len,
								  byte cover)
			{
				typedef typename SrcPixelFormatRenderer::value_type src_value_type;
				const src_value_type* psrc = (src_value_type*)from.row_ptr(ysrc);
				if(psrc)
				{
					value_type* pdst =
						(value_type*)m_rbuf->row_ptr(xdst, ydst, len) + (xdst << 2);
					do
					{
						blender_type::blend_pix(m_comp_op,
												pdst,
												color.r, color.g, color.b, color.a,
												(*psrc * cover + base_mask) >> base_shift);
						++psrc;
						pdst += 4;
					}
					while(--len);
				}
			}

			//--------------------------------------------------------------------
			template<class SrcPixelFormatRenderer>
			void blend_from_lut(const SrcPixelFormatRenderer& from,
								const color_type* color_lut,
								int xdst, int ydst,
								int xsrc, int ysrc,
								int len,
								byte cover)
			{
				typedef typename SrcPixelFormatRenderer::value_type src_value_type;
				const src_value_type* psrc = (src_value_type*)from.row_ptr(ysrc);
				if(psrc)
				{
					value_type* pdst =
						(value_type*)m_rbuf->row_ptr(xdst, ydst, len) + (xdst << 2);
					do
					{
						const color_type& color = color_lut[*psrc];
						blender_type::blend_pix(m_comp_op,
												pdst,
												color.r, color.g, color.b, color.a,
												cover);
						++psrc;
						pdst += 4;
					}
					while(--len);
				}
			}

		private:
			rendering_buffer m_rbuf;
			int m_comp_op;
		};

		//-----------------------------------------------------------------------
		typedef blender_rgba<rgba8, order_rgba> blender_rgba32; //----blender_rgba32
		typedef blender_rgba<rgba8, order_argb> blender_argb32; //----blender_argb32
		typedef blender_rgba<rgba8, order_abgr> blender_abgr32; //----blender_abgr32
		typedef blender_rgba<rgba8, order_bgra> blender_bgra32; //----blender_bgra32

		typedef blender_rgba_pre<rgba8, order_rgba> blender_rgba32_pre; //----blender_rgba32_pre
		typedef blender_rgba_pre<rgba8, order_argb> blender_argb32_pre; //----blender_argb32_pre
		typedef blender_rgba_pre<rgba8, order_abgr> blender_abgr32_pre; //----blender_abgr32_pre
		typedef blender_rgba_pre<rgba8, order_bgra> blender_bgra32_pre; //----blender_bgra32_pre

		typedef blender_rgba_plain<rgba8, order_rgba> blender_rgba32_plain; //----blender_rgba32_plain
		typedef blender_rgba_plain<rgba8, order_argb> blender_argb32_plain; //----blender_argb32_plain
		typedef blender_rgba_plain<rgba8, order_abgr> blender_abgr32_plain; //----blender_abgr32_plain
		typedef blender_rgba_plain<rgba8, order_bgra> blender_bgra32_plain; //----blender_bgra32_plain

		typedef blender_rgba<rgba16, order_rgba> blender_rgba64; //----blender_rgba64
		typedef blender_rgba<rgba16, order_argb> blender_argb64; //----blender_argb64
		typedef blender_rgba<rgba16, order_abgr> blender_abgr64; //----blender_abgr64
		typedef blender_rgba<rgba16, order_bgra> blender_bgra64; //----blender_bgra64

		typedef blender_rgba_pre<rgba16, order_rgba> blender_rgba64_pre; //----blender_rgba64_pre
		typedef blender_rgba_pre<rgba16, order_argb> blender_argb64_pre; //----blender_argb64_pre
		typedef blender_rgba_pre<rgba16, order_abgr> blender_abgr64_pre; //----blender_abgr64_pre
		typedef blender_rgba_pre<rgba16, order_bgra> blender_bgra64_pre; //----blender_bgra64_pre

		//-----------------------------------------------------------------------
		typedef int32u pixel32_type;
		typedef pixfmt_alpha_blend_rgba<blender_rgba32, rendering_buffer, pixel32_type> pixfmt_rgba32; //----pixfmt_rgba32
		typedef pixfmt_alpha_blend_rgba<blender_argb32, rendering_buffer, pixel32_type> pixfmt_argb32; //----pixfmt_argb32
		typedef pixfmt_alpha_blend_rgba<blender_abgr32, rendering_buffer, pixel32_type> pixfmt_abgr32; //----pixfmt_abgr32
		typedef pixfmt_alpha_blend_rgba<blender_bgra32, rendering_buffer, pixel32_type> pixfmt_bgra32; //----pixfmt_bgra32

		typedef pixfmt_alpha_blend_rgba<blender_rgba32_pre, rendering_buffer, pixel32_type> pixfmt_rgba32_pre; //----pixfmt_rgba32_pre
		typedef pixfmt_alpha_blend_rgba<blender_argb32_pre, rendering_buffer, pixel32_type> pixfmt_argb32_pre; //----pixfmt_argb32_pre
		typedef pixfmt_alpha_blend_rgba<blender_abgr32_pre, rendering_buffer, pixel32_type> pixfmt_abgr32_pre; //----pixfmt_abgr32_pre
		typedef pixfmt_alpha_blend_rgba<blender_bgra32_pre, rendering_buffer, pixel32_type> pixfmt_bgra32_pre; //----pixfmt_bgra32_pre

		typedef pixfmt_alpha_blend_rgba<blender_rgba32_plain, rendering_buffer, pixel32_type> pixfmt_rgba32_plain; //----pixfmt_rgba32_plain
		typedef pixfmt_alpha_blend_rgba<blender_argb32_plain, rendering_buffer, pixel32_type> pixfmt_argb32_plain; //----pixfmt_argb32_plain
		typedef pixfmt_alpha_blend_rgba<blender_abgr32_plain, rendering_buffer, pixel32_type> pixfmt_abgr32_plain; //----pixfmt_abgr32_plain
		typedef pixfmt_alpha_blend_rgba<blender_bgra32_plain, rendering_buffer, pixel32_type> pixfmt_bgra32_plain; //----pixfmt_bgra32_plain

		struct  pixel64_type { int16u c[4]; };
		typedef pixfmt_alpha_blend_rgba<blender_rgba64, rendering_buffer, pixel64_type> pixfmt_rgba64; //----pixfmt_rgba64
		typedef pixfmt_alpha_blend_rgba<blender_argb64, rendering_buffer, pixel64_type> pixfmt_argb64; //----pixfmt_argb64
		typedef pixfmt_alpha_blend_rgba<blender_abgr64, rendering_buffer, pixel64_type> pixfmt_abgr64; //----pixfmt_abgr64
		typedef pixfmt_alpha_blend_rgba<blender_bgra64, rendering_buffer, pixel64_type> pixfmt_bgra64; //----pixfmt_bgra64

		typedef pixfmt_alpha_blend_rgba<blender_rgba64_pre, rendering_buffer, pixel64_type> pixfmt_rgba64_pre; //----pixfmt_rgba64_pre
		typedef pixfmt_alpha_blend_rgba<blender_argb64_pre, rendering_buffer, pixel64_type> pixfmt_argb64_pre; //----pixfmt_argb64_pre
		typedef pixfmt_alpha_blend_rgba<blender_abgr64_pre, rendering_buffer, pixel64_type> pixfmt_abgr64_pre; //----pixfmt_abgr64_pre
		typedef pixfmt_alpha_blend_rgba<blender_bgra64_pre, rendering_buffer, pixel64_type> pixfmt_bgra64_pre; //----pixfmt_bgra64_pre
	*/
}

//#endif

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\ClippingProxy.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// class ClippingPixelFormtProxy
//
//----------------------------------------------------------------------------

namespace MatterHackers.Agg.Image
{
	public class ImageClippingProxy : ImageProxy
	{
		private RectangleInt m_ClippingRect;

		public const byte cover_full = 255;

		public ImageClippingProxy(IImageByte ren)
			: base(ren)
		{
			m_ClippingRect = new RectangleInt(0, 0, (int)ren.Width - 1, (int)ren.Height - 1);
		}

		public override void LinkToImage(IImageByte ren)
		{
			base.LinkToImage(ren);
			m_ClippingRect = new RectangleInt(0, 0, (int)ren.Width - 1, (int)ren.Height - 1);
		}

		public bool SetClippingBox(int x1, int y1, int x2, int y2)
		{
			RectangleInt cb = new RectangleInt(x1, y1, x2, y2);
			cb.normalize();
			if (cb.clip(new RectangleInt(0, 0, (int)Width - 1, (int)Height - 1)))
			{
				m_ClippingRect = cb;
				return true;
			}
			m_ClippingRect.Left = 1;
			m_ClippingRect.Bottom = 1;
			m_ClippingRect.Right = 0;
			m_ClippingRect.Top = 0;
			return false;
		}

		public void reset_clipping(bool visibility)
		{
			if (visibility)
			{
				m_ClippingRect.Left = 0;
				m_ClippingRect.Bottom = 0;
				m_ClippingRect.Right = (int)Width - 1;
				m_ClippingRect.Top = (int)Height - 1;
			}
			else
			{
				m_ClippingRect.Left = 1;
				m_ClippingRect.Bottom = 1;
				m_ClippingRect.Right = 0;
				m_ClippingRect.Top = 0;
			}
		}

		public void clip_box_naked(int x1, int y1, int x2, int y2)
		{
			m_ClippingRect.Left = x1;
			m_ClippingRect.Bottom = y1;
			m_ClippingRect.Right = x2;
			m_ClippingRect.Top = y2;
		}

		public bool inbox(int x, int y)
		{
			return x >= m_ClippingRect.Left && y >= m_ClippingRect.Bottom &&
				   x <= m_ClippingRect.Right && y <= m_ClippingRect.Top;
		}

		public RectangleInt clip_box()
		{
			return m_ClippingRect;
		}

		private int xmin()
		{
			return m_ClippingRect.Left;
		}

		private int ymin()
		{
			return m_ClippingRect.Bottom;
		}

		private int xmax()
		{
			return m_ClippingRect.Right;
		}

		private int ymax()
		{
			return m_ClippingRect.Top;
		}

		public RectangleInt bounding_clip_box()
		{
			return m_ClippingRect;
		}

		public int bounding_xmin()
		{
			return m_ClippingRect.Left;
		}

		public int bounding_ymin()
		{
			return m_ClippingRect.Bottom;
		}

		public int bounding_xmax()
		{
			return m_ClippingRect.Right;
		}

		public int bounding_ymax()
		{
			return m_ClippingRect.Top;
		}

		public void clear(IColorType in_c)
		{
			int y;
			Color c = new Color(in_c.Red0To255, in_c.Green0To255, in_c.Blue0To255, in_c.Alpha0To255);
			if (Width != 0)
			{
				for (y = 0; y < Height; y++)
				{
					base.copy_hline(0, (int)y, (int)Width, c);
				}
			}
		}

		public override void copy_pixel(int x, int y, byte[] c, int ByteOffset)
		{
			if (inbox(x, y))
			{
				base.copy_pixel(x, y, c, ByteOffset);
			}
		}

		public override Color GetPixel(int x, int y)
		{
			return inbox(x, y) ? base.GetPixel(x, y) : new Color();
		}

		public override void copy_hline(int x1, int y, int x2, Color c)
		{
			if (x1 > x2) { int t = (int)x2; x2 = (int)x1; x1 = t; }
			if (y > ymax()) return;
			if (y < ymin()) return;
			if (x1 > xmax()) return;
			if (x2 < xmin()) return;

			if (x1 < xmin()) x1 = xmin();
			if (x2 > xmax()) x2 = (int)xmax();

			base.copy_hline(x1, y, (int)(x2 - x1 + 1), c);
		}

		public override void copy_vline(int x, int y1, int y2, Color c)
		{
			if (y1 > y2) { int t = (int)y2; y2 = (int)y1; y1 = t; }
			if (x > xmax()) return;
			if (x < xmin()) return;
			if (y1 > ymax()) return;
			if (y2 < ymin()) return;

			if (y1 < ymin()) y1 = ymin();
			if (y2 > ymax()) y2 = (int)ymax();

			base.copy_vline(x, y1, (int)(y2 - y1 + 1), c);
		}

		public override void blend_hline(int x1, int y, int x2, Color c, byte cover)
		{
			if (x1 > x2)
			{
				int t = (int)x2;
				x2 = x1;
				x1 = t;
			}
			if (y > ymax())
				return;
			if (y < ymin())
				return;
			if (x1 > xmax())
				return;
			if (x2 < xmin())
				return;

			if (x1 < xmin())
				x1 = xmin();
			if (x2 > xmax())
				x2 = xmax();

			base.blend_hline(x1, y, x2, c, cover);
		}

		public override void blend_vline(int x, int y1, int y2, Color c, byte cover)
		{
			if (y1 > y2) { int t = y2; y2 = y1; y1 = t; }
			if (x > xmax()) return;
			if (x < xmin()) return;
			if (y1 > ymax()) return;
			if (y2 < ymin()) return;

			if (y1 < ymin()) y1 = ymin();
			if (y2 > ymax()) y2 = ymax();

			base.blend_vline(x, y1, y2, c, cover);
		}

		public override void blend_solid_hspan(int x, int y, int len, Color c, byte[] covers, int coversIndex)
		{
#if false
            FileStream file = new FileStream("pixels.txt", FileMode.Append, FileAccess.Write);
            StreamWriter sw = new StreamWriter(file);
            sw.Write("h-x=" + x.ToString() + ",y=" + y.ToString() + ",len=" + len.ToString() + "\n");
            sw.Close();
            file.Close();
#endif

			if (y > ymax()) return;
			if (y < ymin()) return;

			if (x < xmin())
			{
				len -= xmin() - x;
				if (len <= 0) return;
				coversIndex += xmin() - x;
				x = xmin();
			}
			if (x + len > xmax())
			{
				len = xmax() - x + 1;
				if (len <= 0) return;
			}
			base.blend_solid_hspan(x, y, len, c, covers, coversIndex);
		}

		public override void blend_solid_vspan(int x, int y, int len, Color c, byte[] covers, int coversIndex)
		{
#if false
            FileStream file = new FileStream("pixels.txt", FileMode.Append, FileAccess.Write);
            StreamWriter sw = new StreamWriter(file);
            sw.Write("v-x=" + x.ToString() + ",y=" + y.ToString() + ",len=" + len.ToString() + "\n");
            sw.Close();
            file.Close();
#endif

			if (x > xmax()) return;
			if (x < xmin()) return;

			if (y < ymin())
			{
				len -= (ymin() - y);
				if (len <= 0) return;
				coversIndex += ymin() - y;
				y = ymin();
			}
			if (y + len > ymax())
			{
				len = (ymax() - y + 1);
				if (len <= 0) return;
			}
			base.blend_solid_vspan(x, y, len, c, covers, coversIndex);
		}

		public override void copy_color_hspan(int x, int y, int len, Color[] colors, int colorsIndex)
		{
			if (y > ymax()) return;
			if (y < ymin()) return;

			if (x < xmin())
			{
				int d = xmin() - x;
				len -= d;
				if (len <= 0) return;
				colorsIndex += d;
				x = xmin();
			}
			if (x + len > xmax())
			{
				len = (xmax() - x + 1);
				if (len <= 0) return;
			}
			base.copy_color_hspan(x, y, len, colors, colorsIndex);
		}

		public override void copy_color_vspan(int x, int y, int len, Color[] colors, int colorsIndex)
		{
			if (x > xmax()) return;
			if (x < xmin()) return;

			if (y < ymin())
			{
				int d = ymin() - y;
				len -= d;
				if (len <= 0) return;
				colorsIndex += d;
				y = ymin();
			}
			if (y + len > ymax())
			{
				len = (ymax() - y + 1);
				if (len <= 0) return;
			}
			base.copy_color_vspan(x, y, len, colors, colorsIndex);
		}

		public override void blend_color_hspan(int x, int y, int in_len, Color[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			int len = (int)in_len;
			if (y > ymax())
				return;
			if (y < ymin())
				return;

			if (x < xmin())
			{
				int d = xmin() - x;
				len -= d;
				if (len <= 0) return;
				if (covers != null) coversIndex += d;
				colorsIndex += d;
				x = xmin();
			}
			if (x + len - 1 > xmax())
			{
				len = xmax() - x + 1;
				if (len <= 0) return;
			}

			base.blend_color_hspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
		}

		public void copy_from(IImageByte src)
		{
			CopyFrom(src, new RectangleInt(0, 0, (int)src.Width, (int)src.Height), 0, 0);
		}

		public override void SetPixel(int x, int y, Color color)
		{
			if ((uint)x < Width && (uint)y < Height)
			{
				base.SetPixel(x, y, color);
			}
		}

		public override void CopyFrom(IImageByte sourceImage,
					   RectangleInt sourceImageRect,
					   int destXOffset,
					   int destYOffset)
		{
			RectangleInt destRect = sourceImageRect;
			destRect.Offset(destXOffset, destYOffset);

			RectangleInt clippedSourceRect = new RectangleInt();
			if (clippedSourceRect.IntersectRectangles(destRect, m_ClippingRect))
			{
				// move it back relative to the source
				clippedSourceRect.Offset(-destXOffset, -destYOffset);

				base.CopyFrom(sourceImage, clippedSourceRect, destXOffset, destYOffset);
			}
		}

		public RectangleInt clip_rect_area(ref RectangleInt destRect, ref RectangleInt sourceRect, int sourceWidth, int sourceHeight)
		{
			RectangleInt rc = new RectangleInt(0, 0, 0, 0);
			RectangleInt cb = clip_box();
			++cb.Right;
			++cb.Top;

			if (sourceRect.Left < 0)
			{
				destRect.Left -= sourceRect.Left;
				sourceRect.Left = 0;
			}
			if (sourceRect.Bottom < 0)
			{
				destRect.Bottom -= sourceRect.Bottom;
				sourceRect.Bottom = 0;
			}

			if (sourceRect.Right > sourceWidth) sourceRect.Right = sourceWidth;
			if (sourceRect.Top > sourceHeight) sourceRect.Top = sourceHeight;

			if (destRect.Left < cb.Left)
			{
				sourceRect.Left += cb.Left - destRect.Left;
				destRect.Left = cb.Left;
			}
			if (destRect.Bottom < cb.Bottom)
			{
				sourceRect.Bottom += cb.Bottom - destRect.Bottom;
				destRect.Bottom = cb.Bottom;
			}

			if (destRect.Right > cb.Right) destRect.Right = cb.Right;
			if (destRect.Top > cb.Top) destRect.Top = cb.Top;

			rc.Right = destRect.Right - destRect.Left;
			rc.Top = destRect.Top - destRect.Bottom;

			if (rc.Right > sourceRect.Right - sourceRect.Left) rc.Right = sourceRect.Right - sourceRect.Left;
			if (rc.Top > sourceRect.Top - sourceRect.Bottom) rc.Top = sourceRect.Top - sourceRect.Bottom;
			return rc;
		}

		public override void blend_color_vspan(int x, int y, int len, Color[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			if (x > xmax()) return;
			if (x < xmin()) return;

			if (y < ymin())
			{
				int d = ymin() - y;
				len -= d;
				if (len <= 0) return;
				if (covers != null) coversIndex += d;
				colorsIndex += d;
				y = ymin();
			}
			if (y + len > ymax())
			{
				len = (ymax() - y + 1);
				if (len <= 0) return;
			}
			base.blend_color_vspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
		}
	}

	public class ImageClippingProxyFloat : ImageProxyFloat
	{
		private RectangleInt m_ClippingRect;

		public const byte cover_full = 255;

		public ImageClippingProxyFloat(IImageFloat ren)
			: base(ren)
		{
			m_ClippingRect = new RectangleInt(0, 0, (int)ren.Width - 1, (int)ren.Height - 1);
		}

		public override void LinkToImage(IImageFloat ren)
		{
			base.LinkToImage(ren);
			m_ClippingRect = new RectangleInt(0, 0, (int)ren.Width - 1, (int)ren.Height - 1);
		}

		public bool SetClippingBox(int x1, int y1, int x2, int y2)
		{
			RectangleInt cb = new RectangleInt(x1, y1, x2, y2);
			cb.normalize();
			if (cb.clip(new RectangleInt(0, 0, (int)Width - 1, (int)Height - 1)))
			{
				m_ClippingRect = cb;
				return true;
			}
			m_ClippingRect.Left = 1;
			m_ClippingRect.Bottom = 1;
			m_ClippingRect.Right = 0;
			m_ClippingRect.Top = 0;
			return false;
		}

		public void reset_clipping(bool visibility)
		{
			if (visibility)
			{
				m_ClippingRect.Left = 0;
				m_ClippingRect.Bottom = 0;
				m_ClippingRect.Right = (int)Width - 1;
				m_ClippingRect.Top = (int)Height - 1;
			}
			else
			{
				m_ClippingRect.Left = 1;
				m_ClippingRect.Bottom = 1;
				m_ClippingRect.Right = 0;
				m_ClippingRect.Top = 0;
			}
		}

		public void clip_box_naked(int x1, int y1, int x2, int y2)
		{
			m_ClippingRect.Left = x1;
			m_ClippingRect.Bottom = y1;
			m_ClippingRect.Right = x2;
			m_ClippingRect.Top = y2;
		}

		public bool inbox(int x, int y)
		{
			return x >= m_ClippingRect.Left && y >= m_ClippingRect.Bottom &&
				   x <= m_ClippingRect.Right && y <= m_ClippingRect.Top;
		}

		public RectangleInt clip_box()
		{
			return m_ClippingRect;
		}

		private int xmin()
		{
			return m_ClippingRect.Left;
		}

		private int ymin()
		{
			return m_ClippingRect.Bottom;
		}

		private int xmax()
		{
			return m_ClippingRect.Right;
		}

		private int ymax()
		{
			return m_ClippingRect.Top;
		}

		public RectangleInt bounding_clip_box()
		{
			return m_ClippingRect;
		}

		public int bounding_xmin()
		{
			return m_ClippingRect.Left;
		}

		public int bounding_ymin()
		{
			return m_ClippingRect.Bottom;
		}

		public int bounding_xmax()
		{
			return m_ClippingRect.Right;
		}

		public int bounding_ymax()
		{
			return m_ClippingRect.Top;
		}

		public void clear(IColorType in_c)
		{
			int y;
			ColorF colorFloat = in_c.ToColorF();
			if (Width != 0)
			{
				for (y = 0; y < Height; y++)
				{
					base.copy_hline(0, (int)y, (int)Width, colorFloat);
				}
			}
		}

		public override void copy_pixel(int x, int y, float[] c, int ByteOffset)
		{
			if (inbox(x, y))
			{
				base.copy_pixel(x, y, c, ByteOffset);
			}
		}

		public override ColorF GetPixel(int x, int y)
		{
			return inbox(x, y) ? base.GetPixel(x, y) : new ColorF();
		}

		public override void copy_hline(int x1, int y, int x2, ColorF c)
		{
			if (x1 > x2) { int t = (int)x2; x2 = (int)x1; x1 = t; }
			if (y > ymax()) return;
			if (y < ymin()) return;
			if (x1 > xmax()) return;
			if (x2 < xmin()) return;

			if (x1 < xmin()) x1 = xmin();
			if (x2 > xmax()) x2 = (int)xmax();

			base.copy_hline(x1, y, (int)(x2 - x1 + 1), c);
		}

		public override void copy_vline(int x, int y1, int y2, ColorF c)
		{
			if (y1 > y2) { int t = (int)y2; y2 = (int)y1; y1 = t; }
			if (x > xmax()) return;
			if (x < xmin()) return;
			if (y1 > ymax()) return;
			if (y2 < ymin()) return;

			if (y1 < ymin()) y1 = ymin();
			if (y2 > ymax()) y2 = (int)ymax();

			base.copy_vline(x, y1, (int)(y2 - y1 + 1), c);
		}

		public override void blend_hline(int x1, int y, int x2, ColorF c, byte cover)
		{
			if (x1 > x2)
			{
				int t = (int)x2;
				x2 = x1;
				x1 = t;
			}
			if (y > ymax())
				return;
			if (y < ymin())
				return;
			if (x1 > xmax())
				return;
			if (x2 < xmin())
				return;

			if (x1 < xmin())
				x1 = xmin();
			if (x2 > xmax())
				x2 = xmax();

			base.blend_hline(x1, y, x2, c, cover);
		}

		public override void blend_vline(int x, int y1, int y2, ColorF c, byte cover)
		{
			if (y1 > y2) { int t = y2; y2 = y1; y1 = t; }
			if (x > xmax()) return;
			if (x < xmin()) return;
			if (y1 > ymax()) return;
			if (y2 < ymin()) return;

			if (y1 < ymin()) y1 = ymin();
			if (y2 > ymax()) y2 = ymax();

			base.blend_vline(x, y1, y2, c, cover);
		}

		public override void blend_solid_hspan(int x, int y, int in_len, ColorF c, byte[] covers, int coversIndex)
		{
			int len = (int)in_len;
			if (y > ymax()) return;
			if (y < ymin()) return;

			if (x < xmin())
			{
				len -= xmin() - x;
				if (len <= 0) return;
				coversIndex += xmin() - x;
				x = xmin();
			}
			if (x + len > xmax())
			{
				len = xmax() - x + 1;
				if (len <= 0) return;
			}
			base.blend_solid_hspan(x, y, len, c, covers, coversIndex);
		}

		public override void blend_solid_vspan(int x, int y, int len, ColorF c, byte[] covers, int coversIndex)
		{
			if (x > xmax()) return;
			if (x < xmin()) return;

			if (y < ymin())
			{
				len -= (ymin() - y);
				if (len <= 0) return;
				coversIndex += ymin() - y;
				y = ymin();
			}
			if (y + len > ymax())
			{
				len = (ymax() - y + 1);
				if (len <= 0) return;
			}
			base.blend_solid_vspan(x, y, len, c, covers, coversIndex);
		}

		public override void copy_color_hspan(int x, int y, int len, ColorF[] colors, int colorsIndex)
		{
			if (y > ymax()) return;
			if (y < ymin()) return;

			if (x < xmin())
			{
				int d = xmin() - x;
				len -= d;
				if (len <= 0) return;
				colorsIndex += d;
				x = xmin();
			}
			if (x + len > xmax())
			{
				len = (xmax() - x + 1);
				if (len <= 0) return;
			}
			base.copy_color_hspan(x, y, len, colors, colorsIndex);
		}

		public override void copy_color_vspan(int x, int y, int len, ColorF[] colors, int colorsIndex)
		{
			if (x > xmax()) return;
			if (x < xmin()) return;

			if (y < ymin())
			{
				int d = ymin() - y;
				len -= d;
				if (len <= 0) return;
				colorsIndex += d;
				y = ymin();
			}
			if (y + len > ymax())
			{
				len = (ymax() - y + 1);
				if (len <= 0) return;
			}
			base.copy_color_vspan(x, y, len, colors, colorsIndex);
		}

		public override void blend_color_hspan(int x, int y, int in_len, ColorF[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			int len = (int)in_len;
			if (y > ymax())
				return;
			if (y < ymin())
				return;

			if (x < xmin())
			{
				int d = xmin() - x;
				len -= d;
				if (len <= 0) return;
				if (covers != null) coversIndex += d;
				colorsIndex += d;
				x = xmin();
			}
			if (x + len - 1 > xmax())
			{
				len = xmax() - x + 1;
				if (len <= 0) return;
			}

			base.blend_color_hspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
		}

		public void copy_from(IImageFloat src)
		{
			CopyFrom(src, new RectangleInt(0, 0, (int)src.Width, (int)src.Height), 0, 0);
		}

		public override void SetPixel(int x, int y, ColorF color)
		{
			if ((uint)x < Width && (uint)y < Height)
			{
				base.SetPixel(x, y, color);
			}
		}

		public override void CopyFrom(IImageFloat sourceImage,
					   RectangleInt sourceImageRect,
					   int destXOffset,
					   int destYOffset)
		{
			RectangleInt destRect = sourceImageRect;
			destRect.Offset(destXOffset, destYOffset);

			RectangleInt clippedSourceRect = new RectangleInt();
			if (clippedSourceRect.IntersectRectangles(destRect, m_ClippingRect))
			{
				// move it back relative to the source
				clippedSourceRect.Offset(-destXOffset, -destYOffset);

				base.CopyFrom(sourceImage, clippedSourceRect, destXOffset, destYOffset);
			}
		}

		public RectangleInt clip_rect_area(ref RectangleInt destRect, ref RectangleInt sourceRect, int sourceWidth, int sourceHeight)
		{
			RectangleInt rc = new RectangleInt(0, 0, 0, 0);
			RectangleInt cb = clip_box();
			++cb.Right;
			++cb.Top;

			if (sourceRect.Left < 0)
			{
				destRect.Left -= sourceRect.Left;
				sourceRect.Left = 0;
			}
			if (sourceRect.Bottom < 0)
			{
				destRect.Bottom -= sourceRect.Bottom;
				sourceRect.Bottom = 0;
			}

			if (sourceRect.Right > sourceWidth) sourceRect.Right = sourceWidth;
			if (sourceRect.Top > sourceHeight) sourceRect.Top = sourceHeight;

			if (destRect.Left < cb.Left)
			{
				sourceRect.Left += cb.Left - destRect.Left;
				destRect.Left = cb.Left;
			}
			if (destRect.Bottom < cb.Bottom)
			{
				sourceRect.Bottom += cb.Bottom - destRect.Bottom;
				destRect.Bottom = cb.Bottom;
			}

			if (destRect.Right > cb.Right) destRect.Right = cb.Right;
			if (destRect.Top > cb.Top) destRect.Top = cb.Top;

			rc.Right = destRect.Right - destRect.Left;
			rc.Top = destRect.Top - destRect.Bottom;

			if (rc.Right > sourceRect.Right - sourceRect.Left) rc.Right = sourceRect.Right - sourceRect.Left;
			if (rc.Top > sourceRect.Top - sourceRect.Bottom) rc.Top = sourceRect.Top - sourceRect.Bottom;
			return rc;
		}

		public override void blend_color_vspan(int x, int y, int len, ColorF[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			if (x > xmax()) return;
			if (x < xmin()) return;

			if (y < ymin())
			{
				int d = ymin() - y;
				len -= d;
				if (len <= 0) return;
				if (covers != null) coversIndex += d;
				colorsIndex += d;
				y = ymin();
			}
			if (y + len > ymax())
			{
				len = (ymax() - y + 1);
				if (len <= 0) return;
			}
			base.blend_color_vspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\IImage.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using MatterHackers.VectorMath;

namespace MatterHackers.Agg.Image
{
	public interface IImage
	{
		Vector2 OriginOffset
		{
			get;
			set;
		}

		int BitDepth { get; }

		int Width { get; }

		int Height { get; }

		RectangleInt GetBounds();

		int GetBufferOffsetY(int y);

		int GetBufferOffsetXY(int x, int y);

		Graphics2D NewGraphics2D();

		void MarkImageChanged();
	}

	public interface IImageByte : IImage
	{
		int StrideInBytes();

		int StrideInBytesAbs();

		IRecieveBlenderByte GetRecieveBlender();

		void SetRecieveBlender(IRecieveBlenderByte value);

		int GetBytesBetweenPixelsInclusive();

		byte[] GetBuffer();

		Color GetPixel(int x, int y);

		void copy_pixel(int x, int y, byte[] c, int ByteOffset);

		void CopyFrom(IImageByte sourceImage);

		void CopyFrom(IImageByte sourceImage, RectangleInt sourceImageRect, int destXOffset, int destYOffset);

		void SetPixel(int x, int y, Color color);

		void BlendPixel(int x, int y, Color sourceColor, byte cover);

		// line stuff
		void copy_hline(int x, int y, int len, Color sourceColor);

		void copy_vline(int x, int y, int len, Color sourceColor);

		void blend_hline(int x, int y, int x2, Color sourceColor, byte cover);

		void blend_vline(int x, int y1, int y2, Color sourceColor, byte cover);

		// color stuff
		void copy_color_hspan(int x, int y, int len, Color[] colors, int colorIndex);

		void copy_color_vspan(int x, int y, int len, Color[] colors, int colorIndex);

		void blend_solid_hspan(int x, int y, int len, Color sourceColor, byte[] covers, int coversIndex);

		void blend_solid_vspan(int x, int y, int len, Color sourceColor, byte[] covers, int coversIndex);

		void blend_color_hspan(int x, int y, int len, Color[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll);

		void blend_color_vspan(int x, int y, int len, Color[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll);
	}

	public interface IImageFloat : IImage
	{
		int StrideInFloats();

		int StrideInFloatsAbs();

		IRecieveBlenderFloat GetBlender();

		void SetRecieveBlender(IRecieveBlenderFloat value);

		int GetFloatsBetweenPixelsInclusive();

		float[] GetBuffer();

		ColorF GetPixel(int x, int y);

		void copy_pixel(int x, int y, float[] c, int floatOffset);

		void CopyFrom(IImageFloat sourceImage);

		void CopyFrom(IImageFloat sourceImage, RectangleInt sourceImageRect, int destXOffset, int destYOffset);

		void SetPixel(int x, int y, ColorF color);

		void BlendPixel(int x, int y, ColorF sourceColor, byte cover);

		// line stuff
		void copy_hline(int x, int y, int len, ColorF sourceColor);

		void copy_vline(int x, int y, int len, ColorF sourceColor);

		void blend_hline(int x, int y, int x2, ColorF sourceColor, byte cover);

		void blend_vline(int x, int y1, int y2, ColorF sourceColor, byte cover);

		// color stuff
		void copy_color_hspan(int x, int y, int len, ColorF[] colors, int colorIndex);

		void copy_color_vspan(int x, int y, int len, ColorF[] colors, int colorIndex);

		void blend_solid_hspan(int x, int y, int len, ColorF sourceColor, byte[] covers, int coversIndex);

		void blend_solid_vspan(int x, int y, int len, ColorF sourceColor, byte[] covers, int coversIndex);

		void blend_color_hspan(int x, int y, int len, ColorF[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll);

		void blend_color_vspan(int x, int y, int len, ColorF[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll);
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\ImageBuffer.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using MatterHackers.Agg.Image.ThresholdFunctions;
using MatterHackers.Agg.RasterizerScanline;
using MatterHackers.VectorMath;

namespace MatterHackers.Agg.Image
{
	public class ImageBuffer : IImageByte
	{
		public const int OrderB = 0;
		public const int OrderG = 1;
		public const int OrderR = 2;
		public const int OrderA = 3;

		internal class InternalImageGraphics2D : ImageGraphics2D
		{
			internal InternalImageGraphics2D(ImageBuffer owner)
				: base()
			{
				var rasterizer = new ScanlineRasterizer();
				var imageClippingProxy = new ImageClippingProxy(owner);

				Initialize(imageClippingProxy, rasterizer);
				ScanlineCache = new ScanlineCachePacked8();
			}
		}

		private bool? _hasTransparency = null;

		public bool HasTransparency
		{
			get
			{
				if (BitDepth == 32)
				{
					if (_hasTransparency == null)
					{
						_hasTransparency = false;
						var buffer = GetBuffer();
						// check if the image has any alpha set to something other than 255
						for (int y = 0; y < Height; y++)
						{
							var yOffset = GetBufferOffsetY(y);
							for (int x = 0; x < Width; x++)
							{
								// get the alpha at this pixel
								if (buffer[yOffset + x * 4 + 3] < 255)
								{
									_hasTransparency = true;
									x = Width;
									y = Height;
								}
							}
						}
					}

					return _hasTransparency.Value;
				}

				throw new NotImplementedException();
			}
		}

		protected int[] yTableArray;
		protected int[] xTableArray;
		private byte[] m_ByteBuffer;
		private int bufferOffset; // the beginning of the image in this buffer
		private int bufferFirstPixel; // Pointer to first pixel depending on strideInBytes and image position

		private int strideInBytes; // Number of bytes per row. Can be < 0
		private int DistanceInBytesBetweenPixelsInclusive;

		private IRecieveBlenderByte recieveBlender;

		private const int base_mask = 255;

		public event EventHandler ImageChanged;

		public int ChangedCount { get; private set; }

		public void MarkImageChanged()
		{
			// mark this unchecked as we don't want to throw an exception if this rolls over.
			unchecked
			{
				ChangedCount++;
				_hasTransparency = null;
				ImageChanged?.Invoke(this, null);
			}
		}

		public ImageBuffer()
		{
		}

		public ImageBuffer(IRecieveBlenderByte recieveBlender)
		{
			SetRecieveBlender(recieveBlender);
		}

		public ImageBuffer(IImageByte sourceImage, IRecieveBlenderByte recieveBlender)
		{
			SetDimmensionAndFormat(sourceImage.Width, sourceImage.Height, sourceImage.StrideInBytes(), sourceImage.BitDepth, sourceImage.GetBytesBetweenPixelsInclusive(), true);
			int offset = sourceImage.GetBufferOffsetXY(0, 0);
			byte[] buffer = sourceImage.GetBuffer();
			byte[] newBuffer = new byte[buffer.Length];
			Util.memcpy(newBuffer, offset, buffer, offset, buffer.Length - offset);
			SetBuffer(newBuffer, offset);
			SetRecieveBlender(recieveBlender);
		}

		public ImageBuffer(ImageBuffer sourceImage)
		{
			SetDimmensionAndFormat(sourceImage.Width, sourceImage.Height, sourceImage.StrideInBytes(), sourceImage.BitDepth, sourceImage.GetBytesBetweenPixelsInclusive(), true);
			int offset = sourceImage.GetBufferOffsetXY(0, 0);
			byte[] buffer = sourceImage.GetBuffer();
			byte[] newBuffer = new byte[buffer.Length];
			Util.memcpy(newBuffer, offset, buffer, offset, buffer.Length - offset);
			SetBuffer(newBuffer, offset);
			SetRecieveBlender(sourceImage.GetRecieveBlender());
		}

		public ImageBuffer(int width, int height, int bitsPerPixel = 32)
		{
			Allocate(width, height, width * (bitsPerPixel / 8), bitsPerPixel);
			SetRecieveBlender(new BlenderBGRA());
		}

		public ImageBuffer(int width, int height, int bitsPerPixel, IRecieveBlenderByte recieveBlender)
		{
			Allocate(width, height, width * (bitsPerPixel / 8), bitsPerPixel);
			SetRecieveBlender(recieveBlender);
		}

		public void Allocate(int width, int height, int bitsPerPixel, IRecieveBlenderByte recieveBlender)
		{
			Allocate(width, height, width * (bitsPerPixel / 8), bitsPerPixel);
			SetRecieveBlender(recieveBlender);
		}

#if false
        public ImageBuffer(IImage image, IBlender blender, GammaLookUpTable gammaTable)
        {
            unsafe
            {
                AttachBuffer(image.GetBuffer(), image.Width(), image.Height(), image.StrideInBytes(), image.BitDepth, image.GetDistanceBetweenPixelsInclusive());
            }

            SetRecieveBlender(blender);
        }
#endif

		public ImageBuffer(IImageByte sourceImageToCopy, IRecieveBlenderByte blender, int distanceBetweenPixelsInclusive, int bufferOffset, int bitsPerPixel)
		{
			SetDimmensionAndFormat(sourceImageToCopy.Width, sourceImageToCopy.Height, sourceImageToCopy.StrideInBytes(), bitsPerPixel, distanceBetweenPixelsInclusive, true);
			int offset = sourceImageToCopy.GetBufferOffsetXY(0, 0);
			byte[] buffer = sourceImageToCopy.GetBuffer();
			byte[] newBuffer = new byte[buffer.Length];
			Util.memcpy(newBuffer, offset, buffer, offset, buffer.Length - offset);
			SetBuffer(newBuffer, offset + bufferOffset);
			SetRecieveBlender(blender);
		}

		/// <summary>
		/// This will create a new ImageBuffer that references the same memory as the image that you took the sub image from.
		/// It will modify the original main image when you draw to it.
		/// </summary>
		/// <param name="imageContainingSubImage">The image to reference</param>
		/// <param name="subImageBounds">The bounds to use for the new image</param>
		/// <returns>The new image that references this images memory</returns>
		public static ImageBuffer NewSubImageReference(IImageByte imageContainingSubImage, RectangleDouble subImageBounds)
		{
			var subImage = new ImageBuffer();
			if (subImageBounds.Left < 0 || subImageBounds.Bottom < 0 || subImageBounds.Right > imageContainingSubImage.Width || subImageBounds.Top > imageContainingSubImage.Height
				|| subImageBounds.Left >= subImageBounds.Right || subImageBounds.Bottom >= subImageBounds.Top)
			{
				throw new ArgumentException("The subImageBounds must be on the image and valid.");
			}

			int left = Math.Max(0, (int)Math.Floor(subImageBounds.Left));
			int bottom = Math.Max(0, (int)Math.Floor(subImageBounds.Bottom));
			int width = Math.Min(imageContainingSubImage.Width - left, (int)subImageBounds.Width);
			int height = Math.Min(imageContainingSubImage.Height - bottom, (int)subImageBounds.Height);
			int bufferOffsetToFirstPixel = imageContainingSubImage.GetBufferOffsetXY(left, bottom);
			subImage.AttachBuffer(imageContainingSubImage.GetBuffer(), bufferOffsetToFirstPixel, width, height, imageContainingSubImage.StrideInBytes(), imageContainingSubImage.BitDepth, imageContainingSubImage.GetBytesBetweenPixelsInclusive());
			subImage.SetRecieveBlender(imageContainingSubImage.GetRecieveBlender());

			return subImage;
		}

		public void AttachBuffer(byte[] buffer, int bufferOffset, int width, int height, int strideInBytes, int bitDepth, int distanceInBytesBetweenPixelsInclusive)
		{
			m_ByteBuffer = null;
			SetDimmensionAndFormat(width, height, strideInBytes, bitDepth, distanceInBytesBetweenPixelsInclusive, false);
			SetBuffer(buffer, bufferOffset);
		}

		public void Attach(IImageByte sourceImage, IRecieveBlenderByte recieveBlender, int distanceBetweenPixelsInclusive, int bufferOffset, int bitsPerPixel)
		{
			SetDimmensionAndFormat(sourceImage.Width, sourceImage.Height, sourceImage.StrideInBytes(), bitsPerPixel, distanceBetweenPixelsInclusive, false);
			int offset = sourceImage.GetBufferOffsetXY(0, 0);
			byte[] buffer = sourceImage.GetBuffer();
			SetBuffer(buffer, offset + bufferOffset);
			SetRecieveBlender(recieveBlender);
		}

		public void Attach(IImageByte sourceImage, IRecieveBlenderByte recieveBlender)
		{
			Attach(sourceImage, recieveBlender, sourceImage.GetBytesBetweenPixelsInclusive(), 0, sourceImage.BitDepth);
		}

		public bool Attach(IImageByte sourceImage, int x1, int y1, int x2, int y2)
		{
			m_ByteBuffer = null;
			DettachBuffer();

			if (x1 > x2 || y1 > y2)
			{
				throw new Exception("You need to have your x1 and y1 be the lower left corner of your sub image.");
			}

			var boundsRect = new RectangleInt(x1, y1, x2, y2);
			if (boundsRect.clip(new RectangleInt(0, 0, (int)sourceImage.Width - 1, (int)sourceImage.Height - 1)))
			{
				SetDimmensionAndFormat(boundsRect.Width, boundsRect.Height, sourceImage.StrideInBytes(), sourceImage.BitDepth, sourceImage.GetBytesBetweenPixelsInclusive(), false);
				int bufferOffset = sourceImage.GetBufferOffsetXY(boundsRect.Left, boundsRect.Bottom);
				byte[] buffer = sourceImage.GetBuffer();
				SetBuffer(buffer, bufferOffset);
				return true;
			}

			return false;
		}

		public void SetAlpha(byte value)
		{
			if (BitDepth != 32)
			{
				throw new Exception("You don't have alpha channel to set.  Your image has a bit depth of " + BitDepth.ToString() + ".");
			}

			int numPixels = Width * Height;
			byte[] buffer = GetBuffer(out int offset);
			for (int i = 0; i < numPixels; i++)
			{
				buffer[offset + i * 4 + 3] = value;
			}
		}

		private void Deallocate()
		{
			if (m_ByteBuffer != null)
			{
				m_ByteBuffer = null;
				SetDimmensionAndFormat(0, 0, 0, 32, 4, true);
			}
		}

		public void Allocate(int inWidth, int inHeight, int inScanWidthInBytes, int bitsPerPixel)
		{
			if (bitsPerPixel != 32 && bitsPerPixel != 24 && bitsPerPixel != 8)
			{
				throw new Exception("Unsupported bits per pixel.");
			}

			if (inScanWidthInBytes < inWidth * (bitsPerPixel / 8))
			{
				throw new Exception("Your scan width is not big enough to hold your width and height.");
			}

			SetDimmensionAndFormat(inWidth, inHeight, inScanWidthInBytes, bitsPerPixel, bitsPerPixel / 8, true);

			if (m_ByteBuffer == null || m_ByteBuffer.Length != strideInBytes * Height)
			{
				m_ByteBuffer = new byte[strideInBytes * Height];
				SetUpLookupTables();
			}

			if (yTableArray.Length != inHeight
				|| xTableArray.Length != inWidth)
			{
				throw new Exception("The yTable and xTable should be allocated correctly at this point. Figure out what happened."); // LBB, don't fix this if you don't understand what it's trying to do.
			}
		}

		public MatterHackers.Agg.Graphics2D NewGraphics2D()
		{
			var imageRenderer = new InternalImageGraphics2D(this);

			imageRenderer.Rasterizer.SetVectorClipBox(0, 0, Width, Height);

			return imageRenderer;
		}

		public void CopyFrom(IImageByte sourceImage)
		{
			if (this == sourceImage)
            {
				return;
            }

			Allocate(sourceImage.Width, sourceImage.Height, sourceImage.StrideInBytesAbs(), sourceImage.BitDepth);

			// make sure we make an exact copy
			SetRecieveBlender(new BlenderBGRAExactCopy());
			CopyFrom(sourceImage, sourceImage.GetBounds(), 0, 0);

			// then set the blender to what we expect
			SetRecieveBlender(sourceImage.GetRecieveBlender());
		
			// and finally let anything that cares know we change the image
			MarkImageChanged();
		}

		protected void CopyFromNoClipping(IImageByte sourceImage, RectangleInt clippedSourceImageRect, int destXOffset, int destYOffset)
		{
			if (GetBytesBetweenPixelsInclusive() != BitDepth / 8
				|| sourceImage.GetBytesBetweenPixelsInclusive() != sourceImage.BitDepth / 8)
			{
				throw new Exception("WIP we only support packed pixel formats at this time.");
			}

			if (BitDepth == sourceImage.BitDepth)
			{
				int lengthInBytes = clippedSourceImageRect.Width * GetBytesBetweenPixelsInclusive();

				int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left, clippedSourceImageRect.Bottom);
				byte[] sourceBuffer = sourceImage.GetBuffer();
				byte[] destBuffer = GetPixelPointerXY(clippedSourceImageRect.Left + destXOffset, clippedSourceImageRect.Bottom + destYOffset, out int destOffset);

				for (int i = 0; i < clippedSourceImageRect.Height; i++)
				{
					Util.memmove(destBuffer, destOffset, sourceBuffer, sourceOffset, lengthInBytes);
					sourceOffset += sourceImage.StrideInBytes();
					destOffset += StrideInBytes();
				}
			}
			else
			{
				bool haveConversion = true;
				switch (sourceImage.BitDepth)
				{
					case 24:
						switch (BitDepth)
						{
							case 32:
								{
									int numPixelsToCopy = clippedSourceImageRect.Width;
									for (int i = clippedSourceImageRect.Bottom; i < clippedSourceImageRect.Top; i++)
									{
										int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left, clippedSourceImageRect.Bottom + i);
										byte[] sourceBuffer = sourceImage.GetBuffer();
										byte[] destBuffer = GetPixelPointerXY(
											clippedSourceImageRect.Left + destXOffset,
											clippedSourceImageRect.Bottom + i + destYOffset,
											out int destOffset);
										for (int x = 0; x < numPixelsToCopy; x++)
										{
											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];
											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];
											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];
											destBuffer[destOffset++] = 255;
										}
									}
								}

								break;

							default:
								haveConversion = false;
								break;
						}

						break;

					default:
						haveConversion = false;
						break;
				}

				if (!haveConversion)
				{
					throw new NotImplementedException("You need to write the " + sourceImage.BitDepth.ToString() + " to " + BitDepth.ToString() + " conversion");
				}
			}
		}

		public void CopyFrom(IImageByte sourceImage, RectangleInt sourceImageRect, int destXOffset, int destYOffset)
		{
			RectangleInt sourceImageBounds = sourceImage.GetBounds();
			var clippedSourceImageRect = default(RectangleInt);
			if (clippedSourceImageRect.IntersectRectangles(sourceImageRect, sourceImageBounds))
			{
				RectangleInt destImageRect = clippedSourceImageRect;
				destImageRect.Offset(destXOffset, destYOffset);
				RectangleInt destImageBounds = GetBounds();
				var clippedDestImageRect = default(RectangleInt);
				if (clippedDestImageRect.IntersectRectangles(destImageRect, destImageBounds))
				{
					// we need to make sure the source is also clipped to the dest. So, we'll copy this back to source and offset it.
					clippedSourceImageRect = clippedDestImageRect;
					clippedSourceImageRect.Offset(-destXOffset, -destYOffset);
					CopyFromNoClipping(sourceImage, clippedSourceImageRect, destXOffset, destYOffset);
				}
			}
		}

		public Vector2 OriginOffset { get; set; }

		/// <summary>
		/// Gets width in pixels
		/// </summary>
		public int Width { get; private set; }

		/// <summary>
		/// Gets height in pixels
		/// </summary>
		public int Height { get; private set; }

		public int StrideInBytes()
		{
			return strideInBytes;
		}

		public int StrideInBytesAbs()
		{
			return System.Math.Abs(strideInBytes);
		}

		public int GetBytesBetweenPixelsInclusive()
		{
			return DistanceInBytesBetweenPixelsInclusive;
		}

		public int BitDepth { get; private set; }

		public virtual RectangleInt GetBounds()
		{
			return new RectangleInt(-(int)OriginOffset.X, -(int)OriginOffset.Y, Width - (int)OriginOffset.X, Height - (int)OriginOffset.Y);
		}

		public IRecieveBlenderByte GetRecieveBlender()
		{
			return recieveBlender;
		}

		public void SetRecieveBlender(IRecieveBlenderByte value)
		{
			if (BitDepth != 0 && value != null && value.NumPixelBits != BitDepth)
			{
				throw new NotSupportedException("The blender has to support the bit depth of this image.");
			}

			recieveBlender = value;
		}

		private void SetUpLookupTables()
		{
			yTableArray = new int[Height];
			for (int i = 0; i < Height; i++)
			{
				yTableArray[i] = i * strideInBytes;
			}

			xTableArray = new int[Width];
			for (int i = 0; i < Width; i++)
			{
				xTableArray[i] = i * DistanceInBytesBetweenPixelsInclusive;
			}
		}

		public void InvertYLookupTable()
		{
			strideInBytes *= -1;
			bufferFirstPixel = bufferOffset;
			if (strideInBytes < 0)
			{
				int addAmount = -((int)((int)Height - 1) * strideInBytes);
				bufferFirstPixel = addAmount + bufferOffset;
			}

			SetUpLookupTables();
		}

		/// <summary>
		/// Flip pixels in the Y axis
		/// </summary>
		public void FlipY()
		{
			byte[] buffer = GetBuffer();
			for (int y = 0; y < Height / 2; y++)
			{
				int bottomBuffer = GetBufferOffsetY(y);
				int topBuffer = GetBufferOffsetY(Height - y - 1);
				for (int x = 0; x < StrideInBytes(); x++)
				{
					byte hold = buffer[bottomBuffer + x];
					buffer[bottomBuffer + x] = buffer[topBuffer + x];
					buffer[topBuffer + x] = hold;
				}
			}
		}

		/// <summary>
		/// Flip pixels in the X axis
		/// </summary>
		public void FlipX()
		{
			byte[] buffer = GetBuffer();

			// Iterate each row, swapping pixels in x from outer to midpoint
			for (int y = 0; y < this.Height; y++)
			{
				for (int x = 0; x < this.Width / 2; x++)
				{
					int leftOffset = GetBufferOffsetXY(x, y);
					int rightOffset = GetBufferOffsetXY(this.Width - x - 1, y);

					// Hold
					byte leftBuffer0 = buffer[leftOffset + 0];
					byte leftBuffer1 = buffer[leftOffset + 1];
					byte leftBuffer2 = buffer[leftOffset + 2];
					byte leftBuffer3 = buffer[leftOffset + 3];

					// Swap
					buffer[leftOffset + 0] = buffer[rightOffset + 0];
					buffer[leftOffset + 1] = buffer[rightOffset + 1];
					buffer[leftOffset + 2] = buffer[rightOffset + 2];
					buffer[leftOffset + 3] = buffer[rightOffset + 3];

					buffer[rightOffset + 0] = leftBuffer0;
					buffer[rightOffset + 1] = leftBuffer1;
					buffer[rightOffset + 2] = leftBuffer2;
					buffer[rightOffset + 3] = leftBuffer3;
				}
			}
		}

		public void SetBuffer(byte[] byteBuffer, int bufferOffset)
		{
			if (byteBuffer.Length < Height * strideInBytes)
			{
				throw new Exception("Your buffer does not have enough room for your height and strideInBytes.");
			}

			m_ByteBuffer = byteBuffer;
			this.bufferOffset = bufferFirstPixel = bufferOffset;
			if (strideInBytes < 0)
			{
				int addAmount = -((int)((int)Height - 1) * strideInBytes);
				bufferFirstPixel = addAmount + bufferOffset;
			}

			SetUpLookupTables();
		}

		private void DeallocateOrClearBuffer(int width, int height, int strideInBytes, int bitDepth, int distanceInBytesBetweenPixelsInclusive)
		{
			if (this.Width == width
				&& this.Height == height
				&& this.strideInBytes == strideInBytes
				&& this.BitDepth == bitDepth
				&& DistanceInBytesBetweenPixelsInclusive == distanceInBytesBetweenPixelsInclusive
				&& m_ByteBuffer != null)
			{
				for (int i = 0; i < m_ByteBuffer.Length; i++)
				{
					m_ByteBuffer[i] = 0;
				}

				return;
			}
			else
			{
				Deallocate();
			}
		}

		private void SetDimmensionAndFormat(int width, int height, int strideInBytes, int bitDepth, int distanceInBytesBetweenPixelsInclusive, bool doDeallocateOrClearBuffer)
		{
			if (doDeallocateOrClearBuffer)
			{
				DeallocateOrClearBuffer(width, height, strideInBytes, bitDepth, distanceInBytesBetweenPixelsInclusive);
			}

			this.Width = width;
			this.Height = height;
			this.strideInBytes = strideInBytes;
			this.BitDepth = bitDepth;
			if (distanceInBytesBetweenPixelsInclusive > 4)
			{
				throw new System.Exception("It looks like you are passing bits per pixel rather than distance in bytes.");
			}

			if (distanceInBytesBetweenPixelsInclusive < (bitDepth / 8))
			{
				throw new Exception("You do not have enough room between pixels to support your bit depth.");
			}

			DistanceInBytesBetweenPixelsInclusive = distanceInBytesBetweenPixelsInclusive;
			if (strideInBytes < distanceInBytesBetweenPixelsInclusive * width)
			{
				throw new Exception("You do not have enough strideInBytes to hold the width and pixel distance you have described.");
			}
		}

		public void DettachBuffer()
		{
			m_ByteBuffer = null;
			Width = Height = strideInBytes = DistanceInBytesBetweenPixelsInclusive = 0;
		}

		public byte[] GetBuffer()
		{
			return m_ByteBuffer;
		}

		public byte[] GetBuffer(out int bufferOffset)
		{
			bufferOffset = this.bufferOffset;
			return m_ByteBuffer;
		}

		public byte[] GetPixelPointerY(int y, out int bufferOffset)
		{
			bufferOffset = bufferFirstPixel + yTableArray[y];
			// bufferOffset = GetBufferOffsetXY(0, y);
			return m_ByteBuffer;
		}

		public byte[] GetPixelPointerXY(int x, int y, out int bufferOffset)
		{
			bufferOffset = GetBufferOffsetXY(x, y);
			return m_ByteBuffer;
		}

		public Color GetPixel(int x, int y)
		{
			return recieveBlender.PixelToColor(m_ByteBuffer, GetBufferOffsetXY(x, y));
		}

		public int GetBufferOffsetY(int y)
		{
			return bufferFirstPixel + yTableArray[y] + xTableArray[0];
		}

		public int GetBufferOffsetXY(int x, int y)
		{
			return bufferFirstPixel + yTableArray[y] + xTableArray[x];
		}

		public void copy_pixel(int x, int y, byte[] c, int ByteOffset)
		{
			throw new System.NotImplementedException();
			// byte* p = GetPixelPointerXY(x, y);
			// ((int*)p)[0] = ((int*)c)[0];
			// p[OrderR] = c.r;
			// p[OrderG] = c.g;
			// p[OrderB] = c.b;
			// p[OrderA] = c.a;
		}

		public void BlendPixel(int x, int y, Color c, byte cover)
		{
			throw new System.NotImplementedException();
			/*
			cob_type::copy_or_blend_pix(
				(value_type*)m_rbuf->row_ptr(x, y, 1)  + x + x + x,
				c.r, c.g, c.b, c.a,
				cover);*/
		}

		public void SetPixel(int x, int y, Color color)
		{
			x -= (int)OriginOffset.X;
			y -= (int)OriginOffset.Y;
			recieveBlender.CopyPixels(GetBuffer(), GetBufferOffsetXY(x, y), color, 1);
		}

		public void copy_hline(int x, int y, int len, Color sourceColor)
		{
			byte[] buffer = GetPixelPointerXY(x, y, out int bufferOffset);

			recieveBlender.CopyPixels(buffer, bufferOffset, sourceColor, len);
		}

		public void copy_vline(int x, int y, int len, Color sourceColor)
		{
			throw new NotImplementedException();
#if false
            int scanWidth = StrideInBytes();
            byte* pDestBuffer = GetPixelPointerXY(x, y);
            do
            {
                m_Blender.CopyPixel(pDestBuffer, sourceColor);
                pDestBuffer = &pDestBuffer[scanWidth];
            }
            while (--len != 0);
#endif
		}

		public void blend_hline(int x1, int y, int x2, Color sourceColor, byte cover)
		{
			if (sourceColor.alpha != 0)
			{
				int len = x2 - x1 + 1;

				byte[] buffer = GetPixelPointerXY(x1, y, out int bufferOffset);

				int alpha = ((int)sourceColor.alpha * (cover + 1)) >> 8;
				if (alpha == base_mask)
				{
					recieveBlender.CopyPixels(buffer, bufferOffset, sourceColor, len);
				}
				else
				{
					do
					{
						recieveBlender.BlendPixel(buffer, bufferOffset, new Color(sourceColor.red, sourceColor.green, sourceColor.blue, alpha));
						bufferOffset += DistanceInBytesBetweenPixelsInclusive;
					}
					while (--len != 0);
				}
			}
		}

		public void blend_vline(int x, int y1, int y2, Color sourceColor, byte cover)
		{
			throw new NotImplementedException();
#if false
            int ScanWidth = StrideInBytes();
            if (sourceColor.m_A != 0)
            {
                unsafe
                {
                    int len = y2 - y1 + 1;
                    byte* p = GetPixelPointerXY(x, y1);
                    sourceColor.m_A = (byte)(((int)(sourceColor.m_A) * (cover + 1)) >> 8);
                    if (sourceColor.m_A == base_mask)
                    {
                        byte cr = sourceColor.m_R;
                        byte cg = sourceColor.m_G;
                        byte cb = sourceColor.m_B;
                        do
                        {
                            m_Blender.CopyPixel(p, sourceColor);
                            p = &p[ScanWidth];
                        }
                        while (--len != 0);
                    }
                    else
                    {
                        if (cover == 255)
                        {
                            do
                            {
                                m_Blender.BlendPixel(p, sourceColor);
                                p = &p[ScanWidth];
                            }
                            while (--len != 0);
                        }
                        else
                        {
                            do
                            {
                                m_Blender.BlendPixel(p, sourceColor);
                                p = &p[ScanWidth];
                            }
                            while (--len != 0);
                        }
                    }
                }
            }
#endif
		}

		public void blend_solid_hspan(int x, int y, int len, Color sourceColor, byte[] covers, int coversIndex)
		{
			int colorAlpha = sourceColor.alpha;
			if (colorAlpha != 0)
			{
				unchecked
				{
					byte[] buffer = GetPixelPointerXY(x, y, out int bufferOffset);

					do
					{
						int alpha = (colorAlpha * (covers[coversIndex] + 1)) >> 8;
						if (alpha == base_mask)
						{
							recieveBlender.CopyPixels(buffer, bufferOffset, sourceColor, 1);
						}
						else
						{
							recieveBlender.BlendPixel(buffer, bufferOffset, new Color(sourceColor.red, sourceColor.green, sourceColor.blue, alpha));
						}

						bufferOffset += DistanceInBytesBetweenPixelsInclusive;
						coversIndex++;
					}
					while (--len != 0);
				}
			}
		}

		public void blend_solid_vspan(int x, int y, int len, Color sourceColor, byte[] covers, int coversIndex)
		{
			if (sourceColor.alpha != 0)
			{
				int scanWidthInBytes = StrideInBytes();
				unchecked
				{
					int bufferOffset = GetBufferOffsetXY(x, y);
					do
					{
						byte oldAlpha = sourceColor.alpha;
						sourceColor.alpha = (byte)(((int)sourceColor.alpha * ((int)covers[coversIndex++] + 1)) >> 8);
						if (sourceColor.alpha == base_mask)
						{
							recieveBlender.CopyPixels(m_ByteBuffer, bufferOffset, sourceColor, 1);
						}
						else
						{
							recieveBlender.BlendPixel(m_ByteBuffer, bufferOffset, sourceColor);
						}

						bufferOffset += scanWidthInBytes;
						sourceColor.alpha = oldAlpha;
					}
					while (--len != 0);
				}
			}
		}

		public void copy_color_hspan(int x, int y, int len, Color[] colors, int colorsIndex)
		{
			int bufferOffset = GetBufferOffsetXY(x, y);

			do
			{
				recieveBlender.CopyPixels(m_ByteBuffer, bufferOffset, colors[colorsIndex], 1);

				++colorsIndex;
				bufferOffset += DistanceInBytesBetweenPixelsInclusive;
			}
			while (--len != 0);
		}

		public void copy_color_vspan(int x, int y, int len, Color[] colors, int colorsIndex)
		{
			int bufferOffset = GetBufferOffsetXY(x, y);

			do
			{
				recieveBlender.CopyPixels(m_ByteBuffer, bufferOffset, colors[colorsIndex], 1);

				++colorsIndex;
				bufferOffset += strideInBytes;
			}
			while (--len != 0);
		}

		public void blend_color_hspan(int x, int y, int len, Color[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			int bufferOffset = GetBufferOffsetXY(x, y);
			recieveBlender.BlendPixels(m_ByteBuffer, bufferOffset, colors, colorsIndex, covers, coversIndex, firstCoverForAll, len);
		}

		public void blend_color_vspan(int x, int y, int len, Color[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			int bufferOffset = GetBufferOffsetXY(x, y);

			int scanWidth = StrideInBytesAbs();
			if (!firstCoverForAll)
			{
				do
				{
					DoCopyOrBlend.BasedOnAlphaAndCover(recieveBlender, m_ByteBuffer, bufferOffset, colors[colorsIndex], covers[coversIndex++]);
					bufferOffset += scanWidth;
					++colorsIndex;
				}
				while (--len != 0);
			}
			else
			{
				if (covers[coversIndex] == 255)
				{
					do
					{
						DoCopyOrBlend.BasedOnAlpha(recieveBlender, m_ByteBuffer, bufferOffset, colors[colorsIndex]);
						bufferOffset += scanWidth;
						++colorsIndex;
					}
					while (--len != 0);
				}
				else
				{
					do
					{
						DoCopyOrBlend.BasedOnAlphaAndCover(recieveBlender, m_ByteBuffer, bufferOffset, colors[colorsIndex], covers[coversIndex]);
						bufferOffset += scanWidth;
						++colorsIndex;
					}
					while (--len != 0);
				}
			}
		}

		public void ApplyGammaInv(GammaLookUpTable g)
		{
			throw new System.NotImplementedException();
			// for_each_pixel(apply_gamma_inv_rgba<color_type, order_type, GammaLut>(g));
		}

		private bool IsPixelVisible(int x, int y, Func<Color, bool> isVisible)
		{
			Color pixelValue = GetRecieveBlender().PixelToColor(m_ByteBuffer, GetBufferOffsetXY(x, y));
			return isVisible(pixelValue);
		}

		/// <summary>
		/// Calculate the visible bounds (set pixel) of a given images.
		/// </summary>
		/// <param name="visibleBounds">The returned bounds of the visible pixels</param>
		/// <param name="isVisible">An optional function for defining the criteria of visibility</param>
		public void GetVisibleBounds(out RectangleInt visibleBounds, Func<Color, bool> isVisible = null)
		{
			if (isVisible == null)
			{
				isVisible = (pixelValue) =>
				{
					return pixelValue.Alpha0To255 != 0
						|| pixelValue.Red0To255 != 0
						|| pixelValue.Green0To255 != 0
						|| pixelValue.Blue0To255 != 0;
				};
			}

			visibleBounds = new RectangleInt(0, 0, Width, Height);

			// trim the bottom
			bool aPixelsIsVisible = false;
			for (int y = 0; y < Height; y++)
			{
				for (int x = 0; x < Width; x++)
				{
					if (IsPixelVisible(x, y, isVisible))
					{
						visibleBounds.Bottom = y;
						y = Height;
						x = Width;
						aPixelsIsVisible = true;
					}
				}
			}

			// if we don't run into any pixels set for the top trim than there are no pixels set at all
			if (!aPixelsIsVisible)
			{
				visibleBounds.SetRect(0, 0, 0, 0);
				return;
			}

			// trim the top
			for (int y = Height - 1; y >= 0; y--)
			{
				for (int x = 0; x < Width; x++)
				{
					if (IsPixelVisible(x, y, isVisible))
					{
						visibleBounds.Top = y + 1;
						y = -1;
						x = Width;
					}
				}
			}

			// trim the left
			for (int x = 0; x < Width; x++)
			{
				for (int y = 0; y < Height; y++)
				{
					if (IsPixelVisible(x, y, isVisible))
					{
						visibleBounds.Left = x;
						y = Height;
						x = Width;
					}
				}
			}

			// trim the right
			for (int x = Width - 1; x >= 0; x--)
			{
				for (int y = 0; y < Height; y++)
				{
					if (IsPixelVisible(x, y, isVisible))
					{
						visibleBounds.Right = x + 1;
						y = Height;
						x = -1;
					}
				}
			}
		}

		public void CropToVisibleInPlace(Func<Color, bool> isVisible = null, bool clearOriginOffset = true)
		{
			var cropped = this.CropToVisible(isVisible);
			if(clearOriginOffset)
            {
				cropped.OriginOffset = Vector2.Zero;
			}

			this.CopyFrom(cropped);
		}

		public ImageBuffer CropToVisible(Func<Color, bool> isVisible = null)
		{
			Vector2 oldOriginOffset = OriginOffset;

			// Move the HotSpot to 0, 0 so PPoint will work the way we want
			OriginOffset = new Vector2(0, 0);

			GetVisibleBounds(out RectangleInt visibleBounds, isVisible);

			if (visibleBounds.Width == Width
				&& visibleBounds.Height == Height)
			{
				OriginOffset = oldOriginOffset;
				return this;
			}

			// check if the Not0Rect has any size
			if (visibleBounds.Width > 0)
			{
				var tempImage = new ImageBuffer();

				// set TempImage equal to the Not0Rect
				tempImage.Initialize(this, visibleBounds);

				tempImage.OriginOffset = new Vector2(-visibleBounds.Left + oldOriginOffset.X, -visibleBounds.Bottom + oldOriginOffset.Y);

				return tempImage;
			}
			else
			{
				return new ImageBuffer();
			}
		}

		public static bool operator ==(ImageBuffer a, ImageBuffer b)
		{
			if (a is null || b is null)
			{
				if (a is null && b is null)
				{
					return true;
				}

				return false;
			}

			return a.Equals(b, 0);
		}

		public static bool operator !=(ImageBuffer a, ImageBuffer b)
		{
			bool areEqual = a == b;
			return !areEqual;
		}

		public override bool Equals(object obj)
		{
			if (obj.GetType() == typeof(ImageBuffer))
			{
				return this == (ImageBuffer)obj;
			}

			return false;
		}

		public bool Equals(ImageBuffer b, int maxError)
		{
			if (Width == b.Width
				&& Height == b.Height
				&& BitDepth == b.BitDepth
				&& StrideInBytes() == b.StrideInBytes()
				&& OriginOffset == b.OriginOffset)
			{
				int bytesPerPixel = BitDepth / 8;
				int aDistanceBetweenPixels = GetBytesBetweenPixelsInclusive();
				int bDistanceBetweenPixels = b.GetBytesBetweenPixelsInclusive();
				byte[] aBuffer = GetBuffer();
				byte[] bBuffer = b.GetBuffer();
				for (int y = 0; y < Height; y++)
				{
					int aBufferOffset = GetBufferOffsetY(y);
					int bBufferOffset = b.GetBufferOffsetY(y);
					for (int x = 0; x < Width; x++)
					{
						for (int byteIndex = 0; byteIndex < bytesPerPixel; byteIndex++)
						{
							byte aByte = aBuffer[aBufferOffset + byteIndex];
							byte bByte = bBuffer[bBufferOffset + byteIndex];
							if (aByte < (bByte - maxError) || aByte > (bByte + maxError))
							{
								return false;
							}
						}

						aBufferOffset += aDistanceBetweenPixels;
						bBufferOffset += bDistanceBetweenPixels;
					}
				}

				return true;
			}

			return false;
		}

		public bool Contains(ImageBuffer imageToFind, int maxError = 0)
		{
			return Contains(imageToFind, out _, out _, maxError);
		}

		public bool Contains(ImageBuffer imageToFind, out int matchX, out int matchY, int maxError = 0)
		{
			matchX = 0;
			matchY = 0;
			if (Width >= imageToFind.Width
				&& Height >= imageToFind.Height
				&& BitDepth == imageToFind.BitDepth)
			{
				int bytesPerPixel = BitDepth / 8;
				int aDistanceBetweenPixels = GetBytesBetweenPixelsInclusive();
				int bDistanceBetweenPixels = imageToFind.GetBytesBetweenPixelsInclusive();
				byte[] thisBuffer = GetBuffer();
				byte[] containedBuffer = imageToFind.GetBuffer();
				for (matchY = 0; matchY <= Height - imageToFind.Height; matchY++)
				{
					for (matchX = 0; matchX <= Width - imageToFind.Width; matchX++)
					{
						bool foundBadMatch = false;
						for (int imageToFindY = 0; imageToFindY < imageToFind.Height; imageToFindY++)
						{
							int thisBufferOffset = GetBufferOffsetXY(matchX, matchY + imageToFindY);
							int imageToFindBufferOffset = imageToFind.GetBufferOffsetY(imageToFindY);
							for (int imageToFindX = 0; imageToFindX < imageToFind.Width; imageToFindX++)
							{
								for (int byteIndex = 0; byteIndex < bytesPerPixel; byteIndex++)
								{
									byte aByte = thisBuffer[thisBufferOffset + byteIndex];
									byte bByte = containedBuffer[imageToFindBufferOffset + byteIndex];
									if (aByte < (bByte - maxError) || aByte > (bByte + maxError))
									{
										foundBadMatch = true;
										byteIndex = bytesPerPixel;
										imageToFindX = imageToFind.Width;
										imageToFindY = imageToFind.Height;
									}
								}

								thisBufferOffset += aDistanceBetweenPixels;
								imageToFindBufferOffset += bDistanceBetweenPixels;
							}
						}

						if (!foundBadMatch)
						{
							return true;
						}
					}
				}
			}

			return false;
		}

		public bool FindLeastSquaresMatch(ImageBuffer imageToFind, double maxError)
		{
			return FindLeastSquaresMatch(imageToFind, out _, out _, maxError);
		}

		public bool FindLeastSquaresMatch(ImageBuffer imageToFind, out Vector2 bestPosition, out double bestLeastSquares, double maxError = double.MaxValue)
		{
			bestPosition = Vector2.Zero;
			bestLeastSquares = double.MaxValue;

			if (Width >= imageToFind.Width
				&& Height >= imageToFind.Height
				&& BitDepth == imageToFind.BitDepth)
			{
				int bytesPerPixel = BitDepth / 8;
				int aDistanceBetweenPixels = GetBytesBetweenPixelsInclusive();
				int bDistanceBetweenPixels = imageToFind.GetBytesBetweenPixelsInclusive();
				byte[] thisBuffer = GetBuffer();
				byte[] containedBuffer = imageToFind.GetBuffer();
				for (int matchY = 0; matchY <= Height - imageToFind.Height; matchY++)
				{
					for (int matchX = 0; matchX <= Width - imageToFind.Width; matchX++)
					{
						double currentLeastSquares = 0;

						for (int imageToFindY = 0; imageToFindY < imageToFind.Height; imageToFindY++)
						{
							int thisBufferOffset = GetBufferOffsetXY(matchX, matchY + imageToFindY);
							int imageToFindBufferOffset = imageToFind.GetBufferOffsetY(imageToFindY);
							for (int imageToFindX = 0; imageToFindX < imageToFind.Width; imageToFindX++)
							{
								for (int byteIndex = 0; byteIndex < bytesPerPixel; byteIndex++)
								{
									byte aByte = thisBuffer[thisBufferOffset + byteIndex];
									byte bByte = containedBuffer[imageToFindBufferOffset + byteIndex];
									int difference = (int)aByte - (int)bByte;
									currentLeastSquares += difference * difference;
								}

								thisBufferOffset += aDistanceBetweenPixels;
								imageToFindBufferOffset += bDistanceBetweenPixels;
								if (currentLeastSquares > maxError)
								{
									// stop checking we have too much error.
									imageToFindX = imageToFind.Width;
									imageToFindY = imageToFind.Height;
								}
							}
						}

						if (currentLeastSquares < bestLeastSquares)
						{
							bestPosition = new Vector2(matchX, matchY);
							bestLeastSquares = currentLeastSquares;
							if (maxError > currentLeastSquares)
							{
								maxError = currentLeastSquares;
								if (currentLeastSquares == 0)
								{
									return true;
								}
							}
						}
					}
				}
			}

			return bestLeastSquares <= maxError;
		}

		public override int GetHashCode()
		{
			// This might be hard to make fast and useful.
			return m_ByteBuffer.GetHashCode() ^ bufferOffset.GetHashCode() ^ bufferFirstPixel.GetHashCode();
		}

		public RectangleInt GetBoundingRect()
		{
			var boundingRect = new RectangleInt(0, 0, Width, Height);
			boundingRect.Offset((int)OriginOffset.X, (int)OriginOffset.Y);
			return boundingRect;
		}

		private void Initialize(ImageBuffer sourceImage)
		{
			RectangleInt sourceBoundingRect = sourceImage.GetBoundingRect();

			Initialize(sourceImage, sourceBoundingRect);
			OriginOffset = sourceImage.OriginOffset;
		}

		private void Initialize(ImageBuffer sourceImage, RectangleInt boundsToCopyFrom)
		{
			if (sourceImage == this)
			{
				throw new Exception("We do not create a temp buffer for this to work.  You must have a source distinct from the dest.");
			}

			Deallocate();
			Allocate(boundsToCopyFrom.Width, boundsToCopyFrom.Height, boundsToCopyFrom.Width * sourceImage.BitDepth / 8, sourceImage.BitDepth);
			SetRecieveBlender(sourceImage.GetRecieveBlender());

			if (Width != 0 && Height != 0)
			{
				// The first thing we need to do is make sure the frame is cleared. LBB [3/15/2004]
				MatterHackers.Agg.Graphics2D graphics2D = NewGraphics2D();
				graphics2D.Clear(new Color(0, 0, 0, 0));

				int x = -boundsToCopyFrom.Left - (int)sourceImage.OriginOffset.X;
				int y = -boundsToCopyFrom.Bottom - (int)sourceImage.OriginOffset.Y;

				graphics2D.Render(sourceImage, x, y, 0, 1, 1);
			}
		}

		public void SetPixel32(int p, int p_2, uint p_3)
		{
			throw new NotImplementedException();
		}

		public uint GetPixel32(double p, double p_2)
		{
			throw new NotImplementedException();
		}
	}

	public static class ImageBufferExtensionMethods
	{
		/// <summary>
		/// Flip pixels in the X axis
		/// </summary>
		public static ImageBuffer MirrorX(this ImageBuffer input)
		{
			var mirrored = new ImageBuffer(input);
			mirrored.FlipX();
			return mirrored;
		}

		/// <summary>
		/// Flip pixels in the Y axis
		/// </summary>
		public static ImageBuffer MirrorY(this ImageBuffer input)
		{
			var mirrored = new ImageBuffer(input);
			mirrored.FlipY();
			return mirrored;
		}

		public static ImageBuffer CreateScaledImage(this ImageBuffer unscaledSourceImage, double width, double height)
		{
			return CreateScaledImage(unscaledSourceImage, (int)Math.Round(width), (int)Math.Round(height));
		}

		/// <summary>
		/// Get the weighted center (considering the amount that pixels are set) of the image
		/// </summary>
		/// <param name="imageBuffer">The image to get the center of</param>
		/// <param name="thresholdFunction">The function that describes if a pixel should be considered (> .5 will be accumulated).</param>
		/// <returns>The weighted center position of the image</returns>
		public static Vector2 GetWeightedCenter(this ImageBuffer imageBuffer, IThresholdFunction thresholdFunction)
		{
			double accumulatedCount = 0;
			Vector2 accumulatedPosition = Vector2.Zero;
			for (int y = 0; y < imageBuffer.Height; y++)
			{
				for (int x = 0; x < imageBuffer.Width; x++)
				{
					Color color = imageBuffer.GetPixel(x, y);
					if (thresholdFunction.Threshold(color) > .5)
					{
						accumulatedCount++;
						double px = x;
						double py = y;
						accumulatedPosition += new Vector2(px, py);
					}
				}
			}

			return accumulatedPosition / accumulatedCount;
		}

		public static Circle GetCircleBounds(this ImageBuffer image)
		{
			var outsidePoints = new List<Vector2>();

			// get the first pixel position for each y
			// get the last pixel position for each y

			return SmallestEnclosingCircle.MakeCircle(outsidePoints);
		}

		public static ImageBuffer CreateScaledImage(this ImageBuffer sourceImage, int width, int height)
		{
			var destImage = new ImageBuffer(width, height, 32, sourceImage.GetRecieveBlender());

			// If the source image is more than twice as big as our dest image.
			while (sourceImage.Width >= destImage.Width * 2)
			{
				// The image sampler we use is a 2x2 filter so we need to scale by a max of 1/2 if we want to get good results.
				// So we scale as many times as we need to get the Image to be the right size.
				// If this were going to be a non-uniform scale we could do the x and y separately to get better results.
				var halfImage = new ImageBuffer(sourceImage.Width / 2, sourceImage.Height / 2, 32, sourceImage.GetRecieveBlender());
				halfImage.NewGraphics2D().Render(sourceImage, 0, 0, 0, halfImage.Width / (double)sourceImage.Width, halfImage.Height / (double)sourceImage.Height);
				sourceImage = halfImage;

				if (sourceImage.Width == width)
				{
					return sourceImage;
				}
			}

			Graphics2D renderGraphics = destImage.NewGraphics2D();
			renderGraphics.ImageRenderQuality = Graphics2D.TransformQuality.Best;

			renderGraphics.Render(sourceImage, 0, 0, 0, destImage.Width / (double)sourceImage.Width, destImage.Height / (double)sourceImage.Height);

			return destImage;
		}

		public static void ScaleImage(this ImageBuffer image, double ratio)
		{
			var scaled = CreateScaledImage(image, image.Width * ratio, image.Height * ratio);
			image.CopyFrom(scaled);
		}

		public static ImageBuffer CreateScaledImage(this ImageBuffer image, double ratio)
		{
			return CreateScaledImage(image, image.Width * ratio, image.Height * ratio);
		}

		public static ImageBuffer ToGrayscale(this ImageBuffer sourceImage)
		{
			var outputImage = new ImageBuffer(sourceImage.Width, sourceImage.Height, 8, new blender_gray(1));
			outputImage.NewGraphics2D().Render(sourceImage, 0, 0);

			return outputImage;
		}
	}

	public static class DoCopyOrBlend
	{
		private const byte base_mask = 255;

		public static void BasedOnAlpha(IRecieveBlenderByte recieveBlender, byte[] destBuffer, int bufferOffset, Color sourceColor)
		{
			// if (sourceColor.m_A != 0)
			{
#if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have additive and faster blending in one blender) LBB
                if (sourceColor.m_A == base_mask)
                {
                    Blender.CopyPixel(pDestBuffer, sourceColor);
                }
                else
#endif
				{
					recieveBlender.BlendPixel(destBuffer, bufferOffset, sourceColor);
				}
			}
		}

		public static void BasedOnAlphaAndCover(IRecieveBlenderByte recieveBlender, byte[] destBuffer, int bufferOffset, Color sourceColor, int cover)
		{
			if (cover == 255)
			{
				BasedOnAlpha(recieveBlender, destBuffer, bufferOffset, sourceColor);
			}
			else
			{
				// if (sourceColor.m_A != 0)
				{
					sourceColor.alpha = (byte)((sourceColor.alpha * (cover + 1)) >> 8);
#if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have additive and faster blending in one blender) LBB
                    if (sourceColor.m_A == base_mask)
                    {
                        Blender.CopyPixel(pDestBuffer, sourceColor);
                    }
                    else
#endif
					{
						recieveBlender.BlendPixel(destBuffer, bufferOffset, sourceColor);
					}
				}
			}
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\ImageBufferFloat.cs
using MatterHackers.Agg.RasterizerScanline;
using MatterHackers.VectorMath;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg.Image
{
	public class ImageBufferFloat : IImageFloat
	{
		public const int OrderB = 0;
		public const int OrderG = 1;
		public const int OrderR = 2;
		public const int OrderA = 3;

		internal class InternalImageGraphics2D : ImageGraphics2D
		{
			private ImageBufferFloat m_Owner;

			internal InternalImageGraphics2D(ImageBufferFloat owner)
				: base()
			{
				m_Owner = owner;

				ScanlineRasterizer rasterizer = new ScanlineRasterizer();
				ImageClippingProxyFloat imageClippingProxy = new ImageClippingProxyFloat(owner);

				Initialize(imageClippingProxy, rasterizer);
				ScanlineCache = new ScanlineCachePacked8();
			}
		};

		protected int[] m_yTable;
		protected int[] m_xTable;
		private float[] m_FloatBuffer;
		private int m_BufferOffset; // the beginning of the image in this buffer
		private int m_BufferFirstPixel; // Pointer to first pixel depending on strideInFloats and image position

		private int m_Width;  // Width in pixels
		private int m_Height; // Height in pixels
		private int m_StrideInFloats; // Number of bytes per row. Can be < 0
		private int m_DistanceInFloatsBetweenPixelsInclusive;
		private int m_BitDepth;
		private Vector2 m_OriginOffset = new Vector2(0, 0);

		private IRecieveBlenderFloat m_Blender;

		private int changedCount = 0;

		public int ChangedCount { get { return changedCount; } }

		public void MarkImageChanged()
		{
			// mark this unchecked as we don't want to throw an exception if this rolls over.
			unchecked
			{
				changedCount++;
			}
		}

		public ImageBufferFloat()
		{
		}

		public ImageBufferFloat(IRecieveBlenderFloat blender)
		{
			SetRecieveBlender(blender);
		}

		public ImageBufferFloat(IImageFloat sourceImage, IRecieveBlenderFloat blender)
		{
			SetDimmensionAndFormat(sourceImage.Width, sourceImage.Height, sourceImage.StrideInFloats(), sourceImage.BitDepth, sourceImage.GetFloatsBetweenPixelsInclusive());
			int offset = sourceImage.GetBufferOffsetXY(0, 0);
			float[] buffer = sourceImage.GetBuffer();
			float[] newBuffer = new float[buffer.Length];
			Util.memcpy(newBuffer, offset, buffer, offset, buffer.Length - offset);
			SetBuffer(newBuffer, offset);
			SetRecieveBlender(blender);
		}

		public ImageBufferFloat(int width, int height, int bitsPerPixel, IRecieveBlenderFloat blender)
		{
			Allocate(width, height, width * (bitsPerPixel / 32), bitsPerPixel);
			SetRecieveBlender(blender);
		}

#if false
        public ImageBuffer(IImageFloat image, IBlenderFloat blender, GammaLookUpTable gammaTable)
        {
            unsafe
            {
                AttachBuffer(image.GetBuffer(), image.Width, image.Height, image.StrideInBytes(), image.BitDepth, image.GetDistanceBetweenPixelsInclusive());
            }

            SetRecieveBlender(blender);
        }
#endif

		public ImageBufferFloat(IImageFloat sourceImageToCopy, IRecieveBlenderFloat blender, int distanceBetweenPixelsInclusive, int bufferOffset, int bitsPerPixel)
		{
			SetDimmensionAndFormat(sourceImageToCopy.Width, sourceImageToCopy.Height, sourceImageToCopy.StrideInFloats(), bitsPerPixel, distanceBetweenPixelsInclusive);
			int offset = sourceImageToCopy.GetBufferOffsetXY(0, 0);
			float[] buffer = sourceImageToCopy.GetBuffer();
			float[] newBuffer = new float[buffer.Length];
			throw new NotImplementedException();
			//agg_basics.memcpy(newBuffer, offset, buffer, offset, buffer.Length - offset);
			//SetBuffer(newBuffer, offset + bufferOffset);
			//SetRecieveBlender(blender);
		}

		public void AttachBuffer(float[] buffer, int bufferOffset, int width, int height, int strideInBytes, int bitDepth, int distanceInBytesBetweenPixelsInclusive)
		{
			m_FloatBuffer = null;
			SetDimmensionAndFormat(width, height, strideInBytes, bitDepth, distanceInBytesBetweenPixelsInclusive);
			SetBuffer(buffer, bufferOffset);
		}

		public void Attach(IImageFloat sourceImage, IRecieveBlenderFloat blender, int distanceBetweenPixelsInclusive, int bufferOffset, int bitsPerPixel)
		{
			SetDimmensionAndFormat(sourceImage.Width, sourceImage.Height, sourceImage.StrideInFloats(), bitsPerPixel, distanceBetweenPixelsInclusive);
			int offset = sourceImage.GetBufferOffsetXY(0, 0);
			float[] buffer = sourceImage.GetBuffer();
			SetBuffer(buffer, offset + bufferOffset);
			SetRecieveBlender(blender);
		}

		public void Attach(IImageFloat sourceImage, IRecieveBlenderFloat blender)
		{
			Attach(sourceImage, blender, sourceImage.GetFloatsBetweenPixelsInclusive(), 0, sourceImage.BitDepth);
		}

		public bool Attach(IImageFloat sourceImage, int x1, int y1, int x2, int y2)
		{
			m_FloatBuffer = null;
			DettachBuffer();

			if (x1 > x2 || y1 > y2)
			{
				throw new Exception("You need to have your x1 and y1 be the lower left corner of your sub image.");
			}
			RectangleInt boundsRect = new RectangleInt(x1, y1, x2, y2);
			if (boundsRect.clip(new RectangleInt(0, 0, (int)sourceImage.Width - 1, (int)sourceImage.Height - 1)))
			{
				SetDimmensionAndFormat(boundsRect.Width, boundsRect.Height, sourceImage.StrideInFloats(), sourceImage.BitDepth, sourceImage.GetFloatsBetweenPixelsInclusive());
				int bufferOffset = sourceImage.GetBufferOffsetXY(boundsRect.Left, boundsRect.Bottom);
				float[] buffer = sourceImage.GetBuffer();
				SetBuffer(buffer, bufferOffset);
				return true;
			}

			return false;
		}

		public void SetAlpha(byte value)
		{
			if (BitDepth != 32)
			{
				throw new Exception("You don't have alpha channel to set.  Your image has a bit depth of " + BitDepth.ToString() + ".");
			}
			int numPixels = Width * Height;
			int offset;
			float[] buffer = GetBuffer(out offset);
			for (int i = 0; i < numPixels; i++)
			{
				buffer[offset + i * 4 + 3] = value;
			}
		}

		private void Deallocate()
		{
			m_FloatBuffer = null;
			SetDimmensionAndFormat(0, 0, 0, 32, 4);
		}

		public void Allocate(int inWidth, int inHeight, int inScanWidthInFloats, int bitsPerPixel)
		{
			if (bitsPerPixel != 128 && bitsPerPixel != 96 && bitsPerPixel != 32)
			{
				throw new Exception("Unsupported bits per pixel.");
			}
			if (inScanWidthInFloats < inWidth * (bitsPerPixel / 32))
			{
				throw new Exception("Your scan width is not big enough to hold your width and height.");
			}
			SetDimmensionAndFormat(inWidth, inHeight, inScanWidthInFloats, bitsPerPixel, bitsPerPixel / 32);

			m_FloatBuffer = new float[m_StrideInFloats * m_Height];

			SetUpLookupTables();
		}

		public Graphics2D NewGraphics2D()
		{
			InternalImageGraphics2D imageRenderer = new InternalImageGraphics2D(this);

			imageRenderer.Rasterizer.SetVectorClipBox(0, 0, Width, Height);

			return imageRenderer;
		}

		public void CopyFrom(IImageFloat sourceImage)
		{
			CopyFrom(sourceImage, sourceImage.GetBounds(), 0, 0);
		}

		protected void CopyFromNoClipping(IImageFloat sourceImage, RectangleInt clippedSourceImageRect, int destXOffset, int destYOffset)
		{
			if (GetFloatsBetweenPixelsInclusive() != BitDepth / 32
				|| sourceImage.GetFloatsBetweenPixelsInclusive() != sourceImage.BitDepth / 32)
			{
				throw new Exception("WIP we only support packed pixel formats at this time.");
			}

			if (BitDepth == sourceImage.BitDepth)
			{
				int lengthInFloats = clippedSourceImageRect.Width * GetFloatsBetweenPixelsInclusive();

				int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left, clippedSourceImageRect.Bottom);
				float[] sourceBuffer = sourceImage.GetBuffer();
				int destOffset;
				float[] destBuffer = GetPixelPointerXY(clippedSourceImageRect.Left + destXOffset, clippedSourceImageRect.Bottom + destYOffset, out destOffset);

				for (int i = 0; i < clippedSourceImageRect.Height; i++)
				{
					Util.memmove(destBuffer, destOffset, sourceBuffer, sourceOffset, lengthInFloats);
					sourceOffset += sourceImage.StrideInFloats();
					destOffset += StrideInFloats();
				}
			}
			else
			{
				bool haveConversion = true;
				switch (sourceImage.BitDepth)
				{
					case 24:
						switch (BitDepth)
						{
							case 32:
								{
									int numPixelsToCopy = clippedSourceImageRect.Width;
									for (int i = clippedSourceImageRect.Bottom; i < clippedSourceImageRect.Top; i++)
									{
										int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left, clippedSourceImageRect.Bottom + i);
										float[] sourceBuffer = sourceImage.GetBuffer();
										int destOffset;
										float[] destBuffer = GetPixelPointerXY(
											clippedSourceImageRect.Left + destXOffset,
											clippedSourceImageRect.Bottom + i + destYOffset,
											out destOffset);
										for (int x = 0; x < numPixelsToCopy; x++)
										{
											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];
											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];
											destBuffer[destOffset++] = sourceBuffer[sourceOffset++];
											destBuffer[destOffset++] = 255;
										}
									}
								}
								break;

							default:
								haveConversion = false;
								break;
						}
						break;

					default:
						haveConversion = false;
						break;
				}

				if (!haveConversion)
				{
					throw new NotImplementedException("You need to write the " + sourceImage.BitDepth.ToString() + " to " + BitDepth.ToString() + " conversion");
				}
			}
		}

		public void CopyFrom(IImageFloat sourceImage, RectangleInt sourceImageRect, int destXOffset, int destYOffset)
		{
			RectangleInt sourceImageBounds = sourceImage.GetBounds();
			RectangleInt clippedSourceImageRect = new RectangleInt();
			if (clippedSourceImageRect.IntersectRectangles(sourceImageRect, sourceImageBounds))
			{
				RectangleInt destImageRect = clippedSourceImageRect;
				destImageRect.Offset(destXOffset, destYOffset);
				RectangleInt destImageBounds = GetBounds();
				RectangleInt clippedDestImageRect = new RectangleInt();
				if (clippedDestImageRect.IntersectRectangles(destImageRect, destImageBounds))
				{
					// we need to make sure the source is also clipped to the dest. So, we'll copy this back to source and offset it.
					clippedSourceImageRect = clippedDestImageRect;
					clippedSourceImageRect.Offset(-destXOffset, -destYOffset);
					CopyFromNoClipping(sourceImage, clippedSourceImageRect, destXOffset, destYOffset);
				}
			}
		}

		public Vector2 OriginOffset
		{
			get { return m_OriginOffset; }
			set { m_OriginOffset = value; }
		}

		public int Width { get { return m_Width; } }

		public int Height { get { return m_Height; } }

		public int StrideInFloats()
		{
			return m_StrideInFloats;
		}

		public int StrideInFloatsAbs()
		{
			return System.Math.Abs(m_StrideInFloats);
		}

		public int GetFloatsBetweenPixelsInclusive()
		{
			return m_DistanceInFloatsBetweenPixelsInclusive;
		}

		public int BitDepth
		{
			get { return m_BitDepth; }
		}

		public virtual RectangleInt GetBounds()
		{
			return new RectangleInt(-(int)m_OriginOffset.X, -(int)m_OriginOffset.Y, Width - (int)m_OriginOffset.X, Height - (int)m_OriginOffset.Y);
		}

		public IRecieveBlenderFloat GetBlender()
		{
			return m_Blender;
		}

		public void SetRecieveBlender(IRecieveBlenderFloat value)
		{
			if (value != null && value.NumPixelBits != BitDepth)
			{
				throw new NotSupportedException("The blender has to support the bit depth of this image.");
			}
			m_Blender = value;
		}

		private void SetUpLookupTables()
		{
			m_yTable = new int[m_Height];
			for (int i = 0; i < m_Height; i++)
			{
				m_yTable[i] = i * m_StrideInFloats;
			}

			m_xTable = new int[m_Width];
			for (int i = 0; i < m_Width; i++)
			{
				m_xTable[i] = i * m_DistanceInFloatsBetweenPixelsInclusive;
			}
		}

		public void FlipY()
		{
			m_StrideInFloats *= -1;
			m_BufferFirstPixel = m_BufferOffset;
			if (m_StrideInFloats < 0)
			{
				int addAmount = -((int)((int)m_Height - 1) * m_StrideInFloats);
				m_BufferFirstPixel = addAmount + m_BufferOffset;
			}

			SetUpLookupTables();
		}

		public void SetBuffer(float[] floatBuffer, int bufferOffset)
		{
			if (floatBuffer.Length < m_Height * m_StrideInFloats)
			{
				throw new Exception("Your buffer does not have enough room for your height and strideInBytes.");
			}
			m_FloatBuffer = floatBuffer;
			m_BufferOffset = m_BufferFirstPixel = bufferOffset;
			if (m_StrideInFloats < 0)
			{
				int addAmount = -((int)((int)m_Height - 1) * m_StrideInFloats);
				m_BufferFirstPixel = addAmount + m_BufferOffset;
			}
			SetUpLookupTables();
		}

		private void SetDimmensionAndFormat(int width, int height, int strideInFloats, int bitDepth, int distanceInFloatsBetweenPixelsInclusive)
		{
			if (m_FloatBuffer != null)
			{
				throw new Exception("You already have a buffer set. You need to set dimensions before the buffer.  You may need to clear the buffer first.");
			}
			m_Width = width;
			m_Height = height;
			m_StrideInFloats = strideInFloats;
			m_BitDepth = bitDepth;
			if (distanceInFloatsBetweenPixelsInclusive > 4)
			{
				throw new System.Exception("It looks like you are passing bits per pixel rather than distance in Floats.");
			}
			if (distanceInFloatsBetweenPixelsInclusive < (bitDepth / 32))
			{
				throw new Exception("You do not have enough room between pixels to support your bit depth.");
			}
			m_DistanceInFloatsBetweenPixelsInclusive = distanceInFloatsBetweenPixelsInclusive;
			if (strideInFloats < distanceInFloatsBetweenPixelsInclusive * width)
			{
				throw new Exception("You do not have enough strideInFloats to hold the width and pixel distance you have described.");
			}
		}

		public void DettachBuffer()
		{
			m_FloatBuffer = null;
			m_Width = m_Height = m_StrideInFloats = m_DistanceInFloatsBetweenPixelsInclusive = 0;
		}

		public float[] GetBuffer()
		{
			return m_FloatBuffer;
		}

		public float[] GetBuffer(out int bufferOffset)
		{
			bufferOffset = m_BufferOffset;
			return m_FloatBuffer;
		}

		public float[] GetPixelPointerY(int y, out int bufferOffset)
		{
			bufferOffset = m_BufferFirstPixel + m_yTable[y];
			//bufferOffset = GetBufferOffsetXY(0, y);
			return m_FloatBuffer;
		}

		public float[] GetPixelPointerXY(int x, int y, out int bufferOffset)
		{
			bufferOffset = GetBufferOffsetXY(x, y);
			return m_FloatBuffer;
		}

		public ColorF GetPixel(int x, int y)
		{
			return m_Blender.PixelToColorRGBA_Floats(m_FloatBuffer, GetBufferOffsetXY(x, y));
		}

		public virtual void SetPixel(int x, int y, ColorF color)
		{
			x -= (int)m_OriginOffset.X;
			y -= (int)m_OriginOffset.Y;
			m_Blender.CopyPixels(GetBuffer(), GetBufferOffsetXY(x, y), color, 1);
		}

		public int GetBufferOffsetY(int y)
		{
			return m_BufferFirstPixel + m_yTable[y];
		}

		public int GetBufferOffsetXY(int x, int y)
		{
			return m_BufferFirstPixel + m_yTable[y] + m_xTable[x];
		}

		public void copy_pixel(int x, int y, float[] c, int ByteOffset)
		{
			throw new System.NotImplementedException();
			//byte* p = GetPixelPointerXY(x, y);
			//((int*)p)[0] = ((int*)c)[0];
			//p[OrderR] = c.r;
			//p[OrderG] = c.g;
			//p[OrderB] = c.b;
			//p[OrderA] = c.a;
		}

		public void BlendPixel(int x, int y, ColorF c, byte cover)
		{
			throw new System.NotImplementedException();
			/*
			cob_type::copy_or_blend_pix(
				(value_type*)m_rbuf->row_ptr(x, y, 1)  + x + x + x,
				c.r, c.g, c.b, c.a,
				cover);*/
		}

		public void SetPixelFromColor(float[] destPixel, IColorType c)
		{
			throw new System.NotImplementedException();
			//pDestPixel[OrderR] = (byte)c.R_Byte;
			//pDestPixel[OrderG] = (byte)c.G_Byte;
			//pDestPixel[OrderB] = (byte)c.B_Byte;
		}

		public void copy_hline(int x, int y, int len, ColorF sourceColor)
		{
			int bufferOffset;
			float[] buffer = GetPixelPointerXY(x, y, out bufferOffset);

			m_Blender.CopyPixels(buffer, bufferOffset, sourceColor, len);
		}

		public void copy_vline(int x, int y, int len, ColorF sourceColor)
		{
			throw new NotImplementedException();
#if false
            int scanWidth = StrideInBytes();
            byte* pDestBuffer = GetPixelPointerXY(x, y);
            do
            {
                m_Blender.CopyPixel(pDestBuffer, sourceColor);
                pDestBuffer = &pDestBuffer[scanWidth];
            }
            while (--len != 0);
#endif
		}

		public void blend_hline(int x1, int y, int x2, ColorF sourceColor, byte cover)
		{
			if (sourceColor.alpha != 0)
			{
				int len = x2 - x1 + 1;

				int bufferOffset;
				float[] buffer = GetPixelPointerXY(x1, y, out bufferOffset);

				float alpha = sourceColor.alpha * (cover * (1.0f / 255.0f));
				if (alpha == 1)
				{
					m_Blender.CopyPixels(buffer, bufferOffset, sourceColor, len);
				}
				else
				{
					do
					{
						m_Blender.BlendPixel(buffer, bufferOffset, new ColorF(sourceColor.red, sourceColor.green, sourceColor.blue, alpha));
						bufferOffset += m_DistanceInFloatsBetweenPixelsInclusive;
					}
					while (--len != 0);
				}
			}
		}

		public void blend_vline(int x, int y1, int y2, ColorF sourceColor, byte cover)
		{
			throw new NotImplementedException();
#if false
            int ScanWidth = StrideInBytes();
            if (sourceColor.m_A != 0)
            {
                unsafe
                {
                    int len = y2 - y1 + 1;
                    byte* p = GetPixelPointerXY(x, y1);
                    sourceColor.m_A = (byte)(((int)(sourceColor.m_A) * (cover + 1)) >> 8);
                    if (sourceColor.m_A == base_mask)
                    {
                        byte cr = sourceColor.m_R;
                        byte cg = sourceColor.m_G;
                        byte cb = sourceColor.m_B;
                        do
                        {
                            m_Blender.CopyPixel(p, sourceColor);
                            p = &p[ScanWidth];
                        }
                        while (--len != 0);
                    }
                    else
                    {
                        if (cover == 255)
                        {
                            do
                            {
                                m_Blender.BlendPixel(p, sourceColor);
                                p = &p[ScanWidth];
                            }
                            while (--len != 0);
                        }
                        else
                        {
                            do
                            {
                                m_Blender.BlendPixel(p, sourceColor);
                                p = &p[ScanWidth];
                            }
                            while (--len != 0);
                        }
                    }
                }
            }
#endif
		}

		public void blend_solid_hspan(int x, int y, int len, ColorF sourceColor, byte[] covers, int coversIndex)
		{
			float colorAlpha = sourceColor.alpha;
			if (colorAlpha != 0)
			{
				unchecked
				{
					int bufferOffset;
					float[] buffer = GetPixelPointerXY(x, y, out bufferOffset);

					do
					{
						float alpha = colorAlpha * (covers[coversIndex] * (1.0f / 255.0f));
						if (alpha == 1)
						{
							m_Blender.CopyPixels(buffer, bufferOffset, sourceColor, 1);
						}
						else
						{
							m_Blender.BlendPixel(buffer, bufferOffset, new ColorF(sourceColor.red, sourceColor.green, sourceColor.blue, alpha));
						}
						bufferOffset += m_DistanceInFloatsBetweenPixelsInclusive;
						coversIndex++;
					}
					while (--len != 0);
				}
			}
		}

		public void blend_solid_vspan(int x, int y, int len, ColorF c, byte[] covers, int coversIndex)
		{
			throw new NotImplementedException();
#if false
            if (sourceColor.m_A != 0)
            {
                int ScanWidth = StrideInBytes();
                unchecked
                {
                    byte* p = GetPixelPointerXY(x, y);
                    do
                    {
                        byte oldAlpha = sourceColor.m_A;
                        sourceColor.m_A = (byte)(((int)(sourceColor.m_A) * ((int)(*covers++) + 1)) >> 8);
                        if (sourceColor.m_A == base_mask)
                        {
                            m_Blender.CopyPixel(p, sourceColor);
                        }
                        else
                        {
                            m_Blender.BlendPixel(p, sourceColor);
                        }
                        p = &p[ScanWidth];
                        sourceColor.m_A = oldAlpha;
                    }
                    while (--len != 0);
                }
            }
#endif
		}

		public void copy_color_hspan(int x, int y, int len, ColorF[] colors, int colorsIndex)
		{
			int bufferOffset = GetBufferOffsetXY(x, y);

			do
			{
				m_Blender.CopyPixels(m_FloatBuffer, bufferOffset, colors[colorsIndex], 1);

				++colorsIndex;
				bufferOffset += m_DistanceInFloatsBetweenPixelsInclusive;
			}
			while (--len != 0);
		}

		public void copy_color_vspan(int x, int y, int len, ColorF[] colors, int colorsIndex)
		{
			int bufferOffset = GetBufferOffsetXY(x, y);

			do
			{
				m_Blender.CopyPixels(m_FloatBuffer, bufferOffset, colors[colorsIndex], 1);

				++colorsIndex;
				bufferOffset += m_StrideInFloats;
			}
			while (--len != 0);
		}

		public void blend_color_hspan(int x, int y, int len, ColorF[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			int bufferOffset = GetBufferOffsetXY(x, y);
			m_Blender.BlendPixels(m_FloatBuffer, bufferOffset, colors, colorsIndex, covers, coversIndex, firstCoverForAll, len);
		}

		public void blend_color_vspan(int x, int y, int len, ColorF[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			int bufferOffset = GetBufferOffsetXY(x, y);

			int ScanWidth = StrideInFloatsAbs();
			if (!firstCoverForAll)
			{
				do
				{
					DoCopyOrBlendFloat.BasedOnAlphaAndCover(m_Blender, m_FloatBuffer, bufferOffset, colors[colorsIndex], covers[coversIndex++]);
					bufferOffset += ScanWidth;
					++colorsIndex;
				}
				while (--len != 0);
			}
			else
			{
				if (covers[coversIndex] == 1)
				{
					do
					{
						DoCopyOrBlendFloat.BasedOnAlpha(m_Blender, m_FloatBuffer, bufferOffset, colors[colorsIndex]);
						bufferOffset += ScanWidth;
						++colorsIndex;
					}
					while (--len != 0);
				}
				else
				{
					do
					{
						DoCopyOrBlendFloat.BasedOnAlphaAndCover(m_Blender, m_FloatBuffer, bufferOffset, colors[colorsIndex], covers[coversIndex]);
						bufferOffset += ScanWidth;
						++colorsIndex;
					}
					while (--len != 0);
				}
			}
		}

		public void apply_gamma_inv(GammaLookUpTable g)
		{
			throw new System.NotImplementedException();
			//for_each_pixel(apply_gamma_inv_rgba<color_type, order_type, GammaLut>(g));
		}

		private bool IsPixelVisible(int x, int y)
		{
			ColorF pixelValue = GetBlender().PixelToColorRGBA_Floats(m_FloatBuffer, GetBufferOffsetXY(x, y));
			return (pixelValue.Alpha0To255 != 0 || pixelValue.Red0To255 != 0 || pixelValue.Green0To255 != 0 || pixelValue.Blue0To255 != 0);
		}

		public void GetVisibleBounds(out RectangleInt visibleBounds)
		{
			visibleBounds = new RectangleInt(0, 0, Width, Height);

			// trim the bottom
			bool aPixelsIsVisible = false;
			for (int y = 0; y < m_Height; y++)
			{
				for (int x = 0; x < m_Width; x++)
				{
					if (IsPixelVisible(x, y))
					{
						visibleBounds.Bottom = y;
						y = m_Height;
						x = m_Width;
						aPixelsIsVisible = true;
					}
				}
			}

			// if we don't run into any pixels set for the top trim than there are no pixels set at all
			if (!aPixelsIsVisible)
			{
				visibleBounds.SetRect(0, 0, 0, 0);
				return;
			}

			// trim the bottom
			for (int y = m_Height - 1; y >= 0; y--)
			{
				for (int x = 0; x < m_Width; x++)
				{
					if (IsPixelVisible(x, y))
					{
						visibleBounds.Top = y + 1;
						y = -1;
						x = m_Width;
					}
				}
			}

			// trim the left
			for (int x = 0; x < m_Width; x++)
			{
				for (int y = 0; y < m_Height; y++)
				{
					if (IsPixelVisible(x, y))
					{
						visibleBounds.Left = x;
						y = m_Height;
						x = m_Width;
					}
				}
			}

			// trim the right
			for (int x = m_Width - 1; x >= 0; x--)
			{
				for (int y = 0; y < m_Height; y++)
				{
					if (IsPixelVisible(x, y))
					{
						visibleBounds.Right = x + 1;
						y = m_Height;
						x = -1;
					}
				}
			}
		}

		public void CropToVisible()
		{
			Vector2 OldOriginOffset = OriginOffset;

			//Move the HotSpot to 0, 0 so PPoint will work the way we want
			OriginOffset = new Vector2(0, 0);

			RectangleInt visibleBounds;
			GetVisibleBounds(out visibleBounds);

			if (visibleBounds.Width == Width
				&& visibleBounds.Height == Height)
			{
				OriginOffset = OldOriginOffset;
				return;
			}

			// check if the Not0Rect has any size
			if (visibleBounds.Width > 0)
			{
				ImageBufferFloat TempImage = new ImageBufferFloat();

				// set TempImage equal to the Not0Rect
				TempImage.Initialize(this, visibleBounds);

				// set the frame equal to the TempImage
				Initialize(TempImage);

				OriginOffset = new Vector2(-visibleBounds.Left + OldOriginOffset.X, -visibleBounds.Bottom + OldOriginOffset.Y);
			}
			else
			{
				Deallocate();
			}
		}

		public RectangleInt GetBoundingRect()
		{
			RectangleInt boundingRect = new RectangleInt(0, 0, Width, Height);
			boundingRect.Offset((int)OriginOffset.X, (int)OriginOffset.Y);
			return boundingRect;
		}

		private void Initialize(ImageBufferFloat sourceImage)
		{
			RectangleInt sourceBoundingRect = sourceImage.GetBoundingRect();

			Initialize(sourceImage, sourceBoundingRect);
			OriginOffset = sourceImage.OriginOffset;
		}

		private void Initialize(ImageBufferFloat sourceImage, RectangleInt boundsToCopyFrom)
		{
			if (sourceImage == this)
			{
				throw new Exception("We do not create a temp buffer for this to work.  You must have a source distinct from the dest.");
			}
			Deallocate();
			Allocate(boundsToCopyFrom.Width, boundsToCopyFrom.Height, boundsToCopyFrom.Width * sourceImage.BitDepth / 8, sourceImage.BitDepth);
			SetRecieveBlender(sourceImage.GetBlender());

			if (m_Width != 0 && m_Height != 0)
			{
				RectangleInt DestRect = new RectangleInt(0, 0, boundsToCopyFrom.Width, boundsToCopyFrom.Height);
				RectangleInt AbsoluteSourceRect = boundsToCopyFrom;
				// The first thing we need to do is make sure the frame is cleared. LBB [3/15/2004]
				Graphics2D graphics2D = NewGraphics2D();
				graphics2D.Clear(new ColorF(0, 0, 0, 0));

				int x = -boundsToCopyFrom.Left - (int)sourceImage.OriginOffset.X;
				int y = -boundsToCopyFrom.Bottom - (int)sourceImage.OriginOffset.Y;

				graphics2D.Render(sourceImage, x, y, 0, 1, 1);
			}
		}
	}

	public static class DoCopyOrBlendFloat
	{
		private const byte base_mask = 255;

		public static void BasedOnAlpha(IRecieveBlenderFloat Blender, float[] destBuffer, int bufferOffset, ColorF sourceColor)
		{
			//if (sourceColor.m_A != 0)
			{
#if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have additive and faster blending in one blender) LBB
                if (sourceColor.m_A == base_mask)
                {
                    Blender.CopyPixel(pDestBuffer, sourceColor);
                }
                else
#endif
				{
					Blender.BlendPixel(destBuffer, bufferOffset, sourceColor);
				}
			}
		}

		public static void BasedOnAlphaAndCover(IRecieveBlenderFloat Blender, float[] destBuffer, int bufferOffset, ColorF sourceColor, int cover)
		{
			if (cover == 255)
			{
				BasedOnAlpha(Blender, destBuffer, bufferOffset, sourceColor);
			}
			else
			{
				//if (sourceColor.m_A != 0)
				{
					sourceColor.alpha = sourceColor.alpha * ((float)cover * (1 / 255));
#if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have additive and faster blending in one blender) LBB
                    if (sourceColor.m_A == base_mask)
                    {
                        Blender.CopyPixel(pDestBuffer, sourceColor);
                    }
                    else
#endif
					{
						Blender.BlendPixel(destBuffer, bufferOffset, sourceColor);
					}
				}
			}
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\ImageGraphics2D.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;
using MatterHackers.Agg.Image;
using MatterHackers.Agg.RasterizerScanline;
using MatterHackers.Agg.Transform;
using MatterHackers.Agg.VertexSource;
using MatterHackers.VectorMath;

namespace MatterHackers.Agg
{
	public class ImageGraphics2D : Graphics2D
	{
		private IScanlineCache scanlineCache;
		private readonly VertexStorage drawImageRectPath = new VertexStorage();
		private readonly span_allocator destImageSpanAllocatorCache = new span_allocator();
		private readonly ScanlineCachePacked8 drawImageScanlineCache = new ScanlineCachePacked8();
		private readonly ScanlineRenderer scanlineRenderer = new ScanlineRenderer();

		public ImageGraphics2D()
		{
		}

		public ImageGraphics2D(IImageByte destImage, ScanlineRasterizer rasterizer, IScanlineCache scanlineCache)
			: base(destImage, rasterizer)
		{
			this.scanlineCache = scanlineCache;
		}

		public override IScanlineCache ScanlineCache
		{
			get { return scanlineCache; }
			set { scanlineCache = value; }
		}

		public override int Width => destImageByte.Width;

		public override int Height => destImageByte.Height;

		public override void SetClippingRect(RectangleDouble clippingRect)
		{
			Rasterizer.SetVectorClipBox(clippingRect);
		}

		public override RectangleDouble GetClippingRect()
		{
			return Rasterizer.GetVectorClipBox();
		}

		public override void Render(IVertexSource vertexSource, IColorType colorBytes)
		{
			rasterizer.reset();
			Affine transform = GetTransform();
			if (!transform.is_identity())
			{
				vertexSource = new VertexSourceApplyTransform(vertexSource, transform);
			}

			rasterizer.add_path(vertexSource);
			if (destImageByte != null)
			{
				scanlineRenderer.RenderSolid(destImageByte, rasterizer, scanlineCache, colorBytes.ToColor());
				DestImage.MarkImageChanged();
			}
			else
			{
				scanlineRenderer.RenderSolid(destImageFloat, rasterizer, scanlineCache, colorBytes.ToColorF());
				destImageFloat.MarkImageChanged();
			}
		}

		private void DrawImageGetDestBounds(IImageByte sourceImage,
			double destX,
			double destY,
			double hotspotOffsetX,
			double hotspotOffsetY,
			double scaleX,
			double scaleY,
			double angleRad,
			out Affine destRectTransform)
		{
			destRectTransform = Affine.NewIdentity();

			if (hotspotOffsetX != 0.0f || hotspotOffsetY != 0.0f)
			{
				destRectTransform *= Affine.NewTranslation(-hotspotOffsetX, -hotspotOffsetY);
			}

			if (scaleX != 1 || scaleY != 1)
			{
				destRectTransform *= Affine.NewScaling(scaleX, scaleY);
			}

			if (angleRad != 0)
			{
				destRectTransform *= Affine.NewRotation(angleRad);
			}

			if (destX != 0 || destY != 0)
			{
				destRectTransform *= Affine.NewTranslation(destX, destY);
			}

			int sourceBufferWidth = (int)sourceImage.Width;
			int sourceBufferHeight = (int)sourceImage.Height;

			drawImageRectPath.Clear();

			drawImageRectPath.MoveTo(0, 0);
			drawImageRectPath.LineTo(sourceBufferWidth, 0);
			drawImageRectPath.LineTo(sourceBufferWidth, sourceBufferHeight);
			drawImageRectPath.LineTo(0, sourceBufferHeight);
			drawImageRectPath.ClosePolygon();
		}

		private void DrawImage(ISpanGenerator spanImageFilter, Affine destRectTransform)
		{
			if (destImageByte.OriginOffset.X != 0 || destImageByte.OriginOffset.Y != 0)
			{
				destRectTransform *= Affine.NewTranslation(-destImageByte.OriginOffset.X, -destImageByte.OriginOffset.Y);
			}

			var transformedRect = new VertexSourceApplyTransform(drawImageRectPath, destRectTransform);
			Rasterizer.add_path(transformedRect);
			{
				var destImageWithClipping = new ImageClippingProxy(destImageByte);
				scanlineRenderer.GenerateAndRender(Rasterizer, drawImageScanlineCache, destImageWithClipping, destImageSpanAllocatorCache, spanImageFilter);
			}
		}

		public override void Render(IImageByte source,
			double destX,
			double destY,
			double angleRadians,
			double inScaleX,
			double inScaleY)
		{
			Affine graphicsTransform = GetTransform();

			// exit early if the dest and source bounds don't touch.
			// TODO: <BUG> make this do rotation and scaling
			RectangleInt sourceBounds = source.GetBounds();
			RectangleInt destBounds = this.destImageByte.GetBounds();
			sourceBounds.Offset((int)(destX + graphicsTransform.tx), (int)(destY + graphicsTransform.ty));

			if (!RectangleInt.DoIntersect(sourceBounds, destBounds))
			{
				if (inScaleX != 1 || inScaleY != 1 || angleRadians != 0)
				{
					//throw new NotImplementedException();
				}

				//return;
			}

			double scaleX = inScaleX;
			double scaleY = inScaleY;

			if (!graphicsTransform.is_identity())
			{
				if (scaleX != 1 || scaleY != 1 || angleRadians != 0)
				{
					//throw new NotImplementedException();
				}

				graphicsTransform.Transform(ref destX, ref destY);
			}

#if false // this is an optimization that eliminates the drawing of images that have their alpha set to all 0 (happens with generated images like explosions).
	        MaxAlphaFrameProperty maxAlphaFrameProperty = MaxAlphaFrameProperty::GetMaxAlphaFrameProperty(source);

	        if((maxAlphaFrameProperty.GetMaxAlpha() * color.A_Byte) / 256 <= ALPHA_CHANNEL_BITS_DIVISOR)
	        {
		        m_OutFinalBlitBounds.SetRect(0,0,0,0);
	        }
#endif
			bool isScaled = scaleX != 1 || scaleY != 1;

			bool isRotated = true;
			if (Math.Abs(angleRadians) < (0.1 * MathHelper.Tau / 360))
			{
				isRotated = false;
				angleRadians = 0;
			}

			// bool IsMipped = false;
			double sourceOriginOffsetX = source.OriginOffset.X;
			double sourceOriginOffsetY = source.OriginOffset.Y;
			bool canUseMipMaps = isScaled;
			if (scaleX > 0.5 || scaleY > 0.5)
			{
				canUseMipMaps = false;
			}

			bool renderRequriesSourceSampling = isScaled || isRotated || destX != (int)destX || destY != (int)destY;

			// this is the fast drawing path
			if (renderRequriesSourceSampling)
			{
#if false // if the scaling is small enough the results can be improved by using mip maps
	        if(CanUseMipMaps)
	        {
		        CMipMapFrameProperty* pMipMapFrameProperty = CMipMapFrameProperty::GetMipMapFrameProperty(source);
		        double OldScaleX = scaleX;
		        double OldScaleY = scaleY;
		        const CFrameInterface* pMippedFrame = pMipMapFrameProperty.GetMipMapFrame(ref scaleX, ref scaleY);
		        if(pMippedFrame != source)
		        {
			        IsMipped = true;
			        source = pMippedFrame;
			        sourceOriginOffsetX *= (OldScaleX / scaleX);
			        sourceOriginOffsetY *= (OldScaleY / scaleY);
		        }

			    HotspotOffsetX *= (inScaleX / scaleX);
			    HotspotOffsetY *= (inScaleY / scaleY);
	        }
#endif
				switch (ImageRenderQuality)
				{
					case TransformQuality.Fastest:
						{
							DrawImageGetDestBounds(source, destX, destY, sourceOriginOffsetX, sourceOriginOffsetY, scaleX, scaleY, angleRadians, out Affine destRectTransform);

							var sourceRectTransform = new Affine(destRectTransform);
							// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]
							sourceRectTransform.invert();

							span_image_filter spanImageFilter;
							var interpolator = new span_interpolator_linear(sourceRectTransform);
							var sourceAccessor = new ImageBufferAccessorClip(source, ColorF.rgba_pre(0, 0, 0, 0).ToColor());

							spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor, ColorF.rgba_pre(0, 0, 0, 0), interpolator);

							DrawImage(spanImageFilter, destRectTransform);
						}

						break;

					case TransformQuality.Best:
						{
							DrawImageGetDestBounds(source, destX, destY, sourceOriginOffsetX, sourceOriginOffsetY, scaleX, scaleY, angleRadians, out Affine destRectTransform);

							var sourceRectTransform = new Affine(destRectTransform);
							// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]
							sourceRectTransform.invert();

							var interpolator = new span_interpolator_linear(sourceRectTransform);
							var sourceAccessor = new ImageBufferAccessorClip(source, ColorF.rgba_pre(0, 0, 0, 0).ToColor());

							// spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor, RGBA_Floats.rgba_pre(0, 0, 0, 0), interpolator);

							IImageFilterFunction filterFunction = null;
							filterFunction = new image_filter_blackman(4);
							var filter = new ImageFilterLookUpTable();
							filter.calculate(filterFunction, true);

							span_image_filter spanGenerator = new span_image_filter_rgba(sourceAccessor, interpolator, filter);

							DrawImage(spanGenerator, destRectTransform);
						}

						break;
				}
#if false // this is some debug you can enable to visualize the dest bounding box
		        LineFloat(BoundingRect.left, BoundingRect.top, BoundingRect.right, BoundingRect.top, WHITE);
		        LineFloat(BoundingRect.right, BoundingRect.top, BoundingRect.right, BoundingRect.bottom, WHITE);
		        LineFloat(BoundingRect.right, BoundingRect.bottom, BoundingRect.left, BoundingRect.bottom, WHITE);
		        LineFloat(BoundingRect.left, BoundingRect.bottom, BoundingRect.left, BoundingRect.top, WHITE);
#endif
			}
			else // TODO: this can be even faster if we do not use an intermediate buffer
			{
				DrawImageGetDestBounds(source, destX, destY, sourceOriginOffsetX, sourceOriginOffsetY, scaleX, scaleY, angleRadians, out Affine destRectTransform);

				var sourceRectTransform = new Affine(destRectTransform);
				// We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]
				sourceRectTransform.invert();

				var interpolator = new span_interpolator_linear(sourceRectTransform);
				var sourceAccessor = new ImageBufferAccessorClip(source, ColorF.rgba_pre(0, 0, 0, 0).ToColor());

				span_image_filter spanImageFilter = null;
				switch (source.BitDepth)
				{
					case 32:
						spanImageFilter = new span_image_filter_rgba_nn_stepXby1(sourceAccessor, interpolator);
						break;

					case 24:
						spanImageFilter = new span_image_filter_rgb_nn_stepXby1(sourceAccessor, interpolator);
						break;

					case 8:
						spanImageFilter = new span_image_filter_gray_nn_stepXby1(sourceAccessor, interpolator);
						break;

					default:
						throw new NotImplementedException();
				}

				// spanImageFilter = new span_image_filter_rgba_nn(sourceAccessor, interpolator);

				DrawImage(spanImageFilter, destRectTransform);
			}

			DestImage.MarkImageChanged();
		}

		public override void Rectangle(double left, double bottom, double right, double top, Color color, double strokeWidth)
		{
			var rect = new RoundedRect(left + .5, bottom + .5, right - .5, top - .5, 0);
			var rectOutline = new Stroke(rect, strokeWidth);

			Render(rectOutline, color);
		}

		public override void FillRectangle(double left, double bottom, double right, double top, IColorType fillColor)
		{
			var rect = new RoundedRect(left, bottom, right, top, 0);
			Render(rect, fillColor.ToColor());
		}

		public override void Render(IImageFloat source,
			double x,
			double y,
			double angleDegrees,
			double inScaleX,
			double inScaleY)
		{
			throw new NotImplementedException();
		}

		public override void Clear(RectangleDouble bounds, IColorType iColor)
		{
			var intBounds = new RectangleInt(bounds);
			var clippingRect = GetClippingRect();
			var clippingRectInt = new RectangleInt(clippingRect);
			// find the intersection of the clipping rect and the bounds
			clippingRectInt.IntersectWithRectangle(intBounds);
			if (clippingRectInt.Width == 0
				|| clippingRectInt.Height == 0)
			{
				return;
			}

            if (DestImage != null)
            {
                var color = iColor.ToColor();
                byte[] buffer = DestImage.GetBuffer();
                switch (DestImage.BitDepth)
                {
                    case 8:
                        {
                            for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)
                            {
                                int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRectInt.Left, y);
                                int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();
                                for (int x = 0; x < clippingRectInt.Width; x++)
                                {
                                    buffer[bufferOffset] = color.blue;
                                    bufferOffset += bytesBetweenPixels;
                                }
                            }
                        }

                        break;

                    case 24:
                        for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)
                        {
                            int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRectInt.Left, y);
                            int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();
                            for (int x = 0; x < clippingRectInt.Width; x++)
                            {
                                buffer[bufferOffset + 0] = color.blue;
                                buffer[bufferOffset + 1] = color.green;
                                buffer[bufferOffset + 2] = color.red;
                                bufferOffset += bytesBetweenPixels;
                            }
                        }

                        break;

                    case 32:
                        if (DestImage.GetBytesBetweenPixelsInclusive() == 4)
                        {
                            unsafe
                            {
                                fixed (byte* pBufferIn = buffer)
                                {
                                    uint colorValue = (uint)color.Alpha0To255 << 24 | (uint)color.Red0To255 << 16 | (uint)color.Green0To255 << 8 | (uint)color.Blue0To255;
                                    ulong colorValue2 = (ulong)colorValue << 32 | colorValue;

                                    var widthDiv2 = clippingRectInt.Width / 2;

                                    for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)
                                    {
                                        byte* pBuffer = pBufferIn + DestImage.GetBufferOffsetXY((int)clippingRectInt.Left, y);
                                        for (int x = 0; x < widthDiv2; x++)
                                        {
                                            // Convert the buffer offset to a pointer to the location where we want to copy the color.
                                            // Copy the color value into the destination buffer in one operation.
                                            *(ulong*)pBuffer = colorValue2;
                                            pBuffer += 8;
                                        }

                                        if (clippingRectInt.Width % 2 == 1)
                                        {
                                            // there is one more pixel to draw. Fill it with colorValue
                                            *(uint*)pBuffer = colorValue;
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)
                            {
                                int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRectInt.Left, y);
                                int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();
                                for (int x = 0; x < clippingRectInt.Width; x++)
                                {
                                    buffer[bufferOffset + 0] = color.blue;
                                    buffer[bufferOffset + 1] = color.green;
                                    buffer[bufferOffset + 2] = color.red;
                                    buffer[bufferOffset + 3] = color.alpha;
                                    bufferOffset += bytesBetweenPixels;
                                }
                            }
                        }

                        break;

                    default:
                        throw new NotImplementedException();
                }

                DestImage.MarkImageChanged();
            }
            else // it is a float
            {
                if (DestImageFloat == null)
                {
                    throw new Exception("You have to have either a byte or float DestImage.");
                }

                var color = iColor.ToColorF();
                int height = DestImageFloat.Height;
                float[] buffer = DestImageFloat.GetBuffer();
                switch (DestImageFloat.BitDepth)
                {
                    case 128:
                        for (int y = 0; y < height; y++)
                        {
                            int bufferOffset = DestImageFloat.GetBufferOffsetXY(clippingRectInt.Left, y);
                            int bytesBetweenPixels = DestImageFloat.GetFloatsBetweenPixelsInclusive();
                            for (int x = 0; x < clippingRectInt.Width; x++)
                            {
                                buffer[bufferOffset + 0] = color.blue;
                                buffer[bufferOffset + 1] = color.green;
                                buffer[bufferOffset + 2] = color.red;
                                buffer[bufferOffset + 3] = color.alpha;
                                bufferOffset += bytesBetweenPixels;
                            }
                        }

                        break;

                    default:
                        throw new NotImplementedException();
                }
            }

            //Rectangle(bounds, Color.Black);
        }


        public override void Clear(IColorType iColor)
		{
			Clear(GetClippingRect(), iColor);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\ImageProxy.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------

using MatterHackers.VectorMath;

namespace MatterHackers.Agg.Image
{
	public abstract class ImageProxy : IImageByte
	{
		protected IImageByte linkedImage;

		public IImageByte LinkedImage
		{
			get
			{
				return linkedImage;
			}

			set
			{
				linkedImage = value;
			}
		}

		public ImageProxy(IImageByte linkedImage)
		{
			this.linkedImage = linkedImage;
		}

		public virtual void LinkToImage(IImageByte linkedImage)
		{
			this.linkedImage = linkedImage;
		}

		public virtual Vector2 OriginOffset
		{
			get { return linkedImage.OriginOffset; }
			set { linkedImage.OriginOffset = value; }
		}

		public virtual int Width
		{
			get
			{
				return linkedImage.Width;
			}
		}

		public virtual int Height
		{
			get
			{
				return linkedImage.Height;
			}
		}

		public virtual int StrideInBytes()
		{
			return linkedImage.StrideInBytes();
		}

		public virtual int StrideInBytesAbs()
		{
			return linkedImage.StrideInBytesAbs();
		}

		public virtual RectangleInt GetBounds()
		{
			return linkedImage.GetBounds();
		}

		public Graphics2D NewGraphics2D()
		{
			return linkedImage.NewGraphics2D();
		}

		public IRecieveBlenderByte GetRecieveBlender()
		{
			return linkedImage.GetRecieveBlender();
		}

		public void SetRecieveBlender(IRecieveBlenderByte value)
		{
			linkedImage.SetRecieveBlender(value);
		}

		public virtual Color GetPixel(int x, int y)
		{
			return linkedImage.GetPixel(x, y);
		}

		public virtual void copy_pixel(int x, int y, byte[] c, int ByteOffset)
		{
			linkedImage.copy_pixel(x, y, c, ByteOffset);
		}

		public virtual void CopyFrom(IImageByte sourceRaster)
		{
			linkedImage.CopyFrom(sourceRaster);
		}

		public virtual void CopyFrom(IImageByte sourceImage, RectangleInt sourceImageRect, int destXOffset, int destYOffset)
		{
			linkedImage.CopyFrom(sourceImage, sourceImageRect, destXOffset, destYOffset);
		}

		public virtual void SetPixel(int x, int y, Color color)
		{
			linkedImage.SetPixel(x, y, color);
		}

		public virtual void BlendPixel(int x, int y, Color sourceColor, byte cover)
		{
			linkedImage.BlendPixel(x, y, sourceColor, cover);
		}

		public virtual void copy_hline(int x, int y, int len, Color sourceColor)
		{
			linkedImage.copy_hline(x, y, len, sourceColor);
		}

		public virtual void copy_vline(int x, int y, int len, Color sourceColor)
		{
			linkedImage.copy_vline(x, y, len, sourceColor);
		}

		public virtual void blend_hline(int x1, int y, int x2, Color sourceColor, byte cover)
		{
			linkedImage.blend_hline(x1, y, x2, sourceColor, cover);
		}

		public virtual void blend_vline(int x, int y1, int y2, Color sourceColor, byte cover)
		{
			linkedImage.blend_vline(x, y1, y2, sourceColor, cover);
		}

		public virtual void blend_solid_hspan(int x, int y, int len, Color c, byte[] covers, int coversIndex)
		{
			linkedImage.blend_solid_hspan(x, y, len, c, covers, coversIndex);
		}

		public virtual void copy_color_hspan(int x, int y, int len, Color[] colors, int colorIndex)
		{
			linkedImage.copy_color_hspan(x, y, len, colors, colorIndex);
		}

		public virtual void copy_color_vspan(int x, int y, int len, Color[] colors, int colorIndex)
		{
			linkedImage.copy_color_vspan(x, y, len, colors, colorIndex);
		}

		public virtual void blend_solid_vspan(int x, int y, int len, Color c, byte[] covers, int coversIndex)
		{
			linkedImage.blend_solid_vspan(x, y, len, c, covers, coversIndex);
		}

		public virtual void blend_color_hspan(int x, int y, int len, Color[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			linkedImage.blend_color_hspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
		}

		public virtual void blend_color_vspan(int x, int y, int len, Color[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			linkedImage.blend_color_vspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
		}

		public byte[] GetBuffer()
		{
			return linkedImage.GetBuffer();
		}

		public int GetBufferOffsetXY(int x, int y)
		{
			return linkedImage.GetBufferOffsetXY(x, y);
		}

		public int GetBufferOffsetY(int y)
		{
			return linkedImage.GetBufferOffsetY(y);
		}

		public virtual int GetBytesBetweenPixelsInclusive()
		{
			return linkedImage.GetBytesBetweenPixelsInclusive();
		}

		public virtual int BitDepth
		{
			get
			{
				return linkedImage.BitDepth;
			}
		}

		public void MarkImageChanged()
		{
			linkedImage.MarkImageChanged();
		}
	}

	public abstract class ImageProxyFloat : IImageFloat
	{
		protected IImageFloat linkedImage;

		public ImageProxyFloat(IImageFloat linkedImage)
		{
			this.linkedImage = linkedImage;
		}

		public virtual void LinkToImage(IImageFloat linkedImage)
		{
			this.linkedImage = linkedImage;
		}

		public virtual Vector2 OriginOffset
		{
			get { return linkedImage.OriginOffset; }
			set { linkedImage.OriginOffset = value; }
		}

		public virtual int Width
		{
			get
			{
				return linkedImage.Width;
			}
		}

		public virtual int Height
		{
			get
			{
				return linkedImage.Height;
			}
		}

		public virtual int StrideInFloats()
		{
			return linkedImage.StrideInFloats();
		}

		public virtual int StrideInFloatsAbs()
		{
			return linkedImage.StrideInFloatsAbs();
		}

		public virtual RectangleInt GetBounds()
		{
			return linkedImage.GetBounds();
		}

		public Graphics2D NewGraphics2D()
		{
			return linkedImage.NewGraphics2D();
		}

		public IRecieveBlenderFloat GetBlender()
		{
			return linkedImage.GetBlender();
		}

		public void SetRecieveBlender(IRecieveBlenderFloat value)
		{
			linkedImage.SetRecieveBlender(value);
		}

		public virtual ColorF GetPixel(int x, int y)
		{
			return linkedImage.GetPixel(y, x);
		}

		public virtual void copy_pixel(int x, int y, float[] c, int FloatOffset)
		{
			linkedImage.copy_pixel(x, y, c, FloatOffset);
		}

		public virtual void CopyFrom(IImageFloat sourceRaster)
		{
			linkedImage.CopyFrom(sourceRaster);
		}

		public virtual void CopyFrom(IImageFloat sourceImage, RectangleInt sourceImageRect, int destXOffset, int destYOffset)
		{
			linkedImage.CopyFrom(sourceImage, sourceImageRect, destXOffset, destYOffset);
		}

		public virtual void SetPixel(int x, int y, ColorF color)
		{
			linkedImage.SetPixel(x, y, color);
		}

		public virtual void BlendPixel(int x, int y, ColorF sourceColor, byte cover)
		{
			linkedImage.BlendPixel(x, y, sourceColor, cover);
		}

		public virtual void copy_hline(int x, int y, int len, ColorF sourceColor)
		{
			linkedImage.copy_hline(x, y, len, sourceColor);
		}

		public virtual void copy_vline(int x, int y, int len, ColorF sourceColor)
		{
			linkedImage.copy_vline(x, y, len, sourceColor);
		}

		public virtual void blend_hline(int x1, int y, int x2, ColorF sourceColor, byte cover)
		{
			linkedImage.blend_hline(x1, y, x2, sourceColor, cover);
		}

		public virtual void blend_vline(int x, int y1, int y2, ColorF sourceColor, byte cover)
		{
			linkedImage.blend_vline(x, y1, y2, sourceColor, cover);
		}

		public virtual void blend_solid_hspan(int x, int y, int len, ColorF c, byte[] covers, int coversIndex)
		{
			linkedImage.blend_solid_hspan(x, y, len, c, covers, coversIndex);
		}

		public virtual void copy_color_hspan(int x, int y, int len, ColorF[] colors, int colorIndex)
		{
			linkedImage.copy_color_hspan(x, y, len, colors, colorIndex);
		}

		public virtual void copy_color_vspan(int x, int y, int len, ColorF[] colors, int colorIndex)
		{
			linkedImage.copy_color_vspan(x, y, len, colors, colorIndex);
		}

		public virtual void blend_solid_vspan(int x, int y, int len, ColorF c, byte[] covers, int coversIndex)
		{
			linkedImage.blend_solid_vspan(x, y, len, c, covers, coversIndex);
		}

		public virtual void blend_color_hspan(int x, int y, int len, ColorF[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			linkedImage.blend_color_hspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
		}

		public virtual void blend_color_vspan(int x, int y, int len, ColorF[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			linkedImage.blend_color_vspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
		}

		public float[] GetBuffer()
		{
			return linkedImage.GetBuffer();
		}

		public int GetBufferOffsetY(int y)
		{
			return linkedImage.GetBufferOffsetY(y);
		}

		public int GetBufferOffsetXY(int x, int y)
		{
			return linkedImage.GetBufferOffsetXY(x, y);
		}

		public virtual int GetFloatsBetweenPixelsInclusive()
		{
			return linkedImage.GetFloatsBetweenPixelsInclusive();
		}

		public virtual int BitDepth
		{
			get
			{
				return linkedImage.BitDepth;
			}
		}

		public void MarkImageChanged()
		{
			linkedImage.MarkImageChanged();
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\ImageSequence.cs
using MatterHackers.VectorMath;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace MatterHackers.Agg.Image
{
	public class ImageSequence
	{
		public List<ImageBuffer> Frames = new List<ImageBuffer>();
		public List<int> FrameTimesMs = new List<int>();

		public ImageSequence()
		{
		}

		public ImageSequence(ImageBuffer firstImage)
		{
			AddImage(firstImage, 0);
		}

		public event EventHandler Invalidated;

		public double FramesPerSecond
		{
			get => 1 / this.SecondsPerFrame;
			set => this.SecondsPerFrame = 1 / value;
		}

		public int Height
		{
			get
			{
				if (Frames.Count > 0)
				{
					RectangleInt bounds = new RectangleInt(int.MaxValue, int.MaxValue, int.MinValue, int.MinValue);
					foreach (ImageBuffer frame in Frames)
					{
						bounds.ExpandToInclude(frame.GetBoundingRect());
					}
					return Math.Max(0, bounds.Height);
				}

				return 0;
			}
		}

		public bool Looping { get; set; }

		public int NumFrames => this.Frames.Count;

		public double SecondsPerFrame { get; set; } = 1.0 / 30.0;

		public double Time
		{
			get
			{
				if (FrameTimesMs.Count > 0)
				{
					int totalTime = 0;
					foreach (var time in FrameTimesMs)
					{
						totalTime += time;
					}

					return totalTime / 1000.0;
				}
				else
				{
					return Frames.Count * SecondsPerFrame;
				}
			}
		}

		public int Width
		{
			get
			{
				if (Frames.Count > 0)
				{
					RectangleInt bounds = new RectangleInt(int.MaxValue, int.MaxValue, int.MinValue, int.MinValue);
					foreach (ImageBuffer frame in Frames)
					{
						bounds.ExpandToInclude(frame.GetBoundingRect());
					}

					return Math.Max(0, bounds.Width);
				}

				return 0;
			}
		}

		public static ImageSequence LoadFromTgas(string pathName)
		{
			var sequenceLoaded = new ImageSequence();

			// Now lets look for and load up any images that we find.
			var sortedTgaFiles = Directory.GetFiles(pathName, "*.tga").OrderBy(s => s);

			foreach (string tgaFile in sortedTgaFiles)
			{
				using (var imageStream = File.OpenRead(tgaFile))
				{
					var imageBuffer = new ImageBuffer(new BlenderPreMultBGRA());
					ImageTgaIO.LoadImageData(imageBuffer, imageStream, 32);
					sequenceLoaded.AddImage(imageBuffer);
				}
			}

			return sequenceLoaded;
		}

		public void AddImage(ImageBuffer imageBuffer, int frameTimeMs = 1000/30)
		{
			Frames.Add(imageBuffer);
			FrameTimesMs.Add(Math.Max(frameTimeMs, 1));
		}

		public void CenterOriginOffset()
		{
			foreach (ImageBuffer image in Frames)
			{
				image.OriginOffset = new Vector2(image.Width / 2, image.Height / 2);
			}
		}

		public void Copy(ImageSequence imageSequenceToCopy)
		{
			this.Frames = imageSequenceToCopy.Frames;
			this.FrameTimesMs = imageSequenceToCopy.FrameTimesMs;
			this.Looping = imageSequenceToCopy.Looping;
			Invalidated?.Invoke(this, null);
		}

		public void CropToVisible()
		{
			for (int i=0; i<Frames.Count; i++)
			{
				Frames[i] = Frames[i].CropToVisible();
			}
		}

		public int GetFrameIndexByRatio(double fractionOfTotalLength)
		{
			return (int)((fractionOfTotalLength * (NumFrames - 1)) + .5);
		}

		public ImageBuffer GetImageByIndex(double ImageIndex)
		{
			return GetImageByIndex((int)(ImageIndex + .5));
		}

		public ImageBuffer GetImageByIndex(int ImageIndex)
		{
			if (Looping)
			{
				return Frames[ImageIndex % NumFrames];
			}

			if (ImageIndex < 0)
			{
				return Frames[0];
			}
			else if (ImageIndex > NumFrames - 1)
			{
				return Frames[NumFrames - 1];
			}

			return Frames[ImageIndex];
		}

		public ImageBuffer GetImageByRatio(double fractionOfTotalLength)
		{
			if (NumFrames > 0)
			{
				return GetImageByIndex(fractionOfTotalLength * (NumFrames - 1));
			}

			return null;
		}

		public ImageBuffer GetImageByTime(double numSeconds)
		{
			return Frames[GetImageIndexByTime(numSeconds)];
		}

		public int GetImageIndexByTime(double numSeconds)
		{
			if (FrameTimesMs.Count > 0)
			{
				int timeMs = (int)(numSeconds * 1000);
				double totalTime = 0;
				int index = 0;
				foreach (var time in FrameTimesMs)
				{
					totalTime += time;
					if (totalTime > timeMs)
					{
						return Math.Min(index, Frames.Count - 1);
					}
					index++;
				}
			}

			int frame = (int)Math.Round(numSeconds * FramesPerSecond);
			return Math.Min(frame, Frames.Count - 1);
		}

		public void Invalidate()
		{
			OnInvalidated(null);
		}

		public virtual void OnInvalidated(EventArgs args)
		{
			Invalidated?.Invoke(this, args);
		}

		public void SetAlpha(byte value)
		{
			foreach (ImageBuffer image in Frames)
			{
				image.SetAlpha(value);
			}
		}

		public class Properties
		{
			public double FramePerFrame = 30;
			public bool Looping = false;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\ImageTgaIO.cs
using System;
using System.IO;
using System.Text;

namespace MatterHackers.Agg.Image
{
	public static class ImageTgaIO
	{
		// Header of a TGA file
		public struct STargaHeader
		{
			public byte PostHeaderSkip;
			public byte ColorMapType;		// 0 = RGB, 1 = Palette
			public byte ImageType;			// 1 = Palette, 2 = RGB, 3 = mono, 9 = RLE Palette, 10 = RLE RGB, 11 RLE mono
			public ushort ColorMapStart;
			public ushort ColorMapLength;
			public byte ColorMapBits;
			public ushort XStart;				// offsets the image would like to have (ignored)
			public ushort YStart;				// offsets the image would like to have (ignored)
			public ushort Width;
			public ushort Height;
			public byte BPP;				// bit depth of the image
			public byte Descriptor;

			public void BinaryWrite(BinaryWriter writerToWriteTo)
			{
				writerToWriteTo.Write(PostHeaderSkip);
				writerToWriteTo.Write(ColorMapType);
				writerToWriteTo.Write(ImageType);
				writerToWriteTo.Write(ColorMapStart);
				writerToWriteTo.Write(ColorMapLength);
				writerToWriteTo.Write(ColorMapBits);
				writerToWriteTo.Write(XStart);
				writerToWriteTo.Write(YStart);
				writerToWriteTo.Write(Width);
				writerToWriteTo.Write(Height);
				writerToWriteTo.Write(BPP);
				writerToWriteTo.Write(Descriptor);
			}
		};

		private const int TargaHeaderSize = 18;
		private const int RGB_BLUE = 2;
		private const int RGB_GREEN = 1;
		private const int RGB_RED = 0;
		private const int RGBA_ALPHA = 3;

		// these are used during loading (only valid during load)
		private static int TGABytesPerLine;

		private static void Do24To8Bit(byte[] Dest, byte[] Source, int SourceOffset, int Width, int Height)
		{
			throw new System.NotImplementedException();
#if false

	        int i;
	        if (Width)
	        {
		        i = 0;
		        Dest = &Dest[Height*Width];
		        do
		        {
			        if(p[RGB_RED] == 0 && p[RGB_GREEN] == 0 && p[RGB_BLUE] == 0)
			        {
				        Dest[i] = 0;
			        }
			        else
			        {
				        // no other color can map to color 0
				        Dest[i] =(byte) pStaticRemap->GetColorIndex(p[RGB_RED], p[RGB_GREEN], p[RGB_BLUE], 1);
			        }
			        p += 3;
		        } while (++i<Width);
	        }
#endif
		}

		private static void Do32To8Bit(byte[] Dest, byte[] Source, int SourceOffset, int Width, int Height)
		{
			throw new System.NotImplementedException();

#if false
	        int i;
	        if (Width)
	        {
		        i = 0;
		        Dest = &Dest[Height*Width];
		        do
		        {
			        if(p[RGB_RED] == 0 && p[RGB_GREEN] == 0 && p[RGB_BLUE] == 0)
			        {
				        Dest[i] = 0;
			        }
			        else
			        {
				        // no other color can map to color 0
				        Dest[i] = (byte)pStaticRemap->GetColorIndex(p[RGB_RED], p[RGB_GREEN], p[RGB_BLUE], 1);
			        }
			        p += 4;
		        } while (++i < Width);
	        }
#endif
		}

		private static unsafe void Do24To24Bit(byte[] Dest, byte[] Source, int SourceOffset, int Width, int Height)
		{
			if (Width > 0)
			{
				int destOffset = Height * Width * 3;
				for (int i = 0; i < Width * 3; i++)
				{
					Dest[destOffset + i] = Source[SourceOffset + i];
				}
			}
		}

		private static unsafe void Do32To24Bit(byte[] Dest, byte[] Source, int SourceOffset, int Width, int Height)
		{
			if (Width > 0)
			{
				int i = 0;
				int destOffest = Height * Width * 3;
				do
				{
					Dest[destOffest + i * 3 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];
					Dest[destOffest + i * 3 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];
					Dest[destOffest + i * 3 + RGB_RED] = Source[SourceOffset + RGB_RED];
					SourceOffset += 4;
				} while (++i < Width);
			}
		}

		private static unsafe void Do24To32Bit(byte[] Dest, byte[] Source, int SourceOffset, int Width, int Height)
		{
			if (Width > 0)
			{
				int i = 0;
				int destOffest = Height * Width * 4;
				do
				{
					Dest[destOffest + i * 4 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];
					Dest[destOffest + i * 4 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];
					Dest[destOffest + i * 4 + RGB_RED] = Source[SourceOffset + RGB_RED];
					Dest[destOffest + i * 4 + 3] = 255;
					SourceOffset += 3;
				} while (++i < Width);
			}
		}

		private static unsafe void Do32To32Bit(byte[] Dest, byte[] Source, int SourceOffset, int Width, int Height)
		{
			if (Width > 0)
			{
				int i = 0;
				int destOffest = Height * Width * 4;
				do
				{
					Dest[destOffest + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];
					Dest[destOffest + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];
					Dest[destOffest + RGB_RED] = Source[SourceOffset + RGB_RED];
					Dest[destOffest + RGBA_ALPHA] = Source[SourceOffset + RGBA_ALPHA];
					SourceOffset += 4;
					destOffest += 4;
				} while (++i < Width);
			}
		}

		private static bool ReadTGAInfo(byte[] WorkPtr, out STargaHeader TargaHeader)
		{
			TargaHeader.PostHeaderSkip = WorkPtr[0];
			TargaHeader.ColorMapType = WorkPtr[1];
			TargaHeader.ImageType = WorkPtr[2];
			TargaHeader.ColorMapStart = BitConverter.ToUInt16(WorkPtr, 3);
			TargaHeader.ColorMapLength = BitConverter.ToUInt16(WorkPtr, 5);
			TargaHeader.ColorMapBits = WorkPtr[7];
			TargaHeader.XStart = BitConverter.ToUInt16(WorkPtr, 8);
			TargaHeader.YStart = BitConverter.ToUInt16(WorkPtr, 10);
			TargaHeader.Width = BitConverter.ToUInt16(WorkPtr, 12);
			TargaHeader.Height = BitConverter.ToUInt16(WorkPtr, 14);
			TargaHeader.BPP = WorkPtr[16];
			TargaHeader.Descriptor = WorkPtr[17];

			// check the header
			if (TargaHeader.ColorMapType != 0 ||	// 0 = RGB, 1 = Palette
				// 1 = Palette, 2 = RGB, 3 = mono, 9 = RLE Palette, 10 = RLE RGB, 11 RLE mono
				(TargaHeader.ImageType != 2 && TargaHeader.ImageType != 10 && TargaHeader.ImageType != 9) ||
				(TargaHeader.BPP != 24 && TargaHeader.BPP != 32))
			{
#if DEBUG
				throw new NotImplementedException("Unsupported TGA mode");
#endif
#if ASSERTS_ENABLED
		        if ( ((byte*)pTargaHeader)[0] == 'B' && ((byte*)pTargaHeader)[1] == 'M' )
		        {
			        assert(!"This TGA's header looks like a BMP!"); //  look at the first two bytes and see if they are 'BM'
			        // if so it's a BMP not a TGA
		        }
		        else
		        {
			        byte * pColorMapType = NULL;
			        switch (TargaHeader.ColorMapType)
			        {
				        case 0:
					        pColorMapType = "RGB Color Map";
					        break;

				        case 1:
					        pColorMapType = "Palette Color Map";
					        break;

				        default:
					        pColorMapType = "<Illegal Color Map>";
					        break;
			        }
			        byte * pImageType = NULL;
			        switch (TargaHeader.ImageType)
			        {
				        case 1:
					        pImageType = "Palette Image Type";
					        break;

				        case 2:
					        pImageType = "RGB Image Type";
					        break;

				        case 3:
					        pImageType = "mono Image Type";
					        break;

				        case 9:
					        pImageType = "RLE Palette Image Type";
					        break;

				        case 10:
					        pImageType = "RLE RGB Image Type";
					        break;

				        case 11:
					        pImageType = "RLE mono Image Type";
					        break;

				        default:
					        pImageType = "<Illegal Image Type>";
					        break;
			        }
			        int ColorDepth = TargaHeader.BPP;
			        CJString ErrorString;
			        ErrorString.Format( "Image type %s %s (%u bpp) not supported!", pColorMapType, pImageType, ColorDepth);
			        ShowSystemMessage("TGA File IO Error", ErrorString.GetBytePtr(), "TGA Error");
		        }
#endif // ASSERTS_ENABLED
				return false;
			}

			return true;
		}

		private const int IS_PIXLE_RUN = 0x80;
		private const int RUN_LENGTH_MASK = 0x7f;

		private static unsafe int Decompress(byte[] pDecompressBits, byte[] pBitsToPars, int ParsOffset, int Width, int Depth, int LineBeingRead)
		{
			int decompressOffset = 0;
			int total = 0;
			do
			{
				int i;
				int numPixels = (pBitsToPars[ParsOffset] & RUN_LENGTH_MASK) + 1;
				total += numPixels;
				if ((pBitsToPars[ParsOffset++] & IS_PIXLE_RUN) != 0)
				{
					// decompress the run for NumPixels
					byte r, g, b, a;
					b = pBitsToPars[ParsOffset++];
					g = pBitsToPars[ParsOffset++];
					r = pBitsToPars[ParsOffset++];
					switch (Depth)
					{
						case 24:
							for (i = 0; i < numPixels; i++)
							{
								pDecompressBits[decompressOffset++] = b;
								pDecompressBits[decompressOffset++] = g;
								pDecompressBits[decompressOffset++] = r;
							}
							break;

						case 32:
							a = pBitsToPars[ParsOffset++];
							for (i = 0; i < numPixels; i++)
							{
								pDecompressBits[decompressOffset++] = b;
								pDecompressBits[decompressOffset++] = g;
								pDecompressBits[decompressOffset++] = r;
								pDecompressBits[decompressOffset++] = a;
							}
							break;

						default:
							throw new System.Exception("Bad bit depth.");
					}
				}
				else // store NumPixels normally
				{
					switch (Depth)
					{
						case 24:
							for (i = 0; i < numPixels * 3; i++)
							{
								pDecompressBits[decompressOffset++] = pBitsToPars[ParsOffset++];
							}
							break;

						case 32:
							for (i = 0; i < numPixels * 4; i++)
							{
								pDecompressBits[decompressOffset++] = pBitsToPars[ParsOffset++];
							}
							break;

						default:
							throw new System.Exception("Bad bit depth.");
					}
				}
			} while (total < Width);

			if (total > Width)
			{
				throw new System.Exception("The TGA you loaded is corrupt (line " + LineBeingRead.ToString() + ").");
			}

			return ParsOffset;
		}

		private static unsafe int LowLevelReadTGABitsFromBuffer(ImageBuffer imageToReadTo, byte[] wholeFileBuffer, int DestBitDepth)
		{
			STargaHeader targaHeader = new STargaHeader();
			int fileReadOffset;

			if (!ReadTGAInfo(wholeFileBuffer, out targaHeader))
			{
				return 0;
			}

			// if the frame we are loading is different then the one we have allocated
			// or we don't have any bits allocated

			if ((imageToReadTo.Width * imageToReadTo.Height) != (targaHeader.Width * targaHeader.Height))
			{
				imageToReadTo.Allocate(targaHeader.Width, targaHeader.Height, targaHeader.Width * DestBitDepth / 8, DestBitDepth);
			}

			// work out the line width
			switch (imageToReadTo.BitDepth)
			{
				case 24:
					TGABytesPerLine = imageToReadTo.Width * 3;
					if (imageToReadTo.GetRecieveBlender() == null)
					{
						imageToReadTo.SetRecieveBlender(new BlenderBGR());
					}
					break;

				case 32:
					TGABytesPerLine = imageToReadTo.Width * 4;
					if (imageToReadTo.GetRecieveBlender() == null)
					{
						imageToReadTo.SetRecieveBlender(new BlenderBGRA());
					}
					break;

				default:
					throw new System.Exception("Bad bit depth.");
			}

			if (TGABytesPerLine > 0)
			{
				byte[] bufferToDecompressTo = null;
				fileReadOffset = TargaHeaderSize + targaHeader.PostHeaderSkip;

				if (targaHeader.ImageType == 10) // 10 is RLE compressed
				{
					bufferToDecompressTo = new byte[TGABytesPerLine * 2];
				}

				// read all the lines *
				for (int i = 0; i < imageToReadTo.Height; i++)
				{
					byte[] bufferToCopyFrom;
					int copyOffset = 0;

					int curReadLine;

					// bit 5 tells us if the image is stored top to bottom or bottom to top
					if ((targaHeader.Descriptor & 0x20) != 0)
					{
						// bottom to top
						curReadLine = imageToReadTo.Height - i - 1;
					}
					else
					{
						// top to bottom
						curReadLine = i;
					}

					if (targaHeader.ImageType == 10) // 10 is RLE compressed
					{
						fileReadOffset = Decompress(bufferToDecompressTo, wholeFileBuffer, fileReadOffset, imageToReadTo.Width, targaHeader.BPP, curReadLine);
						bufferToCopyFrom = bufferToDecompressTo;
					}
					else
					{
						bufferToCopyFrom = wholeFileBuffer;
						copyOffset = fileReadOffset;
					}

					int bufferOffset;
					byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);

					switch (imageToReadTo.BitDepth)
					{
						case 8:
							switch (targaHeader.BPP)
							{
								case 24:
									Do24To8Bit(imageBuffer, bufferToCopyFrom, copyOffset, imageToReadTo.Width, curReadLine);
									break;

								case 32:
									Do32To8Bit(imageBuffer, bufferToCopyFrom, copyOffset, imageToReadTo.Width, curReadLine);
									break;
							}
							break;

						case 24:
							switch (targaHeader.BPP)
							{
								case 24:
									Do24To24Bit(imageBuffer, bufferToCopyFrom, copyOffset, imageToReadTo.Width, curReadLine);
									break;

								case 32:
									Do32To24Bit(imageBuffer, bufferToCopyFrom, copyOffset, imageToReadTo.Width, curReadLine);
									break;
							}
							break;

						case 32:
							switch (targaHeader.BPP)
							{
								case 24:
									Do24To32Bit(imageBuffer, bufferToCopyFrom, copyOffset, imageToReadTo.Width, curReadLine);
									break;

								case 32:
									Do32To32Bit(imageBuffer, bufferToCopyFrom, copyOffset, imageToReadTo.Width, curReadLine);
									break;
							}
							break;

						default:
							throw new System.Exception("Bad bit depth");
					}

					if (targaHeader.ImageType != 10) // 10 is RLE compressed
					{
						fileReadOffset += TGABytesPerLine;
					}
				}
			}

			return targaHeader.Width;
		}

		private const int MAX_RUN_LENGTH = 127;

		private static int memcmp(byte[] pCheck, int CheckOffset, byte[] pSource, int SourceOffset, int Width)
		{
			for (int i = 0; i < Width; i++)
			{
				if (pCheck[CheckOffset + i] < pSource[SourceOffset + i])
				{
					return -1;
				}
				if (pCheck[CheckOffset + i] > pSource[SourceOffset + i])
				{
					return 1;
				}
			}

			return 0;
		}

		private static int GetSameLength(byte[] checkBufer, int checkOffset, byte[] sourceBuffer, int sourceOffsetToNextPixel, int numBytesInPixel, int maxSameLengthWidth)
		{
			int count = 0;
			while (memcmp(checkBufer, checkOffset, sourceBuffer, sourceOffsetToNextPixel, numBytesInPixel) == 0 && count < maxSameLengthWidth)
			{
				count++;
				sourceOffsetToNextPixel += numBytesInPixel;
			}

			return count;
		}

		private static int GetDifLength(byte[] pCheck, byte[] pSource, int SourceOffset, int numBytesInPixel, int Max)
		{
			int count = 0;
			while (memcmp(pCheck, 0, pSource, SourceOffset, numBytesInPixel) != 0 && count < Max)
			{
				count++;
				for (int i = 0; i < numBytesInPixel; i++)
				{
					pCheck[i] = pSource[SourceOffset + i];
				}
				SourceOffset += numBytesInPixel;
			}

			return count;
		}

		private const int MIN_RUN_LENGTH = 2;

		private static int CompressLine8(byte[] destBuffer, byte[] sourceBuffer, int sourceOffset, int Width)
		{
			int writePos = 0;
			int pixelsProcessed = 0;

			while (pixelsProcessed < Width)
			{
				// always get as many as you can that are the same first
				int max = System.Math.Min(MAX_RUN_LENGTH, (Width - 1) - pixelsProcessed);
				int sameLength = GetSameLength(sourceBuffer, sourceOffset, sourceBuffer, sourceOffset + 1, 1, max);
				if (sameLength >= MIN_RUN_LENGTH)
				//if(SameLength)
				{
					// write in the count
					if (sameLength > MAX_RUN_LENGTH)
					{
						throw new System.Exception("Bad Length");
					}
					destBuffer[writePos++] = (byte)((sameLength) | IS_PIXLE_RUN);

					// write in the same length pixel value
					destBuffer[writePos++] = sourceBuffer[sourceOffset];

					pixelsProcessed += sameLength + 1;
				}
				else
				{
					byte checkPixel = sourceBuffer[sourceOffset];
					int difLength = max;

					if (difLength == 0)
					{
						difLength = 1;
					}
					// write in the count (if there is only one the count is 0)
					if (difLength > MAX_RUN_LENGTH)
					{
						throw new System.Exception("Bad Length");
					}

					destBuffer[writePos++] = (byte)(difLength - 1);

					while (difLength-- != 0)
					{
						// write in the same length pixel value
						destBuffer[writePos++] = sourceBuffer[sourceOffset++];
						pixelsProcessed++;
					}
				}
			}

			return writePos;
		}

		private static byte[] differenceHold = new byte[4];

		private static int CompressLine24(byte[] destBuffer, byte[] sourceBuffer, int sourceOffset, int Width)
		{
			int writePos = 0;
			int pixelsProcessed = 0;

			while (pixelsProcessed < Width)
			{
				// always get as many as you can that are the same first
				int max = System.Math.Min(MAX_RUN_LENGTH, (Width - 1) - pixelsProcessed);
				int sameLength = GetSameLength(sourceBuffer, sourceOffset, sourceBuffer, sourceOffset + 3, 3, max);
				if (sameLength > 0)
				{
					// write in the count
					if (sameLength > MAX_RUN_LENGTH)
					{
						throw new Exception();
					}

					destBuffer[writePos++] = (byte)((sameLength) | IS_PIXLE_RUN);

					// write in the same length pixel value
					destBuffer[writePos++] = sourceBuffer[sourceOffset + 0];
					destBuffer[writePos++] = sourceBuffer[sourceOffset + 1];
					destBuffer[writePos++] = sourceBuffer[sourceOffset + 2];

					sourceOffset += (sameLength) * 3;
					pixelsProcessed += sameLength + 1;
				}
				else
				{
					differenceHold[0] = sourceBuffer[sourceOffset + 0];
					differenceHold[1] = sourceBuffer[sourceOffset + 1];
					differenceHold[2] = sourceBuffer[sourceOffset + 2];
					int difLength = GetDifLength(differenceHold, sourceBuffer, sourceOffset + 3, 3, max);
					if (difLength == 0)
					{
						difLength = 1;
					}

					// write in the count (if there is only one the count is 0)
					if (sameLength > MAX_RUN_LENGTH)
					{
						throw new Exception();
					}
					destBuffer[writePos++] = (byte)(difLength - 1);

					while (difLength-- > 0)
					{
						// write in the same length pixel value
						destBuffer[writePos++] = sourceBuffer[sourceOffset + 0];
						destBuffer[writePos++] = sourceBuffer[sourceOffset + 1];
						destBuffer[writePos++] = sourceBuffer[sourceOffset + 2];

						sourceOffset += 3;
						pixelsProcessed++;
					}
				}
			}

			return writePos;
		}

		private static int CompressLine32(byte[] destBuffer, byte[] sourceBuffer, int sourceOffset, int Width)
		{
			int writePos = 0;
			int pixelsProcessed = 0;

			while (pixelsProcessed < Width)
			{
				// always get as many as you can that are the same first
				int max = System.Math.Min(MAX_RUN_LENGTH, (Width - 1) - pixelsProcessed);
				int sameLength = GetSameLength(sourceBuffer, sourceOffset, sourceBuffer, sourceOffset + 4, 4, max);
				if (sameLength > 0)
				{
					// write in the count
					if (sameLength > MAX_RUN_LENGTH)
					{
						throw new Exception();
					}

					destBuffer[writePos++] = (byte)((sameLength) | IS_PIXLE_RUN);

					// write in the same length pixel value
					destBuffer[writePos++] = sourceBuffer[sourceOffset + 0];
					destBuffer[writePos++] = sourceBuffer[sourceOffset + 1];
					destBuffer[writePos++] = sourceBuffer[sourceOffset + 2];
					destBuffer[writePos++] = sourceBuffer[sourceOffset + 3];

					sourceOffset += (sameLength) * 4;
					pixelsProcessed += sameLength + 1;
				}
				else
				{
					differenceHold[0] = sourceBuffer[sourceOffset + 0];
					differenceHold[1] = sourceBuffer[sourceOffset + 1];
					differenceHold[2] = sourceBuffer[sourceOffset + 2];
					differenceHold[3] = sourceBuffer[sourceOffset + 3];
					int difLength = GetDifLength(differenceHold, sourceBuffer, sourceOffset + 4, 4, max);
					if (difLength == 0)
					{
						difLength = 1;
					}

					// write in the count (if there is only one the count is 0)
					if (sameLength > MAX_RUN_LENGTH)
					{
						throw new Exception();
					}
					destBuffer[writePos++] = (byte)(difLength - 1);

					while (difLength-- > 0)
					{
						// write in the dif length pixel value
						destBuffer[writePos++] = sourceBuffer[sourceOffset + 0];
						destBuffer[writePos++] = sourceBuffer[sourceOffset + 1];
						destBuffer[writePos++] = sourceBuffer[sourceOffset + 2];
						destBuffer[writePos++] = sourceBuffer[sourceOffset + 3];

						sourceOffset += 4;
						pixelsProcessed++;
					}
				}
			}

			return writePos;
			/*
			while(SourcePos < Width)
			{
				// always get as many as you can that are the same first
				int Max = System.Math.Min(MAX_RUN_LENGTH, (Width - 1) - SourcePos);
				int SameLength = GetSameLength((byte*)&pSource[SourcePos], (byte*)&pSource[SourcePos + 1], 4, Max);
				if(SameLength)
				{
					// write in the count
					assert(SameLength<= MAX_RUN_LENGTH);
					pDest[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);

					// write in the same length pixel value
					pDest[WritePos++] = pSource[SourcePos].Blue;
					pDest[WritePos++] = pSource[SourcePos].Green;
					pDest[WritePos++] = pSource[SourcePos].Red;
					pDest[WritePos++] = pSource[SourcePos].Alpha;

					SourcePos += SameLength + 1;
				}
				else
				{
					Pixel32 CheckPixel = pSource[SourcePos];
					int DifLength = GetDifLength((byte*)&CheckPixel, (byte*)&pSource[SourcePos+1], 4, Max);
					if(!DifLength)
					{
						DifLength = 1;
					}

					// write in the count (if there is only one the count is 0)
					assert(DifLength <= MAX_RUN_LENGTH);
					pDest[WritePos++] = (byte)(DifLength-1);

					while(DifLength--)
					{
						// write in the same length pixel value
						pDest[WritePos++] = pSource[SourcePos].Blue;
						pDest[WritePos++] = pSource[SourcePos].Green;
						pDest[WritePos++] = pSource[SourcePos].Red;
						pDest[WritePos++] = pSource[SourcePos].Alpha;
						SourcePos++;
					}
				}
			}

			return WritePos;
			 */
		}

		static public bool SaveImageData(String fileNameToSaveTo, ImageBuffer image)
		{
			return Save(image, fileNameToSaveTo);
		}

		static public bool Save(ImageBuffer image, String fileNameToSaveTo)
		{
			using (Stream file = File.Open(fileNameToSaveTo, FileMode.Create))
			{
				return Save(image, file);
			}
		}

		static public bool Save(ImageBuffer image, Stream streamToSaveImageDataTo)
		{
			STargaHeader targaHeader;

			using (BinaryWriter writerToSaveTo = new BinaryWriter(streamToSaveImageDataTo, new ASCIIEncoding(), true))
			{
				int sourceDepth = image.BitDepth;

				// make sure there is something to save before opening the file
				if (image.Width <= 0 || image.Height <= 0)
				{
					return false;
				}

				// set up the header
				targaHeader.PostHeaderSkip = 0; // no skip after the header
				if (sourceDepth == 8)
				{
					targaHeader.ColorMapType = 1;       // Color type is Palette
					targaHeader.ImageType = 9;      // 1 = Palette, 9 = RLE Palette
					targaHeader.ColorMapStart = 0;
					targaHeader.ColorMapLength = 256;
					targaHeader.ColorMapBits = 24;
				}
				else
				{
					targaHeader.ColorMapType = 0;       // Color type is RGB
#if WRITE_RLE_COMPRESSED
		        TargaHeader.ImageType = 10;		// RLE RGB
#else
					targaHeader.ImageType = 2;      // RGB
#endif
					targaHeader.ColorMapStart = 0;
					targaHeader.ColorMapLength = 0;
					targaHeader.ColorMapBits = 0;
				}

				targaHeader.XStart = 0;
				targaHeader.YStart = 0;
				targaHeader.Width = (ushort)image.Width;
				targaHeader.Height = (ushort)image.Height;
				targaHeader.BPP = (byte)sourceDepth;
				targaHeader.Descriptor = 0; // all 8 bits are used for alpha

				targaHeader.BinaryWrite(writerToSaveTo);

				byte[] pLineBuffer = new byte[image.StrideInBytesAbs() * 2];

				// int BytesToSave;
				switch (sourceDepth)
				{
					case 8:
						/*
					if (image.HasPalette())
					{
						for(int i=0; i<256; i++)
						{
							TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_BLUE]);
							TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_GREEN]);
							TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_RED]);
						}
					}
					else
						 */
						{
							// there is no palette for this DIB but we should write something
							for (int i = 0; i < 256; i++)
							{
								writerToSaveTo.Write((byte)i);
								writerToSaveTo.Write((byte)i);
								writerToSaveTo.Write((byte)i);
							}
						}

						for (int i = 0; i < image.Height; i++)
						{
							int bufferOffset;
							byte[] buffer = image.GetPixelPointerY(i, out bufferOffset);
#if WRITE_RLE_COMPRESSED
                    BytesToSave = CompressLine8(pLineBuffer, buffer, bufferOffset, image.Width());
			        writerToSaveTo.Write(pLineBuffer, 0, BytesToSave);
#else
							writerToSaveTo.Write(buffer, bufferOffset, image.Width);
#endif
						}

						break;

					case 24:
						for (int i = 0; i < image.Height; i++)
						{
							int bufferOffset;
							byte[] buffer = image.GetPixelPointerY(i, out bufferOffset);
#if WRITE_RLE_COMPRESSED
                    BytesToSave = CompressLine24(pLineBuffer, buffer, bufferOffset, image.Width());
                    writerToSaveTo.Write(pLineBuffer, 0, BytesToSave);
#else
							writerToSaveTo.Write(buffer, bufferOffset, image.Width * 3);
#endif
						}

						break;

					case 32:
						for (int i = 0; i < image.Height; i++)
						{
							int bufferOffset;
							byte[] buffer = image.GetPixelPointerY(i, out bufferOffset);
#if WRITE_RLE_COMPRESSED
                    BytesToSave = CompressLine32(pLineBuffer, buffer, bufferOffset, image.Width);
                    writerToSaveTo.Write(pLineBuffer, 0, BytesToSave);
#else
							writerToSaveTo.Write(buffer, bufferOffset, image.Width * 4);
#endif
						}

						break;

					default:
						throw new NotSupportedException();
				}

				writerToSaveTo.Flush();
			}

			return true;
		}

		/*
		bool SourceNeedsToBeResaved(String pFileName)
		{
			CFile TGAFile;
			if(TGAFile.Open(pFileName, CFile::modeRead))
			{
				STargaHeader TargaHeader;
				byte[] pWorkPtr = new byte[sizeof(STargaHeader)];

				TGAFile.Read(pWorkPtr, sizeof(STargaHeader));
				TGAFile.Close();

				if(ReadTGAInfo(pWorkPtr, &TargaHeader))
				{
					ArrayDeleteAndSetNull(pWorkPtr);
					return TargaHeader.ImageType != 10;
				}

				ArrayDeleteAndSetNull(pWorkPtr);
			}

			return true;
		}
		 */

		static public int ReadBitsFromBuffer(ImageBuffer image, byte[] WorkPtr, int destBitDepth)
		{
			return LowLevelReadTGABitsFromBuffer(image, WorkPtr, destBitDepth);
		}

		static public bool LoadImageData(ImageBuffer image, string fileName)
		{
			if (System.IO.File.Exists(fileName))
			{
				using (var stream = File.OpenRead(fileName))
				{
					return LoadImageData(image, stream, 32);
				}
			}

			return false;
		}

		static public bool LoadImageData(ImageBuffer image, Stream streamToLoadImageDataFrom, int destBitDepth)
		{
			byte[] imageData = new byte[streamToLoadImageDataFrom.Length];
			streamToLoadImageDataFrom.Read(imageData, 0, (int)streamToLoadImageDataFrom.Length);
			return ReadBitsFromBuffer(image, imageData, destBitDepth) > 0;
		}

		static public int GetBitDepth(Stream streamToReadFrom)
		{
			STargaHeader targaHeader;
			byte[] imageData = new byte[streamToReadFrom.Length];
			streamToReadFrom.Read(imageData, 0, (int)streamToReadFrom.Length);
			if (ReadTGAInfo(imageData, out targaHeader))
			{
				return targaHeader.BPP;
			}

			return 0;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\RecursiveBlur.cs
// <auto-generated>
// Hack to disable analyzers and their warnings - too many issues to address
// </auto-generated>
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// The Stack Blur Algorithm was invented by Mario Klingemann,
// mario@quasimondo.com and described here:
// http://incubator.quasimondo.com/processing/fast_blur_deluxe.php
// (search phrase "Stackblur: Fast But Good looking").
// The major improvement is that there's no more division table
// that was very expensive to create for large blur radii. Instead,
// for 8-bit per channel and radius not exceeding 254 the division is
// replaced by multiplication and shift.
//
//----------------------------------------------------------------------------
using System;
using System.Collections.Generic;

namespace MatterHackers.Agg.Image
{
#if true

	public struct RGBA_Ints
	{
		public int r;
		public int g;
		public int b;
		public int a;
	};

	internal struct stack_blur_tables
	{
		public static ushort[] g_stack_blur8_mul =
        {
            512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
            454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
            482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
            437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
            497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
            320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
            446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
            329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
            505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
            399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
            324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
            268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
            451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
            385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
            332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
            289,287,285,282,280,278,275,273,271,269,267,265,263,261,259
        };

		public static byte[] g_stack_blur8_shr =
        {
              9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
             17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
             19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
             20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
             21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
             21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
             22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
             22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
             23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
             23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
             23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
             23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
             24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
             24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
             24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
             24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24
        };
	};

	//==============================================================stack_blur
	public class stack_blur
	{
		//private VectorPOD<RGBA_Ints> m_buff;
		//private VectorPOD<int> m_stack;
		//int base_mask = 255;

		private enum order_e
		{
			R = 2,
			G = 1,
			B = 0,
			A = 3
		};

		public void blur_x(IImageByte img, int radius)
		{
			throw new NotImplementedException();
#if false
            if(radius < 1) return;

            int x, y, xp, i;
            int stack_ptr;
            int stack_start;

            color_type      pix;
            color_type*     stack_pix;
            calculator_type sum;
            calculator_type sum_in;
            calculator_type sum_out;

            int w   = img.width();
            int h   = img.height();
            int wm  = w - 1;
            int div = radius * 2 + 1;

            int div_sum = (radius + 1) * (radius + 1);
            int mul_sum = 0;
            int shr_sum = 0;
            int max_val = base_mask;

            if(max_val <= 255 && radius < 255)
            {
                mul_sum = stack_blur_tables.g_stack_blur8_mul[radius];
                shr_sum = stack_blur_tables.g_stack_blur8_shr[radius];
            }

            m_buf.allocate(w, 128);
            m_stack.allocate(div, 32);

            for(y = 0; y < h; y++)
            {
                sum.clear();
                sum_in.clear();
                sum_out.clear();

                pix = img.pixel(0, y);
                for(i = 0; i <= radius; i++)
                {
                    m_stack[i] = pix;
                    sum.add(pix, i + 1);
                    sum_out.add(pix);
                }
                for(i = 1; i <= radius; i++)
                {
                    pix = img.pixel((i > wm) ? wm : i, y);
                    m_stack[i + radius] = pix;
                    sum.add(pix, radius + 1 - i);
                    sum_in.add(pix);
                }

                stack_ptr = radius;
                for(x = 0; x < w; x++)
                {
                    if(mul_sum) sum.calc_pix(m_buf[x], mul_sum, shr_sum);
                    else        sum.calc_pix(m_buf[x], div_sum);

                    sum.sub(sum_out);

                    stack_start = stack_ptr + div - radius;
                    if(stack_start >= div) stack_start -= div;
                    stack_pix = &m_stack[stack_start];

                    sum_out.sub(*stack_pix);

                    xp = x + radius + 1;
                    if(xp > wm) xp = wm;
                    pix = img.pixel(xp, y);

                    *stack_pix = pix;

                    sum_in.add(pix);
                    sum.add(sum_in);

                    ++stack_ptr;
                    if(stack_ptr >= div) stack_ptr = 0;
                    stack_pix = &m_stack[stack_ptr];

                    sum_out.add(*stack_pix);
                    sum_in.sub(*stack_pix);
                }
                img.copy_color_hspan(0, y, w, &m_buf[0]);
            }
#endif
		}

		public void blur_y(IImageByte img, int radius)
		{
			FormatTransposer img2 = new FormatTransposer(img);
			blur_x(img2, radius);
		}

		public void blur(ImageBuffer img, int radius)
		{
			blur_x(img, radius);
			FormatTransposer img2 = new FormatTransposer(img);
			blur_x(img2, radius);
		}

		private void stack_blur_gray8(ImageBuffer img, int rx, int ry)
		{
			throw new NotImplementedException();
#if false
            int x, y, xp, yp, i;
            int stack_ptr;
            int stack_start;

            byte* src_pix_ptr;
                  byte* dst_pix_ptr;
            int pix;
            int stack_pix;
            int sum;
            int sum_in;
            int sum_out;

            int w   = img.width();
            int h   = img.height();
            int wm  = w - 1;
            int hm  = h - 1;

            int div;
            int mul_sum;
            int shr_sum;

            pod_vector<byte> stack;

            if(rx > 0)
            {
                if(rx > 254) rx = 254;
                div = rx * 2 + 1;
                mul_sum = stack_blur_tables.g_stack_blur8_mul[rx];
                shr_sum = stack_blur_tables.g_stack_blur8_shr[rx];
                stack.allocate(div);

                for(y = 0; y < h; y++)
                {
                    sum = sum_in = sum_out = 0;

                    src_pix_ptr = img.pix_ptr(0, y);
                    pix = *src_pix_ptr;
                    for(i = 0; i <= rx; i++)
                    {
                        stack[i] = pix;
                        sum     += pix * (i + 1);
                        sum_out += pix;
                    }
                    for(i = 1; i <= rx; i++)
                    {
                        if(i <= wm) src_pix_ptr += Img::pix_step;
                        pix = *src_pix_ptr;
                        stack[i + rx] = pix;
                        sum    += pix * (rx + 1 - i);
                        sum_in += pix;
                    }

                    stack_ptr = rx;
                    xp = rx;
                    if(xp > wm) xp = wm;
                    src_pix_ptr = img.pix_ptr(xp, y);
                    dst_pix_ptr = img.pix_ptr(0, y);
                    for(x = 0; x < w; x++)
                    {
                        *dst_pix_ptr = (sum * mul_sum) >> shr_sum;
                        dst_pix_ptr += Img::pix_step;

                        sum -= sum_out;

                        stack_start = stack_ptr + div - rx;
                        if(stack_start >= div) stack_start -= div;
                        sum_out -= stack[stack_start];

                        if(xp < wm)
                        {
                            src_pix_ptr += Img::pix_step;
                            pix = *src_pix_ptr;
                            ++xp;
                        }

                        stack[stack_start] = pix;

                        sum_in += pix;
                        sum    += sum_in;

                        ++stack_ptr;
                        if(stack_ptr >= div) stack_ptr = 0;
                        stack_pix = stack[stack_ptr];

                        sum_out += stack_pix;
                        sum_in  -= stack_pix;
                    }
                }
            }

            if(ry > 0)
            {
                if(ry > 254) ry = 254;
                div = ry * 2 + 1;
                mul_sum = stack_blur_tables.g_stack_blur8_mul[ry];
                shr_sum = stack_blur_tables.g_stack_blur8_shr[ry];
                stack.allocate(div);

                int stride = img.stride();
                for(x = 0; x < w; x++)
                {
                    sum = sum_in = sum_out = 0;

                    src_pix_ptr = img.pix_ptr(x, 0);
                    pix = *src_pix_ptr;
                    for(i = 0; i <= ry; i++)
                    {
                        stack[i] = pix;
                        sum     += pix * (i + 1);
                        sum_out += pix;
                    }
                    for(i = 1; i <= ry; i++)
                    {
                        if(i <= hm) src_pix_ptr += stride;
                        pix = *src_pix_ptr;
                        stack[i + ry] = pix;
                        sum    += pix * (ry + 1 - i);
                        sum_in += pix;
                    }

                    stack_ptr = ry;
                    yp = ry;
                    if(yp > hm) yp = hm;
                    src_pix_ptr = img.pix_ptr(x, yp);
                    dst_pix_ptr = img.pix_ptr(x, 0);
                    for(y = 0; y < h; y++)
                    {
                        *dst_pix_ptr = (sum * mul_sum) >> shr_sum;
                        dst_pix_ptr += stride;

                        sum -= sum_out;

                        stack_start = stack_ptr + div - ry;
                        if(stack_start >= div) stack_start -= div;
                        sum_out -= stack[stack_start];

                        if(yp < hm)
                        {
                            src_pix_ptr += stride;
                            pix = *src_pix_ptr;
                            ++yp;
                        }

                        stack[stack_start] = pix;

                        sum_in += pix;
                        sum    += sum_in;

                        ++stack_ptr;
                        if(stack_ptr >= div) stack_ptr = 0;
                        stack_pix = stack[stack_ptr];

                        sum_out += stack_pix;
                        sum_in  -= stack_pix;
                    }
                }
            }
#endif
		}

		public void Blur(ImageBuffer img, int rx, int ry)
		{
			switch (img.BitDepth)
			{
				case 24:
					stack_blur_bgr24(img, rx, ry);
					break;

				case 32:
					stack_blur_bgra32(img, rx, ry);
					break;

				default:
					throw new NotImplementedException();
			}
		}

		private void stack_blur_bgr24(ImageBuffer img, int rx, int ry)
		{
			throw new NotImplementedException();
#if false
            //typedef typename Img::color_type color_type;
            //typedef typename Img::order_type order_type;

            int x, y, xp, yp, i;
            int stack_ptr;
            int stack_start;

            byte* src_pix_ptr;
                  byte* dst_pix_ptr;
            color_type*  stack_pix_ptr;

            int sum_r;
            int sum_g;
            int sum_b;
            int sum_in_r;
            int sum_in_g;
            int sum_in_b;
            int sum_out_r;
            int sum_out_g;
            int sum_out_b;

            int w   = img.width();
            int h   = img.height();
            int wm  = w - 1;
            int hm  = h - 1;

            int div;
            int mul_sum;
            int shr_sum;

            pod_vector<color_type> stack;

            if(rx > 0)
            {
                if(rx > 254) rx = 254;
                div = rx * 2 + 1;
                mul_sum = stack_blur_tables.g_stack_blur8_mul[rx];
                shr_sum = stack_blur_tables.g_stack_blur8_shr[rx];
                stack.allocate(div);

                for(y = 0; y < h; y++)
                {
                    sum_r =
                    sum_g =
                    sum_b =
                    sum_in_r =
                    sum_in_g =
                    sum_in_b =
                    sum_out_r =
                    sum_out_g =
                    sum_out_b = 0;

                    src_pix_ptr = img.pix_ptr(0, y);
                    for(i = 0; i <= rx; i++)
                    {
                        stack_pix_ptr    = &stack[i];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        sum_r           += src_pix_ptr[R] * (i + 1);
                        sum_g           += src_pix_ptr[G] * (i + 1);
                        sum_b           += src_pix_ptr[B] * (i + 1);
                        sum_out_r       += src_pix_ptr[R];
                        sum_out_g       += src_pix_ptr[G];
                        sum_out_b       += src_pix_ptr[B];
                    }
                    for(i = 1; i <= rx; i++)
                    {
                        if(i <= wm) src_pix_ptr += Img::pix_width;
                        stack_pix_ptr = &stack[i + rx];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        sum_r           += src_pix_ptr[R] * (rx + 1 - i);
                        sum_g           += src_pix_ptr[G] * (rx + 1 - i);
                        sum_b           += src_pix_ptr[B] * (rx + 1 - i);
                        sum_in_r        += src_pix_ptr[R];
                        sum_in_g        += src_pix_ptr[G];
                        sum_in_b        += src_pix_ptr[B];
                    }

                    stack_ptr = rx;
                    xp = rx;
                    if(xp > wm) xp = wm;
                    src_pix_ptr = img.pix_ptr(xp, y);
                    dst_pix_ptr = img.pix_ptr(0, y);
                    for(x = 0; x < w; x++)
                    {
                        dst_pix_ptr[R] = (sum_r * mul_sum) >> shr_sum;
                        dst_pix_ptr[G] = (sum_g * mul_sum) >> shr_sum;
                        dst_pix_ptr[B] = (sum_b * mul_sum) >> shr_sum;
                        dst_pix_ptr   += Img::pix_width;

                        sum_r -= sum_out_r;
                        sum_g -= sum_out_g;
                        sum_b -= sum_out_b;

                        stack_start = stack_ptr + div - rx;
                        if(stack_start >= div) stack_start -= div;
                        stack_pix_ptr = &stack[stack_start];

                        sum_out_r -= stack_pix_ptr->r;
                        sum_out_g -= stack_pix_ptr->g;
                        sum_out_b -= stack_pix_ptr->b;

                        if(xp < wm)
                        {
                            src_pix_ptr += Img::pix_width;
                            ++xp;
                        }

                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];

                        sum_in_r += src_pix_ptr[R];
                        sum_in_g += src_pix_ptr[G];
                        sum_in_b += src_pix_ptr[B];
                        sum_r    += sum_in_r;
                        sum_g    += sum_in_g;
                        sum_b    += sum_in_b;

                        ++stack_ptr;
                        if(stack_ptr >= div) stack_ptr = 0;
                        stack_pix_ptr = &stack[stack_ptr];

                        sum_out_r += stack_pix_ptr->r;
                        sum_out_g += stack_pix_ptr->g;
                        sum_out_b += stack_pix_ptr->b;
                        sum_in_r  -= stack_pix_ptr->r;
                        sum_in_g  -= stack_pix_ptr->g;
                        sum_in_b  -= stack_pix_ptr->b;
                    }
                }
            }

            if(ry > 0)
            {
                if(ry > 254) ry = 254;
                div = ry * 2 + 1;
                mul_sum = stack_blur_tables.g_stack_blur8_mul[ry];
                shr_sum = stack_blur_tables.g_stack_blur8_shr[ry];
                stack.allocate(div);

                int stride = img.stride();
                for(x = 0; x < w; x++)
                {
                    sum_r =
                    sum_g =
                    sum_b =
                    sum_in_r =
                    sum_in_g =
                    sum_in_b =
                    sum_out_r =
                    sum_out_g =
                    sum_out_b = 0;

                    src_pix_ptr = img.pix_ptr(x, 0);
                    for(i = 0; i <= ry; i++)
                    {
                        stack_pix_ptr    = &stack[i];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        sum_r           += src_pix_ptr[R] * (i + 1);
                        sum_g           += src_pix_ptr[G] * (i + 1);
                        sum_b           += src_pix_ptr[B] * (i + 1);
                        sum_out_r       += src_pix_ptr[R];
                        sum_out_g       += src_pix_ptr[G];
                        sum_out_b       += src_pix_ptr[B];
                    }
                    for(i = 1; i <= ry; i++)
                    {
                        if(i <= hm) src_pix_ptr += stride;
                        stack_pix_ptr = &stack[i + ry];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        sum_r           += src_pix_ptr[R] * (ry + 1 - i);
                        sum_g           += src_pix_ptr[G] * (ry + 1 - i);
                        sum_b           += src_pix_ptr[B] * (ry + 1 - i);
                        sum_in_r        += src_pix_ptr[R];
                        sum_in_g        += src_pix_ptr[G];
                        sum_in_b        += src_pix_ptr[B];
                    }

                    stack_ptr = ry;
                    yp = ry;
                    if(yp > hm) yp = hm;
                    src_pix_ptr = img.pix_ptr(x, yp);
                    dst_pix_ptr = img.pix_ptr(x, 0);
                    for(y = 0; y < h; y++)
                    {
                        dst_pix_ptr[R] = (sum_r * mul_sum) >> shr_sum;
                        dst_pix_ptr[G] = (sum_g * mul_sum) >> shr_sum;
                        dst_pix_ptr[B] = (sum_b * mul_sum) >> shr_sum;
                        dst_pix_ptr += stride;

                        sum_r -= sum_out_r;
                        sum_g -= sum_out_g;
                        sum_b -= sum_out_b;

                        stack_start = stack_ptr + div - ry;
                        if(stack_start >= div) stack_start -= div;

                        stack_pix_ptr = &stack[stack_start];
                        sum_out_r -= stack_pix_ptr->r;
                        sum_out_g -= stack_pix_ptr->g;
                        sum_out_b -= stack_pix_ptr->b;

                        if(yp < hm)
                        {
                            src_pix_ptr += stride;
                            ++yp;
                        }

                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];

                        sum_in_r += src_pix_ptr[R];
                        sum_in_g += src_pix_ptr[G];
                        sum_in_b += src_pix_ptr[B];
                        sum_r    += sum_in_r;
                        sum_g    += sum_in_g;
                        sum_b    += sum_in_b;

                        ++stack_ptr;
                        if(stack_ptr >= div) stack_ptr = 0;
                        stack_pix_ptr = &stack[stack_ptr];

                        sum_out_r += stack_pix_ptr->r;
                        sum_out_g += stack_pix_ptr->g;
                        sum_out_b += stack_pix_ptr->b;
                        sum_in_r  -= stack_pix_ptr->r;
                        sum_in_g  -= stack_pix_ptr->g;
                        sum_in_b  -= stack_pix_ptr->b;
                    }
                }
            }
#endif
		}

		private void stack_blur_bgra32(ImageBuffer img, int rx, int ry)
		{
			throw new NotImplementedException();
#if false
            //typedef typename Img::color_type color_type;
            //typedef typename Img::order_type order_type;

            int x, y, xp, yp, i;
            int stack_ptr;
            int stack_start;

            byte* src_pix_ptr;
                  byte* dst_pix_ptr;
            color_type*  stack_pix_ptr;

            int sum_r;
            int sum_g;
            int sum_b;
            int sum_a;
            int sum_in_r;
            int sum_in_g;
            int sum_in_b;
            int sum_in_a;
            int sum_out_r;
            int sum_out_g;
            int sum_out_b;
            int sum_out_a;

            int w   = img.width();
            int h   = img.height();
            int wm  = w - 1;
            int hm  = h - 1;

            int div;
            int mul_sum;
            int shr_sum;

            pod_vector<color_type> stack;

            if(rx > 0)
            {
                if(rx > 254) rx = 254;
                div = rx * 2 + 1;
                mul_sum = stack_blur_tables.g_stack_blur8_mul[rx];
                shr_sum = stack_blur_tables.g_stack_blur8_shr[rx];
                stack.allocate(div);

                for(y = 0; y < h; y++)
                {
                    sum_r =
                    sum_g =
                    sum_b =
                    sum_a =
                    sum_in_r =
                    sum_in_g =
                    sum_in_b =
                    sum_in_a =
                    sum_out_r =
                    sum_out_g =
                    sum_out_b =
                    sum_out_a = 0;

                    src_pix_ptr = img.pix_ptr(0, y);
                    for(i = 0; i <= rx; i++)
                    {
                        stack_pix_ptr    = &stack[i];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        stack_pix_ptr->a = src_pix_ptr[A];
                        sum_r           += src_pix_ptr[R] * (i + 1);
                        sum_g           += src_pix_ptr[G] * (i + 1);
                        sum_b           += src_pix_ptr[B] * (i + 1);
                        sum_a           += src_pix_ptr[A] * (i + 1);
                        sum_out_r       += src_pix_ptr[R];
                        sum_out_g       += src_pix_ptr[G];
                        sum_out_b       += src_pix_ptr[B];
                        sum_out_a       += src_pix_ptr[A];
                    }
                    for(i = 1; i <= rx; i++)
                    {
                        if(i <= wm) src_pix_ptr += Img::pix_width;
                        stack_pix_ptr = &stack[i + rx];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        stack_pix_ptr->a = src_pix_ptr[A];
                        sum_r           += src_pix_ptr[R] * (rx + 1 - i);
                        sum_g           += src_pix_ptr[G] * (rx + 1 - i);
                        sum_b           += src_pix_ptr[B] * (rx + 1 - i);
                        sum_a           += src_pix_ptr[A] * (rx + 1 - i);
                        sum_in_r        += src_pix_ptr[R];
                        sum_in_g        += src_pix_ptr[G];
                        sum_in_b        += src_pix_ptr[B];
                        sum_in_a        += src_pix_ptr[A];
                    }

                    stack_ptr = rx;
                    xp = rx;
                    if(xp > wm) xp = wm;
                    src_pix_ptr = img.pix_ptr(xp, y);
                    dst_pix_ptr = img.pix_ptr(0, y);
                    for(x = 0; x < w; x++)
                    {
                        dst_pix_ptr[R] = (sum_r * mul_sum) >> shr_sum;
                        dst_pix_ptr[G] = (sum_g * mul_sum) >> shr_sum;
                        dst_pix_ptr[B] = (sum_b * mul_sum) >> shr_sum;
                        dst_pix_ptr[A] = (sum_a * mul_sum) >> shr_sum;
                        dst_pix_ptr += Img::pix_width;

                        sum_r -= sum_out_r;
                        sum_g -= sum_out_g;
                        sum_b -= sum_out_b;
                        sum_a -= sum_out_a;

                        stack_start = stack_ptr + div - rx;
                        if(stack_start >= div) stack_start -= div;
                        stack_pix_ptr = &stack[stack_start];

                        sum_out_r -= stack_pix_ptr->r;
                        sum_out_g -= stack_pix_ptr->g;
                        sum_out_b -= stack_pix_ptr->b;
                        sum_out_a -= stack_pix_ptr->a;

                        if(xp < wm)
                        {
                            src_pix_ptr += Img::pix_width;
                            ++xp;
                        }

                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        stack_pix_ptr->a = src_pix_ptr[A];

                        sum_in_r += src_pix_ptr[R];
                        sum_in_g += src_pix_ptr[G];
                        sum_in_b += src_pix_ptr[B];
                        sum_in_a += src_pix_ptr[A];
                        sum_r    += sum_in_r;
                        sum_g    += sum_in_g;
                        sum_b    += sum_in_b;
                        sum_a    += sum_in_a;

                        ++stack_ptr;
                        if(stack_ptr >= div) stack_ptr = 0;
                        stack_pix_ptr = &stack[stack_ptr];

                        sum_out_r += stack_pix_ptr->r;
                        sum_out_g += stack_pix_ptr->g;
                        sum_out_b += stack_pix_ptr->b;
                        sum_out_a += stack_pix_ptr->a;
                        sum_in_r  -= stack_pix_ptr->r;
                        sum_in_g  -= stack_pix_ptr->g;
                        sum_in_b  -= stack_pix_ptr->b;
                        sum_in_a  -= stack_pix_ptr->a;
                    }
                }
            }

            if(ry > 0)
            {
                if(ry > 254) ry = 254;
                div = ry * 2 + 1;
                mul_sum = stack_blur_tables.g_stack_blur8_mul[ry];
                shr_sum = stack_blur_tables.g_stack_blur8_shr[ry];
                stack.allocate(div);

                int stride = img.stride();
                for(x = 0; x < w; x++)
                {
                    sum_r =
                    sum_g =
                    sum_b =
                    sum_a =
                    sum_in_r =
                    sum_in_g =
                    sum_in_b =
                    sum_in_a =
                    sum_out_r =
                    sum_out_g =
                    sum_out_b =
                    sum_out_a = 0;

                    src_pix_ptr = img.pix_ptr(x, 0);
                    for(i = 0; i <= ry; i++)
                    {
                        stack_pix_ptr    = &stack[i];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        stack_pix_ptr->a = src_pix_ptr[A];
                        sum_r           += src_pix_ptr[R] * (i + 1);
                        sum_g           += src_pix_ptr[G] * (i + 1);
                        sum_b           += src_pix_ptr[B] * (i + 1);
                        sum_a           += src_pix_ptr[A] * (i + 1);
                        sum_out_r       += src_pix_ptr[R];
                        sum_out_g       += src_pix_ptr[G];
                        sum_out_b       += src_pix_ptr[B];
                        sum_out_a       += src_pix_ptr[A];
                    }
                    for(i = 1; i <= ry; i++)
                    {
                        if(i <= hm) src_pix_ptr += stride;
                        stack_pix_ptr = &stack[i + ry];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        stack_pix_ptr->a = src_pix_ptr[A];
                        sum_r           += src_pix_ptr[R] * (ry + 1 - i);
                        sum_g           += src_pix_ptr[G] * (ry + 1 - i);
                        sum_b           += src_pix_ptr[B] * (ry + 1 - i);
                        sum_a           += src_pix_ptr[A] * (ry + 1 - i);
                        sum_in_r        += src_pix_ptr[R];
                        sum_in_g        += src_pix_ptr[G];
                        sum_in_b        += src_pix_ptr[B];
                        sum_in_a        += src_pix_ptr[A];
                    }

                    stack_ptr = ry;
                    yp = ry;
                    if(yp > hm) yp = hm;
                    src_pix_ptr = img.pix_ptr(x, yp);
                    dst_pix_ptr = img.pix_ptr(x, 0);
                    for(y = 0; y < h; y++)
                    {
                        dst_pix_ptr[R] = (sum_r * mul_sum) >> shr_sum;
                        dst_pix_ptr[G] = (sum_g * mul_sum) >> shr_sum;
                        dst_pix_ptr[B] = (sum_b * mul_sum) >> shr_sum;
                        dst_pix_ptr[A] = (sum_a * mul_sum) >> shr_sum;
                        dst_pix_ptr += stride;

                        sum_r -= sum_out_r;
                        sum_g -= sum_out_g;
                        sum_b -= sum_out_b;
                        sum_a -= sum_out_a;

                        stack_start = stack_ptr + div - ry;
                        if(stack_start >= div) stack_start -= div;

                        stack_pix_ptr = &stack[stack_start];
                        sum_out_r -= stack_pix_ptr->r;
                        sum_out_g -= stack_pix_ptr->g;
                        sum_out_b -= stack_pix_ptr->b;
                        sum_out_a -= stack_pix_ptr->a;

                        if(yp < hm)
                        {
                            src_pix_ptr += stride;
                            ++yp;
                        }

                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        stack_pix_ptr->a = src_pix_ptr[A];

                        sum_in_r += src_pix_ptr[R];
                        sum_in_g += src_pix_ptr[G];
                        sum_in_b += src_pix_ptr[B];
                        sum_in_a += src_pix_ptr[A];
                        sum_r    += sum_in_r;
                        sum_g    += sum_in_g;
                        sum_b    += sum_in_b;
                        sum_a    += sum_in_a;

                        ++stack_ptr;
                        if(stack_ptr >= div) stack_ptr = 0;
                        stack_pix_ptr = &stack[stack_ptr];

                        sum_out_r += stack_pix_ptr->r;
                        sum_out_g += stack_pix_ptr->g;
                        sum_out_b += stack_pix_ptr->b;
                        sum_out_a += stack_pix_ptr->a;
                        sum_in_r  -= stack_pix_ptr->r;
                        sum_in_g  -= stack_pix_ptr->g;
                        sum_in_b  -= stack_pix_ptr->b;
                        sum_in_a  -= stack_pix_ptr->a;
                    }
                }
            }
#endif
		}
	}

	//====================================================stack_blur_calc_rgba
	internal struct stack_blur_calc_rgba
	{
		private int r, g, b, a;

		private void clear()
		{
			r = g = b = a = 0;
		}

		private void add(RGBA_Ints v)
		{
			r += v.r;
			g += v.g;
			b += v.b;
			a += v.a;
		}

		private void add(RGBA_Ints v, int k)
		{
			r += v.r * k;
			g += v.g * k;
			b += v.b * k;
			a += v.a * k;
		}

		private void sub(RGBA_Ints v)
		{
			r -= v.r;
			g -= v.g;
			b -= v.b;
			a -= v.a;
		}

		private void calc_pix(RGBA_Ints v, int div)
		{
			v.r = (int)(r / div);
			v.g = (int)(g / div);
			v.b = (int)(b / div);
			v.a = (int)(a / div);
		}

		private void calc_pix(RGBA_Ints v, int mul, int shr)
		{
			v.r = (int)((r * mul) >> shr);
			v.g = (int)((g * mul) >> shr);
			v.b = (int)((b * mul) >> shr);
			v.a = (int)((a * mul) >> shr);
		}
	};

	//=====================================================stack_blur_calc_rgb
	internal struct stack_blur_calc_rgb
	{
		private int r, g, b;

		private void clear()
		{
			r = g = b = 0;
		}

		private void add(RGBA_Ints v)
		{
			r += v.r;
			g += v.g;
			b += v.b;
		}

		private void add(RGBA_Ints v, int k)
		{
			r += v.r * k;
			g += v.g * k;
			b += v.b * k;
		}

		private void sub(RGBA_Ints v)
		{
			r -= v.r;
			g -= v.g;
			b -= v.b;
		}

		private void calc_pix(RGBA_Ints v, int div)
		{
			v.r = (int)(r / div);
			v.g = (int)(g / div);
			v.b = (int)(b / div);
		}

		private void calc_pix(RGBA_Ints v, int mul, int shr)
		{
			v.r = (int)((r * mul) >> shr);
			v.g = (int)((g * mul) >> shr);
			v.b = (int)((b * mul) >> shr);
		}
	};

	//====================================================stack_blur_calc_gray
	internal struct stack_blur_calc_gray
	{
		private int v;

		private void clear()
		{
			v = 0;
		}

		private void add(RGBA_Ints a)
		{
			v += a.r;
		}

		private void add(RGBA_Ints a, int k)
		{
			v += a.r * k;
		}

		private void sub(RGBA_Ints a)
		{
			v -= a.r;
		}

		private void calc_pix(RGBA_Ints a, int div)
		{
			a.r = (int)(v / div);
		}

		private void calc_pix(RGBA_Ints a, int mul, int shr)
		{
			a.r = (int)((v * mul) >> shr);
		}
	};

#endif

	public abstract class RecursizeBlurCalculator
	{
		public double r, g, b, a;

		public abstract RecursizeBlurCalculator CreateNew();

		public abstract void from_pix(Color c);

		public abstract void calc(double b1, double b2, double b3, double b4,
			RecursizeBlurCalculator c1, RecursizeBlurCalculator c2, RecursizeBlurCalculator c3, RecursizeBlurCalculator c4);

		public abstract void to_pix(ref Color c);
	};

	//===========================================================recursive_blur
	public sealed class RecursiveBlur
	{
		private List<RecursizeBlurCalculator> m_sum1;
		private List<RecursizeBlurCalculator> m_sum2;
		private VectorPOD<Color> m_buf;
		private RecursizeBlurCalculator m_RecursizeBlurCalculatorFactory;

		public RecursiveBlur(RecursizeBlurCalculator recursizeBluerCalculatorFactory)
		{
			m_sum1 = new List<RecursizeBlurCalculator>();
			m_sum2 = new List<RecursizeBlurCalculator>();
			m_buf = new VectorPOD<Color>();
			m_RecursizeBlurCalculatorFactory = recursizeBluerCalculatorFactory;
		}

		public void blur_x(IImageByte img, double radius)
		{
			if (radius < 0.62) return;
			if (img.Width < 3) return;

			double s = (double)(radius * 0.5);
			double q = (double)((s < 2.5) ?
									3.97156 - 4.14554 * Math.Sqrt(1 - 0.26891 * s) :
									0.98711 * s - 0.96330);

			double q2 = (double)(q * q);
			double q3 = (double)(q2 * q);

			double b0 = (double)(1.0 / (1.578250 +
											2.444130 * q +
											1.428100 * q2 +
											0.422205 * q3));

			double b1 = (double)(2.44413 * q +
									  2.85619 * q2 +
									  1.26661 * q3);

			double b2 = (double)(-1.42810 * q2 +
									 -1.26661 * q3);

			double b3 = (double)(0.422205 * q3);

			double b = (double)(1 - (b1 + b2 + b3) * b0);

			b1 *= b0;
			b2 *= b0;
			b3 *= b0;

			int w = img.Width;
			int h = img.Height;
			int wm = (int)w - 1;
			int x, y;

			int StartCreatingAt = (int)m_sum1.Count;
			for (int i = StartCreatingAt; i < w; i++)
			{
				m_sum1.Add(null);
				m_sum2.Add(null);
			}
			m_buf.Allocate(w);

			List<RecursizeBlurCalculator> Sum1Array = m_sum1;
			List<RecursizeBlurCalculator> Sum2Array = m_sum2;
			Color[] BufferArray = m_buf.Array;

			for (int i = StartCreatingAt; i < w; i++)
			{
				Sum1Array[i] = m_RecursizeBlurCalculatorFactory.CreateNew();
				Sum2Array[i] = m_RecursizeBlurCalculatorFactory.CreateNew();
			}

			for (y = 0; y < h; y++)
			{
				RecursizeBlurCalculator c = m_RecursizeBlurCalculatorFactory;
				c.from_pix(img.GetPixel(0, y));
				Sum1Array[0].calc(b, b1, b2, b3, c, c, c, c);
				c.from_pix(img.GetPixel(1, y));
				Sum1Array[1].calc(b, b1, b2, b3, c, Sum1Array[0], Sum1Array[0], Sum1Array[0]);
				c.from_pix(img.GetPixel(2, y));
				Sum1Array[2].calc(b, b1, b2, b3, c, Sum1Array[1], Sum1Array[0], Sum1Array[0]);

				for (x = 3; x < w; ++x)
				{
					c.from_pix(img.GetPixel(x, y));
					Sum1Array[x].calc(b, b1, b2, b3, c, Sum1Array[x - 1], Sum1Array[x - 2], Sum1Array[x - 3]);
				}

				Sum2Array[wm].calc(b, b1, b2, b3, Sum1Array[wm], Sum1Array[wm], Sum1Array[wm], Sum1Array[wm]);
				Sum2Array[wm - 1].calc(b, b1, b2, b3, Sum1Array[wm - 1], Sum2Array[wm], Sum2Array[wm], Sum2Array[wm]);
				Sum2Array[wm - 2].calc(b, b1, b2, b3, Sum1Array[wm - 2], Sum2Array[wm - 1], Sum2Array[wm], Sum2Array[wm]);
				Sum2Array[wm].to_pix(ref BufferArray[wm]);
				Sum2Array[wm - 1].to_pix(ref BufferArray[wm - 1]);
				Sum2Array[wm - 2].to_pix(ref BufferArray[wm - 2]);

				for (x = wm - 3; x >= 0; --x)
				{
					Sum2Array[x].calc(b, b1, b2, b3, Sum1Array[x], Sum2Array[x + 1], Sum2Array[x + 2], Sum2Array[x + 3]);
					Sum2Array[x].to_pix(ref BufferArray[x]);
				}

				img.copy_color_hspan(0, y, w, BufferArray, 0);
			}
		}

		public void blur_y(IImageByte img, double radius)
		{
			FormatTransposer img2 = new FormatTransposer(img);
			blur_x(img2, radius);
		}

		public void blur(IImageByte img, double radius)
		{
			blur_x(img, radius);
			blur_y(img, radius);
		}
	};

	//=================================================recursive_blur_calc_rgb
	public sealed class recursive_blur_calc_rgb : RecursizeBlurCalculator
	{
		public override RecursizeBlurCalculator CreateNew()
		{
			return new recursive_blur_calc_rgb();
		}

		public override void from_pix(Color c)
		{
			r = c.red;
			g = c.green;
			b = c.blue;
		}

		public override void calc(double b1, double b2, double b3, double b4,
			RecursizeBlurCalculator c1, RecursizeBlurCalculator c2, RecursizeBlurCalculator c3, RecursizeBlurCalculator c4)
		{
			r = b1 * c1.r + b2 * c2.r + b3 * c3.r + b4 * c4.r;
			g = b1 * c1.g + b2 * c2.g + b3 * c3.g + b4 * c4.g;
			b = b1 * c1.b + b2 * c2.b + b3 * c3.b + b4 * c4.b;
		}

		public override void to_pix(ref Color c)
		{
			c.red = (byte)Util.uround(r);
			c.green = (byte)Util.uround(g);
			c.blue = (byte)Util.uround(b);
		}
	};

	//=================================================recursive_blur_calc_rgba
	public sealed class recursive_blur_calc_rgba : RecursizeBlurCalculator
	{
		public override RecursizeBlurCalculator CreateNew()
		{
			return new recursive_blur_calc_rgba();
		}

		public override void from_pix(Color c)
		{
			r = c.red;
			g = c.green;
			b = c.blue;
			a = c.alpha;
		}

		public override void calc(double b1, double b2, double b3, double b4,
			RecursizeBlurCalculator c1, RecursizeBlurCalculator c2, RecursizeBlurCalculator c3, RecursizeBlurCalculator c4)
		{
			r = b1 * c1.r + b2 * c2.r + b3 * c3.r + b4 * c4.r;
			g = b1 * c1.g + b2 * c2.g + b3 * c3.g + b4 * c4.g;
			b = b1 * c1.b + b2 * c2.b + b3 * c3.b + b4 * c4.b;
			a = b1 * c1.a + b2 * c2.a + b3 * c3.a + b4 * c4.a;
		}

		public override void to_pix(ref Color c)
		{
			c.red = (byte)Util.uround(r);
			c.green = (byte)Util.uround(g);
			c.blue = (byte)Util.uround(b);
			c.alpha = (byte)Util.uround(a);
		}
	};

	//================================================recursive_blur_calc_gray
	public sealed class recursive_blur_calc_gray : RecursizeBlurCalculator
	{
		public override RecursizeBlurCalculator CreateNew()
		{
			return new recursive_blur_calc_gray();
		}

		public override void from_pix(Color c)
		{
			r = c.red;
		}

		public override void calc(double b1, double b2, double b3, double b4,
			RecursizeBlurCalculator c1, RecursizeBlurCalculator c2, RecursizeBlurCalculator c3, RecursizeBlurCalculator c4)
		{
			r = b1 * c1.r + b2 * c2.r + b3 * c3.r + b4 * c4.r;
		}

		public override void to_pix(ref Color c)
		{
			c.red = (byte)Util.uround(r);
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\ThresholdFunctions\AlphaThresholdFunction.cs
/*
Copyright (c) 2017, Lars Brubaker, John Lewin
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using MatterHackers.Agg;
using MatterHackers.Agg.Image;

namespace MatterHackers.Agg.Image.ThresholdFunctions
{
	public class AlphaThresholdFunction : IThresholdFunction
	{
		protected double rangeStart = .1;
		protected double rangeEnd = 1.0;

		public AlphaThresholdFunction()
		{
		}

		/// <summary>
		/// Create a new AlphaThresholdFunction
		/// </summary>
		/// <param name="rangeStart">Any returned value less than this will be set to 0</param>
		/// <param name="rangeEnd">Any returned value greater than this will be set to 0</param>
		public AlphaThresholdFunction(double rangeStart, double rangeEnd)
		{
			this.rangeStart = Math.Max(0, Math.Min(1, rangeStart));
			this.rangeEnd = Math.Max(0, Math.Min(1, rangeEnd));
		}

		public double Transform(Color color)
		{
			return color.Alpha0To255 / 255.0;
		}

		public Color ZeroColor => Color.Transparent;

		public double Threshold(Color color)
		{
			return GetThresholded0To1(Transform(color));
		}

		private double GetThresholded0To1(double rawValue)
		{
			double outValue = 0;
			if (rawValue < rangeStart)
			{
				outValue = 0;
			}
			else if (rawValue > rangeEnd)
			{
				outValue = 0;
			}
			else
			{
				outValue = (double)(rawValue - rangeStart) / (double)(rangeEnd - rangeStart);
			}

			return outValue;
		}
	}

	public class AlphaFunction : IThresholdFunction
	{
		public AlphaFunction()
		{
		}

		public double Transform(Color color)
		{
			return color.Alpha0To1;
		}

		public Color ZeroColor => Color.Transparent;

		public double Threshold(Color color)
		{
			return color.Alpha0To1;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\ThresholdFunctions\HueThresholdFunction.cs
/*
Copyright (c) 2017, Lars Brubaker, John Lewin
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using MatterHackers.Agg;
using MatterHackers.Agg.Image;

namespace MatterHackers.Agg.Image.ThresholdFunctions
{
	public class HueThresholdFunction : IThresholdFunction
	{
		protected double rangeStart = 255.0 / 120.0;
		protected double rangeEnd = 255.0;

		public HueThresholdFunction()
		{
		}

		/// <summary>
		/// Create a new AlphaThresholdFunction
		/// </summary>
		/// <param name="rangeStart">Any returned value less than this will be set to 0</param>
		/// <param name="rangeEnd">Any returned value greater than this will be set to 0</param>
		public HueThresholdFunction(double rangeStart, double rangeEnd)
		{
			this.rangeStart = Math.Max(0, Math.Min(1, rangeStart));
			this.rangeEnd = Math.Max(0, Math.Min(1, rangeEnd));
		}

		public double Transform(Color color)
		{
			double h, s, l;
			color.ToColorF().GetHSL(out h, out s, out l);
			return h;
		}

		public Color ZeroColor => Color.Black;

		public double Threshold(Color color)
		{
			return GetThresholded0To1(Transform(color));
		}

		private double GetThresholded0To1(double rawValue)
		{
			double outValue = 0;
			if (rawValue < rangeStart)
			{
				outValue = 0;
			}
			else if (rawValue > rangeEnd)
			{
				outValue = 0;
			}
			else
			{
				outValue = (double)(rawValue - rangeStart) / (double)(rangeEnd - rangeStart);
			}

			return outValue;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\ThresholdFunctions\IThresholdFunction.cs
/*
Copyright (c) 2017, Lars Brubaker, John Lewin
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using MatterHackers.Agg;

namespace MatterHackers.Agg.Image.ThresholdFunctions

{
	public interface IThresholdFunction
	{
		/// <summary>
		/// Convert the color into the coordinate space used by the threshold function
		/// </summary>
		/// <param name="color"></param>
		/// <returns>A double ranged 0 to 1</returns>
		double Transform(Color color);

		/// <summary>
		/// Do the actual thresholding of the color. This will convert it into the coordinate space
		/// and also apply any clamping to the values.
		/// </summary>
		/// <param name="color"></param>
		/// <returns></returns>
		double Threshold(Color color);

		/// <summary>
		/// The color that represents 0 for this Threshold function
		/// </summary>
		Color ZeroColor { get; }
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\ThresholdFunctions\MapOnMaxIntensity.cs
/*
Copyright (c) 2017, Lars Brubaker, John Lewin
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using MatterHackers.Agg;
using MatterHackers.Agg.Image;

namespace MatterHackers.Agg.Image.ThresholdFunctions
{
	public class MapOnMaxIntensity : IThresholdFunction
	{
		protected double rangeStart = .1;
		protected double rangeEnd = 1.0;

		public MapOnMaxIntensity()
		{
		}

		public MapOnMaxIntensity(double rangeStart, double rangeEnd)
		{
			this.rangeStart = Math.Max(0, Math.Min(1, rangeStart));
			this.rangeEnd = Math.Max(0, Math.Min(1, rangeEnd));
		}

		public double Transform(Color color)
		{
			// we invert the gray value so we have black being the color we are finding
			return (color.Red0To1 * 0.2989) + (color.Blue0To1 * 0.5870) + (color.Green0To1 * 0.1140);
		}

		public double Threshold(Color color)
		{
			// this is on I from HSI
			return GetThresholded0To1(Transform(color));
		}

		public Color ZeroColor => Color.Black;

		protected double GetThresholded0To1(double rawValue)
		{
			double outValue = 0;
			if (rawValue < rangeStart)
			{
				outValue = 0;
			}
			else if (rawValue > rangeEnd)
			{
				outValue = 0;
			}
			else
			{
				outValue = (double)(rawValue - rangeStart) / (double)(rangeEnd - rangeStart);
			}

			return outValue;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\ThresholdFunctions\SilhouetteThresholdFunction.cs
/*
Copyright (c) 2017, Lars Brubaker, John Lewin
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using MatterHackers.Agg;
using MatterHackers.Agg.Image;

namespace MatterHackers.Agg.Image.ThresholdFunctions
{
	public class SilhouetteThresholdFunction : IThresholdFunction
	{
		protected double rangeStart = .1;
		protected double rangeEnd = 1.0;

		public SilhouetteThresholdFunction()
		{
		}

		public SilhouetteThresholdFunction(double rangeStart, double rangeEnd)
		{
			this.rangeStart = Math.Max(0, Math.Min(1, rangeStart));
			this.rangeEnd = Math.Max(0, Math.Min(1, rangeEnd));
		}

		public double Transform(Color color)
		{
			// we invert the gray value so we have black being the color we are finding
			return 1 - ((color.Red0To1 * 0.2989) + (color.Blue0To1 * 0.5870) + (color.Green0To1 * 0.1140));
		}

		public double Threshold(Color color)
		{
			// this is on I from HSI
			return GetThresholded0To1(Transform(color));
		}

		public Color ZeroColor => Color.White;

		protected double GetThresholded0To1(double rawValue)
		{
			double outValue = 0;
			if (rawValue < rangeStart)
			{
				outValue = 0;
			}
			else if (rawValue > rangeEnd)
			{
				outValue = 0;
			}
			else
			{
				outValue = (double)(rawValue - rangeStart) / (double)(rangeEnd - rangeStart);
			}

			return outValue;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Image\Transposer.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------

namespace MatterHackers.Agg.Image
{
	//=======================================================pixfmt_transposer
	public sealed class FormatTransposer : ImageProxy
	{
		public FormatTransposer(IImageByte pixelFormat)
			: base(pixelFormat)
		{
		}

		public override int Width { get { return linkedImage.Height; } }

		public override int Height { get { return linkedImage.Width; } }

		public override Color GetPixel(int x, int y)
		{
			return linkedImage.GetPixel(y, x);
		}

		public override void copy_pixel(int x, int y, byte[] c, int ByteOffset)
		{
			linkedImage.copy_pixel(y, x, c, ByteOffset);
		}

		public override void copy_hline(int x, int y, int len, Color c)
		{
			linkedImage.copy_vline(y, x, len, c);
		}

		public override void copy_vline(int x, int y,
								   int len,
								   Color c)
		{
			linkedImage.copy_hline(y, x, len, c);
		}

		public override void blend_hline(int x1, int y, int x2, Color c, byte cover)
		{
			linkedImage.blend_vline(y, x1, x2, c, cover);
		}

		public override void blend_vline(int x, int y1, int y2, Color c, byte cover)
		{
			linkedImage.blend_hline(y1, x, y2, c, cover);
		}

		public override void blend_solid_hspan(int x, int y, int len, Color c, byte[] covers, int coversIndex)
		{
			linkedImage.blend_solid_vspan(y, x, len, c, covers, coversIndex);
		}

		public override void blend_solid_vspan(int x, int y, int len, Color c, byte[] covers, int coversIndex)
		{
			linkedImage.blend_solid_hspan(y, x, len, c, covers, coversIndex);
		}

		public override void copy_color_hspan(int x, int y, int len, Color[] colors, int colorsIndex)
		{
			linkedImage.copy_color_vspan(y, x, len, colors, colorsIndex);
		}

		public override void copy_color_vspan(int x, int y, int len, Color[] colors, int colorsIndex)
		{
			linkedImage.copy_color_hspan(y, x, len, colors, colorsIndex);
		}

		public override void blend_color_hspan(int x, int y, int len, Color[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			linkedImage.blend_color_vspan(y, x, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
		}

		public override void blend_color_vspan(int x, int y, int len, Color[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
		{
			linkedImage.blend_color_hspan(y, x, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\ImageLineRenderer.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
#if true

using MatterHackers.Agg.Image;
using System;

namespace MatterHackers.Agg
{
	/*
	//========================================================line_image_scale
	public class line_image_scale
	{
		IImage m_source;
		double        m_height;
		double        m_scale;

		public line_image_scale(IImage src, double height)
		{
			m_source = (src);
			m_height = (height);
			m_scale = (src.height() / height);
		}

		public double width()  { return m_source.width(); }
		public double height() { return m_height; }

		public RGBA_Bytes pixel(int x, int y)
		{
			double src_y = (y + 0.5) * m_scale - 0.5;
			int h  = m_source.height() - 1;
			int y1 = ufloor(src_y);
			int y2 = y1 + 1;
			RGBA_Bytes pix1 = (y1 < 0) ? new no_color() : m_source.pixel(x, y1);
			RGBA_Bytes pix2 = (y2 > h) ? no_color() : m_source.pixel(x, y2);
			return pix1.gradient(pix2, src_y - y1);
		}
	};

	 */

	//======================================================line_image_pattern
	public class line_image_pattern : ImageBuffer
	{
		private IPatternFilter m_filter;
		private int m_dilation;
		private int m_dilation_hr;
		private ImageBuffer m_buf = new ImageBuffer();
		private byte[] m_data = null;
		private int m_DataSizeInBytes = 0;
		private int m_width;
		private int m_height;
		private int m_width_hr;
		private int m_half_height_hr;
		private int m_offset_y_hr;

		//--------------------------------------------------------------------
		public line_image_pattern(IPatternFilter filter)
		{
			m_filter = filter;
			m_dilation = (filter.dilation() + 1);
			m_dilation_hr = (m_dilation << LineAABasics.line_subpixel_shift);
			m_width = (0);
			m_height = (0);
			m_width_hr = (0);
			m_half_height_hr = (0);
			m_offset_y_hr = (0);
		}

		~line_image_pattern()
		{
			if (m_DataSizeInBytes > 0)
			{
				m_data = null;
			}
		}

		// Create
		//--------------------------------------------------------------------
		public line_image_pattern(IPatternFilter filter, line_image_pattern src)
		{
			m_filter = (filter);
			m_dilation = (filter.dilation() + 1);
			m_dilation_hr = (m_dilation << LineAABasics.line_subpixel_shift);
			m_width = 0;
			m_height = 0;
			m_width_hr = 0;
			m_half_height_hr = 0;
			m_offset_y_hr = (0);

			create(src);
		}

		// Create
		//--------------------------------------------------------------------
		public void create(IImageByte src)
		{
			// we are going to create a dilated image for filtering
			// we add m_dilation pixels to every side of the image and then copy the image in the x
			// direction into each end so that we can sample into this image to get filtering on x repeating
			// if the original image look like this
			//
			// 123456
			//
			// the new image would look like this
			//
			// 0000000000
			// 0000000000
			// 5612345612
			// 0000000000
			// 0000000000

			m_height = (int)Util.uceil(src.Height);
			m_width = (int)Util.uceil(src.Width);
			m_width_hr = (int)Util.uround(src.Width * LineAABasics.line_subpixel_scale);
			m_half_height_hr = (int)Util.uround(src.Height * LineAABasics.line_subpixel_scale / 2);
			m_offset_y_hr = m_dilation_hr + m_half_height_hr - LineAABasics.line_subpixel_scale / 2;
			m_half_height_hr += LineAABasics.line_subpixel_scale / 2;

			int bufferWidth = m_width + m_dilation * 2;
			int bufferHeight = m_height + m_dilation * 2;
			int bytesPerPixel = src.BitDepth / 8;
			int NewSizeInBytes = bufferWidth * bufferHeight * bytesPerPixel;
			if (m_DataSizeInBytes < NewSizeInBytes)
			{
				m_DataSizeInBytes = NewSizeInBytes;
				m_data = new byte[m_DataSizeInBytes];
			}

			m_buf.AttachBuffer(m_data, 0, bufferWidth, bufferHeight, bufferWidth * bytesPerPixel, src.BitDepth, bytesPerPixel);
			byte[] destBuffer = m_buf.GetBuffer();
			byte[] sourceBuffer = src.GetBuffer();

			// copy the image into the middle of the dest
			for (int y = 0; y < m_height; y++)
			{
				for (int x = 0; x < m_width; x++)
				{
					int sourceOffset = src.GetBufferOffsetXY(x, y);
					int destOffset = m_buf.GetBufferOffsetXY(m_dilation, y + m_dilation);
					for (int channel = 0; channel < bytesPerPixel; channel++)
					{
						destBuffer[destOffset++] = sourceBuffer[sourceOffset++];
					}
				}
			}

			// copy the first two pixels form the end into the beginning and from the beginning into the end
			for (int y = 0; y < m_height; y++)
			{
				int s1Offset = src.GetBufferOffsetXY(0, y);
				int d1Offset = m_buf.GetBufferOffsetXY(m_dilation + m_width, y);

				int s2Offset = src.GetBufferOffsetXY(m_width - m_dilation, y);
				int d2Offset = m_buf.GetBufferOffsetXY(0, y);

				for (int x = 0; x < m_dilation; x++)
				{
					for (int channel = 0; channel < bytesPerPixel; channel++)
					{
						destBuffer[d1Offset++] = sourceBuffer[s1Offset++];
						destBuffer[d2Offset++] = sourceBuffer[s2Offset++];
					}
				}
			}
		}

		//--------------------------------------------------------------------
		public int pattern_width()
		{
			return m_width_hr;
		}

		public int line_width()
		{
			return m_half_height_hr;
		}

		public double width()
		{
			return m_height;
		}

		//--------------------------------------------------------------------
		public void pixel(Color[] destBuffer, int destBufferOffset, int x, int y)
		{
			m_filter.pixel_high_res(m_buf, destBuffer, destBufferOffset,
									 x % m_width_hr + m_dilation_hr,
									 y + m_offset_y_hr);
		}

		//--------------------------------------------------------------------
		public IPatternFilter filter()
		{
			return m_filter;
		}
	};

	/*

	//=================================================line_image_pattern_pow2
	public class line_image_pattern_pow2 :
		line_image_pattern<IPatternFilter>
	{
		uint m_mask;

		//--------------------------------------------------------------------
		public line_image_pattern_pow2(IPatternFilter filter) :
			line_image_pattern<IPatternFilter>(filter), m_mask(line_subpixel_mask) {}

		//--------------------------------------------------------------------
		public line_image_pattern_pow2(IPatternFilter filter, ImageBuffer src) :
			line_image_pattern<IPatternFilter>(filter), m_mask(line_subpixel_mask)
		{
			create(src);
		}

		//--------------------------------------------------------------------
		public void create(ImageBuffer src)
		{
			line_image_pattern<IPatternFilter>::create(src);
			m_mask = 1;
			while(m_mask < base_type::m_width)
			{
				m_mask <<= 1;
				m_mask |= 1;
			}
			m_mask <<= line_subpixel_shift - 1;
			m_mask |=  line_subpixel_mask;
			base_type::m_width_hr = m_mask + 1;
		}

		//--------------------------------------------------------------------
		public void pixel(RGBA_Bytes* p, int x, int y)
		{
			base_type::m_filter->pixel_high_res(
					base_type::m_buf.rows(),
					p,
					(x & m_mask) + base_type::m_dilation_hr,
					y + base_type::m_offset_y_hr);
		}
	};
	 */

	//===================================================distance_interpolator4
	public class distance_interpolator4
	{
		private int m_dx;
		private int m_dy;
		private int m_dx_start;
		private int m_dy_start;
		private int m_dx_pict;
		private int m_dy_pict;
		private int m_dx_end;
		private int m_dy_end;

		private int m_dist;
		private int m_dist_start;
		private int m_dist_pict;
		private int m_dist_end;
		private int m_len;

		//---------------------------------------------------------------------
		public distance_interpolator4()
		{
		}

		public distance_interpolator4(int x1, int y1, int x2, int y2,
							   int sx, int sy, int ex, int ey,
							   int len, double scale, int x, int y)
		{
			m_dx = (x2 - x1);
			m_dy = (y2 - y1);
			m_dx_start = (LineAABasics.line_mr(sx) - LineAABasics.line_mr(x1));
			m_dy_start = (LineAABasics.line_mr(sy) - LineAABasics.line_mr(y1));
			m_dx_end = (LineAABasics.line_mr(ex) - LineAABasics.line_mr(x2));
			m_dy_end = (LineAABasics.line_mr(ey) - LineAABasics.line_mr(y2));

			m_dist = (Util.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -
						  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));

			m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -
						 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);

			m_dist_end = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_end -
					   (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_end);
			m_len = (int)(Util.uround(len / scale));

			double d = len * scale;
			int dx = Util.iround(((x2 - x1) << LineAABasics.line_subpixel_shift) / d);
			int dy = Util.iround(((y2 - y1) << LineAABasics.line_subpixel_shift) / d);
			m_dx_pict = -dy;
			m_dy_pict = dx;
			m_dist_pict = ((x + LineAABasics.line_subpixel_scale / 2 - (x1 - dy)) * m_dy_pict -
							(y + LineAABasics.line_subpixel_scale / 2 - (y1 + dx)) * m_dx_pict) >>
						   LineAABasics.line_subpixel_shift;

			m_dx <<= LineAABasics.line_subpixel_shift;
			m_dy <<= LineAABasics.line_subpixel_shift;
			m_dx_start <<= LineAABasics.line_mr_subpixel_shift;
			m_dy_start <<= LineAABasics.line_mr_subpixel_shift;
			m_dx_end <<= LineAABasics.line_mr_subpixel_shift;
			m_dy_end <<= LineAABasics.line_mr_subpixel_shift;
		}

		//---------------------------------------------------------------------
		public void inc_x()
		{
			m_dist += m_dy;
			m_dist_start += m_dy_start;
			m_dist_pict += m_dy_pict;
			m_dist_end += m_dy_end;
		}

		//---------------------------------------------------------------------
		public void dec_x()
		{
			m_dist -= m_dy;
			m_dist_start -= m_dy_start;
			m_dist_pict -= m_dy_pict;
			m_dist_end -= m_dy_end;
		}

		//---------------------------------------------------------------------
		public void inc_y()
		{
			m_dist -= m_dx;
			m_dist_start -= m_dx_start;
			m_dist_pict -= m_dx_pict;
			m_dist_end -= m_dx_end;
		}

		//---------------------------------------------------------------------
		public void dec_y()
		{
			m_dist += m_dx;
			m_dist_start += m_dx_start;
			m_dist_pict += m_dx_pict;
			m_dist_end += m_dx_end;
		}

		//---------------------------------------------------------------------
		public void inc_x(int dy)
		{
			m_dist += m_dy;
			m_dist_start += m_dy_start;
			m_dist_pict += m_dy_pict;
			m_dist_end += m_dy_end;
			if (dy > 0)
			{
				m_dist -= m_dx;
				m_dist_start -= m_dx_start;
				m_dist_pict -= m_dx_pict;
				m_dist_end -= m_dx_end;
			}
			if (dy < 0)
			{
				m_dist += m_dx;
				m_dist_start += m_dx_start;
				m_dist_pict += m_dx_pict;
				m_dist_end += m_dx_end;
			}
		}

		//---------------------------------------------------------------------
		public void dec_x(int dy)
		{
			m_dist -= m_dy;
			m_dist_start -= m_dy_start;
			m_dist_pict -= m_dy_pict;
			m_dist_end -= m_dy_end;
			if (dy > 0)
			{
				m_dist -= m_dx;
				m_dist_start -= m_dx_start;
				m_dist_pict -= m_dx_pict;
				m_dist_end -= m_dx_end;
			}
			if (dy < 0)
			{
				m_dist += m_dx;
				m_dist_start += m_dx_start;
				m_dist_pict += m_dx_pict;
				m_dist_end += m_dx_end;
			}
		}

		//---------------------------------------------------------------------
		public void inc_y(int dx)
		{
			m_dist -= m_dx;
			m_dist_start -= m_dx_start;
			m_dist_pict -= m_dx_pict;
			m_dist_end -= m_dx_end;
			if (dx > 0)
			{
				m_dist += m_dy;
				m_dist_start += m_dy_start;
				m_dist_pict += m_dy_pict;
				m_dist_end += m_dy_end;
			}
			if (dx < 0)
			{
				m_dist -= m_dy;
				m_dist_start -= m_dy_start;
				m_dist_pict -= m_dy_pict;
				m_dist_end -= m_dy_end;
			}
		}

		//---------------------------------------------------------------------
		public void dec_y(int dx)
		{
			m_dist += m_dx;
			m_dist_start += m_dx_start;
			m_dist_pict += m_dx_pict;
			m_dist_end += m_dx_end;
			if (dx > 0)
			{
				m_dist += m_dy;
				m_dist_start += m_dy_start;
				m_dist_pict += m_dy_pict;
				m_dist_end += m_dy_end;
			}
			if (dx < 0)
			{
				m_dist -= m_dy;
				m_dist_start -= m_dy_start;
				m_dist_pict -= m_dy_pict;
				m_dist_end -= m_dy_end;
			}
		}

		//---------------------------------------------------------------------
		public int dist()
		{
			return m_dist;
		}

		public int dist_start()
		{
			return m_dist_start;
		}

		public int dist_pict()
		{
			return m_dist_pict;
		}

		public int dist_end()
		{
			return m_dist_end;
		}

		//---------------------------------------------------------------------
		public int dx()
		{
			return m_dx;
		}

		public int dy()
		{
			return m_dy;
		}

		public int dx_start()
		{
			return m_dx_start;
		}

		public int dy_start()
		{
			return m_dy_start;
		}

		public int dx_pict()
		{
			return m_dx_pict;
		}

		public int dy_pict()
		{
			return m_dy_pict;
		}

		public int dx_end()
		{
			return m_dx_end;
		}

		public int dy_end()
		{
			return m_dy_end;
		}

		public int len()
		{
			return m_len;
		}
	};

#if true
#if false
    //==================================================line_interpolator_image
    public class line_interpolator_image
    {
        line_parameters m_lp;
        dda2_line_interpolator m_li;
        distance_interpolator4 m_di;
        IImageByte m_ren;
        int m_plen;
        int m_x;
        int m_y;
        int m_old_x;
        int m_old_y;
        int m_width;
        int m_max_extent;
        int m_start;
        int m_step;
        int[] m_dist_pos = new int[max_half_width + 1];
        RGBA_Bytes[] m_colors = new RGBA_Bytes[max_half_width * 2 + 4];

        //---------------------------------------------------------------------
        public const int max_half_width = 64;

        //---------------------------------------------------------------------
        public line_interpolator_image(renderer_outline_aa ren, line_parameters lp,
                                int sx, int sy, int ex, int ey,
                                int pattern_start,
                                double scale_x)
        {
            throw new NotImplementedException();
/*
            m_lp=(lp);
            m_li = new dda2_line_interpolator(lp.vertical ? LineAABasics.line_dbl_hr(lp.x2 - lp.x1) :
                               LineAABasics.line_dbl_hr(lp.y2 - lp.y1),
                 lp.vertical ? Math.Abs(lp.y2 - lp.y1) :
                               Math.Abs(lp.x2 - lp.x1) + 1);
            m_di = new distance_interpolator4(lp.x1, lp.y1, lp.x2, lp.y2, sx, sy, ex, ey, lp.len, scale_x,
                 lp.x1 & ~LineAABasics.line_subpixel_mask, lp.y1 & ~LineAABasics.line_subpixel_mask);
            m_ren=ren;
            m_x = (lp.x1 >> LineAABasics.line_subpixel_shift);
            m_y = (lp.y1 >> LineAABasics.line_subpixel_shift);
            m_old_x=(m_x);
            m_old_y=(m_y);
            m_count = ((lp.vertical ? Math.Abs((lp.y2 >> LineAABasics.line_subpixel_shift) - m_y) :
                                   Math.Abs((lp.x2 >> LineAABasics.line_subpixel_shift) - m_x)));
            m_width=(ren.subpixel_width());
            //m_max_extent(m_width >> (LineAABasics.line_subpixel_shift - 2));
            m_max_extent = ((m_width + LineAABasics.line_subpixel_scale) >> LineAABasics.line_subpixel_shift);
            m_start=(pattern_start + (m_max_extent + 2) * ren.pattern_width());
            m_step=(0);

            dda2_line_interpolator li = new dda2_line_interpolator(0, lp.vertical ?
                                              (lp.dy << LineAABasics.line_subpixel_shift) :
                                              (lp.dx << LineAABasics.line_subpixel_shift),
                                           lp.len);

            uint i;
            int stop = m_width + LineAABasics.line_subpixel_scale * 2;
            for(i = 0; i < max_half_width; ++i)
            {
                m_dist_pos[i] = li.y();
                if(m_dist_pos[i] >= stop) break;
                ++li;
            }
            m_dist_pos[i] = 0x7FFF0000;

            int dist1_start;
            int dist2_start;
            int npix = 1;

            if(lp.vertical)
            {
                do
                {
                    --m_li;
                    m_y -= lp.inc;
                    m_x = (m_lp.x1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

                    if(lp.inc > 0) m_di.dec_y(m_x - m_old_x);
                    else           m_di.inc_y(m_x - m_old_x);

                    m_old_x = m_x;

                    dist1_start = dist2_start = m_di.dist_start();

                    int dx = 0;
                    if(dist1_start < 0) ++npix;
                    do
                    {
                        dist1_start += m_di.dy_start();
                        dist2_start -= m_di.dy_start();
                        if(dist1_start < 0) ++npix;
                        if(dist2_start < 0) ++npix;
                        ++dx;
                    }
                    while(m_dist_pos[dx] <= m_width);
                    if(npix == 0) break;

                    npix = 0;
                }
                while(--m_step >= -m_max_extent);
            }
            else
            {
                do
                {
                    --m_li;

                    m_x -= lp.inc;
                    m_y = (m_lp.y1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

                    if(lp.inc > 0) m_di.dec_x(m_y - m_old_y);
                    else           m_di.inc_x(m_y - m_old_y);

                    m_old_y = m_y;

                    dist1_start = dist2_start = m_di.dist_start();

                    int dy = 0;
                    if(dist1_start < 0) ++npix;
                    do
                    {
                        dist1_start -= m_di.dx_start();
                        dist2_start += m_di.dx_start();
                        if(dist1_start < 0) ++npix;
                        if(dist2_start < 0) ++npix;
                        ++dy;
                    }
                    while(m_dist_pos[dy] <= m_width);
                    if(npix == 0) break;

                    npix = 0;
                }
                while(--m_step >= -m_max_extent);
            }
            m_li.adjust_forward();
            m_step -= m_max_extent;
 */
        }

        //---------------------------------------------------------------------
        public bool step_hor()
        {
            throw new NotImplementedException();
/*
            ++m_li;
            m_x += m_lp.inc;
            m_y = (m_lp.y1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

            if(m_lp.inc > 0) m_di.inc_x(m_y - m_old_y);
            else             m_di.dec_x(m_y - m_old_y);

            m_old_y = m_y;

            int s1 = m_di.dist() / m_lp.len;
            int s2 = -s1;

            if(m_lp.inc < 0) s1 = -s1;

            int dist_start;
            int dist_pict;
            int dist_end;
            int dy;
            int dist;

            dist_start = m_di.dist_start();
            dist_pict  = m_di.dist_pict() + m_start;
            dist_end   = m_di.dist_end();
            RGBA_Bytes* p0 = m_colors + max_half_width + 2;
            RGBA_Bytes* p1 = p0;

            int npix = 0;
            p1->clear();
            if(dist_end > 0)
            {
                if(dist_start <= 0)
                {
                    m_ren.pixel(p1, dist_pict, s2);
                }
                ++npix;
            }
            ++p1;

            dy = 1;
            while((dist = m_dist_pos[dy]) - s1 <= m_width)
            {
                dist_start -= m_di.dx_start();
                dist_pict  -= m_di.dx_pict();
                dist_end   -= m_di.dx_end();
                p1->clear();
                if(dist_end > 0 && dist_start <= 0)
                {
                    if(m_lp.inc > 0) dist = -dist;
                    m_ren.pixel(p1, dist_pict, s2 - dist);
                    ++npix;
                }
                ++p1;
                ++dy;
            }

            dy = 1;
            dist_start = m_di.dist_start();
            dist_pict  = m_di.dist_pict() + m_start;
            dist_end   = m_di.dist_end();
            while((dist = m_dist_pos[dy]) + s1 <= m_width)
            {
                dist_start += m_di.dx_start();
                dist_pict  += m_di.dx_pict();
                dist_end   += m_di.dx_end();
                --p0;
                p0->clear();
                if(dist_end > 0 && dist_start <= 0)
                {
                    if(m_lp.inc > 0) dist = -dist;
                    m_ren.pixel(p0, dist_pict, s2 + dist);
                    ++npix;
                }
                ++dy;
            }
            m_ren.blend_color_vspan(m_x,
                                    m_y - dy + 1,
                                    (uint)(p1 - p0),
                                    p0);
            return npix && ++m_step < m_count;
 */
        }

        //---------------------------------------------------------------------
        public bool step_ver()
        {
            throw new NotImplementedException();
/*
            ++m_li;
            m_y += m_lp.inc;
            m_x = (m_lp.x1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

            if(m_lp.inc > 0) m_di.inc_y(m_x - m_old_x);
            else             m_di.dec_y(m_x - m_old_x);

            m_old_x = m_x;

            int s1 = m_di.dist() / m_lp.len;
            int s2 = -s1;

            if(m_lp.inc > 0) s1 = -s1;

            int dist_start;
            int dist_pict;
            int dist_end;
            int dist;
            int dx;

            dist_start = m_di.dist_start();
            dist_pict  = m_di.dist_pict() + m_start;
            dist_end   = m_di.dist_end();
            RGBA_Bytes* p0 = m_colors + max_half_width + 2;
            RGBA_Bytes* p1 = p0;

            int npix = 0;
            p1->clear();
            if(dist_end > 0)
            {
                if(dist_start <= 0)
                {
                    m_ren.pixel(p1, dist_pict, s2);
                }
                ++npix;
            }
            ++p1;

            dx = 1;
            while((dist = m_dist_pos[dx]) - s1 <= m_width)
            {
                dist_start += m_di.dy_start();
                dist_pict  += m_di.dy_pict();
                dist_end   += m_di.dy_end();
                p1->clear();
                if(dist_end > 0 && dist_start <= 0)
                {
                    if(m_lp.inc > 0) dist = -dist;
                    m_ren.pixel(p1, dist_pict, s2 + dist);
                    ++npix;
                }
                ++p1;
                ++dx;
            }

            dx = 1;
            dist_start = m_di.dist_start();
            dist_pict  = m_di.dist_pict() + m_start;
            dist_end   = m_di.dist_end();
            while((dist = m_dist_pos[dx]) + s1 <= m_width)
            {
                dist_start -= m_di.dy_start();
                dist_pict  -= m_di.dy_pict();
                dist_end   -= m_di.dy_end();
                --p0;
                p0->clear();
                if(dist_end > 0 && dist_start <= 0)
                {
                    if(m_lp.inc > 0) dist = -dist;
                    m_ren.pixel(p0, dist_pict, s2 - dist);
                    ++npix;
                }
                ++dx;
            }
            m_ren.blend_color_hspan(m_x - dx + 1,
                                    m_y,
                                    (uint)(p1 - p0),
                                    p0);
            return npix && ++m_step < m_count;
 */
        }

        //---------------------------------------------------------------------
        public int  pattern_end() { return m_start + m_di.len(); }

        //---------------------------------------------------------------------
        public bool vertical() { return m_lp.vertical; }
        public int  width() { return m_width; }
    }
#endif

	//===================================================renderer_outline_image
	//template<class BaseRenderer, class ImagePattern>
	public class ImageLineRenderer : LineRenderer
	{
		private IImageByte m_ren;
		private line_image_pattern m_pattern;
		private int m_start;
		private double m_scale_x;
		private RectangleInt m_clip_box;
		//private bool m_clipping;

		//---------------------------------------------------------------------
		//typedef renderer_outline_image<BaseRenderer, ImagePattern> self_type;

		//---------------------------------------------------------------------
		public ImageLineRenderer(IImageByte ren, line_image_pattern patt)
		{
			m_ren = ren;
			m_pattern = patt;
			m_start = (0);
			m_scale_x = (1.0);
			m_clip_box = new RectangleInt(0, 0, 0, 0);
			//m_clipping = (false);
		}

		public void attach(IImageByte ren)
		{
			m_ren = ren;
		}

		//---------------------------------------------------------------------
		public void pattern(line_image_pattern p)
		{
			m_pattern = p;
		}

		public line_image_pattern pattern()
		{
			return m_pattern;
		}

		//---------------------------------------------------------------------
		public void reset_clipping()
		{
			//m_clipping = false;
		}

		public void clip_box(double x1, double y1, double x2, double y2)
		{
			m_clip_box.Left = line_coord_sat.conv(x1);
			m_clip_box.Bottom = line_coord_sat.conv(y1);
			m_clip_box.Right = line_coord_sat.conv(x2);
			m_clip_box.Top = line_coord_sat.conv(y2);
			//m_clipping = true;
		}

		//---------------------------------------------------------------------
		public void scale_x(double s)
		{
			m_scale_x = s;
		}

		public double scale_x()
		{
			return m_scale_x;
		}

		//---------------------------------------------------------------------
		public void start_x(double s)
		{
			m_start = Util.iround(s * LineAABasics.line_subpixel_scale);
		}

		public double start_x()
		{
			return (double)(m_start) / LineAABasics.line_subpixel_scale;
		}

		//---------------------------------------------------------------------
		public int subpixel_width()
		{
			return m_pattern.line_width();
		}

		public int pattern_width()
		{
			return m_pattern.pattern_width();
		}

		public double width()
		{
			return (double)(subpixel_width()) / LineAABasics.line_subpixel_scale;
		}

		public void pixel(Color[] p, int offset, int x, int y)
		{
			throw new NotImplementedException();

			//m_pattern.pixel(p, x, y);
		}

		public void blend_color_hspan(int x, int y, uint len, Color[] colors, int colorsOffset)
		{
			throw new NotImplementedException();
			//            m_ren.blend_color_hspan(x, y, len, colors, null, 0);
		}

		public void blend_color_vspan(int x, int y, uint len, Color[] colors, int colorsOffset)
		{
			throw new NotImplementedException();
			//            m_ren.blend_color_vspan(x, y, len, colors, null, 0);
		}

		public static bool accurate_join_only()
		{
			return true;
		}

		public override void semidot(CompareFunction cmp, int xc1, int yc1, int xc2, int yc2)
		{
		}

		public override void semidot_hline(CompareFunction cmp,
						   int xc1, int yc1, int xc2, int yc2,
						   int x1, int y1, int x2)
		{
		}

		public override void pie(int xc, int yc, int x1, int y1, int x2, int y2)
		{
		}

		public override void line0(line_parameters lp)
		{
		}

		public override void line1(line_parameters lp, int sx, int sy)
		{
		}

		public override void line2(line_parameters lp, int ex, int ey)
		{
		}

		public void line3_no_clip(line_parameters lp,
						   int sx, int sy, int ex, int ey)
		{
			throw new NotImplementedException();
			/*
						if(lp.len > LineAABasics.line_max_length)
						{
							line_parameters lp1, lp2;
							lp.divide(lp1, lp2);
							int mx = lp1.x2 + (lp1.y2 - lp1.y1);
							int my = lp1.y2 - (lp1.x2 - lp1.x1);
							line3_no_clip(lp1, (lp.x1 + sx) >> 1, (lp.y1 + sy) >> 1, mx, my);
							line3_no_clip(lp2, mx, my, (lp.x2 + ex) >> 1, (lp.y2 + ey) >> 1);
							return;
						}

						LineAABasics.fix_degenerate_bisectrix_start(lp, ref sx, ref sy);
						LineAABasics.fix_degenerate_bisectrix_end(lp, ref ex, ref ey);
						line_interpolator_image li = new line_interpolator_image(this, lp,
															  sx, sy,
															  ex, ey,
															  m_start, m_scale_x);
						if(li.vertical())
						{
							while(li.step_ver());
						}
						else
						{
							while(li.step_hor());
						}
						m_start += uround(lp.len / m_scale_x);
			 */
		}

		public override void line3(line_parameters lp,
				   int sx, int sy, int ex, int ey)
		{
			throw new NotImplementedException();
			/*
						if(m_clipping)
						{
							int x1 = lp.x1;
							int y1 = lp.y1;
							int x2 = lp.x2;
							int y2 = lp.y2;
							uint flags = clip_line_segment(&x1, &y1, &x2, &y2, m_clip_box);
							int start = m_start;
							if((flags & 4) == 0)
							{
								if(flags)
								{
									line_parameters lp2(x1, y1, x2, y2,
													   uround(calc_distance(x1, y1, x2, y2)));
									if(flags & 1)
									{
										m_start += uround(calc_distance(lp.x1, lp.y1, x1, y1) / m_scale_x);
										sx = x1 + (y2 - y1);
										sy = y1 - (x2 - x1);
									}
									else
									{
										while(Math.Abs(sx - lp.x1) + Math.Abs(sy - lp.y1) > lp2.len)
										{
											sx = (lp.x1 + sx) >> 1;
											sy = (lp.y1 + sy) >> 1;
										}
									}
									if(flags & 2)
									{
										ex = x2 + (y2 - y1);
										ey = y2 - (x2 - x1);
									}
									else
									{
										while(Math.Abs(ex - lp.x2) + Math.Abs(ey - lp.y2) > lp2.len)
										{
											ex = (lp.x2 + ex) >> 1;
											ey = (lp.y2 + ey) >> 1;
										}
									}
									line3_no_clip(lp2, sx, sy, ex, ey);
								}
								else
								{
									line3_no_clip(lp, sx, sy, ex, ey);
								}
							}
							m_start = start + uround(lp.len / m_scale_x);
						}
						else
						{
							line3_no_clip(lp, sx, sy, ex, ey);
						}
			 */
		}
	};

#endif
}

#endif

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Interfaces\IAscendable.cs
/*
Copyright (c) 2017, Lars Brubaker, John Lewin
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

namespace MatterHackers.Agg
{
	public interface IAscendable<T>
	{
		T Parent { get; set; }
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Interfaces\IColorType.cs
//----------------------------------------------------------------------------
// AGG-Sharp - Version 1
// Copyright (C) 2007 Lars Brubaker http://agg-sharp.sourceforge.net/
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: larsbrubaker@gmail.com
//          http://agg-sharp.sourceforge.net/
//----------------------------------------------------------------------------

namespace MatterHackers.Agg
{
	public interface IColorType
	{
		ColorF ToColorF();

		Color ToColor();

		Color gradient(Color c, double k);

		int Red0To255 { get; set; }

		int Green0To255 { get; set; }

		int Blue0To255 { get; set; }

		int Alpha0To255 { get; set; }

		float Red0To1 { get; set; }

		float Green0To1 { get; set; }

		float Blue0To1 { get; set; }

		float Alpha0To1 { get; set; }
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Interfaces\IMarkers.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------

namespace MatterHackers.Agg
{
	public interface IMarkers
	{
		void Clear();

		void add_vertex(double x, double y, FlagsAndCommand unknown);
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Interfaces\IScanline.cs
namespace MatterHackers.Agg
{
	public struct ScanlineSpan
	{
		public int x;
		public int len;
		public int cover_index;
	};

	public interface IScanlineCache
	{
		void finalize(int y);

		void reset(int min_x, int max_x);

		void ResetSpans();

		int num_spans();

		ScanlineSpan begin();

		ScanlineSpan GetNextScanlineSpan();

		int y();

		byte[] GetCovers();

		void add_cell(int x, int cover);

		void add_span(int x, int len, int cover);
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Interfaces\IVertexDest.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using MatterHackers.VectorMath;

namespace MatterHackers.Agg
{
	public interface IVertexDest
	{
		void Clear();

		int Count { get; }

		void Add(Vector2 vertex);
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\OutlineRenderer.cs
using MatterHackers.Agg.Image;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg
{
#if true

	//===================================================distance_interpolator0
	public class distance_interpolator0
	{
		private int m_dx;
		private int m_dy;
		private int m_dist;

		//---------------------------------------------------------------------
		public distance_interpolator0()
		{
		}

		public distance_interpolator0(int x1, int y1, int x2, int y2, int x, int y)
		{
			unchecked
			{
				m_dx = (LineAABasics.line_mr(x2) - LineAABasics.line_mr(x1));
				m_dy = (LineAABasics.line_mr(y2) - LineAABasics.line_mr(y1));
				m_dist = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(x2)) * m_dy -
					   (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(y2)) * m_dx);

				m_dx <<= LineAABasics.line_mr_subpixel_shift;
				m_dy <<= LineAABasics.line_mr_subpixel_shift;
			}
		}

		//---------------------------------------------------------------------
		public void inc_x()
		{
			m_dist += m_dy;
		}

		public int dist()
		{
			return m_dist;
		}
	};

	//==================================================distance_interpolator00
	public class distance_interpolator00
	{
		private int m_dx1;
		private int m_dy1;
		private int m_dx2;
		private int m_dy2;
		private int m_dist1;
		private int m_dist2;

		//---------------------------------------------------------------------
		public distance_interpolator00()
		{
		}

		public distance_interpolator00(int xc, int yc,
								int x1, int y1, int x2, int y2,
								int x, int y)
		{
			m_dx1 = (LineAABasics.line_mr(x1) - LineAABasics.line_mr(xc));
			m_dy1 = (LineAABasics.line_mr(y1) - LineAABasics.line_mr(yc));
			m_dx2 = (LineAABasics.line_mr(x2) - LineAABasics.line_mr(xc));
			m_dy2 = (LineAABasics.line_mr(y2) - LineAABasics.line_mr(yc));
			m_dist1 = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(x1)) * m_dy1 -
					(LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(y1)) * m_dx1);
			m_dist2 = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(x2)) * m_dy2 -
					(LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(y2)) * m_dx2);

			m_dx1 <<= LineAABasics.line_mr_subpixel_shift;
			m_dy1 <<= LineAABasics.line_mr_subpixel_shift;
			m_dx2 <<= LineAABasics.line_mr_subpixel_shift;
			m_dy2 <<= LineAABasics.line_mr_subpixel_shift;
		}

		//---------------------------------------------------------------------
		public void inc_x()
		{
			m_dist1 += m_dy1; m_dist2 += m_dy2;
		}

		public int dist1()
		{
			return m_dist1;
		}

		public int dist2()
		{
			return m_dist2;
		}
	};

	//===================================================distance_interpolator1
	public class distance_interpolator1
	{
		private int m_dx;
		private int m_dy;
		private int m_dist;

		//---------------------------------------------------------------------
		public distance_interpolator1()
		{
		}

		public distance_interpolator1(int x1, int y1, int x2, int y2, int x, int y)
		{
			m_dx = (x2 - x1);
			m_dy = (y2 - y1);
			m_dist = (Util.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -
						  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));

			m_dx <<= LineAABasics.line_subpixel_shift;
			m_dy <<= LineAABasics.line_subpixel_shift;
		}

		//---------------------------------------------------------------------
		public void inc_x()
		{
			m_dist += m_dy;
		}

		public void dec_x()
		{
			m_dist -= m_dy;
		}

		public void inc_y()
		{
			m_dist -= m_dx;
		}

		public void dec_y()
		{
			m_dist += m_dx;
		}

		//---------------------------------------------------------------------
		public void inc_x(int dy)
		{
			m_dist += m_dy;
			if (dy > 0) m_dist -= m_dx;
			if (dy < 0) m_dist += m_dx;
		}

		//---------------------------------------------------------------------
		public void dec_x(int dy)
		{
			m_dist -= m_dy;
			if (dy > 0) m_dist -= m_dx;
			if (dy < 0) m_dist += m_dx;
		}

		//---------------------------------------------------------------------
		public void inc_y(int dx)
		{
			m_dist -= m_dx;
			if (dx > 0) m_dist += m_dy;
			if (dx < 0) m_dist -= m_dy;
		}

		public void dec_y(int dx)
		//---------------------------------------------------------------------
		{
			m_dist += m_dx;
			if (dx > 0) m_dist += m_dy;
			if (dx < 0) m_dist -= m_dy;
		}

		//---------------------------------------------------------------------
		public int dist()
		{
			return m_dist;
		}

		public int dx()
		{
			return m_dx;
		}

		public int dy()
		{
			return m_dy;
		}
	};

	//===================================================distance_interpolator2
	public class distance_interpolator2
	{
		private int m_dx;
		private int m_dy;
		private int m_dx_start;
		private int m_dy_start;

		private int m_dist;
		private int m_dist_start;

		//---------------------------------------------------------------------
		public distance_interpolator2()
		{
		}

		public distance_interpolator2(int x1, int y1, int x2, int y2,
							   int sx, int sy, int x, int y)
		{
			m_dx = (x2 - x1);
			m_dy = (y2 - y1);
			m_dx_start = (LineAABasics.line_mr(sx) - LineAABasics.line_mr(x1));
			m_dy_start = (LineAABasics.line_mr(sy) - LineAABasics.line_mr(y1));

			m_dist = (Util.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -
						  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));

			m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -
						 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);

			m_dx <<= LineAABasics.line_subpixel_shift;
			m_dy <<= LineAABasics.line_subpixel_shift;
			m_dx_start <<= LineAABasics.line_mr_subpixel_shift;
			m_dy_start <<= LineAABasics.line_mr_subpixel_shift;
		}

		public distance_interpolator2(int x1, int y1, int x2, int y2,
							   int ex, int ey, int x, int y, int none)
		{
			m_dx = (x2 - x1);
			m_dy = (y2 - y1);
			m_dx_start = (LineAABasics.line_mr(ex) - LineAABasics.line_mr(x2));
			m_dy_start = (LineAABasics.line_mr(ey) - LineAABasics.line_mr(y2));

			m_dist = (Util.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -
						  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));

			m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_start -
						 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_start);

			m_dx <<= LineAABasics.line_subpixel_shift;
			m_dy <<= LineAABasics.line_subpixel_shift;
			m_dx_start <<= LineAABasics.line_mr_subpixel_shift;
			m_dy_start <<= LineAABasics.line_mr_subpixel_shift;
		}

		//---------------------------------------------------------------------
		public void inc_x()
		{
			m_dist += m_dy; m_dist_start += m_dy_start;
		}

		public void dec_x()
		{
			m_dist -= m_dy; m_dist_start -= m_dy_start;
		}

		public void inc_y()
		{
			m_dist -= m_dx; m_dist_start -= m_dx_start;
		}

		public void dec_y()
		{
			m_dist += m_dx; m_dist_start += m_dx_start;
		}

		//---------------------------------------------------------------------
		public void inc_x(int dy)
		{
			m_dist += m_dy;
			m_dist_start += m_dy_start;
			if (dy > 0)
			{
				m_dist -= m_dx;
				m_dist_start -= m_dx_start;
			}
			if (dy < 0)
			{
				m_dist += m_dx;
				m_dist_start += m_dx_start;
			}
		}

		//---------------------------------------------------------------------
		public void dec_x(int dy)
		{
			m_dist -= m_dy;
			m_dist_start -= m_dy_start;
			if (dy > 0)
			{
				m_dist -= m_dx;
				m_dist_start -= m_dx_start;
			}
			if (dy < 0)
			{
				m_dist += m_dx;
				m_dist_start += m_dx_start;
			}
		}

		//---------------------------------------------------------------------
		public void inc_y(int dx)
		{
			m_dist -= m_dx;
			m_dist_start -= m_dx_start;
			if (dx > 0)
			{
				m_dist += m_dy;
				m_dist_start += m_dy_start;
			}
			if (dx < 0)
			{
				m_dist -= m_dy;
				m_dist_start -= m_dy_start;
			}
		}

		//---------------------------------------------------------------------
		public void dec_y(int dx)
		{
			m_dist += m_dx;
			m_dist_start += m_dx_start;
			if (dx > 0)
			{
				m_dist += m_dy;
				m_dist_start += m_dy_start;
			}
			if (dx < 0)
			{
				m_dist -= m_dy;
				m_dist_start -= m_dy_start;
			}
		}

		//---------------------------------------------------------------------
		public int dist()
		{
			return m_dist;
		}

		public int dist_start()
		{
			return m_dist_start;
		}

		public int dist_end()
		{
			return m_dist_start;
		}

		//---------------------------------------------------------------------
		public int dx()
		{
			return m_dx;
		}

		public int dy()
		{
			return m_dy;
		}

		public int dx_start()
		{
			return m_dx_start;
		}

		public int dy_start()
		{
			return m_dy_start;
		}

		public int dx_end()
		{
			return m_dx_start;
		}

		public int dy_end()
		{
			return m_dy_start;
		}
	};

	//===================================================distance_interpolator3
	public class distance_interpolator3
	{
		private int m_dx;
		private int m_dy;
		private int m_dx_start;
		private int m_dy_start;
		private int m_dx_end;
		private int m_dy_end;

		private int m_dist;
		private int m_dist_start;
		private int m_dist_end;

		//---------------------------------------------------------------------
		public distance_interpolator3()
		{
		}

		public distance_interpolator3(int x1, int y1, int x2, int y2,
							   int sx, int sy, int ex, int ey,
							   int x, int y)
		{
			unchecked
			{
				m_dx = (x2 - x1);
				m_dy = (y2 - y1);
				m_dx_start = (LineAABasics.line_mr(sx) - LineAABasics.line_mr(x1));
				m_dy_start = (LineAABasics.line_mr(sy) - LineAABasics.line_mr(y1));
				m_dx_end = (LineAABasics.line_mr(ex) - LineAABasics.line_mr(x2));
				m_dy_end = (LineAABasics.line_mr(ey) - LineAABasics.line_mr(y2));

				m_dist = (Util.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -
							  (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));

				m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -
							 (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);

				m_dist_end = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_end -
						   (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_end);

				m_dx <<= LineAABasics.line_subpixel_shift;
				m_dy <<= LineAABasics.line_subpixel_shift;
				m_dx_start <<= LineAABasics.line_mr_subpixel_shift;
				m_dy_start <<= LineAABasics.line_mr_subpixel_shift;
				m_dx_end <<= LineAABasics.line_mr_subpixel_shift;
				m_dy_end <<= LineAABasics.line_mr_subpixel_shift;
			}
		}

		private void inc_x()
		{
			m_dist += m_dy; m_dist_start += m_dy_start; m_dist_end += m_dy_end;
		}

		private void dec_x()
		{
			m_dist -= m_dy; m_dist_start -= m_dy_start; m_dist_end -= m_dy_end;
		}

		private void inc_y()
		{
			m_dist -= m_dx; m_dist_start -= m_dx_start; m_dist_end -= m_dx_end;
		}

		private void dec_y()
		{
			m_dist += m_dx; m_dist_start += m_dx_start; m_dist_end += m_dx_end;
		}

		public void inc_x(int dy)
		{
			m_dist += m_dy;
			m_dist_start += m_dy_start;
			m_dist_end += m_dy_end;
			if (dy > 0)
			{
				m_dist -= m_dx;
				m_dist_start -= m_dx_start;
				m_dist_end -= m_dx_end;
			}
			if (dy < 0)
			{
				m_dist += m_dx;
				m_dist_start += m_dx_start;
				m_dist_end += m_dx_end;
			}
		}

		public void dec_x(int dy)
		{
			m_dist -= m_dy;
			m_dist_start -= m_dy_start;
			m_dist_end -= m_dy_end;
			if (dy > 0)
			{
				m_dist -= m_dx;
				m_dist_start -= m_dx_start;
				m_dist_end -= m_dx_end;
			}
			if (dy < 0)
			{
				m_dist += m_dx;
				m_dist_start += m_dx_start;
				m_dist_end += m_dx_end;
			}
		}

		public void inc_y(int dx)
		{
			m_dist -= m_dx;
			m_dist_start -= m_dx_start;
			m_dist_end -= m_dx_end;
			if (dx > 0)
			{
				m_dist += m_dy;
				m_dist_start += m_dy_start;
				m_dist_end += m_dy_end;
			}
			if (dx < 0)
			{
				m_dist -= m_dy;
				m_dist_start -= m_dy_start;
				m_dist_end -= m_dy_end;
			}
		}

		public void dec_y(int dx)
		{
			m_dist += m_dx;
			m_dist_start += m_dx_start;
			m_dist_end += m_dx_end;
			if (dx > 0)
			{
				m_dist += m_dy;
				m_dist_start += m_dy_start;
				m_dist_end += m_dy_end;
			}
			if (dx < 0)
			{
				m_dist -= m_dy;
				m_dist_start -= m_dy_start;
				m_dist_end -= m_dy_end;
			}
		}

		public int dist()
		{
			return m_dist;
		}

		public int dist_start()
		{
			return m_dist_start;
		}

		public int dist_end()
		{
			return m_dist_end;
		}

		private int dx()
		{
			return m_dx;
		}

		private int dy()
		{
			return m_dy;
		}

		public int dx_start()
		{
			return m_dx_start;
		}

		public int dy_start()
		{
			return m_dy_start;
		}

		public int dx_end()
		{
			return m_dx_end;
		}

		public int dy_end()
		{
			return m_dy_end;
		}
	};

	//================================================line_interpolator_aa_base
	public class line_interpolator_aa_base
	{
		protected line_parameters m_lp;
		protected dda2_line_interpolator m_li;
		protected OutlineRenderer m_ren;
		private int m_len;
		protected int m_x;
		protected int m_y;
		protected int m_old_x;
		protected int m_old_y;
		protected int m_count;
		protected int m_width;
		protected int m_max_extent;
		protected int m_step;
		protected int[] m_dist = new int[max_half_width + 1];
		protected byte[] m_covers = new byte[max_half_width * 2 + 4];
		//typedef Renderer renderer_type;

		protected const int max_half_width = 64;

		public line_interpolator_aa_base(OutlineRenderer ren, line_parameters lp)
		{
			m_lp = lp;
			m_li = new dda2_line_interpolator(lp.vertical ? LineAABasics.line_dbl_hr(lp.x2 - lp.x1) : LineAABasics.line_dbl_hr(lp.y2 - lp.y1),
				lp.vertical ? Math.Abs(lp.y2 - lp.y1) : Math.Abs(lp.x2 - lp.x1) + 1);
			m_ren = ren;
			m_len = ((lp.vertical == (lp.inc > 0)) ? -lp.len : lp.len);
			m_x = (lp.x1 >> LineAABasics.line_subpixel_shift);
			m_y = (lp.y1 >> LineAABasics.line_subpixel_shift);
			m_old_x = (m_x);
			m_old_y = (m_y);
			m_count = ((lp.vertical ? Math.Abs((lp.y2 >> LineAABasics.line_subpixel_shift) - m_y) :
								   Math.Abs((lp.x2 >> LineAABasics.line_subpixel_shift) - m_x)));
			m_width = (ren.subpixel_width());
			//m_max_extent(m_width >> (line_subpixel_shift - 2));
			m_max_extent = ((m_width + LineAABasics.line_subpixel_mask) >> LineAABasics.line_subpixel_shift);
			m_step = 0;

			dda2_line_interpolator li = new dda2_line_interpolator(0,
				lp.vertical ? (lp.dy << LineAABasics.line_subpixel_shift) : (lp.dx << LineAABasics.line_subpixel_shift),
				lp.len);

			int i;
			int stop = m_width + LineAABasics.line_subpixel_scale * 2;
			for (i = 0; i < max_half_width; ++i)
			{
				m_dist[i] = li.y();
				if (m_dist[i] >= stop) break;
				li.Next();
			}
			m_dist[i++] = 0x7FFF0000;
		}

		public int step_hor_base(distance_interpolator1 di)
		{
			m_li.Next();
			m_x += m_lp.inc;
			m_y = (m_lp.y1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

			if (m_lp.inc > 0) di.inc_x(m_y - m_old_y);
			else di.dec_x(m_y - m_old_y);

			m_old_y = m_y;

			return di.dist() / m_len;
		}

		public int step_hor_base(distance_interpolator2 di)
		{
			m_li.Next();
			m_x += m_lp.inc;
			m_y = (m_lp.y1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

			if (m_lp.inc > 0) di.inc_x(m_y - m_old_y);
			else di.dec_x(m_y - m_old_y);

			m_old_y = m_y;

			return di.dist() / m_len;
		}

		public int step_hor_base(distance_interpolator3 di)
		{
			m_li.Next();
			m_x += m_lp.inc;
			m_y = (m_lp.y1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

			if (m_lp.inc > 0) di.inc_x(m_y - m_old_y);
			else di.dec_x(m_y - m_old_y);

			m_old_y = m_y;

			return di.dist() / m_len;
		}

		public int step_ver_base(distance_interpolator1 di)
		{
			m_li.Next();
			m_y += m_lp.inc;
			m_x = (m_lp.x1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

			if (m_lp.inc > 0) di.inc_y(m_x - m_old_x);
			else di.dec_y(m_x - m_old_x);

			m_old_x = m_x;

			return di.dist() / m_len;
		}

		public int step_ver_base(distance_interpolator2 di)
		{
			m_li.Next();
			m_y += m_lp.inc;
			m_x = (m_lp.x1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

			if (m_lp.inc > 0) di.inc_y(m_x - m_old_x);
			else di.dec_y(m_x - m_old_x);

			m_old_x = m_x;

			return di.dist() / m_len;
		}

		public int step_ver_base(distance_interpolator3 di)
		{
			m_li.Next();
			m_y += m_lp.inc;
			m_x = (m_lp.x1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

			if (m_lp.inc > 0) di.inc_y(m_x - m_old_x);
			else di.dec_y(m_x - m_old_x);

			m_old_x = m_x;

			return di.dist() / m_len;
		}

		public bool vertical()
		{
			return m_lp.vertical;
		}

		public int width()
		{
			return m_width;
		}

		public int count()
		{
			return m_count;
		}
	};

	//====================================================line_interpolator_aa0
	public class line_interpolator_aa0 : line_interpolator_aa_base
	{
		private distance_interpolator1 m_di;
		//typedef Renderer renderer_type;
		//typedef line_interpolator_aa_base<Renderer> base_type;

		//---------------------------------------------------------------------
		public line_interpolator_aa0(OutlineRenderer ren, line_parameters lp)
			: base(ren, lp)
		{
			m_di = new distance_interpolator1(lp.x1, lp.y1, lp.x2, lp.y2,
				 lp.x1 & ~LineAABasics.line_subpixel_mask, lp.y1 & ~LineAABasics.line_subpixel_mask);

			m_li.adjust_forward();
		}

		//---------------------------------------------------------------------
		public bool step_hor()
		{
			int dist;
			int dy;
			int s1 = step_hor_base(m_di);
			int Offset0 = max_half_width + 2;
			int Offset1 = Offset0;

			m_covers[Offset1++] = (byte)m_ren.cover(s1);

			dy = 1;
			while ((dist = base.m_dist[dy] - s1) <= base.m_width)
			{
				m_covers[Offset1++] = (byte)base.m_ren.cover(dist);
				++dy;
			}

			dy = 1;
			while ((dist = base.m_dist[dy] + s1) <= base.m_width)
			{
				m_covers[--Offset0] = (byte)base.m_ren.cover(dist);
				++dy;
			}
			base.m_ren.blend_solid_vspan(base.m_x,
											   base.m_y - dy + 1,
											   Offset1 - Offset0,
											   m_covers, Offset0);
			return ++base.m_step < base.m_count;
		}

		//---------------------------------------------------------------------
		public bool step_ver()
		{
			int dist;
			int dx;
			int s1 = base.step_ver_base(m_di);
			int Offset0 = max_half_width + 2;
			int Offset1 = Offset0;

			m_covers[Offset1++] = (byte)m_ren.cover(s1);

			dx = 1;
			while ((dist = base.m_dist[dx] - s1) <= base.m_width)
			{
				m_covers[Offset1++] = (byte)base.m_ren.cover(dist);
				++dx;
			}

			dx = 1;
			while ((dist = base.m_dist[dx] + s1) <= base.m_width)
			{
				m_covers[--Offset0] = (byte)base.m_ren.cover(dist);
				++dx;
			}
			base.m_ren.blend_solid_hspan(base.m_x - dx + 1,
											   base.m_y,
											   Offset1 - Offset0,
											   m_covers, Offset0);
			return ++base.m_step < base.m_count;
		}
	};

	//====================================================line_interpolator_aa1
	public class line_interpolator_aa1 : line_interpolator_aa_base
	{
		private distance_interpolator2 m_di;
		//typedef Renderer renderer_type;
		//typedef line_interpolator_aa_base<Renderer> base_type;

		//---------------------------------------------------------------------
		public line_interpolator_aa1(OutlineRenderer ren, line_parameters lp,
							  int sx, int sy)
			:
			base(ren, lp)
		{
			m_di = new distance_interpolator2(lp.x1, lp.y1, lp.x2, lp.y2, sx, sy,
				 lp.x1 & ~LineAABasics.line_subpixel_mask, lp.y1 & ~LineAABasics.line_subpixel_mask);

			int dist1_start;
			int dist2_start;

			int npix = 1;

			if (lp.vertical)
			{
				do
				{
					base.m_li.Prev();
					base.m_y -= lp.inc;
					base.m_x = (base.m_lp.x1 + base.m_li.y()) >> LineAABasics.line_subpixel_shift;

					if (lp.inc > 0) m_di.dec_y(base.m_x - base.m_old_x);
					else m_di.inc_y(base.m_x - base.m_old_x);

					base.m_old_x = base.m_x;

					dist1_start = dist2_start = m_di.dist_start();

					int dx = 0;
					if (dist1_start < 0) ++npix;
					do
					{
						dist1_start += m_di.dy_start();
						dist2_start -= m_di.dy_start();
						if (dist1_start < 0) ++npix;
						if (dist2_start < 0) ++npix;
						++dx;
					}
					while (base.m_dist[dx] <= base.m_width);
					--base.m_step;
					if (npix == 0) break;
					npix = 0;
				}
				while (base.m_step >= -base.m_max_extent);
			}
			else
			{
				do
				{
					base.m_li.Prev();
					base.m_x -= lp.inc;
					base.m_y = (base.m_lp.y1 + base.m_li.y()) >> LineAABasics.line_subpixel_shift;

					if (lp.inc > 0) m_di.dec_x(base.m_y - base.m_old_y);
					else m_di.inc_x(base.m_y - base.m_old_y);

					base.m_old_y = base.m_y;

					dist1_start = dist2_start = m_di.dist_start();

					int dy = 0;
					if (dist1_start < 0) ++npix;
					do
					{
						dist1_start -= m_di.dx_start();
						dist2_start += m_di.dx_start();
						if (dist1_start < 0) ++npix;
						if (dist2_start < 0) ++npix;
						++dy;
					}
					while (base.m_dist[dy] <= base.m_width);
					--base.m_step;
					if (npix == 0) break;
					npix = 0;
				}
				while (base.m_step >= -base.m_max_extent);
			}
			base.m_li.adjust_forward();
		}

		//---------------------------------------------------------------------
		public bool step_hor()
		{
			int dist_start;
			int dist;
			int dy;
			int s1 = base.step_hor_base(m_di);

			dist_start = m_di.dist_start();
			int Offset0 = max_half_width + 2;
			int Offset1 = Offset0;

			m_covers[Offset1] = 0;
			if (dist_start <= 0)
			{
				m_covers[Offset1] = (byte)base.m_ren.cover(s1);
			}
			++Offset1;

			dy = 1;
			while ((dist = base.m_dist[dy] - s1) <= base.m_width)
			{
				dist_start -= m_di.dx_start();
				m_covers[Offset1] = 0;
				if (dist_start <= 0)
				{
					m_covers[Offset1] = (byte)base.m_ren.cover(dist);
				}
				++Offset1;
				++dy;
			}

			dy = 1;
			dist_start = m_di.dist_start();
			while ((dist = base.m_dist[dy] + s1) <= base.m_width)
			{
				dist_start += m_di.dx_start();
				m_covers[--Offset0] = 0;
				if (dist_start <= 0)
				{
					m_covers[Offset0] = (byte)base.m_ren.cover(dist);
				}
				++dy;
			}

			int len = Offset1 - Offset0;
			base.m_ren.blend_solid_vspan(base.m_x,
											   base.m_y - dy + 1,
											   len, m_covers,
											   Offset0);
			return ++base.m_step < base.m_count;
		}

		//---------------------------------------------------------------------
		public bool step_ver()
		{
			int dist_start;
			int dist;
			int dx;
			int s1 = base.step_ver_base(m_di);
			int Offset0 = max_half_width + 2;
			int Offset1 = Offset0;

			dist_start = m_di.dist_start();

			m_covers[Offset1] = 0;
			if (dist_start <= 0)
			{
				m_covers[Offset1] = (byte)base.m_ren.cover(s1);
			}
			++Offset1;

			dx = 1;
			while ((dist = base.m_dist[dx] - s1) <= base.m_width)
			{
				dist_start += m_di.dy_start();
				m_covers[Offset1] = 0;
				if (dist_start <= 0)
				{
					m_covers[Offset1] = (byte)base.m_ren.cover(dist);
				}
				++Offset1;
				++dx;
			}

			dx = 1;
			dist_start = m_di.dist_start();
			while ((dist = base.m_dist[dx] + s1) <= base.m_width)
			{
				dist_start -= m_di.dy_start();
				m_covers[--Offset0] = 0;
				if (dist_start <= 0)
				{
					m_covers[Offset0] = (byte)base.m_ren.cover(dist);
				}
				++dx;
			}
			base.m_ren.blend_solid_hspan(base.m_x - dx + 1,
											   base.m_y,
											   Offset1 - Offset0, m_covers,
											   Offset0);

			return ++base.m_step < base.m_count;
		}
	};

	//====================================================line_interpolator_aa2
	public class line_interpolator_aa2 : line_interpolator_aa_base
	{
		private distance_interpolator2 m_di;
		//typedef Renderer renderer_type;
		//typedef line_interpolator_aa_base<Renderer> base_type;

		//---------------------------------------------------------------------
		public line_interpolator_aa2(OutlineRenderer ren, line_parameters lp,
							  int ex, int ey)
			:
			base(ren, lp)
		{
			m_di = new distance_interpolator2(lp.x1, lp.y1, lp.x2, lp.y2, ex, ey,
				 lp.x1 & ~LineAABasics.line_subpixel_mask, lp.y1 & ~LineAABasics.line_subpixel_mask,
				 0);
			base.m_li.adjust_forward();
			base.m_step -= base.m_max_extent;
		}

		//---------------------------------------------------------------------
		public bool step_hor()
		{
			int dist_end;
			int dist;
			int dy;
			int s1 = base.step_hor_base(m_di);
			int Offset0 = max_half_width + 2;
			int Offset1 = Offset0;

			dist_end = m_di.dist_end();

			int npix = 0;
			m_covers[Offset1] = 0;
			if (dist_end > 0)
			{
				m_covers[Offset1] = (byte)base.m_ren.cover(s1);
				++npix;
			}
			++Offset1;

			dy = 1;
			while ((dist = base.m_dist[dy] - s1) <= base.m_width)
			{
				dist_end -= m_di.dx_end();
				m_covers[Offset1] = 0;
				if (dist_end > 0)
				{
					m_covers[Offset1] = (byte)base.m_ren.cover(dist);
					++npix;
				}
				++Offset1;
				++dy;
			}

			dy = 1;
			dist_end = m_di.dist_end();
			while ((dist = base.m_dist[dy] + s1) <= base.m_width)
			{
				dist_end += m_di.dx_end();
				m_covers[--Offset0] = 0;
				if (dist_end > 0)
				{
					m_covers[Offset0] = (byte)base.m_ren.cover(dist);
					++npix;
				}
				++dy;
			}
			base.m_ren.blend_solid_vspan(base.m_x,
											   base.m_y - dy + 1,
											   Offset1 - Offset0, m_covers,
											   Offset0);
			return npix != 0 && ++base.m_step < base.m_count;
		}

		//---------------------------------------------------------------------
		public bool step_ver()
		{
			int dist_end;
			int dist;
			int dx;
			int s1 = base.step_ver_base(m_di);
			int Offset0 = max_half_width + 2;
			int Offset1 = Offset0;

			dist_end = m_di.dist_end();

			int npix = 0;
			m_covers[Offset1] = 0;
			if (dist_end > 0)
			{
				m_covers[Offset1] = (byte)base.m_ren.cover(s1);
				++npix;
			}
			++Offset1;

			dx = 1;
			while ((dist = base.m_dist[dx] - s1) <= base.m_width)
			{
				dist_end += m_di.dy_end();
				m_covers[Offset1] = 0;
				if (dist_end > 0)
				{
					m_covers[Offset1] = (byte)base.m_ren.cover(dist);
					++npix;
				}
				++Offset1;
				++dx;
			}

			dx = 1;
			dist_end = m_di.dist_end();
			while ((dist = base.m_dist[dx] + s1) <= base.m_width)
			{
				dist_end -= m_di.dy_end();
				m_covers[--Offset0] = 0;
				if (dist_end > 0)
				{
					m_covers[Offset0] = (byte)base.m_ren.cover(dist);
					++npix;
				}
				++dx;
			}
			base.m_ren.blend_solid_hspan(base.m_x - dx + 1,
											   base.m_y,
											   Offset1 - Offset0, m_covers,
											   Offset0);
			return npix != 0 && ++base.m_step < base.m_count;
		}
	};

	//====================================================line_interpolator_aa3
	public class line_interpolator_aa3 : line_interpolator_aa_base
	{
		private distance_interpolator3 m_di;
		//typedef Renderer renderer_type;
		//typedef line_interpolator_aa_base<Renderer> base_type;

		//---------------------------------------------------------------------
		public line_interpolator_aa3(OutlineRenderer ren, line_parameters lp,
							  int sx, int sy, int ex, int ey)
			:
			base(ren, lp)
		{
			m_di = new distance_interpolator3(lp.x1, lp.y1, lp.x2, lp.y2, sx, sy, ex, ey,
				 lp.x1 & ~LineAABasics.line_subpixel_mask, lp.y1 & ~LineAABasics.line_subpixel_mask);
			int dist1_start;
			int dist2_start;
			int npix = 1;
			if (lp.vertical)
			{
				do
				{
					base.m_li.Prev();
					base.m_y -= lp.inc;
					base.m_x = (base.m_lp.x1 + base.m_li.y()) >> LineAABasics.line_subpixel_shift;

					if (lp.inc > 0) m_di.dec_y(base.m_x - base.m_old_x);
					else m_di.inc_y(base.m_x - base.m_old_x);

					base.m_old_x = base.m_x;

					dist1_start = dist2_start = m_di.dist_start();

					int dx = 0;
					if (dist1_start < 0) ++npix;
					do
					{
						dist1_start += m_di.dy_start();
						dist2_start -= m_di.dy_start();
						if (dist1_start < 0) ++npix;
						if (dist2_start < 0) ++npix;
						++dx;
					}
					while (base.m_dist[dx] <= base.m_width);
					if (npix == 0) break;
					npix = 0;
				}
				while (--base.m_step >= -base.m_max_extent);
			}
			else
			{
				do
				{
					base.m_li.Prev();
					base.m_x -= lp.inc;
					base.m_y = (base.m_lp.y1 + base.m_li.y()) >> LineAABasics.line_subpixel_shift;

					if (lp.inc > 0) m_di.dec_x(base.m_y - base.m_old_y);
					else m_di.inc_x(base.m_y - base.m_old_y);

					base.m_old_y = base.m_y;

					dist1_start = dist2_start = m_di.dist_start();

					int dy = 0;
					if (dist1_start < 0) ++npix;
					do
					{
						dist1_start -= m_di.dx_start();
						dist2_start += m_di.dx_start();
						if (dist1_start < 0) ++npix;
						if (dist2_start < 0) ++npix;
						++dy;
					}
					while (base.m_dist[dy] <= base.m_width);
					if (npix == 0) break;
					npix = 0;
				}
				while (--base.m_step >= -base.m_max_extent);
			}
			base.m_li.adjust_forward();
			base.m_step -= base.m_max_extent;
		}

		//---------------------------------------------------------------------
		public bool step_hor()
		{
			int dist_start;
			int dist_end;
			int dist;
			int dy;
			int s1 = base.step_hor_base(m_di);
			int Offset0 = max_half_width + 2;
			int Offset1 = Offset0;

			dist_start = m_di.dist_start();
			dist_end = m_di.dist_end();

			int npix = 0;
			m_covers[Offset1] = 0;
			if (dist_end > 0)
			{
				if (dist_start <= 0)
				{
					m_covers[Offset1] = (byte)base.m_ren.cover(s1);
				}
				++npix;
			}
			++Offset1;

			dy = 1;
			while ((dist = base.m_dist[dy] - s1) <= base.m_width)
			{
				dist_start -= m_di.dx_start();
				dist_end -= m_di.dx_end();
				m_covers[Offset1] = 0;
				if (dist_end > 0 && dist_start <= 0)
				{
					m_covers[Offset1] = (byte)base.m_ren.cover(dist);
					++npix;
				}
				++Offset1;
				++dy;
			}

			dy = 1;
			dist_start = m_di.dist_start();
			dist_end = m_di.dist_end();
			while ((dist = base.m_dist[dy] + s1) <= base.m_width)
			{
				dist_start += m_di.dx_start();
				dist_end += m_di.dx_end();
				m_covers[--Offset0] = 0;
				if (dist_end > 0 && dist_start <= 0)
				{
					m_covers[Offset0] = (byte)base.m_ren.cover(dist);
					++npix;
				}
				++dy;
			}
			base.m_ren.blend_solid_vspan(base.m_x,
											   base.m_y - dy + 1,
											   Offset1 - Offset0, m_covers,
											   Offset0);
			return npix != 0 && ++base.m_step < base.m_count;
		}

		//---------------------------------------------------------------------
		public bool step_ver()
		{
			int dist_start;
			int dist_end;
			int dist;
			int dx;
			int s1 = base.step_ver_base(m_di);
			int Offset0 = max_half_width + 2;
			int Offset1 = Offset0;

			dist_start = m_di.dist_start();
			dist_end = m_di.dist_end();

			int npix = 0;
			m_covers[Offset1] = 0;
			if (dist_end > 0)
			{
				if (dist_start <= 0)
				{
					m_covers[Offset1] = (byte)base.m_ren.cover(s1);
				}
				++npix;
			}
			++Offset1;

			dx = 1;
			while ((dist = base.m_dist[dx] - s1) <= base.m_width)
			{
				dist_start += m_di.dy_start();
				dist_end += m_di.dy_end();
				m_covers[Offset1] = 0;
				if (dist_end > 0 && dist_start <= 0)
				{
					m_covers[Offset1] = (byte)base.m_ren.cover(dist);
					++npix;
				}
				++Offset1;
				++dx;
			}

			dx = 1;
			dist_start = m_di.dist_start();
			dist_end = m_di.dist_end();
			while ((dist = base.m_dist[dx] + s1) <= base.m_width)
			{
				dist_start -= m_di.dy_start();
				dist_end -= m_di.dy_end();
				m_covers[--Offset0] = 0;
				if (dist_end > 0 && dist_start <= 0)
				{
					m_covers[Offset0] = (byte)base.m_ren.cover(dist);
					++npix;
				}
				++dx;
			}
			base.m_ren.blend_solid_hspan(base.m_x - dx + 1,
											   base.m_y,
											   Offset1 - Offset0, m_covers,
											   Offset0);
			return npix != 0 && ++base.m_step < base.m_count;
		}
	};

	//==========================================================line_profile_aa
	//
	// See Implementation agg_line_profile_aa.cpp
	//
	public class LineProfileAnitAlias
	{
		private const int subpixel_shift = 8;
		private const int subpixel_scale = 1 << subpixel_shift;
		private const int subpixel_mask = subpixel_scale - 1;

		private const int aa_shift = 8;
		private const int aa_scale = 1 << aa_shift;
		private const int aa_mask = aa_scale - 1;

		private ArrayPOD<byte> m_profile = new ArrayPOD<byte>();
		private byte[] m_gamma = new byte[aa_scale];
		private int m_subpixel_width;
		private double m_min_width;
		private double m_smoother_width;

		//---------------------------------------------------------------------

		//---------------------------------------------------------------------
		public LineProfileAnitAlias()
		{
			m_subpixel_width = (0);
			m_min_width = (1.0);
			m_smoother_width = (1.0);

			int i;
			for (i = 0; i < aa_scale; i++) m_gamma[i] = (byte)i;
		}

		//---------------------------------------------------------------------
		public LineProfileAnitAlias(double w, IGammaFunction gamma_function)
		{
			m_subpixel_width = (0);
			m_min_width = (1.0);
			m_smoother_width = (1.0);
			gamma(gamma_function);
			width(w);
		}

		//---------------------------------------------------------------------
		public void min_width(double w)
		{
			m_min_width = w;
		}

		public void smoother_width(double w)
		{
			m_smoother_width = w;
		}

		//---------------------------------------------------------------------
		public void gamma(IGammaFunction gamma_function)
		{
			int i;
			for (i = 0; i < aa_scale; i++)
			{
				m_gamma[i] = (byte)(Util.uround(gamma_function.GetGamma((double)(i) / aa_mask) * aa_mask));
			}
		}

		public void width(double w)
		{
			if (w < 0.0) w = 0.0;

			if (w < m_smoother_width) w += w;
			else w += m_smoother_width;

			w *= 0.5;

			w -= m_smoother_width;
			double s = m_smoother_width;
			if (w < 0.0)
			{
				s += w;
				w = 0.0;
			}
			set(w, s);
		}

		public int profile_size()
		{
			return m_profile.Size();
		}

		public int subpixel_width()
		{
			return m_subpixel_width;
		}

		//---------------------------------------------------------------------
		public double min_width()
		{
			return m_min_width;
		}

		public double smoother_width()
		{
			return m_smoother_width;
		}

		//---------------------------------------------------------------------
		public byte value(int dist)
		{
			return m_profile.Array[dist + subpixel_scale * 2];
		}

		private byte[] profile(double w)
		{
			m_subpixel_width = (int)Util.uround(w * subpixel_scale);
			int size = m_subpixel_width + subpixel_scale * 6;
			if (size > m_profile.Size())
			{
				m_profile.Resize(size);
			}
			return m_profile.Array;
		}

		private void set(double center_width, double smoother_width)
		{
			double base_val = 1.0;
			if (center_width == 0.0) center_width = 1.0 / subpixel_scale;
			if (smoother_width == 0.0) smoother_width = 1.0 / subpixel_scale;

			double width = center_width + smoother_width;
			if (width < m_min_width)
			{
				double k = width / m_min_width;
				base_val *= k;
				center_width /= k;
				smoother_width /= k;
			}

			byte[] ch = profile(center_width + smoother_width);
			int chIndex = 0;

			int subpixel_center_width = (int)(center_width * subpixel_scale);
			int subpixel_smoother_width = (int)(smoother_width * subpixel_scale);

			int ch_center = subpixel_scale * 2;
			int ch_smoother = ch_center + subpixel_center_width;

			int i;

			int val = m_gamma[(int)(base_val * aa_mask)];
			chIndex = ch_center;
			for (i = 0; i < subpixel_center_width; i++)
			{
				ch[chIndex++] = (byte)val;
			}

			for (i = 0; i < subpixel_smoother_width; i++)
			{
				ch[ch_smoother++] =
					m_gamma[(int)((base_val -
									  base_val *
									  ((double)(i) / subpixel_smoother_width)) * aa_mask)];
			}

			int n_smoother = ch.Length -
								  subpixel_smoother_width -
								  subpixel_center_width -
								  subpixel_scale * 2;

			val = m_gamma[0];
			for (i = 0; i < n_smoother; i++)
			{
				ch[ch_smoother++] = (byte)val;
			}

			chIndex = ch_center;
			for (i = 0; i < subpixel_scale * 2; i++)
			{
				ch[--chIndex] = ch[ch_center++];
			}

			for (i = 0; i < ch.Length; i++)
			{
				m_profile.Array[i] = ch[i];
			}
		}
	};

	public class ellipse_bresenham_interpolator
	{
		private int m_rx2;
		private int m_ry2;
		private int m_two_rx2;
		private int m_two_ry2;
		private int m_dx;
		private int m_dy;
		private int m_inc_x;
		private int m_inc_y;
		private int m_cur_f;

		public ellipse_bresenham_interpolator(int rx, int ry)
		{
			m_rx2 = (rx * rx);
			m_ry2 = (ry * ry);
			m_two_rx2 = (m_rx2 << 1);
			m_two_ry2 = (m_ry2 << 1);
			m_dx = (0);
			m_dy = (0);
			m_inc_x = (0);
			m_inc_y = (-ry * m_two_rx2);
			m_cur_f = (0);
		}

		public int dx()
		{
			return m_dx;
		}

		public int dy()
		{
			return m_dy;
		}

		public void Next()
		{
			int mx, my, mxy, min_m;
			int fx, fy, fxy;

			mx = fx = m_cur_f + m_inc_x + m_ry2;
			if (mx < 0) mx = -mx;

			my = fy = m_cur_f + m_inc_y + m_rx2;
			if (my < 0) my = -my;

			mxy = fxy = m_cur_f + m_inc_x + m_ry2 + m_inc_y + m_rx2;
			if (mxy < 0) mxy = -mxy;

			min_m = mx;
			bool flag = true;

			if (min_m > my)
			{
				min_m = my;
				flag = false;
			}

			m_dx = m_dy = 0;

			if (min_m > mxy)
			{
				m_inc_x += m_two_ry2;
				m_inc_y += m_two_rx2;
				m_cur_f = fxy;
				m_dx = 1;
				m_dy = 1;
				return;
			}

			if (flag)
			{
				m_inc_x += m_two_ry2;
				m_cur_f = fx;
				m_dx = 1;
				return;
			}

			m_inc_y += m_two_rx2;
			m_cur_f = fy;
			m_dy = 1;
		}
	};

	public abstract class LineRenderer
	{
		private Color m_color;

		public delegate bool CompareFunction(int value);

		public Color color()
		{
			return m_color;
		}

		public void color(IColorType c)
		{
			m_color = c.ToColor();
		}

		public abstract void semidot(CompareFunction cmp, int xc1, int yc1, int xc2, int yc2);

		public abstract void semidot_hline(CompareFunction cmp, int xc1, int yc1, int xc2, int yc2, int x1, int y1, int x2);

		public abstract void pie(int xc, int yc, int x1, int y1, int x2, int y2);

		public abstract void line0(line_parameters lp);

		public abstract void line1(line_parameters lp, int sx, int sy);

		public abstract void line2(line_parameters lp, int ex, int ey);

		public abstract void line3(line_parameters lp, int sx, int sy, int ex, int ey);
	}

	//======================================================renderer_outline_aa
	public class OutlineRenderer : LineRenderer
	{
		private IImageByte destImageSurface;
		private LineProfileAnitAlias lineProfile;
		private RectangleInt clippingRectangle;
		private bool doClipping;
		protected const int max_half_width = 64;

#if false
        public int min_x() { throw new System.NotImplementedException(); }
        public int min_y() { throw new System.NotImplementedException(); }
        public int max_x() { throw new System.NotImplementedException(); }
        public int max_y() { throw new System.NotImplementedException(); }
        public void gamma(IGammaFunction gamma_function) { throw new System.NotImplementedException(); }
        public bool sweep_scanline(IScanlineCache sl) { throw new System.NotImplementedException(); }
        public void reset() { throw new System.NotImplementedException(); }
#endif

		//---------------------------------------------------------------------
		public OutlineRenderer(IImageByte destImage, LineProfileAnitAlias profile)
		{
			destImageSurface = destImage;
			lineProfile = profile;
			clippingRectangle = new RectangleInt(0, 0, 0, 0);
			doClipping = false;
		}

		public void attach(IImageByte ren)
		{
			destImageSurface = ren;
		}

		//---------------------------------------------------------------------
		public void profile(LineProfileAnitAlias prof)
		{
			lineProfile = prof;
		}

		public LineProfileAnitAlias profile()
		{
			return lineProfile;
		}

		//---------------------------------------------------------------------
		public int subpixel_width()
		{
			return lineProfile.subpixel_width();
		}

		//---------------------------------------------------------------------
		public void reset_clipping()
		{
			doClipping = false;
		}

		public void clip_box(double x1, double y1, double x2, double y2)
		{
			clippingRectangle.Left = line_coord_sat.conv(x1);
			clippingRectangle.Bottom = line_coord_sat.conv(y1);
			clippingRectangle.Right = line_coord_sat.conv(x2);
			clippingRectangle.Top = line_coord_sat.conv(y2);
			doClipping = true;
		}

		//---------------------------------------------------------------------
		public int cover(int d)
		{
			return lineProfile.value(d);
		}

		public void blend_solid_hspan(int x, int y, int len, byte[] covers, int coversOffset)
		{
			destImageSurface.blend_solid_hspan(x, y, len, color(), covers, coversOffset);
		}

		public void blend_solid_vspan(int x, int y, int len, byte[] covers, int coversOffset)
		{
			destImageSurface.blend_solid_vspan(x, y, len, color(), covers, coversOffset);
		}

		public static bool accurate_join_only()
		{
			return false;
		}

		public override void semidot_hline(CompareFunction cmp,
						   int xc1, int yc1, int xc2, int yc2,
						   int x1, int y1, int x2)
		{
			byte[] covers = new byte[max_half_width * 2 + 4];
			int Offset0 = 0;
			int Offset1 = 0;
			int x = x1 << LineAABasics.line_subpixel_shift;
			int y = y1 << LineAABasics.line_subpixel_shift;
			int w = subpixel_width();
			distance_interpolator0 di = new distance_interpolator0(xc1, yc1, xc2, yc2, x, y);
			x += LineAABasics.line_subpixel_scale / 2;
			y += LineAABasics.line_subpixel_scale / 2;

			int x0 = x1;
			int dx = x - xc1;
			int dy = y - yc1;
			do
			{
				int d = (int)(agg_math.fast_sqrt(dx * dx + dy * dy));
				covers[Offset1] = 0;
				if (cmp(di.dist()) && d <= w)
				{
					covers[Offset1] = (byte)cover(d);
				}
				++Offset1;
				dx += LineAABasics.line_subpixel_scale;
				di.inc_x();
			}
			while (++x1 <= x2);
			destImageSurface.blend_solid_hspan(x0, y1,
									 Offset1 - Offset0,
									 color(), covers,
									 Offset0);
		}

		public override void semidot(CompareFunction cmp, int xc1, int yc1, int xc2, int yc2)
		{
			if (doClipping && ClipLiangBarsky.clipping_flags(xc1, yc1, clippingRectangle) != 0) return;

			int r = ((subpixel_width() + LineAABasics.line_subpixel_mask) >> LineAABasics.line_subpixel_shift);
			if (r < 1) r = 1;
			ellipse_bresenham_interpolator ei = new ellipse_bresenham_interpolator(r, r);
			int dx = 0;
			int dy = -r;
			int dy0 = dy;
			int dx0 = dx;
			int x = xc1 >> LineAABasics.line_subpixel_shift;
			int y = yc1 >> LineAABasics.line_subpixel_shift;

			do
			{
				dx += ei.dx();
				dy += ei.dy();

				if (dy != dy0)
				{
					semidot_hline(cmp, xc1, yc1, xc2, yc2, x - dx0, y + dy0, x + dx0);
					semidot_hline(cmp, xc1, yc1, xc2, yc2, x - dx0, y - dy0, x + dx0);
				}
				dx0 = dx;
				dy0 = dy;
				ei.Next();
			}
			while (dy < 0);
			semidot_hline(cmp, xc1, yc1, xc2, yc2, x - dx0, y + dy0, x + dx0);
		}

		public void pie_hline(int xc, int yc, int xp1, int yp1, int xp2, int yp2,
					   int xh1, int yh1, int xh2)
		{
			if (doClipping && ClipLiangBarsky.clipping_flags(xc, yc, clippingRectangle) != 0) return;

			byte[] covers = new byte[max_half_width * 2 + 4];
			int index0 = 0;
			int index1 = 0;
			int x = xh1 << LineAABasics.line_subpixel_shift;
			int y = yh1 << LineAABasics.line_subpixel_shift;
			int w = subpixel_width();

			distance_interpolator00 di = new distance_interpolator00(xc, yc, xp1, yp1, xp2, yp2, x, y);
			x += LineAABasics.line_subpixel_scale / 2;
			y += LineAABasics.line_subpixel_scale / 2;

			int xh0 = xh1;
			int dx = x - xc;
			int dy = y - yc;
			do
			{
				int d = (int)(agg_math.fast_sqrt(dx * dx + dy * dy));
				covers[index1] = 0;
				if (di.dist1() <= 0 && di.dist2() > 0 && d <= w)
				{
					covers[index1] = (byte)cover(d);
				}
				++index1;
				dx += LineAABasics.line_subpixel_scale;
				di.inc_x();
			}
			while (++xh1 <= xh2);
			destImageSurface.blend_solid_hspan(xh0, yh1, index1 - index0, color(), covers, index0);
		}

		public override void pie(int xc, int yc, int x1, int y1, int x2, int y2)
		{
			int r = ((subpixel_width() + LineAABasics.line_subpixel_mask) >> LineAABasics.line_subpixel_shift);
			if (r < 1) r = 1;
			ellipse_bresenham_interpolator ei = new ellipse_bresenham_interpolator(r, r);
			int dx = 0;
			int dy = -r;
			int dy0 = dy;
			int dx0 = dx;
			int x = xc >> LineAABasics.line_subpixel_shift;
			int y = yc >> LineAABasics.line_subpixel_shift;

			do
			{
				dx += ei.dx();
				dy += ei.dy();

				if (dy != dy0)
				{
					pie_hline(xc, yc, x1, y1, x2, y2, x - dx0, y + dy0, x + dx0);
					pie_hline(xc, yc, x1, y1, x2, y2, x - dx0, y - dy0, x + dx0);
				}
				dx0 = dx;
				dy0 = dy;
				ei.Next();
			}
			while (dy < 0);
			pie_hline(xc, yc, x1, y1, x2, y2, x - dx0, y + dy0, x + dx0);
		}

		public void line0_no_clip(line_parameters lp)
		{
			if (lp.len > LineAABasics.line_max_length)
			{
				line_parameters lp1, lp2;
				lp.divide(out lp1, out lp2);
				line0_no_clip(lp1);
				line0_no_clip(lp2);
				return;
			}

			line_interpolator_aa0 li = new line_interpolator_aa0(this, lp);
			if (li.count() != 0)
			{
				if (li.vertical())
				{
					while (li.step_ver()) ;
				}
				else
				{
					while (li.step_hor()) ;
				}
			}
		}

		public override void line0(line_parameters lp)
		{
			if (doClipping)
			{
				int x1 = lp.x1;
				int y1 = lp.y1;
				int x2 = lp.x2;
				int y2 = lp.y2;
				int flags = ClipLiangBarsky.clip_line_segment(ref x1, ref y1, ref x2, ref y2, clippingRectangle);
				if ((flags & 4) == 0)
				{
					if (flags != 0)
					{
						line_parameters lp2 = new line_parameters(x1, y1, x2, y2,
										   Util.uround(agg_math.CalcDistance(x1, y1, x2, y2)));
						line0_no_clip(lp2);
					}
					else
					{
						line0_no_clip(lp);
					}
				}
			}
			else
			{
				line0_no_clip(lp);
			}
		}

		public void line1_no_clip(line_parameters lp, int sx, int sy)
		{
			if (lp.len > LineAABasics.line_max_length)
			{
				line_parameters lp1, lp2;
				lp.divide(out lp1, out lp2);
				line1_no_clip(lp1, (lp.x1 + sx) >> 1, (lp.y1 + sy) >> 1);
				line1_no_clip(lp2, lp1.x2 + (lp1.y2 - lp1.y1), lp1.y2 - (lp1.x2 - lp1.x1));
				return;
			}

			LineAABasics.fix_degenerate_bisectrix_start(lp, ref sx, ref sy);
			line_interpolator_aa1 li = new line_interpolator_aa1(this, lp, sx, sy);
			if (li.vertical())
			{
				while (li.step_ver()) ;
			}
			else
			{
				while (li.step_hor()) ;
			}
		}

		public override void line1(line_parameters lp, int sx, int sy)
		{
			if (doClipping)
			{
				int x1 = lp.x1;
				int y1 = lp.y1;
				int x2 = lp.x2;
				int y2 = lp.y2;
				int flags = ClipLiangBarsky.clip_line_segment(ref x1, ref y1, ref x2, ref y2, clippingRectangle);
				if ((flags & 4) == 0)
				{
					if (flags != 0)
					{
						line_parameters lp2 = new line_parameters(x1, y1, x2, y2,
										   Util.uround(agg_math.CalcDistance(x1, y1, x2, y2)));
						if (((int)flags & 1) != 0)
						{
							sx = x1 + (y2 - y1);
							sy = y1 - (x2 - x1);
						}
						else
						{
							while (Math.Abs(sx - lp.x1) + Math.Abs(sy - lp.y1) > lp2.len)
							{
								sx = (lp.x1 + sx) >> 1;
								sy = (lp.y1 + sy) >> 1;
							}
						}
						line1_no_clip(lp2, sx, sy);
					}
					else
					{
						line1_no_clip(lp, sx, sy);
					}
				}
			}
			else
			{
				line1_no_clip(lp, sx, sy);
			}
		}

		public void line2_no_clip(line_parameters lp, int ex, int ey)
		{
			if (lp.len > LineAABasics.line_max_length)
			{
				line_parameters lp1, lp2;
				lp.divide(out lp1, out lp2);
				line2_no_clip(lp1, lp1.x2 + (lp1.y2 - lp1.y1), lp1.y2 - (lp1.x2 - lp1.x1));
				line2_no_clip(lp2, (lp.x2 + ex) >> 1, (lp.y2 + ey) >> 1);
				return;
			}

			LineAABasics.fix_degenerate_bisectrix_end(lp, ref ex, ref ey);
			line_interpolator_aa2 li = new line_interpolator_aa2(this, lp, ex, ey);
			if (li.vertical())
			{
				while (li.step_ver()) ;
			}
			else
			{
				while (li.step_hor()) ;
			}
		}

		public override void line2(line_parameters lp, int ex, int ey)
		{
			if (doClipping)
			{
				int x1 = lp.x1;
				int y1 = lp.y1;
				int x2 = lp.x2;
				int y2 = lp.y2;
				int flags = ClipLiangBarsky.clip_line_segment(ref x1, ref y1, ref x2, ref y2, clippingRectangle);
				if ((flags & 4) == 0)
				{
					if (flags != 0)
					{
						line_parameters lp2 = new line_parameters(x1, y1, x2, y2,
										   Util.uround(agg_math.CalcDistance(x1, y1, x2, y2)));
						if ((flags & 2) != 0)
						{
							ex = x2 + (y2 - y1);
							ey = y2 - (x2 - x1);
						}
						else
						{
							while (Math.Abs(ex - lp.x2) + Math.Abs(ey - lp.y2) > lp2.len)
							{
								ex = (lp.x2 + ex) >> 1;
								ey = (lp.y2 + ey) >> 1;
							}
						}
						line2_no_clip(lp2, ex, ey);
					}
					else
					{
						line2_no_clip(lp, ex, ey);
					}
				}
			}
			else
			{
				line2_no_clip(lp, ex, ey);
			}
		}

		public void line3_no_clip(line_parameters lp,
						   int sx, int sy, int ex, int ey)
		{
			if (lp.len > LineAABasics.line_max_length)
			{
				line_parameters lp1, lp2;
				lp.divide(out lp1, out lp2);
				int mx = lp1.x2 + (lp1.y2 - lp1.y1);
				int my = lp1.y2 - (lp1.x2 - lp1.x1);
				line3_no_clip(lp1, (lp.x1 + sx) >> 1, (lp.y1 + sy) >> 1, mx, my);
				line3_no_clip(lp2, mx, my, (lp.x2 + ex) >> 1, (lp.y2 + ey) >> 1);
				return;
			}

			LineAABasics.fix_degenerate_bisectrix_start(lp, ref sx, ref sy);
			LineAABasics.fix_degenerate_bisectrix_end(lp, ref ex, ref ey);
			line_interpolator_aa3 li = new line_interpolator_aa3(this, lp, sx, sy, ex, ey);
			if (li.vertical())
			{
				while (li.step_ver()) ;
			}
			else
			{
				while (li.step_hor()) ;
			}
		}

		public override void line3(line_parameters lp,
				   int sx, int sy, int ex, int ey)
		{
			if (doClipping)
			{
				int x1 = lp.x1;
				int y1 = lp.y1;
				int x2 = lp.x2;
				int y2 = lp.y2;
				int flags = ClipLiangBarsky.clip_line_segment(ref x1, ref y1, ref x2, ref y2, clippingRectangle);
				if ((flags & 4) == 0)
				{
					if (flags != 0)
					{
						line_parameters lp2 = new line_parameters(x1, y1, x2, y2,
							Util.uround(agg_math.CalcDistance(x1, y1, x2, y2)));
						if ((flags & 1) != 0)
						{
							sx = x1 + (y2 - y1);
							sy = y1 - (x2 - x1);
						}
						else
						{
							while (Math.Abs(sx - lp.x1) + Math.Abs(sy - lp.y1) > lp2.len)
							{
								sx = (lp.x1 + sx) >> 1;
								sy = (lp.y1 + sy) >> 1;
							}
						}
						if ((flags & 2) != 0)
						{
							ex = x2 + (y2 - y1);
							ey = y2 - (x2 - x1);
						}
						else
						{
							while (Math.Abs(ex - lp.x2) + Math.Abs(ey - lp.y2) > lp2.len)
							{
								ex = (lp.x2 + ex) >> 1;
								ey = (lp.y2 + ey) >> 1;
							}
						}
						line3_no_clip(lp2, sx, sy, ex, ey);
					}
					else
					{
						line3_no_clip(lp, sx, sy, ex, ey);
					}
				}
			}
			else
			{
				line3_no_clip(lp, sx, sy, ex, ey);
			}
		}
	};

#endif
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Platform\AggContext.cs
/*
Copyright (c) 2019, Lars Brubaker, John Lewin
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using MatterHackers.Agg.Font;
using System;

namespace MatterHackers.Agg.Platform
{
	public enum OSType
	{
		Unknown,
		Windows,
		Mac,
		X11,
		Other,
		Android
	}

	public static class AggContext
	{
		private static IFileDialogProvider _fileDialogs = null;
		private static IOsInformationProvider _osInformation = null;
		private static PlatformConfig _config = null;

		/// <summary>
		/// Construct the specified type from a fully qualified typename
		/// </summary>
		/// <typeparam name="T">The type to construct</typeparam>
		/// <param name="typeString">The fully qualified typename: i.e. "MyNamespace.MyType, MyAssembly"</param>
		/// <returns>An instance of the given type</returns>
		public static T CreateInstanceFrom<T>(string typeString) where T : class
		{
			var type = Type.GetType(typeString);
			return (type == null) ? null : Activator.CreateInstance(type) as T;
		}


		public static IFileDialogProvider FileDialogs
		{
			get
			{
				if (_fileDialogs == null)
				{
					// FileDialog Provider
					FileDialogs = CreateInstanceFrom<IFileDialogProvider>(Config.ProviderTypes.DialogProvider);
				}

				return _fileDialogs;
			}

			set
			{
				_fileDialogs = value;
			}
		}

		public static IOsInformationProvider OsInformation
		{
			get
			{
				if (_osInformation == null)
				{
					// OsInformation Provider
					OsInformation = CreateInstanceFrom<IOsInformationProvider>(Config.ProviderTypes.OsInformationProvider);
				}

				return _osInformation;
			}

			set
			{
				_osInformation = value;
			}
		}

		public static long PhysicalMemory => OsInformation.PhysicalMemory;

		public static OSType OperatingSystem => OsInformation.OperatingSystem;

		public static Point2D DesktopSize => OsInformation.DesktopSize;

		public static PlatformConfig Config
		{
			get
			{
				if (_config == null)
				{
					_config = new PlatformConfig();
				}

				return _config;
			}
		}

		public class PlatformConfig
		{
			public ProviderSettings ProviderTypes { get; set; } = new ProviderSettings();

			public AggGraphicsMode GraphicsMode { get; set; } = new AggGraphicsMode();
		}

		public class ProviderSettings
		{
			public string OsInformationProvider { get; set; } = "MatterHackers.Agg.Platform.WinformsInformationProvider, agg_platform_win32";

			public string DialogProvider { get; set; } = "MatterHackers.Agg.Platform.WinformsFileDialogProvider, agg_platform_win32";

			public string SystemWindowProvider { get; set; } = "MatterHackers.Agg.UI.BitmapWinformsWindowProvider, agg_platform_win32";
		}

		public class AggGraphicsMode
		{
			/// <summary>
			/// Gets or sets the ColorFormat of the color buffer - when cast from int, constructs a new ColorFormat with the specified aggregate bits per pixel
			/// </summary>
			public int Color { get; set; } = 32;

			/// <summary>
			/// Gets or sets the number of bits in the depth buffer - a System.Int32 that contains the bits per pixel for the depth buffer
			/// </summary>
			public int Depth { get; set; } = 24;

			/// <summary>
			/// Gets or sets the number of bits in the stencil buffer - a System.Int32 that contains the bits per pixel for the stencil buffer
			/// </summary>
			public int Stencil { get; set; } = 0;

			/// <summary>
			/// Gets or sets the number of samples for FSAA - a System.Int32 that contains the number of FSAA samples per pixel
			/// </summary>
			public int FSAASamples { get; set; } = 8;
		}

		public static TypeFace DefaultFont { get; set; } = LiberationSansFont.Instance;

		public static TypeFace DefaultFontBold { get; set; } = LiberationSansBoldFont.Instance;

		public static TypeFace DefaultFontItalic { get; set; } = LiberationSansFont.Instance;

		public static TypeFace DefaultFontBoldItalic { get; set; } = LiberationSansBoldFont.Instance;
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Platform\FileDialogs\FileDialogParams.cs
using System;

namespace MatterHackers.Agg.Platform
{
	public abstract class FileDialogParams
	{
		public FileDialogParams(string fileTypeFilter, string initialDirectory, string title, string actionButtonLabel)
		{
			this.Filter = fileTypeFilter;
			this.InitialDirectory = initialDirectory;
			this.Title = title;
			this.ActionButtonLabel = actionButtonLabel;
		}

		public int FilterIndex { get; set; }

		/// <summary>
		/// The title of the dialog window. If not set will show 'Open' or 'Save' as appropriate
		/// </summary>
		public string Title { get; set; }

		/// <summary>
		/// This does not show on Windows (but does on Mac)
		/// </summary>
		public string ActionButtonLabel { get; set; }

		/// <summary>
		/// The following are complete examples of valid Filter string values:
		/// All Files|*.*
		/// Word Documents|*.doc|All Files|*.*
		/// </summary>
		public string Filter { get; set; }

		public string InitialDirectory { get; set; }

		public string FileName { get; set; }

		public string[] FileNames { get; set; }
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Platform\FileDialogs\OpenFileDialogPrams.cs
using System;

namespace MatterHackers.Agg.Platform
{
	public class OpenFileDialogParams : FileDialogParams
	{
		public bool MultiSelect { get; set; }

		/// <summary>
		/// These are the parameters passed to an open file dialog
		/// </summary>
		/// <param name="fileTypeFilter">The following are complete examples of valid Filter string values: "All Files|*.*", "Word Documents|*.doc|All Files|*.*"</param>
		/// <param name="initialDirectory">Where to start</param>
		/// <param name="multiSelect">Allow more than one file selection</param>
		/// <param name="title">What are we opening</param>
		/// <param name="actionButtonLabel">The text on the 'Open' button</param>
		public OpenFileDialogParams(string fileTypeFilter, string initialDirectory = "", bool multiSelect = false, string title = "", string actionButtonLabel = "")
			: base(fileTypeFilter, initialDirectory, title, actionButtonLabel)
		{
			this.MultiSelect = multiSelect;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Platform\FileDialogs\SaveFileDialogParams.cs
using System;

namespace MatterHackers.Agg.Platform
{
	public class SaveFileDialogParams : FileDialogParams
	{
		/// The following are examples of valid Filter string values:
		///   Word Documents|*.doc
		///   All Files|*.*
		///   Word Documents|*.doc|Excel Worksheets|*.xls|PowerPoint Presentations|*.ppt|Office Files|*.doc;*.xls;*.ppt|All Files|*.*
		public SaveFileDialogParams(string fileTypeFilter, string initialDirectory = "", string title = "", string actionButtonLabel = "")
			: base(fileTypeFilter, initialDirectory, title, actionButtonLabel)
		{
			if (InitialDirectory == "")
			{
				InitialDirectory = AggContext.FileDialogs.LastDirectoryUsed;
			}
		}
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Platform\FileDialogs\SelectFolderDialogParams.cs
using System;

namespace MatterHackers.Agg.Platform
{
	public class SelectFolderDialogParams
	{
		public enum RootFolderTypes
		{
			MyComputer,
            Specify
		};

		public string Description { get; set; }

		public RootFolderTypes RootFolder { get; set; }

		public string FolderPath { get; set; }

		public bool ShowNewFolderButton { get; set; }

		/// <summary>
		/// The title of the dialog window. If not set will show 'Open' or 'Save' as appropriate
		/// </summary>
		public string Title { get; set; }

		/// <summary>
		/// This does not show on Windows (but does on mac.
		/// </summary>
		public string ActionButtonLabel { get; set; }

		public SelectFolderDialogParams(string description, RootFolderTypes rootFolder = RootFolderTypes.MyComputer, bool showNewFolderButton = true, string title = "", string actionButtonLabel = "")
		{
			this.Description = description;
			this.RootFolder = rootFolder;
			this.ShowNewFolderButton = showNewFolderButton;
			this.Title = title;
			this.ActionButtonLabel = actionButtonLabel;
		}
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Platform\Providers\IFileDialogProvider.cs
using System;

namespace MatterHackers.Agg.Platform
{
	/// <summary>
	/// The FileDialog provider interface
	/// </summary>
	public interface IFileDialogProvider
	{
		string LastDirectoryUsed { get; }

		string ResolveFilePath(string path);

		bool OpenFileDialog(OpenFileDialogParams openParams, Action<OpenFileDialogParams> callback);

		bool SelectFolderDialog(SelectFolderDialogParams folderParams, Action<SelectFolderDialogParams> callback);

		bool SaveFileDialog(SaveFileDialogParams saveParams, Action<SaveFileDialogParams> callback);

		void ShowFileInFolder(string fileName);
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Platform\Providers\IOsInformationProvider.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MatterHackers.Agg.Platform
{
	public interface IOsInformationProvider
	{
		OSType OperatingSystem { get; }
		Point2D DesktopSize { get; }
		long PhysicalMemory { get; }
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\agg_bounding_rect.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// bounding_rect function template
//
//----------------------------------------------------------------------------
using MatterHackers.Agg.VertexSource;

namespace MatterHackers.Agg
{
	static public class bounding_rect
	{
		public static bool get_bounding_rect(VertexStorage vs, int[] gi,
						   int start, int num,
						   out double x1, out double y1, out double x2, out double y2)
		{
			int i;
			double x = 0;
			double y = 0;
			bool first = true;

			x1 = 1;
			y1 = 1;
			x2 = 0;
			y2 = 0;

			for (i = 0; i < num; i++)
			{
				vs.Rewind(gi[start + i]);
				FlagsAndCommand PathAndFlags;
				while (!ShapePath.IsStop(PathAndFlags = vs.Vertex(out x, out y)))
				{
					if (ShapePath.IsVertex(PathAndFlags))
					{
						if (first)
						{
							x1 = x;
							y1 = y;
							x2 = x;
							y2 = y;
							first = false;
						}
						else
						{
							if (x < x1) x1 = x;
							if (y < y1) y1 = y;
							if (x > x2) x2 = x;
							if (y > y2) y2 = y;
						}
					}
				}
			}
			return x1 <= x2 && y1 <= y2;
		}

		public static bool get_bounding_rect(VertexStorage vs, int[] gi,
						   int start, int num,
						   out RectangleDouble boundingRect)
		{
			return get_bounding_rect(vs, gi, start, num, out boundingRect.Left, out boundingRect.Bottom, out boundingRect.Right, out boundingRect.Top);
		}

		public static bool bounding_rect_single(IVertexSource vs, int path_id, ref RectangleDouble rect)
		{
			double x1, y1, x2, y2;
			bool rValue = bounding_rect_single(vs, path_id, out x1, out y1, out x2, out y2);
			rect.Left = x1;
			rect.Bottom = y1;
			rect.Right = x2;
			rect.Top = y2;
			return rValue;
		}

		//-----------------------------------------------------bounding_rect_single
		//template<class VertexSource, class CoordT>
		public static bool bounding_rect_single(IVertexSource vs, int path_id,
								  out double x1, out double y1, out double x2, out double y2)
		{
			double x = 0;
			double y = 0;
			bool first = true;

			x1 = 1;
			y1 = 1;
			x2 = 0;
			y2 = 0;

			vs.Rewind(path_id);
			FlagsAndCommand PathAndFlags;
			while (!ShapePath.IsStop(PathAndFlags = vs.Vertex(out x, out y)))
			{
				if (ShapePath.IsVertex(PathAndFlags))
				{
					if (first)
					{
						x1 = x;
						y1 = y;
						x2 = x;
						y2 = y;
						first = false;
					}
					else
					{
						if (x < x1) x1 = x;
						if (y < y1) y1 = y;
						if (x > x2) x2 = x;
						if (y > y2) y2 = y;
					}
				}
			}
			return x1 <= x2 && y1 <= y2;
		}
	}
}

//#endif

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\agg_bspline.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// class bspline
//
//----------------------------------------------------------------------------

namespace MatterHackers.Agg
{
	//----------------------------------------------------------------bspline
	// A very simple class of Bi-cubic Spline interpolation.
	// First call init(num, x[], y[]) where num - number of source points,
	// x, y - arrays of X and Y values respectively. Here Y must be a function
	// of X. It means that all the X-coordinates must be arranged in the ascending
	// order.
	// Then call get(x) that calculates a value Y for the respective X.
	// The class supports extrapolation, i.e. you can call get(x) where x is
	// outside the given with init() X-range. Extrapolation is a simple linear
	// function.
	//------------------------------------------------------------------------
	public sealed class bspline
	{
		private int m_max;
		private int m_num;
		private int m_xOffset;
		private int m_yOffset;
		private ArrayPOD<double> m_am = new ArrayPOD<double>(16);
		private int m_last_idx;

		//------------------------------------------------------------------------
		public bspline()
		{
			m_max = (0);
			m_num = (0);
			m_xOffset = (0);
			m_yOffset = (0);
			m_last_idx = -1;
		}

		//------------------------------------------------------------------------
		public bspline(int num)
		{
			m_max = (0);
			m_num = (0);
			m_xOffset = (0);
			m_yOffset = (0);
			m_last_idx = -1;

			init(num);
		}

		//------------------------------------------------------------------------
		public bspline(int num, double[] x, double[] y)
		{
			m_max = (0);
			m_num = (0);
			m_xOffset = (0);
			m_yOffset = (0);
			m_last_idx = -1;
			init(num, x, y);
		}

		//------------------------------------------------------------------------
		public void init(int max)
		{
			if (max > 2 && max > m_max)
			{
				m_am.Resize(max * 3);
				m_max = max;
				m_xOffset = m_max;
				m_yOffset = m_max * 2;
			}
			m_num = 0;
			m_last_idx = -1;
		}

		//------------------------------------------------------------------------
		public void add_point(double x, double y)
		{
			if (m_num < m_max)
			{
				m_am[m_xOffset + m_num] = x;
				m_am[m_yOffset + m_num] = y;
				++m_num;
			}
		}

		//------------------------------------------------------------------------
		public void prepare()
		{
			if (m_num > 2)
			{
				int i, k;
				int r;
				int s;
				double h, p, d, f, e;

				for (k = 0; k < m_num; k++)
				{
					m_am[k] = 0.0;
				}

				int n1 = 3 * m_num;

				ArrayPOD<double> al = new ArrayPOD<double>(n1);

				for (k = 0; k < n1; k++)
				{
					al[k] = 0.0;
				}

				r = m_num;
				s = m_num * 2;

				n1 = m_num - 1;
				d = m_am[m_xOffset + 1] - m_am[m_xOffset + 0];
				e = (m_am[m_yOffset + 1] - m_am[m_yOffset + 0]) / d;

				for (k = 1; k < n1; k++)
				{
					h = d;
					d = m_am[m_xOffset + k + 1] - m_am[m_xOffset + k];
					f = e;
					e = (m_am[m_yOffset + k + 1] - m_am[m_yOffset + k]) / d;
					al[k] = d / (d + h);
					al[r + k] = 1.0 - al[k];
					al[s + k] = 6.0 * (e - f) / (h + d);
				}

				for (k = 1; k < n1; k++)
				{
					p = 1.0 / (al[r + k] * al[k - 1] + 2.0);
					al[k] *= -p;
					al[s + k] = (al[s + k] - al[r + k] * al[s + k - 1]) * p;
				}

				m_am[n1] = 0.0;
				al[n1 - 1] = al[s + n1 - 1];
				m_am[n1 - 1] = al[n1 - 1];

				for (k = n1 - 2, i = 0; i < m_num - 2; i++, k--)
				{
					al[k] = al[k] * al[k + 1] + al[s + k];
					m_am[k] = al[k];
				}
			}
			m_last_idx = -1;
		}

		//------------------------------------------------------------------------
		public void init(int num, double[] x, double[] y)
		{
			if (num > 2)
			{
				init(num);
				int i;
				for (i = 0; i < num; i++)
				{
					add_point(x[i], y[i]);
				}
				prepare();
			}
			m_last_idx = -1;
		}

		//------------------------------------------------------------------------
		private void bsearch(int n, int xOffset, double x0, out int i)
		{
			int j = n - 1;
			int k;

			for (i = 0; (j - i) > 1; )
			{
				k = (i + j) >> 1;
				if (x0 < m_am[xOffset + k]) j = k;
				else i = k;
			}
		}

		//------------------------------------------------------------------------
		private double interpolation(double x, int i)
		{
			int j = i + 1;
			double d = m_am[m_xOffset + i] - m_am[m_xOffset + j];
			double h = x - m_am[m_xOffset + j];
			double r = m_am[m_xOffset + i] - x;
			double p = d * d / 6.0;
			return (m_am[j] * r * r * r + m_am[i] * h * h * h) / 6.0 / d +
				   ((m_am[m_yOffset + j] - m_am[j] * p) * r + (m_am[m_yOffset + i] - m_am[i] * p) * h) / d;
		}

		//------------------------------------------------------------------------
		private double extrapolation_left(double x)
		{
			double d = m_am[m_xOffset + 1] - m_am[m_xOffset + 0];
			return (-d * m_am[1] / 6 + (m_am[m_yOffset + 1] - m_am[m_yOffset + 0]) / d) *
				   (x - m_am[m_xOffset + 0]) +
				   m_am[m_yOffset + 0];
		}

		//------------------------------------------------------------------------
		private double extrapolation_right(double x)
		{
			double d = m_am[m_xOffset + m_num - 1] - m_am[m_xOffset + m_num - 2];
			return (d * m_am[m_num - 2] / 6 + (m_am[m_yOffset + m_num - 1] - m_am[m_yOffset + m_num - 2]) / d) *
				   (x - m_am[m_xOffset + m_num - 1]) +
				   m_am[m_yOffset + m_num - 1];
		}

		//------------------------------------------------------------------------
		public double get(double x)
		{
			if (m_num > 2)
			{
				int i;

				// Extrapolation on the left
				if (x < m_am[m_xOffset + 0]) return extrapolation_left(x);

				// Extrapolation on the right
				if (x >= m_am[m_xOffset + m_num - 1]) return extrapolation_right(x);

				// Interpolation
				bsearch(m_num, m_xOffset, x, out i);
				return interpolation(x, i);
			}
			return 0.0;
		}

		//------------------------------------------------------------------------
		public double get_stateful(double x)
		{
			if (m_num > 2)
			{
				// Extrapolation on the left
				if (x < m_am[m_xOffset + 0]) return extrapolation_left(x);

				// Extrapolation on the right
				if (x >= m_am[m_xOffset + m_num - 1]) return extrapolation_right(x);

				if (m_last_idx >= 0)
				{
					// Check if x is not in current range
					if (x < m_am[m_xOffset + m_last_idx] || x > m_am[m_xOffset + m_last_idx + 1])
					{
						// Check if x between next points (most probably)
						if (m_last_idx < m_num - 2 &&
						   x >= m_am[m_xOffset + m_last_idx + 1] &&
						   x <= m_am[m_xOffset + m_last_idx + 2])
						{
							++m_last_idx;
						}
						else
							if (m_last_idx > 0 &&
							   x >= m_am[m_xOffset + m_last_idx - 1] &&
							   x <= m_am[m_xOffset + m_last_idx])
							{
								// x is between previous points
								--m_last_idx;
							}
							else
							{
								// Else perform full search
								bsearch(m_num, m_xOffset, x, out m_last_idx);
							}
					}
					return interpolation(x, m_last_idx);
				}
				else
				{
					// Interpolation
					bsearch(m_num, m_xOffset, x, out m_last_idx);
					return interpolation(x, m_last_idx);
				}
			}
			return 0.0;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\Array2D.cs
namespace MatterHackers.Agg
{
	public class Array2D<dataType>
	{
		private dataType[][] internalArray;

		public Array2D(int width, int height)
		{
			internalArray = new dataType[height][];
			for (int column = 0; column < height; column++)
			{
				internalArray[column] = new dataType[width];
			}
		}

		public int Width { get { return GetRow(0).Length; } }

		public int Height { get { return internalArray.Length; } }

		public dataType[] GetRow(int y)
		{
			return internalArray[y];
		}

		public void Fill(dataType valueToFillWith)
		{
			for (int y = 0; y < Height; y++)
			{
				dataType[] row = GetRow(y);
				for (int x = 0; x < Width; x++)
				{
					row[x] = valueToFillWith;
				}
			}
		}

		public dataType GetValue(int x, int y)
		{
			return GetRow(y)[x];
		}

		public void SetValue(int x, int y, dataType value)
		{
			GetRow(y)[x] = value;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\ArrayPOD.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg
{
    public class ArrayPOD<T> where T : struct
    {
        private T[] m_array;

        private int m_size;

        public ArrayPOD()
                            : this(64)
        {
        }

        public ArrayPOD(int size)
        {
            m_array = new T[size];
            m_size = size;
        }

        public ArrayPOD(ArrayPOD<T> v)
        {
            m_array = (T[])v.m_array.Clone();
            m_size = v.m_size;
        }

        public T[] Array
        {
            get
            {
                return m_array;
            }
        }

        public T this[int index]
        {
            get
            {
                return m_array[index];
            }

            set
            {
                m_array[index] = value;
            }
        }

        public void RemoveLast()
        {
            throw new NotImplementedException();
        }

        public void Resize(int size)
        {
            if (size != m_size)
            {
                m_array = new T[size];
            }
        }

        public int Size()
        {
            return m_size;
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\AscendableSafeList.cs
/*
Copyright (c) 2017, Lars Brubaker, John Lewin
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using System.Collections.Generic;

namespace MatterHackers.Agg
{
	public class AscendableSafeList<T> : SafeList<T> where T : IAscendable<T>
	{
		private T parentItem;
		
		public AscendableSafeList(T parent)
		{
			this.parentItem = parent;
		}

		public AscendableSafeList(IEnumerable<T> sourceItems, T parent)
		{
			this.parentItem = parent;

			// Ensure that new parent is pushed to children
			foreach (var item in sourceItems)
			{
				item.Parent = parent;
			}

			items = new List<T>(sourceItems);
		}

		public void SetParent(T parent)
		{
			this.parentItem = parent;
		}

		/// <summary>
		/// Provides a safe context to manipulate items. Copies items into a new list, invokes the 'modifier'
		/// Action passing in the copied list and finally swaps the modified list into place after the invoked Action completes
		/// </summary>
		/// <param name="modifier">The Action to invoke</param>
		override public void Modify(Action<List<T>> modifier)
		{
			// Copy the child items to a new list
			var safeClone = new List<T>(items);

			// Pass the new list to the Action for manipulation
			modifier(safeClone);

			// Swap the modified list into place
			items = safeClone;

			if (parentItem != null)
			{
				foreach (var item in items)
				{
					item.Parent = parentItem;
				}
			}

			base.OnItemsModified(null);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\BorderDouble.cs
using System;
using System.ComponentModel;
using System.Globalization;
using System.Linq;

namespace MatterHackers.Agg
{
	/// <summary>
	/// BorderDouble is used to represent the border around (Margin) on inside (Padding) of a rectangular area.
	/// </summary>
	[TypeConverter(typeof(BorderDoubleConverter))]
	public struct BorderDouble
	{
		public double Left, Bottom, Right, Top;

		public BorderDouble(double valueForAll)
			: this(valueForAll, valueForAll, valueForAll, valueForAll)
		{
		}

		public BorderDouble(double leftRight, double bottomTop)
			: this(leftRight, bottomTop, leftRight, bottomTop)
		{
		}

		public BorderDouble(BorderDouble copy, double left = double.MinValue, double bottom = double.MinValue, double right = double.MinValue, double top = double.MinValue)
		{
			this.Left = (left != double.MinValue) ? left : copy.Left;
			this.Bottom = (bottom != double.MinValue) ? bottom : copy.Bottom;
			this.Right = (right != double.MinValue) ? right : copy.Right;
			this.Top = (top != double.MinValue) ? top : copy.Top;
		}

		public BorderDouble(double left = 0, double bottom = 0, double right = 0, double top = 0)
		{
			this.Left = left;
			this.Bottom = bottom;
			this.Right = right;
			this.Top = top;
		}

		public static implicit operator BorderDouble(int valueForAll) // explicit byte to digit conversion operator
		{
			return new BorderDouble(valueForAll);
		}

		public static implicit operator BorderDouble(double valueForAll)
		{
			return new BorderDouble(valueForAll);
		}

		public static bool operator ==(BorderDouble a, BorderDouble b)
		{
			if (a.Left == b.Left && a.Bottom == b.Bottom && a.Right == b.Right && a.Top == b.Top)
			{
				return true;
			}

			return false;
		}

		public static bool operator !=(BorderDouble a, BorderDouble b)
		{
			if (a.Left != b.Left || a.Bottom != b.Bottom || a.Right != b.Right || a.Top != b.Top)
			{
				return true;
			}

			return false;
		}

		public static BorderDouble operator *(BorderDouble a, double b)
		{
			return new BorderDouble(a.Left * b, a.Bottom * b, a.Right * b, a.Top * b);
		}

		public static BorderDouble operator *(double b, BorderDouble a)
		{
			return new BorderDouble(a.Left * b, a.Bottom * b, a.Right * b, a.Top * b);
		}

		public static BorderDouble operator +(BorderDouble left, BorderDouble right)
		{
			left.Left += right.Left;
			left.Bottom += right.Bottom;
			left.Right += right.Right;
			left.Top += right.Top;
			return left;
		}

		public static RectangleDouble operator -(RectangleDouble left, BorderDouble right)
		{
			left.Left += right.Left;
			left.Bottom += right.Bottom;
			left.Right -= right.Right;
			left.Top -= right.Top;
			return left;
		}

		public override int GetHashCode()
		{
			return new { x1 = Left, x2 = Right, y1 = Bottom, y2 = Top }.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj.GetType() == typeof(BorderDouble))
			{
				return this == (BorderDouble)obj;
			}

			return false;
		}

		public double Width
		{
			get
			{
				return Left + Right;
			}
		}

		// This function assumes the rect is normalized
		public double Height
		{
			get
			{
				return Bottom + Top;
			}
		}

		public override string ToString()
		{
			return $"{Left}, {Bottom}, {Right}, {Top}";
		}

		public void Round()
		{
			this.Left = Math.Round(this.Left);
			this.Bottom = Math.Round(this.Bottom);
			this.Right = Math.Round(this.Right);
			this.Top = Math.Round(this.Top);
		}
	}

	public class BorderDoubleConverter : TypeConverter
	{
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			return sourceType == typeof(string) || base.CanConvertFrom(context, sourceType);
		}

		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			string stringValue = value as string;

			if (!string.IsNullOrEmpty(stringValue))
			{
				var values = stringValue.Split(',').Select(s =>
				{
					double.TryParse(s, out double result);
					return result;
				}).ToArray();

				switch (values.Length)
				{
					case 1:
						return new BorderDouble(values[0]);
					case 2:
						return new BorderDouble(values[0], values[1]);
					case 4:
						return new BorderDouble(values[0], values[1], values[2], values[3]);
					default:
						return 0;
				}
			}

			return base.ConvertFrom(context, culture, value);
		}
	}

	public static class BorderDoubleExtensions
	{
		public static BorderDouble Clone(this BorderDouble source, double left = double.MinValue, double bottom = double.MinValue, double right = double.MinValue, double top = double.MinValue)
		{
			return new BorderDouble(source, left, bottom, right, top);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\Color.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;

namespace MatterHackers.Agg
{
    // Supported byte orders for RGB and RGBA pixel formats
    //=======================================================================
    internal struct order_rgb { private enum rgb_e { R = 0, G = 1, B = 2, rgb_tag }; };       //----order_rgb

    internal struct order_bgr { private enum bgr_e { B = 0, G = 1, R = 2, rgb_tag }; };       //----order_bgr

    internal struct order_rgba { private enum rgba_e { R = 0, G = 1, B = 2, A = 3, rgba_tag }; }; //----order_rgba

    internal struct order_argb { private enum argb_e { A = 0, R = 1, G = 2, B = 3, rgba_tag }; }; //----order_argb

    internal struct order_abgr { private enum abgr_e { A = 0, B = 1, G = 2, R = 3, rgba_tag }; }; //----order_abgr

    internal struct order_bgra { private enum bgra_e { B = 0, G = 1, R = 2, A = 3, rgba_tag }; }; //----order_bgra

    [TypeConverter(typeof(ColorTypeConverter))]
    [JsonConverter(typeof(ColorJsonConverter))]
    public struct Color : IColorType
    {
        public const int cover_shift = 8;
        public const int cover_size = 1 << cover_shift;  //----cover_size
        public const int cover_mask = cover_size - 1;    //----cover_mask
                                                         //public const int cover_none  = 0,                 //----cover_none
                                                         //public const int cover_full  = cover_mask         //----cover_full

        public const int base_shift = 8;
        public const int base_scale = (int)(1 << base_shift);
        public const int base_mask = base_scale - 1;

        [JsonIgnore]
        public byte blue;

        [JsonIgnore]
        public byte green;

        [JsonIgnore]
        public byte red;

        [JsonIgnore]
        public byte alpha;

        public static readonly Color DarkBlue = new Color("#0000A0");
        public static readonly Color DarkGreen = new Color(0, 100, 0);
        public static readonly Color DarkMagenta = new Color(139, 0, 139);
        public static readonly Color DarkRed = new Color(139, 0, 0);
        public static readonly Color DarkYellow = new Color(139, 139, 0);
        public static readonly Color Green = new Color(0, 255, 0);
        public static readonly Color LightGreen = new Color(144, 238, 144);
        public static readonly Color Magenta = new Color(255, 0, 255);
        public static readonly Color Red = new Color(255, 0, 0);
        public static readonly Color Yellow = new Color(255, 255, 0);
        public static readonly Color Black = new Color(0, 0, 0);
        public static readonly Color Blue = new Color("#0000FF");
        public static readonly Color Crimson = new Color("#DC143C");
        public static readonly Color Cyan = new Color(0, 255, 255);
        public static readonly Color DarkCyan = new Color(0, 139, 139);
        public static readonly Color DarkGray = new Color(85, 85, 85);
        public static readonly Color FireEngineRed = new Color("#F62817");
        public static readonly Color Gray = new Color(125, 125, 125);
        public static readonly Color Indigo = new Color(75, 0, 130);
        public static readonly Color LightBlue = new Color("#ADD8E6");
        public static readonly Color LightGray = new Color(225, 225, 225);
        public static readonly Color Orange = new Color(255, 127, 0);
        public static readonly Color Purple = new Color(128, 0, 128);
        public static readonly Color Pink = new Color(255, 192, 203);
        public static readonly Color Transparent = new Color(0, 0, 0, 0);
        public static readonly Color Violet = new Color(143, 0, 255);
        public static readonly Color White = new Color(255, 255, 255);
        public static readonly Color YellowGreen = new Color(154, 205, 50);

        [JsonIgnore]
        public int Red0To255 { get { return (int)red; } set { red = (byte)value; } }

        [JsonIgnore]
        public int Green0To255 { get { return (int)green; } set { green = (byte)value; } }

        [JsonIgnore]
        public int Blue0To255 { get { return (int)blue; } set { blue = (byte)value; } }

        [JsonIgnore]
        public int Alpha0To255 { get { return (int)alpha; } set { alpha = (byte)value; } }

        [JsonIgnore]
        public float Red0To1 { get { return red / 255.0f; } set { red = (byte)Math.Max(0, Math.Min((int)(value * 255), 255)); } }

        [JsonIgnore]
        public float Green0To1 { get { return green / 255.0f; } set { green = (byte)Math.Max(0, Math.Min((int)(value * 255), 255)); } }

        [JsonIgnore]
        public float Blue0To1 { get { return blue / 255.0f; } set { blue = (byte)Math.Max(0, Math.Min((int)(value * 255), 255)); } }

        [JsonIgnore]
        public float Alpha0To1 { get { return alpha / 255.0f; } set { alpha = (byte)Math.Max(0, Math.Min((int)(value * 255), 255)); } }

        // serialize
        public string Html
        {
            get
            {
                return $"#{red:X2}{green:X2}{blue:X2}{alpha:X2}";
            }

            set
            {
                var lowered = value.Trim().ToLower();
                // check that it has a length
                // starts with a #
                // and is anly characters 0-9 and a-f
                if (lowered.Length > 3
                    && lowered.StartsWith("#")
                    && lowered.Substring(1).All(c => "0123456789abcdef".Contains(c)))
                {
                    switch (lowered.Length)
                    {
                        case 4: // #CCC, single char rgb
                        case 5: // also has alpha
                            red = (byte)Convert.ToInt32(lowered.Substring(1, 1) + lowered.Substring(1, 1), 16);
                            green = (byte)Convert.ToInt32(lowered.Substring(2, 1) + lowered.Substring(2, 1), 16);
                            blue = (byte)Convert.ToInt32(lowered.Substring(3, 1) + lowered.Substring(3, 1), 16);
                            if (lowered.Length == 5)
                            {
                                alpha = (byte)Convert.ToInt32(lowered.Substring(4, 1) + lowered.Substring(4, 1), 16);
                            }
                            else
                            {
                                alpha = 255;
                            }
                            break;

                        case 7: // #ACACAC, two char rgb
                        case 9: // also has alpha
                            red = (byte)Convert.ToInt32(lowered.Substring(1, 2), 16);
                            green = (byte)Convert.ToInt32(lowered.Substring(3, 2), 16);
                            blue = (byte)Convert.ToInt32(lowered.Substring(5, 2), 16);
                            if (lowered.Length == 9)
                            {
                                alpha = (byte)Convert.ToInt32(lowered.Substring(7, 2), 16);
                            }
                            else
                            {
                                alpha = 255;
                            }
                            break;

                        default:
                            break; // don't know what it is, do nothing
                    }
                }
                else
                {
                    var named = lowered.Trim().ToLower();
                    if (named.StartsWith("#"))
                    {
                        named = named.Substring(1);
                    }

                    switch (named)
                    {
                        case "blue":
                            this = Blue;
                            return;

                        case "green":
                            this = Green;
                            return;

                        case "red":
                            this = Red;
                            return;

                        case "black":
                            this = Black;
                            return;

                        case "gray":
                        case "grey":
                            this = Gray;
                            return;

                        case "orange":
                            this = Orange;
                            return;

                        case "purple":
                            this = Purple;
                            return;

                        case "yellow":
                            this = Yellow;
                            return;

                        case "white":
                            this = White;
                            return;

                        default:
                            break;
                    }
                }
            }
        }

        public ulong GetLongHashCode(ulong hash = 14695981039346656037)
        {
            return Util.ComputeHash(new byte[] { red, green, blue, alpha }, hash);
        }

        public Color(string htmlString)
            : this()
        {
            Html = htmlString;
        }

        public Color(int r_, int g_, int b_)
            : this(r_, g_, b_, base_mask)
        { }

        public Color(int r_, int g_, int b_, int a_)
        {
            red = (byte)Math.Min(Math.Max(r_, 0), 255);
            green = (byte)Math.Min(Math.Max(g_, 0), 255);
            blue = (byte)Math.Min(Math.Max(b_, 0), 255);
            alpha = (byte)Math.Min(Math.Max(a_, 0), 255);
        }

        public Color(double r_, double g_, double b_, double a_)
        {
            red = ((byte)Util.uround(r_ * (double)base_mask));
            green = ((byte)Util.uround(g_ * (double)base_mask));
            blue = ((byte)Util.uround(b_ * (double)base_mask));
            alpha = ((byte)Util.uround(a_ * (double)base_mask));
        }

        public Color(double r_, double g_, double b_)
        {
            red = ((byte)Util.uround(r_ * (double)base_mask));
            green = ((byte)Util.uround(g_ * (double)base_mask));
            blue = ((byte)Util.uround(b_ * (double)base_mask));
            alpha = (byte)base_mask;
        }

        public Color(ColorF c, double a_)
        {
            red = ((byte)Util.uround(c.red * (double)base_mask));
            green = ((byte)Util.uround(c.green * (double)base_mask));
            blue = ((byte)Util.uround(c.blue * (double)base_mask));
            alpha = ((byte)Util.uround(a_ * (double)base_mask));
        }

        public Color(Color c)
            : this(c, c.alpha)
        {
        }

        public Color(Color c, int a_)
        {
            red = (byte)c.red;
            green = (byte)c.green;
            blue = (byte)c.blue;
            alpha = (byte)Math.Max(0, Math.Min(255, a_));
        }

        public Color(uint fourByteColor)
        {
            red = (byte)((fourByteColor >> 16) & 0xFF);
            green = (byte)((fourByteColor >> 8) & 0xFF);
            blue = (byte)((fourByteColor >> 0) & 0xFF);
            alpha = (byte)((fourByteColor >> 24) & 0xFF);
        }

        public Color(ColorF c)
        {
            red = ((byte)Util.uround(c.red * (double)base_mask));
            green = ((byte)Util.uround(c.green * (double)base_mask));
            blue = ((byte)Util.uround(c.blue * (double)base_mask));
            alpha = ((byte)Util.uround(c.alpha * (double)base_mask));
        }

        public static bool operator ==(Color a, Color b)
        {
            if (a.red == b.red && a.green == b.green && a.blue == b.blue && a.alpha == b.alpha)
            {
                return true;
            }

            return false;
        }

        public static bool operator !=(Color a, Color b)
        {
            if (a.red != b.red || a.green != b.green || a.blue != b.blue || a.alpha != b.alpha)
            {
                return true;
            }

            return false;
        }

        public static Color FromHSL(double hue0To1, double saturation0To1, double lightness0To1, double alpha = 1)
        {
            return ColorF.FromHSL(hue0To1, saturation0To1, lightness0To1, alpha).ToColor();
        }

        public override string ToString()
        {
            return GetAsHTMLString();
        }

        public override bool Equals(object obj)
        {
            if (obj.GetType() == typeof(Color))
            {
                return this == (Color)obj;
            }
            return false;
        }

        public override int GetHashCode()
        {
            return new { blue, green, red, alpha }.GetHashCode();
        }

        public ColorF ToColorF()
        {
            return new ColorF((float)red / (float)base_mask, (float)green / (float)base_mask, (float)blue / (float)base_mask, (float)alpha / (float)base_mask);
        }

        public Color ToColor()
        {
            return this;
        }

        public string GetAsHTMLString()
        {
            if (alpha == 255)
            {
                return $"#{red:X2}{green:X2}{blue:X2}";
            }
            else
            {
                return $"#{red:X2}{green:X2}{blue:X2}{alpha:X2}";
            }
        }

        private void clear()
        {
            red = green = blue = alpha = 0;
        }

        public Color gradient(Color c, double k)
        {
            Color ret = new Color();
            int ik = Util.uround(k * base_scale);
            ret.Red0To255 = (byte)((int)(Red0To255) + ((((int)(c.Red0To255) - Red0To255) * ik) >> base_shift));
            ret.Green0To255 = (byte)((int)(Green0To255) + ((((int)(c.Green0To255) - Green0To255) * ik) >> base_shift));
            ret.Blue0To255 = (byte)((int)(Blue0To255) + ((((int)(c.Blue0To255) - Blue0To255) * ik) >> base_shift));
            ret.Alpha0To255 = (byte)((int)(Alpha0To255) + ((((int)(c.Alpha0To255) - Alpha0To255) * ik) >> base_shift));
            return ret;
        }

        static public Color operator +(Color A, Color B)
        {
            Color temp = new Color();
            temp.red = (byte)((A.red + B.red) > 255 ? 255 : (A.red + B.red));
            temp.green = (byte)((A.green + B.green) > 255 ? 255 : (A.green + B.green));
            temp.blue = (byte)((A.blue + B.blue) > 255 ? 255 : (A.blue + B.blue));
            temp.alpha = (byte)((A.alpha + B.alpha) > 255 ? 255 : (A.alpha + B.alpha));
            return temp;
        }

        static public Color operator -(Color A, Color B)
        {
            Color temp = new Color();
            temp.red = (byte)((A.red - B.red) < 0 ? 0 : (A.red - B.red));
            temp.green = (byte)((A.green - B.green) < 0 ? 0 : (A.green - B.green));
            temp.blue = (byte)((A.blue - B.blue) < 0 ? 0 : (A.blue - B.blue));
            temp.alpha = 255;// (byte)((A.m_A - B.m_A) < 0 ? 0 : (A.m_A - B.m_A));
            return temp;
        }

        static public Color operator *(Color A, double doubleB)
        {
            float B = (float)doubleB;
            ColorF temp = new ColorF();
            temp.red = A.red / 255.0f * B;
            temp.green = A.green / 255.0f * B;
            temp.blue = A.blue / 255.0f * B;
            temp.alpha = A.alpha / 255.0f * B;
            return new Color(temp);
        }

        public void add(Color c, int cover)
        {
            int cr, cg, cb, ca;
            if (cover == cover_mask)
            {
                if (c.Alpha0To255 == base_mask)
                {
                    this = c;
                }
                else
                {
                    cr = Red0To255 + c.Red0To255; Red0To255 = (cr > (int)(base_mask)) ? (int)(base_mask) : cr;
                    cg = Green0To255 + c.Green0To255; Green0To255 = (cg > (int)(base_mask)) ? (int)(base_mask) : cg;
                    cb = Blue0To255 + c.Blue0To255; Blue0To255 = (cb > (int)(base_mask)) ? (int)(base_mask) : cb;
                    ca = Alpha0To255 + c.Alpha0To255; Alpha0To255 = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;
                }
            }
            else
            {
                cr = Red0To255 + ((c.Red0To255 * cover + cover_mask / 2) >> cover_shift);
                cg = Green0To255 + ((c.Green0To255 * cover + cover_mask / 2) >> cover_shift);
                cb = Blue0To255 + ((c.Blue0To255 * cover + cover_mask / 2) >> cover_shift);
                ca = Alpha0To255 + ((c.Alpha0To255 * cover + cover_mask / 2) >> cover_shift);
                Red0To255 = (cr > (int)(base_mask)) ? (int)(base_mask) : cr;
                Green0To255 = (cg > (int)(base_mask)) ? (int)(base_mask) : cg;
                Blue0To255 = (cb > (int)(base_mask)) ? (int)(base_mask) : cb;
                Alpha0To255 = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;
            }
        }

        public void apply_gamma_dir(GammaLookUpTable gamma)
        {
            Red0To255 = gamma.dir((byte)Red0To255);
            Green0To255 = gamma.dir((byte)Green0To255);
            Blue0To255 = gamma.dir((byte)Blue0To255);
        }

        public static IColorType no_color()
        {
            return new Color(0, 0, 0, 0);
        }

        //-------------------------------------------------------------rgb8_packed
        static public Color rgb8_packed(int v)
        {
            return new Color((v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF);
        }

        public Color Blend(Color other, double weight)
        {
            Color result = new Color(this);
            result = this * (1 - weight) + other * weight;
            return result;
        }

        private static readonly Dictionary<string, Color> SmallColorDictionary = new Dictionary<string, Color>
        {
            { "Red", new Color(255, 0, 0) },
            { "Green", new Color(0, 255, 0) },
            { "Blue", new Color(0, 0, 255) },
            { "Aqua", new Color(0, 255, 255) },
            { "Black", new Color(0, 0, 0) },
            { "Fuchsia", new Color(255, 0, 255) },
            { "Gray", new Color(128, 128, 128) },
            { "Lime", new Color(0, 255, 0) },
            { "Maroon", new Color(128, 0, 0) },
            { "Navy", new Color(0, 0, 128) },
            { "Olive", new Color(128, 128, 0) },
            { "Purple", new Color(128, 0, 128) },
            { "Silver", new Color(192, 192, 192) },
            { "Teal", new Color(0, 128, 128) },
            { "White", new Color(255, 255, 255) },
            { "Yellow", new Color(255, 255, 0) },
        };

        private static readonly Dictionary<string, Color> DetailedColorDictionary = new Dictionary<string, Color>
        {
            { "Red", new Color(255, 0, 0) },
            { "Green", new Color(0, 255, 0) },
            { "Blue", new Color(0, 0, 255) },
            { "Aqua", new Color(0, 255, 255) },
            { "Black", new Color(0, 0, 0) },
            { "Fuchsia", new Color(255, 0, 255) },
            { "Gray", new Color(128, 128, 128) },
            { "Lime", new Color(0, 255, 0) },
            { "Maroon", new Color(128, 0, 0) },
            { "Navy", new Color(0, 0, 128) },
            { "Olive", new Color(128, 128, 0) },
            { "Purple", new Color(128, 0, 128) },
            { "Silver", new Color(192, 192, 192) },
            { "Teal", new Color(0, 128, 128) },
            { "White", new Color(255, 255, 255) },
            { "Yellow", new Color(255, 255, 0) },
            { "Orange", new Color(255, 165, 0) },
            { "Pink", new Color(255, 192, 203) },
            { "Cyan", new Color(0, 255, 255) },
            { "Magenta", new Color(255, 0, 255) },
            { "Gold", new Color(255, 215, 0) },
            { "Chocolate", new Color(210, 105, 30) },
            { "Coral", new Color(255, 127, 80) },
            { "DarkBlue", new Color(0, 0, 139) },
            { "DarkCyan", new Color(0, 139, 139) },
            { "DarkGray", new Color(169, 169, 169) },
            { "DarkGreen", new Color(0, 100, 0) },
            { "DarkMagenta", new Color(139, 0, 139) },
            { "DarkOliveGreen", new Color(85, 107, 47) },
            { "DarkOrange", new Color(255, 140, 0) },
            { "DarkOrchid", new Color(153, 50, 204) },
            { "DarkRed", new Color(139, 0, 0) },
            { "DarkSalmon", new Color(233, 150, 122) },
            { "DarkSeaGreen", new Color(143, 188, 139) },
            { "DarkSlateBlue", new Color(72, 61, 139) },
            { "DarkSlateGray", new Color(47, 79, 79) },
            { "DarkTurquoise", new Color(0, 206, 209) },
            { "DarkViolet", new Color(148, 0, 211) },
            { "DeepPink", new Color(255, 20, 147) },
            { "DeepSkyBlue", new Color(0, 191, 255) },
            { "DimGray", new Color(105, 105, 105) },
            { "DodgerBlue", new Color(30, 144, 255) },
            { "Firebrick", new Color(178, 34, 34) },
            { "ForestGreen", new Color(34, 139, 34) },
            { "Gainsboro", new Color(220, 220, 220) },
            { "HotPink", new Color(255, 105, 180) },
            { "IndianRed", new Color(205, 92, 92) },
            { "Indigo", new Color(75, 0, 130) },
            { "Khaki", new Color(240, 230, 140) },
            { "Lavender", new Color(230, 230, 250) },
            { "LawnGreen", new Color(124, 252, 0) },
            { "LightBlue", new Color(173, 216, 230) },
            { "LightCoral", new Color(240, 128, 128) },
            { "LightCyan", new Color(224, 255, 255) },
            { "LightGoldenrodYellow", new Color(250, 250, 210) },
            { "LightGray", new Color(211, 211, 211) },
            { "LightGreen", new Color(144, 238, 144) },
            { "LightPink", new Color(255, 182, 193) },
            { "LightSalmon", new Color(255, 160, 122) },
            { "LightSeaGreen", new Color(32, 178, 170) },
            { "LightSkyBlue", new Color(135, 206, 250) },
            { "LightSlateGray", new Color(119, 136, 153) },
            { "LightSteelBlue", new Color(176, 196, 222) },
            { "LightYellow", new Color(255, 255, 224) },
            { "Beige", new Color("#F5F5DC") },
            { "Brown", new Color("#8B4513") },
            { "LimeGreen", new Color(50, 205, 50) },
        };

        public string ColorToName()
        {
            var lab = RgbToLab(this);
            var closestColor = FindClosestNamedColor(lab);
            var distance = CalculateColorDistance(lab, RgbToLab(closestColor.Value));

            if (distance < 10) // Threshold for considering it a direct match
            {
                return closestColor.Key;
            }

            var lightness = lab[0];
            var lightnessDesc = GetLightnessDescription(lightness);
            var saturation = Math.Sqrt(lab[1] * lab[1] + lab[2] * lab[2]);
            var saturationDesc = GetSaturationDescription(saturation);

            return $"{lightnessDesc}{saturationDesc}{closestColor.Key}";
        }

        // Helper method to find the closest named color
        private static KeyValuePair<string, Color> FindClosestNamedColor(double[] labColor)
        {
            return DetailedColorDictionary.MinBy(kvp => CalculateColorDistance(labColor, RgbToLab(kvp.Value)));
        }

        /// <summary>
        /// Calculates the Euclidean distance between two colors in the LAB color space.
        /// </summary>
        /// <param name="color2">The second color to compare.</param>
        /// <returns>The distance between the two colors in the LAB color space.</returns>
        public double CalculateColorDistance(Color color2)
        {
            double[] lab1 = RgbToLab(this);
            double[] lab2 = RgbToLab(color2);

            double lDiff = lab1[0] - lab2[0];
            double aDiff = lab1[1] - lab2[1];
            double bDiff = lab1[2] - lab2[2];

            return Math.Sqrt(lDiff * lDiff + aDiff * aDiff + bDiff * bDiff);
        }

        // Helper method to calculate color distance in LAB space
        private static double CalculateColorDistance(double[] lab1, double[] lab2)
        {
            return Math.Sqrt(
                Math.Pow(lab1[0] - lab2[0], 2) +
                Math.Pow(lab1[1] - lab2[1], 2) +
                Math.Pow(lab1[2] - lab2[2], 2)
            );
        }

        // Helper method to get lightness description
        private static string GetLightnessDescription(double lightness)
        {
            if (lightness >= 90) return "Very Light ";
            if (lightness >= 70) return "Light ";
            if (lightness <= 20) return "Very Dark ";
            if (lightness <= 40) return "Dark ";
            return "";
        }

        // Helper method to get saturation description
        private static string GetSaturationDescription(double saturation)
        {
            if (saturation < 5) return "Grayish ";
            if (saturation < 30) return "Muted ";
            if (saturation > 60) return "Vivid ";
            return "";
        }

        /// <summary>
        /// Blends two colors in the HSL color space using the specified ratio.
        /// </summary>
        /// <param name="color2">The second color to blend with the current color.</param>
        /// <param name="ratioB">The ratio of the second color in the blended result (0.0 to 1.0).</param>
        /// <returns>A new Color object representing the blended color in the HSL color space.</returns>
        public Color BlendHsl(Color color2, double ratioOf2)
        {
            double aH, aS, aL;
            new ColorF(this).GetHSL(out aH, out aS, out aL);
            double bH, bS, bL;
            new ColorF(color2).GetHSL(out bH, out bS, out bL);

            return ColorF.FromHSL(
                aH * (1 - ratioOf2) + bH * ratioOf2,
                aS * (1 - ratioOf2) + bS * ratioOf2,
                aL * (1 - ratioOf2) + bL * ratioOf2).ToColor();
        }

        private static double[] XyzToRgb(double[] xyz)
        {
            // xyz is normalized to [0,1]
            var x = xyz[0] / 100;
            var y = xyz[1] / 100;
            var z = xyz[2] / 100;
            // xyz is multiplied by the reverse transformation matrix to linear rgb
            var invR = 3.2406254773200533 * x - 1.5372079722103187 * y -
              0.4986285986982479 * z;
            var invG = -0.9689307147293197 * x + 1.8757560608852415 * y +
              0.041517523842953964 * z;
            var invB = 0.055710120445510616 * x + -0.2040210505984867 * y +
              1.0569959422543882 * z;
            // Linear rgb must be gamma corrected to normalized srgb. Gamma correction
            // is linear for values <= 0.0031308 to avoid infinite log slope near zero
            double compand(double c)
            {
                return c <= 0.0031308 ? 12.92 * c : 1.055 * Math.Pow(c, 1 / 2.4) - 0.055;
            }

            var cR = compand(invR);
            var cG = compand(invG);
            var cB = compand(invB);
            // srgb is scaled to [0,255]
            // Add zero to prevent signed zeros (force 0 rather than -0)
            return new double[]
            {
                Math.Round(cR * 255) + 0,
                Math.Round(cG * 255) + 0,
                Math.Round(cB * 255) + 0
            };
        }

        private static double[] LabToXyz(double[] lab)
        {
            /** d65 standard illuminant in XYZ */
            double[] d65 = { 95.05, 100, 108.9 };

            var L = lab[0];
            var a = lab[1];
            var b = lab[2];
            var eps = 216 / 24389;
            var kap = 24389 / 27;
            var fY = (L + 16) / 116;
            var fZ = (fY - b / 200);
            var fX = a / 500 + fY;
            var xR = Math.Pow(fX, 3) > eps ? Math.Pow(fX, 3) : (116 * fX - 16) / kap;
            var yR = L > kap * eps ? Math.Pow((L + 16) / 116, 3) : L / kap;
            var zR = Math.Pow(fZ, 3) > eps ? Math.Pow(fZ, 3) : (116 * fZ - 16) / kap;
            // Add zero to prevent signed zeros (force 0 rather than -0)
            return new double[]
            {
                xR * d65[0] + 0,
                yR * d65[1] + 0,
                zR * d65[2] + 0
            };
        }

        private static Color LabToRgb(double[] lab)
        {
            var xyz = LabToXyz(lab);
            var rgb = XyzToRgb(xyz);
            return new Color((int)rgb[0], (int)rgb[1], (int)rgb[2]);
        }

        public static Color FromLab(double l, double a, double b)
        {
            return LabToRgb(new double[] { l, a, b });
        }

        public static double[] RgbToLab(Color color)
        {
            // First, convert RGB to XYZ
            double[] xyz = RgbToXyz(color);

            // Then, convert XYZ to LAB
            double[] lab = XyzToLab(xyz[0], xyz[1], xyz[2]);

            return lab;
        }

        public static double[] XyzToLab(double x, double y, double z)
        {
            double ref_X = 95.047;
            double ref_Y = 100.000;
            double ref_Z = 108.883;

            double var_X = x / ref_X;
            double var_Y = y / ref_Y;
            double var_Z = z / ref_Z;

            if (var_X > 0.008856) var_X = Math.Pow(var_X, (1.0 / 3.0));
            else var_X = (7.787 * var_X) + (16.0 / 116.0);
            if (var_Y > 0.008856) var_Y = Math.Pow(var_Y, (1.0 / 3.0));
            else var_Y = (7.787 * var_Y) + (16.0 / 116.0);
            if (var_Z > 0.008856) var_Z = Math.Pow(var_Z, (1.0 / 3.0));
            else var_Z = (7.787 * var_Z) + (16.0 / 116.0);

            double l = (116.0 * var_Y) - 16.0;
            double a = 500.0 * (var_X - var_Y);
            double b = 200.0 * (var_Y - var_Z);

            return new double[] { l, a, b };
        }

        private static double[] RgbToXyz(Color color)
        {
            double var_R = (color.red / 255.0);
            double var_G = (color.green / 255.0);
            double var_B = (color.blue / 255.0);

            if (var_R > 0.04045) var_R = Math.Pow((var_R + 0.055) / 1.055, 2.4);
            else var_R = var_R / 12.92;
            if (var_G > 0.04045) var_G = Math.Pow((var_G + 0.055) / 1.055, 2.4);
            else var_G = var_G / 12.92;
            if (var_B > 0.04045) var_B = Math.Pow((var_B + 0.055) / 1.055, 2.4);
            else var_B = var_B / 12.92;

            var_R = var_R * 100.0;
            var_G = var_G * 100.0;
            var_B = var_B * 100.0;

            double x = var_R * 0.4124 + var_G * 0.3576 + var_B * 0.1805;
            double y = var_R * 0.2126 + var_G * 0.7152 + var_B * 0.0722;
            double z = var_R * 0.0193 + var_G * 0.1192 + var_B * 0.9505;

            return new double[] { x, y, z };
        }

    }

    public class ColorTypeConverter : TypeConverter
    {
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
        {
            return sourceType == typeof(string) || base.CanConvertFrom(context, sourceType);
        }

        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            string stringValue = value as string;

            if (string.IsNullOrEmpty(stringValue))
            {
                return Color.Transparent;
            }
            else if (stringValue.Contains("#"))
            {
                return new Color(stringValue);
            }

            return base.ConvertFrom(context, culture, value);
        }
    }

    public class ColorJsonConverter : JsonConverter
    {
        public override bool CanWrite => false;

        public override bool CanRead => true;

        public override bool CanConvert(Type objectType)
        {
            return true;
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            // Use raw value if string and starts with #
            if (reader.Value is string itemValue
                && itemValue.StartsWith("#"))
            {
                return new Color(itemValue);
            }

            // Use .html if applicable
            if (reader.Value != null
                && JObject.Load(reader)?["Html"] is JToken jtoken
                && jtoken != null
                && jtoken.Value<string>() is string html)
            {
                return new Color(html);
            }

            return Color.Transparent;
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            // Should never get invoked due to CanWrite => false
            throw new NotImplementedException();
        }
    }

    public static class ColorExtensionMethods
    {
        public static IColorType WithContrast(this IColorType colorToAdjust, IColorType fixedColor, double minimumRequiredContrast = 3)
        {
            var contrast = colorToAdjust.Contrast(fixedColor);
            int tries = 0;
            while (contrast < minimumRequiredContrast
                && tries++ < 30)
            {
                if (fixedColor.Luminance0To1() < .5)
                {
                    colorToAdjust = colorToAdjust.AdjustLightness(1.05).ToColor();
                }
                else
                {
                    colorToAdjust = colorToAdjust.AdjustLightness(.95).ToColor();
                }
                contrast = colorToAdjust.Contrast(fixedColor);
            }

            return colorToAdjust;
        }

        public static Color WithAlpha(this Color color, int alpha)
        {
            return new Color(color, alpha);
        }

        public static Color WithAlpha(this Color color, double alpha)
        {
            return new Color(color, (int)Math.Round(255 * alpha));
        }

        public static ColorF AdjustSaturation(this IColorType original, double saturationMultiplier)
        {
            ColorF colorF = original.ToColorF();

            colorF.GetHSL(out double hue0To1, out double saturation0To1, out double lightness0To1);
            saturation0To1 *= saturationMultiplier;

            return ColorF.FromHSL(hue0To1, saturation0To1, lightness0To1);
        }

        public static double Luminance0To1(this IColorType color)
        {
            double R = 0, G = 0, B = 0;
            if (color.Red0To1 <= 0.03928)
            {
                R = color.Red0To1 / 12.92;
            }
            else
            {
                R = Math.Pow(((color.Red0To1 + 0.055) / 1.055), 2.4);
            }

            if (color.Green0To1 <= 0.03928)
            {
                G = color.Green0To1 / 12.92;
            }
            else
            {
                G = Math.Pow(((color.Green0To1 + 0.055) / 1.055), 2.4);
            }

            if (color.Blue0To1 <= 0.03928)
            {
                B = color.Blue0To1 / 12.92;
            }
            else
            {
                B = Math.Pow(((color.Blue0To1 + 0.055) / 1.055), 2.4);
            }
            return 0.2126 * R + 0.7152 * G + 0.0722 * B;
        }

        // Overlay a color over another
        public static IColorType OverlayOn(this IColorType thisA, IColorType color)
        {
            var overlaid = thisA;

            var alpha = thisA.Alpha0To1;

            if (alpha >= 1)
            {
                return overlaid;
            }

            overlaid.Red0To1 = overlaid.Red0To1 * alpha + color.Red0To1 * color.Alpha0To1 * (1 - alpha);
            overlaid.Green0To1 = overlaid.Green0To1 * alpha + color.Green0To1 * color.Alpha0To1 * (1 - alpha);
            overlaid.Blue0To1 = overlaid.Blue0To1 * alpha + color.Blue0To1 * color.Alpha0To1 * (1 - alpha);

            overlaid.Alpha0To1 = alpha + color.Alpha0To1 * (1 - alpha);

            return overlaid;
        }

        // Contrast ratios can range from 1 to 21 (commonly written 1:1 to 21:1).
        public static double Contrast(this IColorType thisA, IColorType color)
        {
            // Formula: http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
            var alpha = thisA.Alpha0To1;

            if (alpha >= 1)
            {
                if (color.Alpha0To1 < 1)
                {
                    color = color.OverlayOn(thisA);
                }

                var l1 = thisA.Luminance0To1() + .05;
                var l2 = color.Luminance0To1() + .05;
                var ratio = l1 / l2;

                if (l2 > l1)
                {
                    ratio = 1 / ratio;
                }

                ratio = Math.Round(ratio, 1);

                return ratio;
            }

            // If were here, it means we have a semi-transparent background
            // The text color may or may not be semi-transparent, but that doesn't matter
            var onBlack = thisA.OverlayOn(Color.Black);
            var onWhite = thisA.OverlayOn(Color.White);
            var contrastOnBlack = onBlack.Contrast(color);
            var contrastOnWhite = onWhite.Contrast(color);

            var max = Math.Max(contrastOnBlack, contrastOnWhite);

            var min = 1.0;
            if (onBlack.Luminance0To1() > color.Luminance0To1())
            {
                min = contrastOnBlack;
            }
            else if (onWhite.Luminance0To1() < color.Luminance0To1())
            {
                min = contrastOnWhite;
            }
            var error = Math.Round((max - min) / 2, 2);
            var farthest = contrastOnWhite == max ? Color.White : Color.Black;

            return Math.Round((min + max) / 2, 2);
        }

        public static ColorF WithLightness(this IColorType original, double lightness)
        {
            ColorF colorF = original.ToColorF();

            colorF.GetHSL(out double hue0To1, out double saturation0To1, out _);

            return ColorF.FromHSL(hue0To1, saturation0To1, lightness);
        }

        public static ColorF AdjustLightness(this IColorType original, double lightnessMultiplier)
        {
            ColorF colorF = original.ToColorF();

            colorF.GetHSL(out double hue0To1, out double saturation0To1, out double lightness0To1);
            lightness0To1 *= lightnessMultiplier;

            return ColorF.FromHSL(hue0To1, saturation0To1, lightness0To1);
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\ColorF.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;
using Newtonsoft.Json;

namespace MatterHackers.Agg
{
	public struct ColorF : IColorType
	{
		private const int base_shift = 8;
		private const int base_scale = (int)(1 << base_shift);
		private const int base_mask = base_scale - 1;

		public float red;
		public float green;
		public float blue;
		public float alpha;

		[JsonIgnore]
		public int Red0To255 { get { return (int)Util.uround(Math.Max(0, Math.Min(255, red)) * (float)base_mask); } set { red = (float)value / (float)base_mask; } }

		[JsonIgnore]
		public int Green0To255 { get { return (int)Util.uround(Math.Max(0, Math.Min(255, green)) * (float)base_mask); } set { green = (float)value / (float)base_mask; } }

		[JsonIgnore]
		public int Blue0To255 { get { return (int)Util.uround(Math.Max(0, Math.Min(255, blue)) * (float)base_mask); } set { blue = (float)value / (float)base_mask; } }

		[JsonIgnore]
		public int Alpha0To255 { get { return (int)Util.uround(Math.Max(0, Math.Min(255, alpha)) * (float)base_mask); } set { alpha = (float)value / (float)base_mask; } }

		[JsonIgnore]
		public float Red0To1 { get { return red; } set { red = value; } }

		[JsonIgnore]
		public float Green0To1 { get { return green; } set { green = value; } }

		[JsonIgnore]
		public float Blue0To1 { get { return blue; } set { blue = value; } }

		[JsonIgnore]
		public float Alpha0To1 { get { return alpha; } set { alpha = value; } }

		#region Defined Colors

		public static readonly ColorF White = new ColorF(1, 1, 1, 1);
		public static readonly ColorF Black = new ColorF(0, 0, 0, 1);
		public static readonly ColorF Red = new ColorF(1, 0, 0, 1);
		public static readonly ColorF Green = new ColorF(0, 1, 0, 1);
		public static readonly ColorF Blue = new ColorF(0, 0, 1, 1);
		public static readonly ColorF Cyan = new ColorF(0, 1, 1, 1);
		public static readonly ColorF Magenta = new ColorF(1, 0, 1, 1);
		public static readonly ColorF Yellow = new ColorF(1, 1, 0, 1);

		#endregion Defined Colors

		#region Constructors

		public ColorF(double r_, double g_, double b_)
			: this(r_, g_, b_, 1.0)
		{
		}

		public ColorF(double r_, double g_, double b_, double a_)
		{
			red = (float)r_;
			green = (float)g_;
			blue = (float)b_;
			alpha = (float)a_;
		}

		public ColorF(float r_, float g_, float b_)
			: this(r_, g_, b_, 1.0f)
		{
		}

		public ColorF(float r_, float g_, float b_, float a_)
		{
			red = r_;
			green = g_;
			blue = b_;
			alpha = a_;
		}

		public ColorF(ColorF c)
			: this(c, c.alpha)
		{
		}

		public ColorF(ColorF c, float a_)
		{
			red = c.red;
			green = c.green;
			blue = c.blue;
			alpha = a_;
		}

		public ColorF(float wavelen)
			: this(wavelen, 1.0f)
		{
		}

		public ColorF(float wavelen, float gamma)
		{
			this = from_wavelength(wavelen, gamma);
		}

		public ColorF(Color color)
		{
			red = color.Red0To1;
			green = color.Green0To1;
			blue = color.Blue0To1;
			alpha = color.Alpha0To1;
		}

		#endregion Constructors

		#region HSL

		// Given H,S,L,A in range of 0-1
		// Returns a Color (RGB struct) in range of 0-255
		public static ColorF FromHSL(double hue0To1, double saturation0To1, double lightness0To1, double alpha = 1)
		{
			double v;
			double r, g, b;
			if (alpha > 1.0)
			{
				alpha = 1.0;
			}

			r = lightness0To1;   // default to gray
			g = lightness0To1;
			b = lightness0To1;
			v = lightness0To1 + saturation0To1 - lightness0To1 * saturation0To1;
			if (lightness0To1 <= 0.5)
			{
				v = lightness0To1 * (1.0 + saturation0To1);
			}

			if (v > 0)
			{
				double m;
				double sv;
				int sextant;
				double fract, vsf, mid1, mid2;

				m = lightness0To1 + lightness0To1 - v;
				sv = (v - m) / v;
				hue0To1 *= 6.0;
				sextant = (int)hue0To1;
				fract = hue0To1 - sextant;
				vsf = v * sv * fract;
				mid1 = m + vsf;
				mid2 = v - vsf;
				switch (sextant)
				{
					case 0:
						r = v;
						g = mid1;
						b = m;
						break;

					case 1:
						r = mid2;
						g = v;
						b = m;
						break;

					case 2:
						r = m;
						g = v;
						b = mid1;
						break;

					case 3:
						r = m;
						g = mid2;
						b = v;
						break;

					case 4:
						r = mid1;
						g = m;
						b = v;
						break;

					case 5:
						r = v;
						g = m;
						b = mid2;
						break;

					case 6:
						goto case 0;
				}
			}

			return new ColorF(r, g, b, alpha);
		}

		public void GetHSL(out double hue0To1, out double saturation0To1, out double lightness0To1)
		{
			double maxRGB = Math.Max(red, Math.Max(green, blue));
			double minRGB = Math.Min(red, Math.Min(green, blue));
			double deltaMaxToMin = maxRGB - minRGB;
			double r2, g2, b2;

			hue0To1 = 0; // default to black
			saturation0To1 = 0;
			lightness0To1 = (minRGB + maxRGB) / 2.0;
			if (lightness0To1 <= 0.0)
			{
				return;
			}
			saturation0To1 = deltaMaxToMin;
			if (saturation0To1 > 0.0)
			{
				saturation0To1 /= (lightness0To1 <= 0.5) ? (maxRGB + minRGB) : (2.0 - maxRGB - minRGB);
			}
			else
			{
				return;
			}
			r2 = (maxRGB - red) / deltaMaxToMin;
			g2 = (maxRGB - green) / deltaMaxToMin;
			b2 = (maxRGB - blue) / deltaMaxToMin;
			if (red == maxRGB)
			{
				if (green == minRGB)
				{
					hue0To1 = 5.0 + b2;
				}
				else
				{
					hue0To1 = 1.0 - g2;
				}
			}
			else if (green == maxRGB)
			{
				if (blue == minRGB)
				{
					hue0To1 = 1.0 + r2;
				}
				else
				{
					hue0To1 = 3.0 - b2;
				}
			}
			else
			{
				if (red == minRGB)
				{
					hue0To1 = 3.0 + g2;
				}
				else
				{
					hue0To1 = 5.0 - r2;
				}
			}
			hue0To1 /= 6.0;
		}
		#endregion HSL

		public static bool operator ==(ColorF a, ColorF b)
		{
			if (a.red == b.red && a.green == b.green && a.blue == b.blue && a.alpha == b.alpha)
			{
				return true;
			}

			return false;
		}

		public static bool operator !=(ColorF a, ColorF b)
		{
			if (a.red != b.red || a.green != b.green || a.blue != b.blue || a.alpha != b.alpha)
			{
				return true;
			}

			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj.GetType() == typeof(ColorF))
			{
				return this == (ColorF)obj;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return new { blue, green, red, alpha }.GetHashCode();
		}

		public Color ToColor()
		{
			return new Color(Red0To255, Green0To255, Blue0To255, Alpha0To255);
		}

		public ColorF ToColorF()
		{
			return this;
		}

		static public ColorF operator +(ColorF A, ColorF B)
		{
			ColorF temp = new ColorF();
			temp.red = A.red + B.red;
			temp.green = A.green + B.green;
			temp.blue = A.blue + B.blue;
			temp.alpha = A.alpha + B.alpha;
			return temp;
		}

		static public ColorF operator -(ColorF A, ColorF B)
		{
			ColorF temp = new ColorF();
			temp.red = A.red - B.red;
			temp.green = A.green - B.green;
			temp.blue = A.blue - B.blue;
			temp.alpha = A.alpha - B.alpha;
			return temp;
		}

		static public ColorF operator *(ColorF A, ColorF B)
		{
			ColorF temp = new ColorF();
			temp.red = A.red * B.red;
			temp.green = A.green * B.green;
			temp.blue = A.blue * B.blue;
			temp.alpha = A.alpha * B.alpha;
			return temp;
		}

		static public ColorF operator /(ColorF A, ColorF B)
		{
			ColorF temp = new ColorF();
			temp.red = A.red / B.red;
			temp.green = A.green / B.green;
			temp.blue = A.blue / B.blue;
			temp.alpha = A.alpha / B.alpha;
			return temp;
		}

		static public ColorF operator /(ColorF A, float B)
		{
			ColorF temp = new ColorF();
			temp.red = A.red / B;
			temp.green = A.green / B;
			temp.blue = A.blue / B;
			temp.alpha = A.alpha / B;
			return temp;
		}

		static public ColorF operator /(ColorF A, double doubleB)
		{
			float B = (float)doubleB;
			ColorF temp = new ColorF();
			temp.red = A.red / B;
			temp.green = A.green / B;
			temp.blue = A.blue / B;
			temp.alpha = A.alpha / B;
			return temp;
		}

		static public ColorF operator *(ColorF A, float B)
		{
			ColorF temp = new ColorF();
			temp.red = A.red * B;
			temp.green = A.green * B;
			temp.blue = A.blue * B;
			temp.alpha = A.alpha * B;
			return temp;
		}

		static public ColorF operator *(ColorF A, double doubleB)
		{
			float B = (float)doubleB;
			ColorF temp = new ColorF();
			temp.red = A.red * B;
			temp.green = A.green * B;
			temp.blue = A.blue * B;
			temp.alpha = A.alpha * B;
			return temp;
		}

		public void clear()
		{
			red = green = blue = alpha = 0;
		}

		public ColorF transparent()
		{
			alpha = 0.0f;
			return this;
		}

		public ColorF opacity(float a_)
		{
			if (a_ < 0.0) a_ = 0.0f;
			if (a_ > 1.0) a_ = 1.0f;
			alpha = a_;
			return this;
		}

		public float opacity()
		{
			return alpha;
		}

		public ColorF premultiply()
		{
			red *= alpha;
			green *= alpha;
			blue *= alpha;
			return this;
		}

		public ColorF premultiply(float a_)
		{
			if (alpha <= 0.0 || a_ <= 0.0)
			{
				red = green = blue = alpha = 0.0f;
				return this;
			}
			a_ /= alpha;
			red *= a_;
			green *= a_;
			blue *= a_;
			alpha = a_;
			return this;
		}

		public static ColorF ComponentMax(ColorF a, ColorF b)
		{
			ColorF result = a;
			if (result.red < b.red) result.red = b.red;
			if (result.green < b.green) result.green = b.green;
			if (result.blue < b.blue) result.blue = b.blue;
			if (result.alpha < b.alpha) result.alpha = b.alpha;

			return result;
		}

		public ColorF demultiply()
		{
			if (alpha == 0)
			{
				red = green = blue = 0;
				return this;
			}
			float a_ = 1.0f / alpha;
			red *= a_;
			green *= a_;
			blue *= a_;
			return this;
		}

		public Color gradient(Color c_8, double k)
		{
			ColorF c = c_8.ToColorF();
			ColorF ret;
			ret.red = (float)(red + (c.red - red) * k);
			ret.green = (float)(green + (c.green - green) * k);
			ret.blue = (float)(blue + (c.blue - blue) * k);
			ret.alpha = (float)(alpha + (c.alpha - alpha) * k);
			return ret.ToColor();
		}

		public static IColorType no_color()
		{
			return (IColorType)new ColorF(0, 0, 0, 0);
		}

		public static ColorF from_wavelength(float wl)
		{
			return from_wavelength(wl, 1.0f);
		}

		public static ColorF from_wavelength(float wl, float gamma)
		{
			ColorF t = new ColorF(0.0f, 0.0f, 0.0f);

			if (wl >= 380.0 && wl <= 440.0)
			{
				t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));
				t.blue = 1.0f;
			}
			else if (wl >= 440.0 && wl <= 490.0)
			{
				t.green = (float)((wl - 440.0) / (490.0 - 440.0));
				t.blue = 1.0f;
			}
			else if (wl >= 490.0 && wl <= 510.0)
			{
				t.green = 1.0f;
				t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));
			}
			else if (wl >= 510.0 && wl <= 580.0)
			{
				t.red = (float)((wl - 510.0) / (580.0 - 510.0));
				t.green = 1.0f;
			}
			else if (wl >= 580.0 && wl <= 645.0)
			{
				t.red = 1.0f;
				t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));
			}
			else if (wl >= 645.0 && wl <= 780.0)
			{
				t.red = 1.0f;
			}

			float s = 1.0f;
			if (wl > 700.0) s = (float)(0.3 + 0.7 * (780.0 - wl) / (780.0 - 700.0));
			else if (wl < 420.0) s = (float)(0.3 + 0.7 * (wl - 380.0) / (420.0 - 380.0));

			t.red = (float)Math.Pow(t.red * s, gamma);
			t.green = (float)Math.Pow(t.green * s, gamma);
			t.blue = (float)Math.Pow(t.blue * s, gamma);

			return t;
		}

		public static ColorF rgba_pre(double r, double g, double b)
		{
			return rgba_pre((float)r, (float)g, (float)b, 1.0f);
		}

		public static ColorF rgba_pre(float r, float g, float b)
		{
			return rgba_pre(r, g, b, 1.0f);
		}

		public static ColorF rgba_pre(float r, float g, float b, float a)
		{
			return new ColorF(r, g, b, a).premultiply();
		}

		public static ColorF rgba_pre(double r, double g, double b, double a)
		{
			return new ColorF((float)r, (float)g, (float)b, (float)a).premultiply();
		}

		public static ColorF rgba_pre(ColorF c)
		{
			return new ColorF(c).premultiply();
		}

		public static ColorF rgba_pre(ColorF c, float a)
		{
			return new ColorF(c, a).premultiply();
		}

		public static ColorF GetTweenColor(ColorF Color1, ColorF Color2, double RatioOf2)
		{
			if (RatioOf2 <= 0)
			{
				return new ColorF(Color1);
			}

			if (RatioOf2 >= 1.0)
			{
				return new ColorF(Color2);
			}

			// figure out how much of each color we should be.
			double RatioOf1 = 1.0 - RatioOf2;
			return new ColorF(
				Color1.red * RatioOf1 + Color2.red * RatioOf2,
				Color1.green * RatioOf1 + Color2.green * RatioOf2,
				Color1.blue * RatioOf1 + Color2.blue * RatioOf2);
		}

		public ColorF Blend(ColorF other, double weight)
		{
			ColorF result = new ColorF(this);
			result = this * (1 - weight) + other * weight;
			return result;
		}

		public double SumOfDistances(ColorF other)
		{
			double dist = Math.Abs(red - other.red) + Math.Abs(green - other.green) + Math.Abs(blue - other.blue);
			return dist;
		}

		private void Clamp0To1(ref float value)
		{
			if (value < 0)
			{
				value = 0;
			}
			else if (value > 1)
			{
				value = 1;
			}
		}

		public void Clamp0To1()
		{
			Clamp0To1(ref red);
			Clamp0To1(ref green);
			Clamp0To1(ref blue);
			Clamp0To1(ref alpha);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\FirstInFirstOutQueue.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg
{
    public class FirstInFirstOutQueue<T>
    {
        private int head;
        private T[] itemArray;
        private int mask;
        private int shiftFactor;
        private int size;

        public FirstInFirstOutQueue(int shiftFactor)
        {
            this.shiftFactor = shiftFactor;
            mask = (1 << shiftFactor) - 1;
            itemArray = new T[1 << shiftFactor];
            head = 0;
            size = 0;
        }

        public int Count
        {
            get { return size; }
        }

        public T First
        {
            get { return itemArray[head & mask]; }
        }

        public T Dequeue()
        {
            int headIndex = head & mask;
            T firstItem = itemArray[headIndex];
            if (size > 0)
            {
                head++;
                size--;
            }
            return firstItem;
        }

        public void Enqueue(T itemToQueue)
        {
            if (size == itemArray.Length)
            {
                int headIndex = head & mask;
                shiftFactor += 1;
                mask = (1 << shiftFactor) - 1;
                T[] newArray = new T[1 << shiftFactor];
                // copy the from head to the end
                Array.Copy(itemArray, headIndex, newArray, 0, size - headIndex);
                // copy form 0 to the size
                Array.Copy(itemArray, 0, newArray, size - headIndex, headIndex);
                itemArray = newArray;
                head = 0;
            }
            itemArray[(head + size++) & mask] = itemToQueue;
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\Point2D.cs
/*
Copyright (c) 2014, Lars Brubaker
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;

namespace MatterHackers.Agg
{
    public struct Point2D
    {
        public static readonly Point2D Zero = new Point2D();
        public int x, y;

        public Point2D(int x, int y)
        {
            this.x = x;
            this.y = y;
        }

        public Point2D(double x, double y)
        {
            this.x = (int)Math.Round(x);
            this.y = (int)Math.Round(y);
        }

        public static double GetDeltaAngle(double StartAngle, double EndAngle)
        {
            if (StartAngle != Range0To2PI(StartAngle)) throw new Exception("StartAngle == Range0To2PI(StartAngle)");
            if (EndAngle != Range0To2PI(EndAngle)) throw new Exception("EndAngle   == Range0To2PI(EndAngle)");

            double DeltaAngle = EndAngle - StartAngle;
            if (DeltaAngle > System.Math.PI)
            {
                DeltaAngle -= 2 * Math.PI;
            }

            if (DeltaAngle < -System.Math.PI)
            {
                DeltaAngle += 2 * Math.PI;
            }

            return DeltaAngle;
        }

        public static double GetDistanceBetween(Point2D a, Point2D b)
        {
            return (double)System.Math.Sqrt(GetDistanceBetweenSquared(a, b));
        }

        public static double GetDistanceBetweenSquared(Point2D a, Point2D b)
        {
            return ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
        }

        public static Point2D operator -(Point2D a, Point2D b)
        {
            Point2D temp = new Point2D();
            temp.x = a.x - b.x;
            temp.y = a.y - b.y;
            return temp;
        }

        public static bool operator !=(Point2D a, Point2D b)
        {
            return !a.Equals(b);
        }

        public static Point2D operator *(Point2D a, Point2D b)
        {
            Point2D temp = new Point2D();
            temp.x = a.x * b.x;
            temp.y = a.y * b.y;
            return temp;
        }

        public static Point2D operator *(Point2D a, int b)
        {
            Point2D temp = new Point2D();
            temp.x = a.x * b;
            temp.y = a.y * b;
            return temp;
        }

        public static Point2D operator *(int b, Point2D a)
        {
            Point2D temp = new Point2D();
            temp.x = a.x * b;
            temp.y = a.y * b;
            return temp;
        }

        public static Point2D operator /(Point2D a, Point2D b)
        {
            Point2D temp = new Point2D();
            temp.x = a.x / b.x;
            temp.y = a.y / b.y;
            return temp;
        }

        public static Point2D operator /(Point2D a, int b)
        {
            Point2D temp = new Point2D();
            temp.x = a.x / b;
            temp.y = a.y / b;
            return temp;
        }

        public static Point2D operator /(int b, Point2D a)
        {
            Point2D temp = new Point2D();
            temp.x = a.x / b;
            temp.y = a.y / b;
            return temp;
        }

        public static Point2D operator +(Point2D a, Point2D b)
        {
            Point2D temp = new Point2D();
            temp.x = a.x + b.x;
            temp.y = a.y + b.y;
            return temp;
        }

        public static bool operator ==(Point2D a, Point2D b)
        {
            return a.Equals(b);
        }

        public static double Range0To2PI(double Value)
        {
            if (Value < 0)
            {
                Value += 2 * Math.PI;
            }

            if (Value >= 2 * Math.PI)
            {
                Value -= 2 * Math.PI;
            }

            if (Value < 0 || Value > 2 * System.Math.PI) throw new Exception("Value >= 0 && Value <= 2 * PI");

            return Value;
        }

        public double Cross(Point2D B)
        {
            return x * B.y - y * B.x;
        }

        public double Dot(Point2D B)
        {
            return (x * B.x + y * B.y);
        }

        // are they the same within the error value?
        public bool Equals(Point2D otherVector)
        {
            if (x == otherVector.x && y == otherVector.y)
            {
                return true;
            }

            return false;
        }

        public override bool Equals(object obj)
        {
            // If parameter is null return false.
            if (obj == null)
            {
                return false;
            }

            // If parameter cannot be cast to Point return false.
            Point2D p = (Point2D)obj;
            if ((System.Object)p == null)
            {
                return false;
            }

            // Return true if the fields match:
            return (x == p.x) && (y == p.y);
        }

        public double GetAngle0To2PI()
        {
            return (double)Range0To2PI((double)System.Math.Atan2(y, x));
        }

        public double GetDeltaAngle(Point2D point)
        {
            return (double)GetDeltaAngle(GetAngle0To2PI(), point.GetAngle0To2PI());
        }

        public override int GetHashCode()
        {
            return new { x, y }.GetHashCode();
        }

        public double GetLength()
        {
            return Math.Sqrt((x * x) + (y * y));
        }

        public double GetLengthSquared()
        {
            return Dot(this);
        }

        public Point2D GetNormal()
        {
            Point2D normal = this;
            normal.Normalize();
            return normal;
        }

        public Point2D GetPerpendicular()
        {
            Point2D temp = new Point2D(y, -x);

            return temp;
        }

        public Point2D GetPerpendicularNormal()
        {
            Point2D Perpendicular = GetPerpendicular();
            Perpendicular.Normalize();
            return Perpendicular;
        }

        public double GetSquaredDistanceTo(Point2D other)
        {
            return ((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y));
        }

        public void Negate()
        {
            x = -x;
            y = -y;
        }

        public void Normalize()
        {
            double Length;

            Length = GetLength();

            if (Length == 0) throw new Exception("Length != 0.f");

            if (Length != 0.0f)
            {
                double InversLength = 1.0f / Length;
                x = Convert.ToInt32(x * InversLength);
                y = Convert.ToInt32(y * InversLength);
            }
        }

        public void Normalize(double Length)
        {
            if (Length == 0) throw new Exception("Length == 0.f");

            if (Length != 0.0f)
            {
                double InversLength = 1.0f / Length;
                x = Convert.ToInt32(x * InversLength);
                y = Convert.ToInt32(y * InversLength);
            }
        }

        public double NormalizeAndReturnLength()
        {
            double Length;

            Length = GetLength();

            if (Length != 0.0f)
            {
                double InversLength = 1.0f / Length;
                x = Convert.ToInt32(x * InversLength);
                y = Convert.ToInt32(y * InversLength);
            }

            return Length;
        }

        public void Set(int x, int y)
        {
            this.x = x;
            this.y = y;
        }
    };
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\RadiusCorners.cs
using System;
using System.ComponentModel;
using System.Globalization;
using System.Linq;

namespace MatterHackers.Agg
{
	[TypeConverter(typeof(RadiusCornersConverter))]
	public struct RadiusCorners
	{
		public double NE, NW, SW, SE;

		public RadiusCorners(double valueForAll)
			: this(valueForAll, valueForAll, valueForAll, valueForAll)
		{
		}

		public RadiusCorners(double leftRight, double bottomTop)
			: this(leftRight, bottomTop, leftRight, bottomTop)
		{
		}

		public RadiusCorners(double ne = 0, double nw = 0, double sw = 0, double se = 0)
		{
			this.NE = ne;
			this.NW = nw;
			this.SW = sw;
			this.SE = se;
		}

		public static implicit operator RadiusCorners(int valueForAll) // explicit byte to digit conversion operator
		{
			return new RadiusCorners(valueForAll);
		}

		public static implicit operator RadiusCorners(double valueForAll)
		{
			return new RadiusCorners(valueForAll);
		}

		public static bool operator ==(RadiusCorners a, RadiusCorners b)
		{
			if (a.NE == b.NE && a.NW == b.NW && a.SW == b.SW && a.SE == b.SE)
			{
				return true;
			}

			return false;
		}

		public static bool operator !=(RadiusCorners a, RadiusCorners b)
		{
			if (a.NE != b.NE || a.NW != b.NW || a.SW != b.SW || a.SE != b.SE)
			{
				return true;
			}

			return false;
		}

		public override int GetHashCode()
		{
			return new { x1 = NE, x2 = SW, y1 = NW, y2 = SE }.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj.GetType() == typeof(RadiusCorners))
			{
				return this == (RadiusCorners)obj;
			}

			return false;
		}

		public override string ToString()
		{
			return $"{NE}, {NW}, {SW}, {SE}";
		}
	}

	public class RadiusCornersConverter : TypeConverter
	{
		public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
		{
			return sourceType == typeof(string) || base.CanConvertFrom(context, sourceType);
		}

		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
		{
			string stringValue = value as string;

			if (!string.IsNullOrEmpty(stringValue))
			{
				var values = stringValue.Split(',').Select(s =>
				{
					double.TryParse(s, out double result);
					return result;
				}).ToArray();

				switch (values.Length)
				{
					case 1:
						return new RadiusCorners(values[0]);
					case 2:
						return new RadiusCorners(values[0], values[1]);
					case 4:
						return new RadiusCorners(values[0], values[1], values[2], values[3]);
					default:
						return 0;
				}
			}

			return base.ConvertFrom(context, culture, value);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\RectangleDouble.cs
/*
Copyright (c) 2014, Lars Brubaker
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using MatterHackers.VectorMath;
using Newtonsoft.Json;
using System;

namespace MatterHackers.Agg
{
	public struct RectangleDouble
	{
		public double Left, Bottom, Right, Top;

		public static readonly RectangleDouble ZeroIntersection = new RectangleDouble(double.MaxValue, double.MaxValue, double.MinValue, double.MinValue);

		public RectangleDouble(double left, double bottom, double right, double top)
		{
			this.Left = left;
			this.Bottom = bottom;
			this.Right = right;
			this.Top = top;
		}

		public RectangleDouble(RectangleInt intRect)
		{
			Left = intRect.Left;
			Bottom = intRect.Bottom;
			Right = intRect.Right;
			Top = intRect.Top;
		}

		public RectangleDouble(Vector2 position1, Vector2 position2) :
			this(Math.Min(position1.X, position2.X), Math.Min(position1.Y, position2.Y), Math.Max(position1.X, position2.X), Math.Max(position1.Y, position2.Y))
		{
		}

		public void SetRect(double left, double bottom, double right, double top)
		{
			init(left, bottom, right, top);
		}

		public static bool operator ==(RectangleDouble a, RectangleDouble b)
		{
			if (a.Left == b.Left && a.Bottom == b.Bottom && a.Right == b.Right && a.Top == b.Top)
			{
				return true;
			}

			return false;
		}

		public static bool operator !=(RectangleDouble a, RectangleDouble b)
		{
			if (a.Left != b.Left || a.Bottom != b.Bottom || a.Right != b.Right || a.Top != b.Top)
			{
				return true;
			}

			return false;
		}

		public override int GetHashCode()
		{
			return new { x1 = Left, x2 = Right, y1 = Bottom, y2 = Top }.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj.GetType() == typeof(RectangleDouble))
			{
				return this == (RectangleDouble)obj;
			}

			return false;
		}

		public bool Equals(RectangleDouble other, double epsilon)
		{
			return Math.Abs(Left - other.Left) <= epsilon
				&& Math.Abs(Bottom - other.Bottom) <= epsilon
				&& Math.Abs(Right - other.Right) <= epsilon
				&& Math.Abs(Top - other.Top) <= epsilon;
		}

		public void init(double left, double bottom, double right, double top)
		{
			Left = left;
			Bottom = bottom;
			Right = right;
			Top = top;
		}

		// This function assumes the rect is normalized
		[JsonIgnoreAttribute]
		public double Width
		{
			get
			{
				return Right - Left;
			}
		}

		// This function assumes the rect is normalized
		[JsonIgnoreAttribute]
		public double Height
		{
			get
			{
				return Top - Bottom;
			}
		}

		public RectangleDouble normalize()
		{
			double t;
			if (Left > Right)
			{
				t = Left;
				Left = Right;
				Right = t;
			}

			if (Bottom > Top)
			{
				t = Bottom;
				Bottom = Top;
				Top = t;
			}

			return this;
		}

		public bool clip(RectangleDouble r)
		{
			if (Right > r.Right)
			{
				Right = r.Right;
			}

			if (Top > r.Top)
			{
				Top = r.Top;
			}

			if (Left < r.Left)
			{
				Left = r.Left;
			}

			if (Bottom < r.Bottom)
			{
				Bottom = r.Bottom;
			}

			return Left <= Right && Bottom <= Top;
		}

		public bool is_valid()
		{
			return Left <= Right && Bottom <= Top;
		}

		public bool Contains(double x, double y)
		{
			return x >= Left && x <= Right && y >= Bottom && y <= Top;
		}

		public bool Contains(RectangleDouble innerRect)
		{
			if (Contains(innerRect.Left, innerRect.Bottom) && Contains(innerRect.Right, innerRect.Top))
			{
				return true;
			}

			return false;
		}

		public bool Contains(Vector2 position)
		{
			return Contains(position.X, position.Y);
		}

		public bool Contains(Point2D position)
		{
			return Contains(position.x, position.y);
		}

		public bool IntersectRectangles(RectangleDouble rectToCopy, RectangleDouble rectToIntersectWith)
		{
			Left = rectToCopy.Left;
			Bottom = rectToCopy.Bottom;
			Right = rectToCopy.Right;
			Top = rectToCopy.Top;

			if (Left < rectToIntersectWith.Left)
			{
				Left = rectToIntersectWith.Left;
			}

			if (Bottom < rectToIntersectWith.Bottom)
			{
				Bottom = rectToIntersectWith.Bottom;
			}

			if (Right > rectToIntersectWith.Right)
			{
				Right = rectToIntersectWith.Right;
			}

			if (Top > rectToIntersectWith.Top)
			{
				Top = rectToIntersectWith.Top;
			}

			if (Left < Right && Bottom < Top)
			{
				return true;
			}

			return false;
		}

		public bool IsTouching(RectangleDouble rectToIntersectWith)
		{
			RectangleDouble temp = this;

			return temp.IntersectWithRectangle(rectToIntersectWith);
		}

		public bool IntersectWithRectangle(RectangleDouble rectToIntersectWith)
		{
			if (Left < rectToIntersectWith.Left)
			{
				Left = rectToIntersectWith.Left;
			}

			if (Bottom < rectToIntersectWith.Bottom)
			{
				Bottom = rectToIntersectWith.Bottom;
			}

			if (Right > rectToIntersectWith.Right)
			{
				Right = rectToIntersectWith.Right;
			}

			if (Top > rectToIntersectWith.Top)
			{
				Top = rectToIntersectWith.Top;
			}

			if (Left < Right && Bottom < Top)
			{
				return true;
			}

			return false;
		}

		public void unite_rectangles(RectangleDouble r1, RectangleDouble r2)
		{
			Left = r1.Left;
			Bottom = r1.Bottom;
			Right = r1.Right;
			Right = r1.Top;
			if (Right < r2.Right)
			{
				Right = r2.Right;
			}

			if (Top < r2.Top)
			{
				Top = r2.Top;
			}

			if (Left > r2.Left)
			{
				Left = r2.Left;
			}

			if (Bottom > r2.Bottom)
			{
				Bottom = r2.Bottom;
			}
		}

		public void ExpandToInclude(RectangleDouble rectToInclude)
		{
			if (Right < rectToInclude.Right)
			{
				Right = rectToInclude.Right;
			}

			if (Top < rectToInclude.Top)
			{
				Top = rectToInclude.Top;
			}

			if (Left > rectToInclude.Left)
			{
				Left = rectToInclude.Left;
			}

			if (Bottom > rectToInclude.Bottom)
			{
				Bottom = rectToInclude.Bottom;
			}
		}

		public void ExpandToInclude(Vector2 position)
		{
			ExpandToInclude(position.X, position.Y);
		}

		public void ExpandToInclude(double x, double y)
		{
			if (Right < x)
			{
				Right = x;
			}

			if (Top < y)
			{
				Top = y;
			}

			if (Left > x)
			{
				Left = x;
			}

			if (Bottom > y)
			{
				Bottom = y;
			}
		}

		public void Inflate(int inflateSize)
		{
			Left -= inflateSize;
			Bottom -= inflateSize;
			Right += inflateSize;
			Top += inflateSize;
		}

		public void Inflate(double inflateSize)
		{
			Left -= inflateSize;
			Bottom -= inflateSize;
			Right += inflateSize;
			Top += inflateSize;
		}

		public void Inflate(BorderDouble borderDouble)
		{
			Left -= borderDouble.Left;
			Right += borderDouble.Right;
			Bottom -= borderDouble.Bottom;
			Top += borderDouble.Top;
		}

		public void Deflate(BorderDouble borderDouble)
		{
			Left += borderDouble.Left;
			Right -= borderDouble.Right;
			Bottom += borderDouble.Bottom;
			Top -= borderDouble.Top;
		}

		public void Offset(Vector2 offset)
		{
			Offset(offset.X, offset.Y);
		}

		public void Offset(double x, double y)
		{
			Left += x;
			Bottom += y;
			Right += x;
			Top += y;
		}

		public static RectangleDouble operator *(RectangleDouble a, double b)
		{
			return new RectangleDouble(a.Left * b, a.Bottom * b, a.Right * b, a.Top * b);
		}

		public static RectangleDouble operator *(double b, RectangleDouble a)
		{
			return new RectangleDouble(a.Left * b, a.Bottom * b, a.Right * b, a.Top * b);
		}

		[JsonIgnore]
		public Vector2 Center => new Vector2(XCenter, YCenter);

		[JsonIgnore]
		public double XCenter => (Right + Left) / 2;

		[JsonIgnore]
		public double YCenter => (Top + Bottom) / 2;

		public Vector2 Size
		{
			get
			{
				return new Vector2(Width, Height);
			}
		}

		public override string ToString()
		{
			return string.Format("L:{0}, B:{1}, R:{2}, T:{3}", Left, Bottom, Right, Top);
		}

		[Flags]
		public enum OutCode
		{
			Inside = 0,
			Left = 1,
			Right = 2,
			Bottom = 4,
			Top = 8,
			Surrounded = Left | Right | Bottom | Top
		}

		public OutCode ComputeOutCode(double x, double y)
		{
			var code = OutCode.Inside;

			if (x < this.Left)
			{
				code |= OutCode.Left;
			}

			if (x > this.Right)
			{
				code |= OutCode.Right;
			}

			if (y < this.Bottom)
			{
				code |= OutCode.Bottom;
			}

			if (y > this.Top)
			{
				code |= OutCode.Top;
			}

			return code;
		}

		public OutCode ComputeOutCode(Vector2 p)
		{
			return ComputeOutCode(p.X, p.Y); 
		}

		private Vector2 CalculateIntersection(Vector2 p1, Vector2 p2, OutCode clipTo)
		{
			var dx = p2.X - p1.X;
			var dy = p2.Y - p1.Y;

			var slopeY = dx / dy; // slope to use for possibly-vertical lines
			var slopeX = dy / dx; // slope to use for possibly-horizontal lines

			if (clipTo.HasFlag(OutCode.Top))
			{
				return new Vector2(
					p1.X + slopeY * (this.Top - p1.Y),
					this.Top);
			}

			if (clipTo.HasFlag(OutCode.Bottom))
			{
				return new Vector2(
					p1.X + slopeY * (this.Bottom - p1.Y),
					this.Bottom);
			}

			if (clipTo.HasFlag(OutCode.Right))
			{
				return new Vector2(
					this.Right,
					p1.Y + slopeX * (this.Right - p1.X));
			}

			if (clipTo.HasFlag(OutCode.Left))
			{
				return new Vector2(
					this.Left,
					p1.Y + slopeX * (this.Left - p1.X));
			}

			throw new ArgumentOutOfRangeException("clipTo = " + clipTo);
		}

		private Tuple<Vector2, Vector2> ClipSegment(Vector2 p1, Vector2 p2)
		{
			// classify the endpoints of the line
			var outCodeP1 = this.ComputeOutCode(p1);
			var outCodeP2 = this.ComputeOutCode(p2);
			var accept = false;

			while (true)
			{ // should only iterate twice, at most
			  // Case 1:
			  // both endpoints are within the clipping region
				if ((outCodeP1 | outCodeP2) == OutCode.Inside)
				{
					accept = true;
					break;
				}

				// Case 2:
				// both endpoints share an excluded region, impossible for a line between them to be within the clipping region
				if ((outCodeP1 & outCodeP2) != 0)
				{
					break;
				}

				// Case 3:
				// The endpoints are in different regions, and the segment is partially within the clipping rectangle

				// Select one of the endpoints outside the clipping rectangle
				var outCode = outCodeP1 != OutCode.Inside ? outCodeP1 : outCodeP2;

				// calculate the intersection of the line with the clipping rectangle
				var p = this.CalculateIntersection(p1, p2, outCode);

				// update the point after clipping and recalculate outcode
				if (outCode == outCodeP1)
				{
					p1 = p;
					outCodeP1 = this.ComputeOutCode(p1);
				}
				else
				{
					p2 = p;
					outCodeP2 = this.ComputeOutCode(p2);
				}
			}

			// if clipping area contained a portion of the line
			if (accept)
			{
				return new Tuple<Vector2, Vector2>(p1, p2);
			}

			// the line did not intersect the clipping area
			return null;
		}

		public Vector2 Clamp(Vector2 actualNozzlePosition)
		{
			var newX = Math.Min(Right, Math.Max(Left, actualNozzlePosition.X));
			var newY = Math.Min(Top, Math.Max(Bottom, actualNozzlePosition.Y));
			return new Vector2(newX, newY);
		}

		public bool ClipLine(Vector2 p1, Vector2 p2)
		{
			if (this.ClipSegment(p1, p2) != null)
			{
				return true;
			}

			return false;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\RectangleFloat.cs
/*
Copyright (c) 2014, Lars Brubaker
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using MatterHackers.VectorMath;
using Newtonsoft.Json;
using System;

namespace MatterHackers.Agg
{
	public struct RectangleFloat
	{
		public float Left, Bottom, Right, Top;

		public static readonly RectangleFloat ZeroIntersection = new RectangleFloat(float.MaxValue, float.MaxValue, float.MinValue, float.MinValue);

		public RectangleFloat(float left, float bottom, float right, float top)
		{
			this.Left = left;
			this.Bottom = bottom;
			this.Right = right;
			this.Top = top;
		}

		public RectangleFloat(RectangleInt intRect)
		{
			Left = intRect.Left;
			Bottom = intRect.Bottom;
			Right = intRect.Right;
			Top = intRect.Top;
		}

		public void SetRect(float left, float bottom, float right, float top)
		{
			init(left, bottom, right, top);
		}

		public static bool operator ==(RectangleFloat a, RectangleFloat b)
		{
			if (a.Left == b.Left && a.Bottom == b.Bottom && a.Right == b.Right && a.Top == b.Top)
			{
				return true;
			}

			return false;
		}

		public static bool operator !=(RectangleFloat a, RectangleFloat b)
		{
			if (a.Left != b.Left || a.Bottom != b.Bottom || a.Right != b.Right || a.Top != b.Top)
			{
				return true;
			}

			return false;
		}

		public override int GetHashCode()
		{
			return new { x1 = Left, x2 = Right, y1 = Bottom, y2 = Top }.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj.GetType() == typeof(RectangleFloat))
			{
				return this == (RectangleFloat)obj;
			}
			return false;
		}

		public bool Equals(RectangleFloat other, float epsilon)
		{
			return Math.Abs(Left - other.Left) <= epsilon
				&& Math.Abs(Bottom - other.Bottom) <= epsilon
				&& Math.Abs(Right - other.Right) <= epsilon
				&& Math.Abs(Top - other.Top) <= epsilon;
		}

		public void init(float left, float bottom, float right, float top)
		{
			Left = left;
			Bottom = bottom;
			Right = right;
			Top = top;
		}

		// This function assumes the rect is normalized
		[JsonIgnoreAttribute]
		public float Width
		{
			get
			{
				return Right - Left;
			}
		}

		// This function assumes the rect is normalized
		[JsonIgnoreAttribute]
		public float Height
		{
			get
			{
				return Top - Bottom;
			}
		}

		public RectangleFloat normalize()
		{
			float t;
			if (Left > Right) { t = Left; Left = Right; Right = t; }
			if (Bottom > Top) { t = Bottom; Bottom = Top; Top = t; }
			return this;
		}

		public bool clip(RectangleFloat r)
		{
			if (Right > r.Right) Right = r.Right;
			if (Top > r.Top) Top = r.Top;
			if (Left < r.Left) Left = r.Left;
			if (Bottom < r.Bottom) Bottom = r.Bottom;
			return Left <= Right && Bottom <= Top;
		}

		public bool is_valid()
		{
			return Left <= Right && Bottom <= Top;
		}

		public bool Contains(float x, float y)
		{
			return (x >= Left && x <= Right && y >= Bottom && y <= Top);
		}

		public bool Contains(RectangleFloat innerRect)
		{
			if (Contains(innerRect.Left, innerRect.Bottom) && Contains(innerRect.Right, innerRect.Top))
			{
				return true;
			}

			return false;
		}

		public bool Contains(Vector2 position)
		{
			return Contains((float)position.X, (float)position.Y);
		}

		public bool IntersectRectangles(RectangleFloat rectToCopy, RectangleFloat rectToIntersectWith)
		{
			Left = rectToCopy.Left;
			Bottom = rectToCopy.Bottom;
			Right = rectToCopy.Right;
			Top = rectToCopy.Top;

			if (Left < rectToIntersectWith.Left) Left = rectToIntersectWith.Left;
			if (Bottom < rectToIntersectWith.Bottom) Bottom = rectToIntersectWith.Bottom;
			if (Right > rectToIntersectWith.Right) Right = rectToIntersectWith.Right;
			if (Top > rectToIntersectWith.Top) Top = rectToIntersectWith.Top;

			if (Left < Right && Bottom < Top)
			{
				return true;
			}

			return false;
		}

		public bool IntersectWithRectangle(RectangleFloat rectToIntersectWith)
		{
			if (Left < rectToIntersectWith.Left) Left = rectToIntersectWith.Left;
			if (Bottom < rectToIntersectWith.Bottom) Bottom = rectToIntersectWith.Bottom;
			if (Right > rectToIntersectWith.Right) Right = rectToIntersectWith.Right;
			if (Top > rectToIntersectWith.Top) Top = rectToIntersectWith.Top;

			if (Left < Right && Bottom < Top)
			{
				return true;
			}

			return false;
		}

		public void unite_rectangles(RectangleFloat r1, RectangleFloat r2)
		{
			Left = r1.Left;
			Bottom = r1.Bottom;
			Right = r1.Right;
			Right = r1.Top;
			if (Right < r2.Right) Right = r2.Right;
			if (Top < r2.Top) Top = r2.Top;
			if (Left > r2.Left) Left = r2.Left;
			if (Bottom > r2.Bottom) Bottom = r2.Bottom;
		}

		public void ExpandToInclude(RectangleFloat rectToInclude)
		{
			if (Right < rectToInclude.Right) Right = rectToInclude.Right;
			if (Top < rectToInclude.Top) Top = rectToInclude.Top;
			if (Left > rectToInclude.Left) Left = rectToInclude.Left;
			if (Bottom > rectToInclude.Bottom) Bottom = rectToInclude.Bottom;
		}

		public void ExpandToInclude(Vector2 position)
		{
			ExpandToInclude((float)position.X, (float)position.Y);
		}

		public void ExpandToInclude(float x, float y)
		{
			if (Right < x) Right = x;
			if (Top < y) Top = y;
			if (Left > x) Left = x;
			if (Bottom > y) Bottom = y;
		}

		public void Inflate(float inflateSize)
		{
			Left = Left - inflateSize;
			Bottom = Bottom - inflateSize;
			Right = Right + inflateSize;
			Top = Top + inflateSize;
		}

		public void Offset(Vector2 offset)
		{
			Offset((float)offset.X, (float)offset.Y);
		}

		public void Offset(float x, float y)
		{
			Left = Left + x;
			Bottom = Bottom + y;
			Right = Right + x;
			Top = Top + y;
		}

		static public RectangleFloat operator *(RectangleFloat a, float b)
		{
			return new RectangleFloat(a.Left * b, a.Bottom * b, a.Right * b, a.Top * b);
		}

		static public RectangleFloat operator *(float b, RectangleFloat a)
		{
			return new RectangleFloat(a.Left * b, a.Bottom * b, a.Right * b, a.Top * b);
		}

		public float XCenter
		{
			get { return (Right - Left) / 2; }
		}

		public float YCenter
		{
			get { return (Top - Bottom) / 2; }
		}

#if false
		public void Inflate(BorderFloat borderFloat)
		{
			Left -= borderFloat.Left;
			Right += borderFloat.Right;
			Bottom -= borderFloat.Bottom;
			Top += borderFloat.Top;
		}

		public void Deflate(BorderFloat borderFloat)
		{
			Left += borderFloat.Left;
			Right -= borderFloat.Right;
			Bottom += borderFloat.Bottom;
			Top -= borderFloat.Top;
		}
#endif

		public override string ToString()
		{
			return string.Format("L:{0}, B:{1}, R:{2}, T:{3}", Left, Bottom, Right, Top);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\RectangleInt.cs
/*
Copyright (c) 2022, Lars Brubaker
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using Newtonsoft.Json;
using System;

namespace MatterHackers.Agg
{
    public struct RectangleInt
    {
        public int Left, Bottom, Right, Top;

        public RectangleInt(int left, int bottom, int right, int top)
        {
            Left = left;
            Bottom = bottom;
            Right = right;
            Top = top;
        }

        public RectangleInt(RectangleDouble rect)
        {
            Left = (int)Math.Floor(rect.Left);
            Bottom = (int)Math.Floor(rect.Bottom);
            Right = (int)Math.Ceiling(rect.Right);
            Top = (int)Math.Ceiling(rect.Top);
        }

        // This function assumes the rect is normalized
        [JsonIgnoreAttribute]
        public int Height
        {
            get
            {
                return Top - Bottom;
            }
        }

        // This function assumes the rect is normalized
        [JsonIgnoreAttribute]
        public int Width
        {
            get
            {
                return Right - Left;
            }
        }

        //***************************************************************************************************************************************************
        public static bool ClipRect(RectangleInt pBoundingRect, ref RectangleInt pDestRect)
        {
            // clip off the top so we don't write into random memory
            if (pDestRect.Top < pBoundingRect.Top)
            {
                pDestRect.Top = pBoundingRect.Top;
                if (pDestRect.Top >= pDestRect.Bottom)
                {
                    return false;
                }
            }
            // clip off the bottom
            if (pDestRect.Bottom > pBoundingRect.Bottom)
            {
                pDestRect.Bottom = pBoundingRect.Bottom;
                if (pDestRect.Bottom <= pDestRect.Top)
                {
                    return false;
                }
            }

            // clip off the left
            if (pDestRect.Left < pBoundingRect.Left)
            {
                pDestRect.Left = pBoundingRect.Left;
                if (pDestRect.Left >= pDestRect.Right)
                {
                    return false;
                }
            }

            // clip off the right
            if (pDestRect.Right > pBoundingRect.Right)
            {
                pDestRect.Right = pBoundingRect.Right;
                if (pDestRect.Right <= pDestRect.Left)
                {
                    return false;
                }
            }

            return true;
        }

        public static bool ClipRects(RectangleInt pBoundingRect, ref RectangleInt pSourceRect, ref RectangleInt pDestRect)
        {
            // clip off the top so we don't write into random memory
            if (pDestRect.Top < pBoundingRect.Top)
            {
                // This type of clipping only works when we aren't scaling an image...
                // If we are scaling an image, the source and dest sizes won't match
                if (pSourceRect.Height != pDestRect.Height)
                {
                    throw new Exception("source and dest rects must have the same height");
                }

                pSourceRect.Top += pBoundingRect.Top - pDestRect.Top;
                pDestRect.Top = pBoundingRect.Top;
                if (pDestRect.Top >= pDestRect.Bottom)
                {
                    return false;
                }
            }
            // clip off the bottom
            if (pDestRect.Bottom > pBoundingRect.Bottom)
            {
                // This type of clipping only works when we aren't scaling an image...
                // If we are scaling an image, the source and dest sizes won't match
                if (pSourceRect.Height != pDestRect.Height)
                {
                    throw new Exception("source and dest rects must have the same height");
                }

                pSourceRect.Bottom -= pDestRect.Bottom - pBoundingRect.Bottom;
                pDestRect.Bottom = pBoundingRect.Bottom;
                if (pDestRect.Bottom <= pDestRect.Top)
                {
                    return false;
                }
            }

            // clip off the left
            if (pDestRect.Left < pBoundingRect.Left)
            {
                // This type of clipping only works when we aren't scaling an image...
                // If we are scaling an image, the source and dest sizes won't match
                if (pSourceRect.Width != pDestRect.Width)
                {
                    throw new Exception("source and dest rects must have the same width");
                }

                pSourceRect.Left += pBoundingRect.Left - pDestRect.Left;
                pDestRect.Left = pBoundingRect.Left;
                if (pDestRect.Left >= pDestRect.Right)
                {
                    return false;
                }
            }
            // clip off the right
            if (pDestRect.Right > pBoundingRect.Right)
            {
                // This type of clipping only works when we aren't scaling an image...
                // If we are scaling an image, the source and dest sizes won't match
                if (pSourceRect.Width != pDestRect.Width)
                {
                    throw new Exception("source and dest rects must have the same width");
                }

                pSourceRect.Right -= pDestRect.Right - pBoundingRect.Right;
                pDestRect.Right = pBoundingRect.Right;
                if (pDestRect.Right <= pDestRect.Left)
                {
                    return false;
                }
            }

            return true;
        }

        public static bool DoIntersect(RectangleInt rect1, RectangleInt rect2)
        {
            int x1 = rect1.Left;
            int y1 = rect1.Bottom;
            int x2 = rect1.Right;
            int y2 = rect1.Top;

            if (x1 < rect2.Left) x1 = rect2.Left;
            if (y1 < rect2.Bottom) y1 = rect2.Bottom;
            if (x2 > rect2.Right) x2 = rect2.Right;
            if (y2 > rect2.Top) y2 = rect2.Top;

            if (x1 < x2 && y1 < y2)
            {
                return true;
            }

            return false;
        }

        public bool clip(RectangleInt r)
        {
            if (Right > r.Right) Right = r.Right;
            if (Top > r.Top) Top = r.Top;
            if (Left < r.Left) Left = r.Left;
            if (Bottom < r.Bottom) Bottom = r.Bottom;
            return Left <= Right && Bottom <= Top;
        }

        public void ExpandToInclude(RectangleInt rectToInclude)
        {
            if (Right < rectToInclude.Right) Right = rectToInclude.Right;
            if (Top < rectToInclude.Top) Top = rectToInclude.Top;
            if (Left > rectToInclude.Left) Left = rectToInclude.Left;
            if (Bottom > rectToInclude.Bottom) Bottom = rectToInclude.Bottom;
        }

        public override int GetHashCode()
        {
            return new { x1 = Left, x2 = Right, y1 = Bottom, y2 = Top }.GetHashCode();
        }

        public bool hit_test(int x, int y)
        {
            return (x >= Left && x <= Right && y >= Bottom && y <= Top);
        }

        public void Inflate(int inflateSize)
        {
            Left = Left - inflateSize;
            Bottom = Bottom - inflateSize;
            Right = Right + inflateSize;
            Top = Top + inflateSize;
        }

        public void init(int x1_, int y1_, int x2_, int y2_)
        {
            Left = x1_;
            Bottom = y1_;
            Right = x2_;
            Top = y2_;
        }

        public bool IntersectRectangles(RectangleInt rectToCopy, RectangleInt rectToIntersectWith)
        {
            Left = rectToCopy.Left;
            Bottom = rectToCopy.Bottom;
            Right = rectToCopy.Right;
            Top = rectToCopy.Top;

            if (Left < rectToIntersectWith.Left) Left = rectToIntersectWith.Left;
            if (Bottom < rectToIntersectWith.Bottom) Bottom = rectToIntersectWith.Bottom;
            if (Right > rectToIntersectWith.Right) Right = rectToIntersectWith.Right;
            if (Top > rectToIntersectWith.Top) Top = rectToIntersectWith.Top;

            if (Left < Right && Bottom < Top)
            {
                return true;
            }

            return false;
        }

        public bool IntersectWithRectangle(RectangleInt rectToIntersectWith)
        {
            if (Left < rectToIntersectWith.Left) Left = rectToIntersectWith.Left;
            if (Bottom < rectToIntersectWith.Bottom) Bottom = rectToIntersectWith.Bottom;
            if (Right > rectToIntersectWith.Right) Right = rectToIntersectWith.Right;
            if (Top > rectToIntersectWith.Top) Top = rectToIntersectWith.Top;

            if (Left < Right && Bottom < Top)
            {
                return true;
            }

            return false;
        }

        public bool is_valid()
        {
            return Left <= Right && Bottom <= Top;
        }

        public RectangleInt normalize()
        {
            int t;
            if (Left > Right) { t = Left; Left = Right; Right = t; }
            if (Bottom > Top) { t = Bottom; Bottom = Top; Top = t; }
            return this;
        }

        public void Offset(int x, int y)
        {
            Left = Left + x;
            Bottom = Bottom + y;
            Right = Right + x;
            Top = Top + y;
        }

        public void SetRect(int left, int bottom, int right, int top)
        {
            init(left, bottom, right, top);
        }

        //---------------------------------------------------------unite_rectangles
        public void unite_rectangles(RectangleInt r1, RectangleInt r2)
        {
            Left = r1.Left;
            Bottom = r1.Bottom;
            Right = r1.Right;
            Right = r1.Top;
            if (Right < r2.Right) Right = r2.Right;
            if (Top < r2.Top) Top = r2.Top;
            if (Left > r2.Left) Left = r2.Left;
            if (Bottom > r2.Bottom) Bottom = r2.Bottom;
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\RectangleLong.cs
/*
Copyright (c) 2022, Lars Brubaker
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using Newtonsoft.Json;
using System;

namespace MatterHackers.Agg
{
    public struct RectangleLong
    {
        public long Left, Bottom, Right, Top;

        public long minX { get => Left; set => Left = value; }
        public long minY { get => Bottom; set => Bottom = value; }
        public long maxX { get => Right; set => Right = value; }
        public long maxY { get => Top; set => Top = value; }
        

        public static readonly RectangleLong ZeroIntersection = new RectangleLong(long.MaxValue, long.MaxValue, long.MinValue, long.MinValue);

        public RectangleLong(long left, long bottom, long right, long top)
        {
            Left = left;
            Bottom = bottom;
            Right = right;
            Top = top;
        }

        // This function assumes the rect is normalized
        [JsonIgnoreAttribute]
        public long Height
        {
            get
            {
                return Top - Bottom;
            }
        }

        // This function assumes the rect is normalized
        [JsonIgnoreAttribute]
        public long Width
        {
            get
            {
                return Right - Left;
            }
        }

        public static bool ClipRect(RectangleLong pBoundingRect, ref RectangleLong pDestRect)
        {
            // clip off the top so we don't write into random memory
            if (pDestRect.Top < pBoundingRect.Top)
            {
                pDestRect.Top = pBoundingRect.Top;
                if (pDestRect.Top >= pDestRect.Bottom)
                {
                    return false;
                }
            }
            // clip off the bottom
            if (pDestRect.Bottom > pBoundingRect.Bottom)
            {
                pDestRect.Bottom = pBoundingRect.Bottom;
                if (pDestRect.Bottom <= pDestRect.Top)
                {
                    return false;
                }
            }

            // clip off the left
            if (pDestRect.Left < pBoundingRect.Left)
            {
                pDestRect.Left = pBoundingRect.Left;
                if (pDestRect.Left >= pDestRect.Right)
                {
                    return false;
                }
            }

            // clip off the right
            if (pDestRect.Right > pBoundingRect.Right)
            {
                pDestRect.Right = pBoundingRect.Right;
                if (pDestRect.Right <= pDestRect.Left)
                {
                    return false;
                }
            }

            return true;
        }

        public static bool ClipRects(RectangleLong pBoundingRect, ref RectangleLong pSourceRect, ref RectangleLong pDestRect)
        {
            // clip off the top so we don't write into random memory
            if (pDestRect.Top < pBoundingRect.Top)
            {
                // This type of clipping only works when we aren't scaling an image...
                // If we are scaling an image, the source and dest sizes won't match
                if (pSourceRect.Height != pDestRect.Height)
                {
                    throw new Exception("source and dest rects must have the same height");
                }

                pSourceRect.Top += pBoundingRect.Top - pDestRect.Top;
                pDestRect.Top = pBoundingRect.Top;
                if (pDestRect.Top >= pDestRect.Bottom)
                {
                    return false;
                }
            }
            // clip off the bottom
            if (pDestRect.Bottom > pBoundingRect.Bottom)
            {
                // This type of clipping only works when we aren't scaling an image...
                // If we are scaling an image, the source and dest sizes won't match
                if (pSourceRect.Height != pDestRect.Height)
                {
                    throw new Exception("source and dest rects must have the same height");
                }

                pSourceRect.Bottom -= pDestRect.Bottom - pBoundingRect.Bottom;
                pDestRect.Bottom = pBoundingRect.Bottom;
                if (pDestRect.Bottom <= pDestRect.Top)
                {
                    return false;
                }
            }

            // clip off the left
            if (pDestRect.Left < pBoundingRect.Left)
            {
                // This type of clipping only works when we aren't scaling an image...
                // If we are scaling an image, the source and dest sizes won't match
                if (pSourceRect.Width != pDestRect.Width)
                {
                    throw new Exception("source and dest rects must have the same width");
                }

                pSourceRect.Left += pBoundingRect.Left - pDestRect.Left;
                pDestRect.Left = pBoundingRect.Left;
                if (pDestRect.Left >= pDestRect.Right)
                {
                    return false;
                }
            }
            // clip off the right
            if (pDestRect.Right > pBoundingRect.Right)
            {
                // This type of clipping only works when we aren't scaling an image...
                // If we are scaling an image, the source and dest sizes won't match
                if (pSourceRect.Width != pDestRect.Width)
                {
                    throw new Exception("source and dest rects must have the same width");
                }

                pSourceRect.Right -= pDestRect.Right - pBoundingRect.Right;
                pDestRect.Right = pBoundingRect.Right;
                if (pDestRect.Right <= pDestRect.Left)
                {
                    return false;
                }
            }

            return true;
        }

        public static bool DoIntersect(RectangleLong rect1, RectangleLong rect2)
        {
            long x1 = rect1.Left;
            long y1 = rect1.Bottom;
            long x2 = rect1.Right;
            long y2 = rect1.Top;

            if (x1 < rect2.Left) x1 = rect2.Left;
            if (y1 < rect2.Bottom) y1 = rect2.Bottom;
            if (x2 > rect2.Right) x2 = rect2.Right;
            if (y2 > rect2.Top) y2 = rect2.Top;

            if (x1 < x2 && y1 < y2)
            {
                return true;
            }

            return false;
        }

        public bool clip(RectangleLong r)
        {
            if (Right > r.Right) Right = r.Right;
            if (Top > r.Top) Top = r.Top;
            if (Left < r.Left) Left = r.Left;
            if (Bottom < r.Bottom) Bottom = r.Bottom;
            return Left <= Right && Bottom <= Top;
        }

        public void ExpandToInclude(RectangleLong rectToInclude)
        {
            if (Right < rectToInclude.Right) Right = rectToInclude.Right;
            if (Top < rectToInclude.Top) Top = rectToInclude.Top;
            if (Left > rectToInclude.Left) Left = rectToInclude.Left;
            if (Bottom > rectToInclude.Bottom) Bottom = rectToInclude.Bottom;
        }

        public void ExpandToInclude(long x, long y)
        {
            if (Right < x) Right = x;
            if (Top < y) Top = y;
            if (Left > x) Left = x;
            if (Bottom > y) Bottom = y;
        }

        public override int GetHashCode()
        {
            var hash = Left.GetLongHashCode(Bottom.GetLongHashCode(Right.GetLongHashCode(Top.GetLongHashCode())));
            return (int)hash;
        }

        public bool hit_test(long x, long y)
        {
            return (x >= Left && x <= Right && y >= Bottom && y <= Top);
        }

        public void Inflate(long inflateSize)
        {
            Left = Left - inflateSize;
            Bottom = Bottom - inflateSize;
            Right = Right + inflateSize;
            Top = Top + inflateSize;
        }

        public void init(long x1_, long y1_, long x2_, long y2_)
        {
            Left = x1_;
            Bottom = y1_;
            Right = x2_;
            Top = y2_;
        }

        public bool IntersectRectangles(RectangleLong rectToCopy, RectangleLong rectToIntersectWith)
        {
            Left = rectToCopy.Left;
            Bottom = rectToCopy.Bottom;
            Right = rectToCopy.Right;
            Top = rectToCopy.Top;

            if (Left < rectToIntersectWith.Left) Left = rectToIntersectWith.Left;
            if (Bottom < rectToIntersectWith.Bottom) Bottom = rectToIntersectWith.Bottom;
            if (Right > rectToIntersectWith.Right) Right = rectToIntersectWith.Right;
            if (Top > rectToIntersectWith.Top) Top = rectToIntersectWith.Top;

            if (Left < Right && Bottom < Top)
            {
                return true;
            }

            return false;
        }

        public bool IntersectWithRectangle(RectangleLong rectToIntersectWith)
        {
            if (Left < rectToIntersectWith.Left) Left = rectToIntersectWith.Left;
            if (Bottom < rectToIntersectWith.Bottom) Bottom = rectToIntersectWith.Bottom;
            if (Right > rectToIntersectWith.Right) Right = rectToIntersectWith.Right;
            if (Top > rectToIntersectWith.Top) Top = rectToIntersectWith.Top;

            if (Left < Right && Bottom < Top)
            {
                return true;
            }

            return false;
        }

        public bool is_valid()
        {
            return Left <= Right && Bottom <= Top;
        }

        public RectangleLong normalize()
        {
            long t;
            if (Left > Right) { t = Left; Left = Right; Right = t; }
            if (Bottom > Top) { t = Bottom; Bottom = Top; Top = t; }
            return this;
        }

        public void Offset(long x, long y)
        {
            Left = Left + x;
            Bottom = Bottom + y;
            Right = Right + x;
            Top = Top + y;
        }

        public void SetRect(long left, long bottom, long right, long top)
        {
            init(left, bottom, right, top);
        }

        //---------------------------------------------------------unite_rectangles
        public void unite_rectangles(RectangleLong r1, RectangleLong r2)
        {
            Left = r1.Left;
            Bottom = r1.Bottom;
            Right = r1.Right;
            Right = r1.Top;
            if (Right < r2.Right) Right = r2.Right;
            if (Top < r2.Top) Top = r2.Top;
            if (Left > r2.Left) Left = r2.Left;
            if (Bottom > r2.Bottom) Bottom = r2.Bottom;
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\SafeList.cs
/*
Copyright (c) 2017, Lars Brubaker, John Lewin
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

using System;
using System.Collections;
using System.Collections.Generic;

namespace MatterHackers.Agg
{
	public class SafeList<T> : IEnumerable<T>
	{
		public event EventHandler ItemsModified;

		protected List<T> items = new List<T>();

		public SafeList()
		{
		}

		public SafeList(IEnumerable<T> sourceItems)
		{
			items = new List<T>(sourceItems);
		}

		public void Add(T item) => this.Modify(list => list.Add(item));

		public void Remove(T item) => this.Modify(list => list.Remove(item));

		public int Count => items.Count;

		public bool Contains(T item) => items.Contains(item);

		public T this[int index]
		{
			get
			{
				var tempItems = items;
				if (index < tempItems.Count)
				{
					return tempItems[index];
				}

				return default(T);
			}
		}

		/// <summary>
		/// Provides a safe context to manipulate items. Copies items into a new list, invokes the 'modifier'
		/// Action passing in the copied list and finally swaps the modified list into place after the invoked Action completes
		/// </summary>
		/// <param name="modifier">The Action to invoke</param>
		virtual public void Modify(Action<List<T>> modifier)
		{
			// Copy the child items to a new list
			var safeClone = new List<T>(items);

			// Pass the new list to the Action for manipulation
			modifier(safeClone);

			// Swap the modified list into place
			items = safeClone;

			this.OnItemsModified(null);
		}

		public IEnumerator<T> GetEnumerator() => items.GetEnumerator();

		IEnumerator IEnumerable.GetEnumerator() => items.GetEnumerator();

		public override string ToString()
		{
			if (Count == 1)
			{
				return $"Count = {Count}, Item[0] = {items[0]}";
			}
			else
			{
				return $"Count = {Count}";
			}
		}

		public int IndexOf(T childToFind)
		{
			return items.IndexOf(childToFind);
		}

		protected void OnItemsModified(EventArgs e)
		{
			this.ItemsModified?.Invoke(this, e);
		}

		public void Clear()
		{
			Modify((list) =>
			{
				list.Clear();
			});
		}

		public void AddRange(IEnumerable<T> enumerable)
		{
			this.Modify(list => list.AddRange(enumerable));
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\VectorPOD.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;

namespace MatterHackers.Agg
{
    //--------------------------------------------------------------pod_vector
    // A simple class template to store Plain Old Data, a vector
    // of a fixed size. The data is contiguous in memory
    //------------------------------------------------------------------------
    public class VectorPOD<DataType> where DataType : struct
    {
        protected int currentSize;
        private static DataType zeroed_object;
        private DataType[] internalArray = new DataType[0];

        public VectorPOD()
        {
        }

        public VectorPOD(int cap)
            : this(cap, 0)
        {
        }

        public VectorPOD(int capacity, int extraTail)
        {
            Allocate(capacity, extraTail);
        }

        // Copying
        public VectorPOD(VectorPOD<DataType> vectorToCopy)
        {
            currentSize = vectorToCopy.currentSize;
            internalArray = (DataType[])vectorToCopy.internalArray.Clone();
        }

        public int AllocatedSize
        {
            get
            {
                return internalArray.Length;
            }
        }

        public DataType[] Array
        {
            get
            {
                return internalArray;
            }
        }

        public int Count
        {
            get { return currentSize; }
        }

        public int Length
        {
            get
            {
                return currentSize;
            }
        }

        public DataType this[int i]
        {
            get
            {
                return internalArray[i];
            }
        }

        public virtual void Add(DataType v)
        {
            if (internalArray == null || internalArray.Length < (currentSize + 1))
            {
                if (currentSize < 100000)
                {
                    Resize(currentSize + (currentSize / 2) + 16);
                }
                else
                {
                    Resize(currentSize + currentSize / 4);
                }
            }
            internalArray[currentSize++] = v;
        }

        // Allocate n elements. All data is lost,
        // but elements can be accessed in range 0...size-1.
        public void Allocate(int size)
        {
            Allocate(size, 0);
        }

        public void Allocate(int size, int extraTail)
        {
            Capacity(size, extraTail);
            currentSize = size;
        }

        public DataType at(int i)
        {
            return internalArray[i];
        }

        // Set new capacity. All data is lost, size is set to zero.
        public void Capacity(int newCapacity)
        {
            Capacity(newCapacity, 0);
        }

        public void Capacity(int newCapacity, int extraTail)
        {
            currentSize = 0;
            if (newCapacity > AllocatedSize)
            {
                internalArray = null;
                int sizeToAllocate = newCapacity + extraTail;
                if (sizeToAllocate != 0)
                {
                    internalArray = new DataType[sizeToAllocate];
                }
            }
        }

        public int Capacity()
        {
            return AllocatedSize;
        }

        public void clear()
        {
            currentSize = 0;
        }

        public void Clear()
        {
            currentSize = 0;
        }

        public void CopyFrom(VectorPOD<DataType> vetorToCopy)
        {
            Allocate(vetorToCopy.currentSize);
            if (vetorToCopy.currentSize != 0)
            {
                vetorToCopy.internalArray.CopyTo(internalArray, 0);
            }
        }

        public void cut_at(int num)
        {
            if (num < currentSize) currentSize = num;
        }

        public DataType[] data()
        {
            return internalArray;
        }

        public IEnumerable<DataType> DataIterator()
        {
            for (int index = 0; index < currentSize; index++)
            {
                // Yield each day of the week.
                yield return internalArray[index];
            }
        }

        public IEnumerator GetEnumerator()
        {
            for (int index = 0; index < currentSize; index++)
            {
                // Yield each day of the week.
                yield return internalArray[index];
            }
        }

        public void inc_size(int size)
        {
            currentSize += size;
        }

        public void Insert(int index, DataType value)
        {
            insert_at(index, value);
        }

        public void insert_at(int pos, DataType val)
        {
            if (pos >= currentSize)
            {
                internalArray[currentSize] = val;
            }
            else
            {
                for (int i = 0; i < currentSize - pos; i++)
                {
                    internalArray[i + pos + 1] = internalArray[i + pos];
                }
                internalArray[pos] = val;
            }
            ++currentSize;
        }

        public void push_back(DataType v)
        {
            internalArray[currentSize++] = v;
        }

        public void Remove(int indexToRemove)
        {
            if (indexToRemove >= Length)
            {
                throw new Exception("requested remove past end of array");
            }

            for (int i = indexToRemove; i < Length - 1; i++)
            {
                internalArray[i] = internalArray[i + 1];
            }

            currentSize--;
        }

        public void Remove(DataType itemToRemove)
        {
            for (int i = 0; i < Length; i++)
            {
                if ((object)internalArray[i] == (object)itemToRemove)
                {
                    Remove(i);
                }
            }
        }

        public void RemoveAt(int indexToRemove)
        {
            Remove(indexToRemove);
        }

        public void RemoveLast()
        {
            if (currentSize != 0)
            {
                currentSize--;
            }
        }

        // Resize keeping the content.
        public void Resize(int newSize)
        {
            if (newSize > currentSize)
            {
                if (newSize > AllocatedSize)
                {
                    var newArray = new DataType[newSize];
                    if (internalArray != null)
                    {
                        for (int i = 0; i < internalArray.Length; i++)
                        {
                            newArray[i] = internalArray[i];
                        }
                    }
                    internalArray = newArray;
                }
            }
        }

#pragma warning disable 649
#pragma warning restore 649

        public DataType value_at(int i)
        {
            return internalArray[i];
        }

        public void zero()
        {
            int NumItems = internalArray.Length;
            for (int i = 0; i < NumItems; i++)
            {
                internalArray[i] = zeroed_object;
            }
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Primitives\VectorPodRangeAdaptor.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------

namespace MatterHackers.Agg
{

    //----------------------------------------------------------range_adaptor
    public class VectorPodRangeAdaptor
    {
        private VectorPOD<int> podArray;
        private int size;
        private int start;

        public VectorPodRangeAdaptor(VectorPOD<int> array, int start, int size)
        {
            podArray = array;
            this.start = start;
            this.size = size;
        }

        public int this[int i]
        {
            get
            {
                return podArray.Array[start + i];
            }

            set
            {
                podArray.Array[start + i] = value;
            }
        }

        public int at(int i)
        {
            return podArray.Array[start + i];
        }

        public int Size()
        {
            return size;
        }

        public int ValueAt(int i)
        {
            return podArray.Array[start + i];
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\quicksort.cs
/*
Copyright (c) 2014, Lars Brubaker
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
*/

namespace MatterHackers.Agg
{
	public class QuickSortCellAa
	{
		public QuickSortCellAa()
		{
		}

		public void Sort(PixelCellAa[] dataToSort)
		{
			Sort(dataToSort, 0, (int)(dataToSort.Length - 1));
		}

		public void Sort(PixelCellAa[] dataToSort, int beg, int end)
		{
			if (end == beg)
			{
				return;
			}
			else
			{
				int pivot = GetPivotPoint(dataToSort, beg, end);
				if (pivot > beg)
				{
					Sort(dataToSort, beg, pivot - 1);
				}

				if (pivot < end)
				{
					Sort(dataToSort, pivot + 1, end);
				}
			}
		}

		private int GetPivotPoint(PixelCellAa[] dataToSort, int begPoint, int endPoint)
		{
			int pivot = begPoint;
			int m = begPoint + 1;
			int n = endPoint;
			while ((m < endPoint)
				&& dataToSort[pivot].x >= dataToSort[m].x)
			{
				m++;
			}

			while ((n > begPoint) && (dataToSort[pivot].x <= dataToSort[n].x))
			{
				n--;
			}
			while (m < n)
			{
				PixelCellAa temp = dataToSort[m];
				dataToSort[m] = dataToSort[n];
				dataToSort[n] = temp;

				while ((m < endPoint) && (dataToSort[pivot].x >= dataToSort[m].x))
				{
					m++;
				}

				while ((n > begPoint) && (dataToSort[pivot].x <= dataToSort[n].x))
				{
					n--;
				}
			}
			if (pivot != n)
			{
				PixelCellAa temp2 = dataToSort[n];
				dataToSort[n] = dataToSort[pivot];
				dataToSort[pivot] = temp2;
			}
			return n;
		}
	}

	public class QuickSortRangeAdaptorUint
	{
		public QuickSortRangeAdaptorUint()
		{
		}

		public void Sort(VectorPodRangeAdaptor dataToSort)
		{
			Sort(dataToSort, 0, (int)(dataToSort.Size() - 1));
		}

		public void Sort(VectorPodRangeAdaptor dataToSort, int beg, int end)
		{
			if (end == beg)
			{
				return;
			}
			else
			{
				int pivot = GetPivotPoint(dataToSort, beg, end);
				if (pivot > beg)
				{
					Sort(dataToSort, beg, pivot - 1);
				}

				if (pivot < end)
				{
					Sort(dataToSort, pivot + 1, end);
				}
			}
		}

		private int GetPivotPoint(VectorPodRangeAdaptor dataToSort, int begPoint, int endPoint)
		{
			int pivot = begPoint;
			int m = begPoint + 1;
			int n = endPoint;
			while ((m < endPoint)
				&& dataToSort[pivot] >= dataToSort[m])
			{
				m++;
			}

			while ((n > begPoint) && (dataToSort[pivot] <= dataToSort[n]))
			{
				n--;
			}
			while (m < n)
			{
				int temp = dataToSort[m];
				dataToSort[m] = dataToSort[n];
				dataToSort[n] = temp;

				while ((m < endPoint) && (dataToSort[pivot] >= dataToSort[m]))
				{
					m++;
				}

				while ((n > begPoint) && (dataToSort[pivot] <= dataToSort[n]))
				{
					n--;
				}
			}
			if (pivot != n)
			{
				int temp2 = dataToSort[n];
				dataToSort[n] = dataToSort[pivot];
				dataToSort[pivot] = temp2;
			}
			return n;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\RasterBufferAccessors.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using MatterHackers.Agg.Image;

namespace MatterHackers.Agg
{
	public interface IImageBufferAccessor
	{
		byte[] span(int x, int y, int len, out int bufferIndex);

		byte[] next_x(out int bufferByteOffset);

		byte[] next_y(out int bufferByteOffset);

		IImageByte SourceImage
		{
			get;
		}
	};

	public class ImageBufferAccessorCommon : IImageBufferAccessor
	{
		protected IImageByte m_SourceImage;
		protected int m_x, m_x0, m_y, m_DistanceBetweenPixelsInclusive;
		protected byte[] m_Buffer;
		protected int m_CurrentBufferOffset = -1;
		private int m_Width;

		public ImageBufferAccessorCommon(IImageByte pixf)
		{
			attach(pixf);
		}

		private void attach(IImageByte pixf)
		{
			m_SourceImage = pixf;
			m_Buffer = m_SourceImage.GetBuffer();
			m_Width = m_SourceImage.Width;
			m_DistanceBetweenPixelsInclusive = m_SourceImage.GetBytesBetweenPixelsInclusive();
		}

		public IImageByte SourceImage
		{
			get
			{
				return m_SourceImage;
			}
		}

		private byte[] pixel(out int bufferByteOffset)
		{
			int x = m_x;
			int y = m_y;
			unchecked
			{
				if ((uint)x >= (uint)m_SourceImage.Width)
				{
					if (x < 0)
					{
						x = 0;
					}
					else
					{
						x = (int)m_SourceImage.Width - 1;
					}
				}

				if ((uint)y >= (uint)m_SourceImage.Height)
				{
					if (y < 0)
					{
						y = 0;
					}
					else
					{
						y = (int)m_SourceImage.Height - 1;
					}
				}
			}

			bufferByteOffset = m_SourceImage.GetBufferOffsetXY(x, y);
			return m_SourceImage.GetBuffer();
		}

		public byte[] span(int x, int y, int len, out int bufferOffset)
		{
			m_x = m_x0 = x;
			m_y = y;
			unchecked
			{
				if ((uint)y < (uint)m_SourceImage.Height
					&& x >= 0 && x + len <= (int)m_SourceImage.Width)
				{
					bufferOffset = m_SourceImage.GetBufferOffsetXY(x, y);
					m_Buffer = m_SourceImage.GetBuffer();
					m_CurrentBufferOffset = bufferOffset;
					return m_Buffer;
				}
			}

			m_CurrentBufferOffset = -1;
			return pixel(out bufferOffset);
		}

		public byte[] next_x(out int bufferOffset)
		{
			// this is the code (managed) that the original agg used.
			// It looks like it doesn't check x but, It should be a bit faster and is valid
			// because "span" checked the whole length for good x.
			if (m_CurrentBufferOffset != -1)
			{
				m_CurrentBufferOffset += m_DistanceBetweenPixelsInclusive;
				bufferOffset = m_CurrentBufferOffset;
				return m_Buffer;
			}
			++m_x;
			return pixel(out bufferOffset);
		}

		public byte[] next_y(out int bufferOffset)
		{
			++m_y;
			m_x = m_x0;
			if (m_CurrentBufferOffset != -1
				&& (uint)m_y < (uint)m_SourceImage.Height)
			{
				m_CurrentBufferOffset = m_SourceImage.GetBufferOffsetXY(m_x, m_y);
				m_SourceImage.GetBuffer();
				bufferOffset = m_CurrentBufferOffset;
				return m_Buffer;
			}

			m_CurrentBufferOffset = -1;
			return pixel(out bufferOffset);
		}
	};

	public sealed class ImageBufferAccessorClip : ImageBufferAccessorCommon
	{
		private byte[] m_OutsideBufferColor;

		public ImageBufferAccessorClip(IImageByte sourceImage, Color bk)
			: base(sourceImage)
		{
			m_OutsideBufferColor = new byte[4];
			m_OutsideBufferColor[0] = bk.red;
			m_OutsideBufferColor[1] = bk.green;
			m_OutsideBufferColor[2] = bk.blue;
			m_OutsideBufferColor[3] = bk.alpha;
		}

		private byte[] pixel(out int bufferByteOffset)
		{
			unchecked
			{
				if (((uint)m_x < (uint)m_SourceImage.Width)
					&& ((uint)m_y < (uint)m_SourceImage.Height))
				{
					bufferByteOffset = m_SourceImage.GetBufferOffsetXY(m_x, m_y);
					return m_SourceImage.GetBuffer();
				}
			}

			bufferByteOffset = 0;
			return m_OutsideBufferColor;
		}
	};

	/*
		//--------------------------------------------------image_accessor_no_clip
		template<class PixFmt> class image_accessor_no_clip
		{
		public:
			typedef PixFmt   pixfmt_type;
			typedef typename pixfmt_type::color_type color_type;
			typedef typename pixfmt_type::order_type order_type;
			typedef typename pixfmt_type::value_type value_type;
			enum pix_width_e { pix_width = pixfmt_type::pix_width };

			image_accessor_no_clip() {}
			explicit image_accessor_no_clip(pixfmt_type& pixf) :
				m_pixf(&pixf)
			{}

			void attach(pixfmt_type& pixf)
			{
				m_pixf = &pixf;
			}

			byte* span(int x, int y, int)
			{
				m_x = x;
				m_y = y;
				return m_pix_ptr = m_pixf->pix_ptr(x, y);
			}

			byte* next_x()
			{
				return m_pix_ptr += pix_width;
			}

			byte* next_y()
			{
				++m_y;
				return m_pix_ptr = m_pixf->pix_ptr(m_x, m_y);
			}

		private:
			pixfmt_type* m_pixf;
			int                m_x, m_y;
			byte*       m_pix_ptr;
		};
	 */

	public sealed class ImageBufferAccessorClamp : ImageBufferAccessorCommon
	{
		public ImageBufferAccessorClamp(IImageByte pixf)
			: base(pixf)
		{
		}

		private byte[] pixel(out int bufferByteOffset)
		{
			int x = m_x;
			int y = m_y;
			unchecked
			{
				if ((uint)x >= (uint)m_SourceImage.Width)
				{
					if (x < 0)
					{
						x = 0;
					}
					else
					{
						x = (int)m_SourceImage.Width - 1;
					}
				}

				if ((uint)y >= (uint)m_SourceImage.Height)
				{
					if (y < 0)
					{
						y = 0;
					}
					else
					{
						y = (int)m_SourceImage.Height - 1;
					}
				}
			}

			bufferByteOffset = m_SourceImage.GetBufferOffsetXY(x, y);
			return m_SourceImage.GetBuffer();
		}
	};

	/*

		//-----------------------------------------------------image_accessor_wrap
		template<class PixFmt, class WrapX, class WrapY> class image_accessor_wrap
		{
		public:
			typedef PixFmt   pixfmt_type;
			typedef typename pixfmt_type::color_type color_type;
			typedef typename pixfmt_type::order_type order_type;
			typedef typename pixfmt_type::value_type value_type;
			enum pix_width_e { pix_width = pixfmt_type::pix_width };

			image_accessor_wrap() {}
			explicit image_accessor_wrap(pixfmt_type& pixf) :
				m_pixf(&pixf),
				m_wrap_x(pixf.Width),
				m_wrap_y(pixf.Height)
			{}

			void attach(pixfmt_type& pixf)
			{
				m_pixf = &pixf;
			}

			byte* span(int x, int y, int)
			{
				m_x = x;
				m_row_ptr = m_pixf->row_ptr(m_wrap_y(y));
				return m_row_ptr + m_wrap_x(x) * pix_width;
			}

			byte* next_x()
			{
				int x = ++m_wrap_x;
				return m_row_ptr + x * pix_width;
			}

			byte* next_y()
			{
				m_row_ptr = m_pixf->row_ptr(++m_wrap_y);
				return m_row_ptr + m_wrap_x(m_x) * pix_width;
			}

		private:
			pixfmt_type* m_pixf;
			byte*       m_row_ptr;
			int                m_x;
			WrapX              m_wrap_x;
			WrapY              m_wrap_y;
		};

		//--------------------------------------------------------wrap_mode_repeat
		class wrap_mode_repeat
		{
		public:
			wrap_mode_repeat() {}
			wrap_mode_repeat(int size) :
				m_size(size),
				m_add(size * (0x3FFFFFFF / size)),
				m_value(0)
			{}

			int operator() (int v)
			{
				return m_value = (int(v) + m_add) % m_size;
			}

			int operator++ ()
			{
				++m_value;
				if(m_value >= m_size) m_value = 0;
				return m_value;
			}
		private:
			int m_size;
			int m_add;
			int m_value;
		};

		//---------------------------------------------------wrap_mode_repeat_pow2
		class wrap_mode_repeat_pow2
		{
		public:
			wrap_mode_repeat_pow2() {}
			wrap_mode_repeat_pow2(int size) : m_value(0)
			{
				m_mask = 1;
				while(m_mask < size) m_mask = (m_mask << 1) | 1;
				m_mask >>= 1;
			}
			int operator() (int v)
			{
				return m_value = int(v) & m_mask;
			}
			int operator++ ()
			{
				++m_value;
				if(m_value > m_mask) m_value = 0;
				return m_value;
			}
		private:
			int m_mask;
			int m_value;
		};

		//----------------------------------------------wrap_mode_repeat_auto_pow2
		class wrap_mode_repeat_auto_pow2
		{
		public:
			wrap_mode_repeat_auto_pow2() {}
			wrap_mode_repeat_auto_pow2(int size) :
				m_size(size),
				m_add(size * (0x3FFFFFFF / size)),
				m_mask((m_size & (m_size-1)) ? 0 : m_size-1),
				m_value(0)
			{}

			int operator() (int v)
			{
				if(m_mask) return m_value = int(v) & m_mask;
				return m_value = (int(v) + m_add) % m_size;
			}
			int operator++ ()
			{
				++m_value;
				if(m_value >= m_size) m_value = 0;
				return m_value;
			}

		private:
			int m_size;
			int m_add;
			int m_mask;
			int m_value;
		};

		//-------------------------------------------------------wrap_mode_reflect
		class wrap_mode_reflect
		{
		public:
			wrap_mode_reflect() {}
			wrap_mode_reflect(int size) :
				m_size(size),
				m_size2(size * 2),
				m_add(m_size2 * (0x3FFFFFFF / m_size2)),
				m_value(0)
			{}

			int operator() (int v)
			{
				m_value = (int(v) + m_add) % m_size2;
				if(m_value >= m_size) return m_size2 - m_value - 1;
				return m_value;
			}

			int operator++ ()
			{
				++m_value;
				if(m_value >= m_size2) m_value = 0;
				if(m_value >= m_size) return m_size2 - m_value - 1;
				return m_value;
			}
		private:
			int m_size;
			int m_size2;
			int m_add;
			int m_value;
		};

		//--------------------------------------------------wrap_mode_reflect_pow2
		class wrap_mode_reflect_pow2
		{
		public:
			wrap_mode_reflect_pow2() {}
			wrap_mode_reflect_pow2(int size) : m_value(0)
			{
				m_mask = 1;
				m_size = 1;
				while(m_mask < size)
				{
					m_mask = (m_mask << 1) | 1;
					m_size <<= 1;
				}
			}
			int operator() (int v)
			{
				m_value = int(v) & m_mask;
				if(m_value >= m_size) return m_mask - m_value;
				return m_value;
			}
			int operator++ ()
			{
				++m_value;
				m_value &= m_mask;
				if(m_value >= m_size) return m_mask - m_value;
				return m_value;
			}
		private:
			int m_size;
			int m_mask;
			int m_value;
		};

		//---------------------------------------------wrap_mode_reflect_auto_pow2
		class wrap_mode_reflect_auto_pow2
		{
		public:
			wrap_mode_reflect_auto_pow2() {}
			wrap_mode_reflect_auto_pow2(int size) :
				m_size(size),
				m_size2(size * 2),
				m_add(m_size2 * (0x3FFFFFFF / m_size2)),
				m_mask((m_size2 & (m_size2-1)) ? 0 : m_size2-1),
				m_value(0)
			{}

			int operator() (int v)
			{
				m_value = m_mask ? int(v) & m_mask :
								  (int(v) + m_add) % m_size2;
				if(m_value >= m_size) return m_size2 - m_value - 1;
				return m_value;
			}
			int operator++ ()
			{
				++m_value;
				if(m_value >= m_size2) m_value = 0;
				if(m_value >= m_size) return m_size2 - m_value - 1;
				return m_value;
			}

		private:
			int m_size;
			int m_size2;
			int m_add;
			int m_mask;
			int m_value;
		};
	 */

	public interface IImageBufferAccessorFloat
	{
		float[] span(int x, int y, int len, out int bufferIndex);

		float[] next_x(out int bufferFloatOffset);

		float[] next_y(out int bufferFloatOffset);

		IImageFloat SourceImage
		{
			get;
		}
	};

	public class ImageBufferAccessorCommonFloat : IImageBufferAccessorFloat
	{
		protected IImageFloat m_SourceImage;
		protected int m_x, m_x0, m_y, m_DistanceBetweenPixelsInclusive;
		protected float[] m_Buffer;
		protected int m_CurrentBufferOffset = -1;
		private int m_Width;

		public ImageBufferAccessorCommonFloat(IImageFloat pixf)
		{
			attach(pixf);
		}

		private void attach(IImageFloat pixf)
		{
			m_SourceImage = pixf;
			m_Buffer = m_SourceImage.GetBuffer();
			m_Width = m_SourceImage.Width;
			m_DistanceBetweenPixelsInclusive = m_SourceImage.GetFloatsBetweenPixelsInclusive();
		}

		public IImageFloat SourceImage
		{
			get
			{
				return m_SourceImage;
			}
		}

		private float[] pixel(out int bufferFloatOffset)
		{
			int x = m_x;
			int y = m_y;
			unchecked
			{
				if ((uint)x >= (uint)m_SourceImage.Width)
				{
					if (x < 0)
					{
						x = 0;
					}
					else
					{
						x = (int)m_SourceImage.Width - 1;
					}
				}

				if ((uint)y >= (uint)m_SourceImage.Height)
				{
					if (y < 0)
					{
						y = 0;
					}
					else
					{
						y = (int)m_SourceImage.Height - 1;
					}
				}
			}

			bufferFloatOffset = m_SourceImage.GetBufferOffsetXY(x, y);
			return m_SourceImage.GetBuffer();
		}

		public float[] span(int x, int y, int len, out int bufferOffset)
		{
			m_x = m_x0 = x;
			m_y = y;
			unchecked
			{
				if ((uint)y < (uint)m_SourceImage.Height
					&& x >= 0 && x + len <= (int)m_SourceImage.Width)
				{
					bufferOffset = m_SourceImage.GetBufferOffsetXY(x, y);
					m_Buffer = m_SourceImage.GetBuffer();
					m_CurrentBufferOffset = bufferOffset;
					return m_Buffer;
				}
			}

			m_CurrentBufferOffset = -1;
			return pixel(out bufferOffset);
		}

		public float[] next_x(out int bufferOffset)
		{
			// this is the code (managed) that the original agg used.
			// It looks like it doesn't check x but, It should be a bit faster and is valid
			// because "span" checked the whole length for good x.
			if (m_CurrentBufferOffset != -1)
			{
				m_CurrentBufferOffset += m_DistanceBetweenPixelsInclusive;
				bufferOffset = m_CurrentBufferOffset;
				return m_Buffer;
			}
			++m_x;
			return pixel(out bufferOffset);
		}

		public float[] next_y(out int bufferOffset)
		{
			++m_y;
			m_x = m_x0;
			if (m_CurrentBufferOffset != -1
				&& (uint)m_y < (uint)m_SourceImage.Height)
			{
				m_CurrentBufferOffset = m_SourceImage.GetBufferOffsetXY(m_x, m_y);
				bufferOffset = m_CurrentBufferOffset;
				return m_Buffer;
			}

			m_CurrentBufferOffset = -1;
			return pixel(out bufferOffset);
		}
	};

	public sealed class ImageBufferAccessorClipFloat : ImageBufferAccessorCommonFloat
	{
		private float[] m_OutsideBufferColor;

		public ImageBufferAccessorClipFloat(IImageFloat sourceImage, ColorF bk)
			: base(sourceImage)
		{
			m_OutsideBufferColor = new float[4];
			m_OutsideBufferColor[0] = bk.red;
			m_OutsideBufferColor[1] = bk.green;
			m_OutsideBufferColor[2] = bk.blue;
			m_OutsideBufferColor[3] = bk.alpha;
		}

		private float[] pixel(out int bufferFloatOffset)
		{
			unchecked
			{
				if (((uint)m_x < (uint)m_SourceImage.Width)
					&& ((uint)m_y < (uint)m_SourceImage.Height))
				{
					bufferFloatOffset = m_SourceImage.GetBufferOffsetXY(m_x, m_y);
					return m_SourceImage.GetBuffer();
				}
			}

			bufferFloatOffset = 0;
			return m_OutsideBufferColor;
		}

		//public void background_color(IColorType bk)
		//{
		//  m_pixf.make_pix(m_pBackBufferColor, bk);
		//}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\RasterizerScanline\agg_scanline_p.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Class scanline_p - a general purpose scanline container with packed spans.
//
//----------------------------------------------------------------------------
//
// Adaptation for 32-bit screen coordinates (scanline32_p) has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------

namespace MatterHackers.Agg.RasterizerScanline
{
	//=============================================================scanline_p8
	//
	// This is a general purpose scanline container which supports the interface
	// used in the rasterizer::render(). See description of scanline_u8
	// for details.
	//
	//------------------------------------------------------------------------
	public sealed class ScanlineCachePacked8 : IScanlineCache
	{
		private int m_last_x;
		private int m_y;
		private byte[] m_covers;
		private int m_cover_index;
		private ScanlineSpan[] m_spans;
		private int m_span_index;
		private int m_interator_index;

		public ScanlineSpan GetNextScanlineSpan()
		{
			m_interator_index++;
			return m_spans[m_interator_index - 1];
		}

		public ScanlineCachePacked8()
		{
			m_last_x = 0x7FFFFFF0;
			m_covers = new byte[1000];
			m_spans = new ScanlineSpan[1000];
		}

		//--------------------------------------------------------------------
		public void reset(int min_x, int max_x)
		{
			int max_len = max_x - min_x + 3;
			if (max_len > m_spans.Length)
			{
				m_spans = new ScanlineSpan[max_len];
				m_covers = new byte[max_len];
			}
			m_last_x = 0x7FFFFFF0;
			m_cover_index = 0;
			m_span_index = 0;
			m_spans[m_span_index].len = 0;
		}

		//--------------------------------------------------------------------
		public void add_cell(int x, int cover)
		{
			m_covers[m_cover_index] = (byte)cover;
			if (x == m_last_x + 1 && m_spans[m_span_index].len > 0)
			{
				m_spans[m_span_index].len++;
			}
			else
			{
				m_span_index++;
				m_spans[m_span_index].cover_index = m_cover_index;
				m_spans[m_span_index].x = (short)x;
				m_spans[m_span_index].len = 1;
			}
			m_last_x = x;
			m_cover_index++;
		}

		//--------------------------------------------------------------------
		public void add_cells(int x, int len, byte[] covers, int coversIndex)
		{
			for (int i = 0; i < len; i++)
			{
				m_covers[m_cover_index + i] = covers[i];
			}

			if (x == m_last_x + 1 && m_spans[m_span_index].len > 0)
			{
				m_spans[m_span_index].len += (short)len;
			}
			else
			{
				m_span_index++;
				m_spans[m_span_index].cover_index = m_cover_index;
				m_spans[m_span_index].x = (short)x;
				m_spans[m_span_index].len = (short)len;
			}

			m_cover_index += len;
			m_last_x = x + (int)len - 1;
		}

		//--------------------------------------------------------------------
		public void add_span(int x, int len, int cover)
		{
			if (x == m_last_x + 1
				&& m_spans[m_span_index].len < 0
				&& cover == m_spans[m_span_index].cover_index)
			{
				m_spans[m_span_index].len -= (short)len;
			}
			else
			{
				m_covers[m_cover_index] = (byte)cover;
				m_span_index++;
				m_spans[m_span_index].cover_index = m_cover_index++;
				m_spans[m_span_index].x = (short)x;
				m_spans[m_span_index].len = (short)(-(int)(len));
			}
			m_last_x = x + (int)len - 1;
		}

		//--------------------------------------------------------------------
		public void finalize(int y)
		{
			m_y = y;
		}

		//--------------------------------------------------------------------
		public void ResetSpans()
		{
			m_last_x = 0x7FFFFFF0;
			m_cover_index = 0;
			m_span_index = 0;
			m_spans[m_span_index].len = 0;
		}

		public int y()
		{
			return m_y;
		}

		public int num_spans()
		{
			return (int)m_span_index;
		}

		public ScanlineSpan begin()
		{
			m_interator_index = 1;
			return GetNextScanlineSpan();
		}

		public byte[] GetCovers()
		{
			return m_covers;
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\RasterizerScanline\agg_scanline_u.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for 32-bit screen coordinates (scanline32_u) has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
namespace MatterHackers.Agg.RasterizerScanline
{
	//=============================================================scanline_u8
	//
	// Unpacked scanline container class
	//
	// This class is used to transfer data from a scanline rasterizer
	// to the rendering buffer. It's organized very simple. The class stores
	// information of horizontal spans to render it into a pixel-map buffer.
	// Each span has staring X, length, and an array of bytes that determine the
	// cover-values for each pixel.
	// Before using this class you should know the minimal and maximal pixel
	// coordinates of your scanline. The protocol of using is:
	// 1. reset(min_x, max_x)
	// 2. add_cell() / add_span() - accumulate scanline.
	//    When forming one scanline the next X coordinate must be always greater
	//    than the last stored one, i.e. it works only with ordered coordinates.
	// 3. Call finalize(y) and render the scanline.
	// 3. Call reset_spans() to prepare for the new scanline.
	//
	// 4. Rendering:
	//
	// Scanline provides an iterator class that allows you to extract
	// the spans and the cover values for each pixel. Be aware that clipping
	// has not been done yet, so you should perform it yourself.
	// Use scanline_u8::iterator to render spans:
	//-------------------------------------------------------------------------
	//
	// int y = sl.y();                    // Y-coordinate of the scanline
	//
	// ************************************
	// ...Perform vertical clipping here...
	// ************************************
	//
	// scanline_u8::const_iterator span = sl.begin();
	//
	// unsigned char* row = m_rbuf->row(y); // The address of the beginning
	//                                      // of the current row
	//
	// unsigned num_spans = sl.num_spans(); // Number of spans. It's guaranteed that
	//                                      // num_spans is always greater than 0.
	//
	// do
	// {
	//     const scanline_u8::cover_type* covers =
	//         span->covers;                     // The array of the cover values
	//
	//     int num_pix = span->len;              // Number of pixels of the span.
	//                                           // Always greater than 0, still it's
	//                                           // better to use "int" instead of
	//                                           // "unsigned" because it's more
	//                                           // convenient for clipping
	//     int x = span->x;
	//
	//     **************************************
	//     ...Perform horizontal clipping here...
	//     ...you have x, covers, and pix_count..
	//     **************************************
	//
	//     unsigned char* dst = row + x;  // Calculate the start address of the row.
	//                                    // In this case we assume a simple
	//                                    // grayscale image 1-byte per pixel.
	//     do
	//     {
	//         *dst++ = *covers++;        // Hypothetical rendering.
	//     }
	//     while(--num_pix);
	//
	//     ++span;
	// }
	// while(--num_spans);  // num_spans cannot be 0, so this loop is quite safe
	//------------------------------------------------------------------------
	//
	// The question is: why should we accumulate the whole scanline when we
	// could render just separate spans when they're ready?
	// That's because using the scanline is generally faster. When is consists
	// of more than one span the conditions for the processor cash system
	// are better, because switching between two different areas of memory
	// (that can be very large) occurs less frequently.
	//------------------------------------------------------------------------
	public sealed class scanline_unpacked_8 : IScanlineCache
	{
		private int m_min_x;
		private int m_last_x;
		private int m_y;
		private ArrayPOD<byte> m_covers;
		private ArrayPOD<ScanlineSpan> m_spans;
		private int m_span_index;
		private int m_interator_index;

		public ScanlineSpan GetNextScanlineSpan()
		{
			m_interator_index++;
			return m_spans.Array[m_interator_index - 1];
		}

		//--------------------------------------------------------------------
		public scanline_unpacked_8()
		{
			m_last_x = (0x7FFFFFF0);
			m_covers = new ArrayPOD<byte>(1000);
			m_spans = new ArrayPOD<ScanlineSpan>(1000);
		}

		//--------------------------------------------------------------------
		public void reset(int min_x, int max_x)
		{
			int max_len = max_x - min_x + 2;
			if (max_len > m_spans.Size())
			{
				m_spans.Resize(max_len);
				m_covers.Resize(max_len);
			}
			m_last_x = 0x7FFFFFF0;
			m_min_x = min_x;
			m_span_index = 0;
		}

		//--------------------------------------------------------------------
		public void add_cell(int x, int cover)
		{
			x -= m_min_x;
			m_covers.Array[x] = (byte)cover;
			if (x == m_last_x + 1)
			{
				m_spans.Array[m_span_index].len++;
			}
			else
			{
				m_span_index++;
				m_spans.Array[m_span_index].x = x + m_min_x;
				m_spans.Array[m_span_index].len = 1;
				m_spans.Array[m_span_index].cover_index = (int)x;
			}
			m_last_x = x;
		}

		/*
		//--------------------------------------------------------------------
		unsafe public void add_cells(int x, int len, byte* covers)
		{
			x -= m_min_x;
			for (int i = 0; i < len; i++)
			{
				m_covers.Array[x + i] = covers[i];
			}
			if (x == m_last_x + 1)
			{
				m_spans.Array[m_span_index].len += (int)len;
			}
			else
			{
				m_span_index++;
				m_spans.Array[m_span_index].x = x + m_min_x;
				m_spans.Array[m_span_index].len = (int)len;
				m_spans.Array[m_span_index].cover_index = x;
			}
			m_last_x = x + (int)len - 1;
		}
		 */

		//--------------------------------------------------------------------
		public void add_span(int x, int len, int cover)
		{
			x -= m_min_x;
			for (int i = 0; i < len; i++)
			{
				m_covers.Array[x + i] = (byte)cover;
			}

			if (x == m_last_x + 1)
			{
				m_spans.Array[m_span_index].len += (int)len;
			}
			else
			{
				m_span_index++;
				m_spans.Array[m_span_index].x = x + m_min_x;
				m_spans.Array[m_span_index].len = (int)len;
				m_spans.Array[m_span_index].cover_index = (int)x;
			}
			m_last_x = x + (int)len - 1;
		}

		//--------------------------------------------------------------------
		public void finalize(int y)
		{
			m_y = y;
		}

		//--------------------------------------------------------------------
		public void ResetSpans()
		{
			m_last_x = 0x7FFFFFF0;
			m_span_index = 0;
		}

		//--------------------------------------------------------------------
		public int y()
		{
			return m_y;
		}

		public int num_spans()
		{
			return (int)m_span_index;
		}

		public ScanlineSpan begin()
		{
			m_interator_index = 1;
			return GetNextScanlineSpan();
		}

		public byte[] GetCovers()
		{
			return m_covers.Array;
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\ReferenceEqualityComparer.cs
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace MatterHackers.Agg
{
	public sealed class ReferenceEqualityComparer
		: IEqualityComparer, IEqualityComparer<object>
	{
		public static readonly ReferenceEqualityComparer Default
			= new ReferenceEqualityComparer(); // JIT-lazy is sufficiently lazy imo.

		private ReferenceEqualityComparer()
		{
		}

		public bool Equals(object left, object right)
		{
			return left == right; // Reference identity comparison
		}

		public int GetHashCode(object obj)
		{
			return RuntimeHelpers.GetHashCode(obj);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\ScanlineRasterizer.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
//
// The author gratefully acknowledges the support of David Turner,
// Robert Wilhelm, and Werner Lemberg - the authors of the FreeType
// library - in producing this work. See http://www.freetype.org for details.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for 32-bit screen coordinates has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
using MatterHackers.Agg.VertexSource;
using MatterHackers.VectorMath;
using filling_rule_e = MatterHackers.Agg.Util.filling_rule_e;
using poly_subpixel_scale_e = MatterHackers.Agg.Util.poly_subpixel_scale_e;

namespace MatterHackers.Agg
{
	//==================================================rasterizer_scanline_aa
	// Polygon rasterizer that is used to render filled polygons with
	// high-quality Anti-Aliasing. Internally, by default, the class uses
	// integer coordinates in format 24.8, i.e. 24 bits for integer part
	// and 8 bits for fractional - see poly_subpixel_shift. This class can be
	// used in the following  way:
	//
	// 1. filling_rule(filling_rule_e ft) - optional.
	//
	// 2. gamma() - optional.
	//
	// 3. reset()
	//
	// 4. move_to(x, y) / line_to(x, y) - make the polygon. One can create
	//    more than one contour, but each contour must consist of at least 3
	//    vertices, i.e. move_to(x1, y1); line_to(x2, y2); line_to(x3, y3);
	//    is the absolute minimum of vertices that define a triangle.
	//    The algorithm does not check either the number of vertices nor
	//    coincidence of their coordinates, but in the worst case it just
	//    won't draw anything.
	//    The order of the vertices (clockwise or counterclockwise)
	//    is important when using the non-zero filling rule (fill_non_zero).
	//    In this case the vertex order of all the contours must be the same
	//    if you want your intersecting polygons to be without "holes".
	//    You actually can use different vertices order. If the contours do not
	//    intersect each other the order is not important anyway. If they do,
	//    contours with the same vertex order will be rendered without "holes"
	//    while the intersecting contours with different orders will have "holes".
	//
	// filling_rule() and gamma() can be called anytime before "sweeping".
	//------------------------------------------------------------------------
	public interface IRasterizer
	{
		int min_x();

		int min_y();

		int max_x();

		int max_y();

		void gamma(IGammaFunction gamma_function);

		bool sweep_scanline(IScanlineCache sl);

		void reset();

		void add_path(IVertexSource vs);

		bool rewind_scanlines();
	}

	public sealed class ScanlineRasterizer : IRasterizer
	{
		private RasterizerCellsAa m_outline;
		private VectorClipper m_VectorClipper;
		private int[] m_gamma = new int[(int)aa_scale_e.aa_scale];
		private Util.filling_rule_e m_filling_rule;
		private bool m_auto_close;
		private int m_start_x;
		private int m_start_y;
		private status m_status;
		private int m_scan_y;

		public enum status
		{
			status_initial,
			status_move_to,
			status_line_to,
			status_closed
		};

		public enum aa_scale_e
		{
			aa_shift = 8,
			aa_scale = 1 << aa_shift,
			aa_mask = aa_scale - 1,
			aa_scale2 = aa_scale * 2,
			aa_mask2 = aa_scale2 - 1
		};

		public ScanlineRasterizer()
			: this(new VectorClipper())
		{
		}

		//--------------------------------------------------------------------
		public ScanlineRasterizer(VectorClipper rasterizer_sl_clip)
		{
			m_outline = new RasterizerCellsAa();
			m_VectorClipper = rasterizer_sl_clip;
			m_filling_rule = filling_rule_e.fill_non_zero;
			m_auto_close = true;
			m_start_x = 0;
			m_start_y = 0;
			m_status = status.status_initial;

			for (int i = 0; i < (int)aa_scale_e.aa_scale; i++)
			{
				m_gamma[i] = i;
			}
		}

		/*
		//--------------------------------------------------------------------
		public rasterizer_scanline_aa(IClipper rasterizer_sl_clip, IGammaFunction gamma_function)
		{
			m_outline = new rasterizer_cells_aa();
			m_clipper = rasterizer_sl_clip;
			m_filling_rule = filling_rule_e.fill_non_zero;
			m_auto_close = true;
			m_start_x = 0;
			m_start_y = 0;
			m_status = status.status_initial;

			gamma(gamma_function);
		}*/

		//--------------------------------------------------------------------
		public void reset()
		{
			m_outline.reset();
			m_status = status.status_initial;
		}

		public void reset_clipping()
		{
			reset();
			m_VectorClipper.reset_clipping();
		}

		public RectangleDouble GetVectorClipBox()
		{
			return new RectangleDouble(
				m_VectorClipper.downscale(m_VectorClipper.clipBox.Left),
				m_VectorClipper.downscale(m_VectorClipper.clipBox.Bottom),
				m_VectorClipper.downscale(m_VectorClipper.clipBox.Right),
				m_VectorClipper.downscale(m_VectorClipper.clipBox.Top));
		}

		public void SetVectorClipBox(RectangleDouble clippingRect)
		{
			SetVectorClipBox(clippingRect.Left, clippingRect.Bottom, clippingRect.Right, clippingRect.Top);
		}

		public void SetVectorClipBox(double x1, double y1, double x2, double y2)
		{
			reset();
			m_VectorClipper.clip_box(m_VectorClipper.upscale(x1), m_VectorClipper.upscale(y1),
							   m_VectorClipper.upscale(x2), m_VectorClipper.upscale(y2));
		}

		public void filling_rule(Util.filling_rule_e filling_rule)
		{
			m_filling_rule = filling_rule;
		}

		public void auto_close(bool flag)
		{
			m_auto_close = flag;
		}

		//--------------------------------------------------------------------
		public void gamma(IGammaFunction gamma_function)
		{
			for (int i = 0; i < (int)aa_scale_e.aa_scale; i++)
			{
				m_gamma[i] = (int)Util.uround(gamma_function.GetGamma((double)(i) / (int)aa_scale_e.aa_mask) * (int)aa_scale_e.aa_mask);
			}
		}

		/*
		//--------------------------------------------------------------------
		public int apply_gamma(int cover)
		{
			return (int)m_gamma[cover];
		}
		 */

		//--------------------------------------------------------------------
		private void move_to(int x, int y)
		{
			if (m_outline.sorted()) reset();
			if (m_auto_close) close_polygon();
			m_VectorClipper.move_to(m_start_x = m_VectorClipper.downscale(x),
							  m_start_y = m_VectorClipper.downscale(y));
			m_status = status.status_move_to;
		}

		//------------------------------------------------------------------------
		private void line_to(int x, int y)
		{
			m_VectorClipper.line_to(m_outline,
							  m_VectorClipper.downscale(x),
							  m_VectorClipper.downscale(y));
			m_status = status.status_line_to;
		}

		//------------------------------------------------------------------------
		public void move_to_d(double x, double y)
		{
			if (m_outline.sorted()) reset();
			if (m_auto_close) close_polygon();
			m_VectorClipper.move_to(m_start_x = m_VectorClipper.upscale(x),
							  m_start_y = m_VectorClipper.upscale(y));
			m_status = status.status_move_to;
		}

		//------------------------------------------------------------------------
		public void line_to_d(double x, double y)
		{
			m_VectorClipper.line_to(m_outline,
							  m_VectorClipper.upscale(x),
							  m_VectorClipper.upscale(y));
			m_status = status.status_line_to;
		}

		public void close_polygon()
		{
			if (m_status == status.status_line_to)
			{
				m_VectorClipper.line_to(m_outline, m_start_x, m_start_y);
				m_status = status.status_closed;
			}
		}

		private void AddVertex(VertexData vertexData)
		{
			if (ShapePath.IsMoveTo(vertexData.Command))
			{
				move_to_d(vertexData.Position.X, vertexData.Position.Y);
			}
			else
			{
				if (ShapePath.IsVertex(vertexData.Command))
				{
					line_to_d(vertexData.Position.X, vertexData.Position.Y);
				}
				else
				{
					if (ShapePath.IsClose(vertexData.Command))
					{
						close_polygon();
					}
				}
			}
		}

		//------------------------------------------------------------------------
		private void edge(int x1, int y1, int x2, int y2)
		{
			if (m_outline.sorted()) reset();
			m_VectorClipper.move_to(m_VectorClipper.downscale(x1), m_VectorClipper.downscale(y1));
			m_VectorClipper.line_to(m_outline,
							  m_VectorClipper.downscale(x2),
							  m_VectorClipper.downscale(y2));
			m_status = status.status_move_to;
		}

		//------------------------------------------------------------------------
		private void edge_d(double x1, double y1, double x2, double y2)
		{
			if (m_outline.sorted()) reset();
			m_VectorClipper.move_to(m_VectorClipper.upscale(x1), m_VectorClipper.upscale(y1));
			m_VectorClipper.line_to(m_outline,
							  m_VectorClipper.upscale(x2),
							  m_VectorClipper.upscale(y2));
			m_status = status.status_move_to;
		}

		//-------------------------------------------------------------------
		public void add_path(IVertexSource vs)
		{
			double x = 0;
			double y = 0;

			FlagsAndCommand PathAndFlags;
			vs.Rewind(0);
			if (m_outline.sorted())
			{
				reset();
			}

			while (!ShapePath.IsStop(PathAndFlags = vs.Vertex(out x, out y)))
			{
				AddVertex(new VertexData(PathAndFlags, new Vector2(x, y)));
			}
		}

		//--------------------------------------------------------------------
		public int min_x()
		{
			return m_outline.min_x();
		}

		public int min_y()
		{
			return m_outline.min_y();
		}

		public int max_x()
		{
			return m_outline.max_x();
		}

		public int max_y()
		{
			return m_outline.max_y();
		}

		//--------------------------------------------------------------------
		private void sort()
		{
			if (m_auto_close) close_polygon();
			m_outline.sort_cells();
		}

		//------------------------------------------------------------------------
		public bool rewind_scanlines()
		{
			if (m_auto_close) close_polygon();
			m_outline.sort_cells();
			if (m_outline.total_cells() == 0)
			{
				return false;
			}
			m_scan_y = m_outline.min_y();
			return true;
		}

		//------------------------------------------------------------------------
		private bool navigate_scanline(int y)
		{
			if (m_auto_close) close_polygon();
			m_outline.sort_cells();
			if (m_outline.total_cells() == 0 ||
			   y < m_outline.min_y() ||
			   y > m_outline.max_y())
			{
				return false;
			}
			m_scan_y = y;
			return true;
		}

		//--------------------------------------------------------------------
		public int calculate_alpha(int area)
		{
			int cover = area >> ((int)poly_subpixel_scale_e.poly_subpixel_shift * 2 + 1 - (int)aa_scale_e.aa_shift);

			if (cover < 0)
			{
				cover = -cover;
			}

			if (m_filling_rule == filling_rule_e.fill_even_odd)
			{
				cover &= (int)aa_scale_e.aa_mask2;
				if (cover > (int)aa_scale_e.aa_scale)
				{
					cover = (int)aa_scale_e.aa_scale2 - cover;
				}
			}

			if (cover > (int)aa_scale_e.aa_mask)
			{
				cover = (int)aa_scale_e.aa_mask;
			}

			return (int)m_gamma[cover];
		}

		//--------------------------------------------------------------------
		public bool sweep_scanline(IScanlineCache scanlineCache)
		{
			for (; ; )
			{
				if (m_scan_y > m_outline.max_y())
				{
					return false;
				}

				scanlineCache.ResetSpans();
				int num_cells = (int)m_outline.scanline_num_cells(m_scan_y);
				PixelCellAa[] cells;
				int Offset;
				m_outline.scanline_cells(m_scan_y, out cells, out Offset);
				int cover = 0;

				while (num_cells != 0)
				{
					PixelCellAa cur_cell = cells[Offset];
					int x = cur_cell.x;
					int area = cur_cell.area;
					int alpha;

					cover += cur_cell.cover;

					//accumulate all cells with the same X
					while (--num_cells != 0)
					{
						Offset++;
						cur_cell = cells[Offset];
						if (cur_cell.x != x)
						{
							break;
						}

						area += cur_cell.area;
						cover += cur_cell.cover;
					}

					if (area != 0)
					{
						alpha = calculate_alpha((cover << ((int)poly_subpixel_scale_e.poly_subpixel_shift + 1)) - area);
						if (alpha != 0)
						{
							scanlineCache.add_cell(x, alpha);
						}
						x++;
					}

					if ((num_cells != 0) && (cur_cell.x > x))
					{
						alpha = calculate_alpha(cover << ((int)poly_subpixel_scale_e.poly_subpixel_shift + 1));
						if (alpha != 0)
						{
							scanlineCache.add_span(x, (cur_cell.x - x), alpha);
						}
					}
				}

				if (scanlineCache.num_spans() != 0) break;
				++m_scan_y;
			}

			scanlineCache.finalize(m_scan_y);
			++m_scan_y;
			return true;
		}

		//--------------------------------------------------------------------
		private bool hit_test(int tx, int ty)
		{
			if (!navigate_scanline(ty)) return false;
			//scanline_hit_test sl(tx);
			//sweep_scanline(sl);
			//return sl.hit();
			return true;
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\ScanlineRenderer.cs
using MatterHackers.Agg.Image;
using MatterHackers.Agg.VertexSource;

namespace MatterHackers.Agg
{
	public class ScanlineRenderer
	{
		private VectorPOD<Color> tempSpanColors = new VectorPOD<Color>();
		private VectorPOD<ColorF> tempSpanColorsFloats = new VectorPOD<ColorF>();

		public void RenderSolid(IImageByte destImage, IRasterizer rasterizer, IScanlineCache scanLine, Color color)
		{
			if (rasterizer.rewind_scanlines())
			{
				scanLine.reset(rasterizer.min_x(), rasterizer.max_x());
				while (rasterizer.sweep_scanline(scanLine))
				{
					RenderSolidSingleScanLine(destImage, scanLine, color);
				}
			}
		}

		public void RenderSolid(IImageFloat destImage, IRasterizer rasterizer, IScanlineCache scanLine, ColorF color)
		{
			if (rasterizer.rewind_scanlines())
			{
				scanLine.reset(rasterizer.min_x(), rasterizer.max_x());
				while (rasterizer.sweep_scanline(scanLine))
				{
					RenderSolidSingleScanLine(destImage, scanLine, color);
				}
			}
		}

		protected virtual void RenderSolidSingleScanLine(IImageByte destImage, IScanlineCache scanLine, Color color)
		{
			int y = scanLine.y();
			int num_spans = scanLine.num_spans();
			ScanlineSpan scanlineSpan = scanLine.begin();

			byte[] ManagedCoversArray = scanLine.GetCovers();
			for (; ; )
			{
				int x = scanlineSpan.x;
				if (scanlineSpan.len > 0)
				{
					destImage.blend_solid_hspan(x, y, scanlineSpan.len, color, ManagedCoversArray, scanlineSpan.cover_index);
				}
				else
				{
					int x2 = (x - (int)scanlineSpan.len - 1);
					destImage.blend_hline(x, y, x2, color, ManagedCoversArray[scanlineSpan.cover_index]);
				}
				if (--num_spans == 0) break;
				scanlineSpan = scanLine.GetNextScanlineSpan();
			}
		}

		private void RenderSolidSingleScanLine(IImageFloat destImage, IScanlineCache scanLine, ColorF color)
		{
			int y = scanLine.y();
			int num_spans = scanLine.num_spans();
			ScanlineSpan scanlineSpan = scanLine.begin();

			byte[] ManagedCoversArray = scanLine.GetCovers();
			for (; ; )
			{
				int x = scanlineSpan.x;
				if (scanlineSpan.len > 0)
				{
					destImage.blend_solid_hspan(x, y, scanlineSpan.len, color, ManagedCoversArray, scanlineSpan.cover_index);
				}
				else
				{
					int x2 = (x - (int)scanlineSpan.len - 1);
					destImage.blend_hline(x, y, x2, color, ManagedCoversArray[scanlineSpan.cover_index]);
				}
				if (--num_spans == 0) break;
				scanlineSpan = scanLine.GetNextScanlineSpan();
			}
		}

		private void GenerateAndRenderSingleScanline(IScanlineCache scanLineCache, IImageByte destImage, span_allocator alloc, ISpanGenerator span_gen)
		{
			int y = scanLineCache.y();
			int num_spans = scanLineCache.num_spans();
			ScanlineSpan scanlineSpan = scanLineCache.begin();

			byte[] ManagedCoversArray = scanLineCache.GetCovers();
			for (; ; )
			{
				int x = scanlineSpan.x;
				int len = scanlineSpan.len;
				if (len < 0) len = -len;

				if (tempSpanColors.Capacity() < len)
				{
					tempSpanColors.Capacity(len);
				}

				span_gen.generate(tempSpanColors.Array, 0, x, y, len);
				bool useFirstCoverForAll = scanlineSpan.len < 0;
				destImage.blend_color_hspan(x, y, len, tempSpanColors.Array, 0, ManagedCoversArray, scanlineSpan.cover_index, useFirstCoverForAll);

				if (--num_spans == 0) break;
				scanlineSpan = scanLineCache.GetNextScanlineSpan();
			}
		}

		private void GenerateAndRenderSingleScanline(IScanlineCache scanLineCache, IImageFloat destImageFloat, span_allocator alloc, ISpanGeneratorFloat span_gen)
		{
			int y = scanLineCache.y();
			int num_spans = scanLineCache.num_spans();
			ScanlineSpan scanlineSpan = scanLineCache.begin();

			byte[] ManagedCoversArray = scanLineCache.GetCovers();
			for (; ; )
			{
				int x = scanlineSpan.x;
				int len = scanlineSpan.len;
				if (len < 0) len = -len;

				if (tempSpanColorsFloats.Capacity() < len)
				{
					tempSpanColorsFloats.Capacity(len);
				}

				span_gen.generate(tempSpanColorsFloats.Array, 0, x, y, len);
				bool useFirstCoverForAll = scanlineSpan.len < 0;
				destImageFloat.blend_color_hspan(x, y, len, tempSpanColorsFloats.Array, 0, ManagedCoversArray, scanlineSpan.cover_index, useFirstCoverForAll);

				if (--num_spans == 0) break;
				scanlineSpan = scanLineCache.GetNextScanlineSpan();
			}
		}

		public void GenerateAndRender(IRasterizer rasterizer, IScanlineCache scanlineCache, IImageByte destImage, span_allocator spanAllocator, ISpanGenerator spanGenerator)
		{
			if (rasterizer.rewind_scanlines())
			{
				scanlineCache.reset(rasterizer.min_x(), rasterizer.max_x());
				spanGenerator.prepare();
				while (rasterizer.sweep_scanline(scanlineCache))
				{
					GenerateAndRenderSingleScanline(scanlineCache, destImage, spanAllocator, spanGenerator);
				}
			}
		}

		public void GenerateAndRender(IRasterizer rasterizer, IScanlineCache scanlineCache, IImageFloat destImage, span_allocator spanAllocator, ISpanGeneratorFloat spanGenerator)
		{
			if (rasterizer.rewind_scanlines())
			{
				scanlineCache.reset(rasterizer.min_x(), rasterizer.max_x());
				spanGenerator.prepare();
				while (rasterizer.sweep_scanline(scanlineCache))
				{
					GenerateAndRenderSingleScanline(scanlineCache, destImage, spanAllocator, spanGenerator);
				}
			}
		}

		public void RenderCompound(rasterizer_compound_aa ras, IScanlineCache sl_aa, IScanlineCache sl_bin, IImageByte imageFormat, span_allocator alloc, IStyleHandler sh)
		{
#if false
            unsafe
            {
                if (ras.rewind_scanlines())
                {
                    int min_x = ras.min_x();
                    int len = ras.max_x() - min_x + 2;
                    sl_aa.reset(min_x, ras.max_x());
                    sl_bin.reset(min_x, ras.max_x());

                    //typedef typename BaseRenderer::color_type color_type;
                    ArrayPOD<RGBA_Bytes> color_span = alloc.allocate((int)len * 2);
                    byte[] ManagedCoversArray = sl_aa.GetCovers();
                    fixed (byte* pCovers = ManagedCoversArray)
                    {
                        fixed (RGBA_Bytes* pColorSpan = color_span.Array)
                        {
                            int mix_bufferOffset = len;
                            int num_spans;

                            int num_styles;
                            int style;
                            bool solid;
                            while ((num_styles = ras.sweep_styles()) > 0)
                            {
                                if (num_styles == 1)
                                {
                                    // Optimization for a single style. Happens often
                                    //-------------------------
                                    if (ras.sweep_scanline(sl_aa, 0))
                                    {
                                        style = ras.style(0);
                                        if (sh.is_solid(style))
                                        {
                                            // Just solid fill
                                            //-----------------------
                                            RenderSolidSingleScanLine(imageFormat, sl_aa, sh.color(style));
                                        }
                                        else
                                        {
                                            // Arbitrary span generator
                                            //-----------------------
                                            ScanlineSpan span_aa = sl_aa.Begin();
                                            num_spans = sl_aa.num_spans();
                                            for (; ; )
                                            {
                                                len = span_aa.len;
                                                sh.generate_span(pColorSpan,
                                                                 span_aa.x,
                                                                 sl_aa.y(),
                                                                 (int)len,
                                                                 style);

                                                imageFormat.blend_color_hspan(span_aa.x,
                                                                      sl_aa.y(),
                                                                      (int)span_aa.len,
                                                                      pColorSpan,
                                                                      &pCovers[span_aa.cover_index], 0);
                                                if (--num_spans == 0) break;
                                                span_aa = sl_aa.GetNextScanlineSpan();
                                            }
                                        }
                                    }
                                }
                                else // there are multiple styles
                                {
                                    if (ras.sweep_scanline(sl_bin, -1))
                                    {
                                        // Clear the spans of the mix_buffer
                                        //--------------------
                                        ScanlineSpan span_bin = sl_bin.Begin();
                                        num_spans = sl_bin.num_spans();
                                        for (; ; )
                                        {
                                            agg_basics.MemClear((byte*)&pColorSpan[mix_bufferOffset + span_bin.x - min_x],
                                                   span_bin.len * sizeof(RGBA_Bytes));

                                            if (--num_spans == 0) break;
                                            span_bin = sl_bin.GetNextScanlineSpan();
                                        }

                                        for (int i = 0; i < num_styles; i++)
                                        {
                                            style = ras.style(i);
                                            solid = sh.is_solid(style);

                                            if (ras.sweep_scanline(sl_aa, (int)i))
                                            {
                                                //IColorType* colors;
                                                //IColorType* cspan;
                                                //typename ScanlineAA::cover_type* covers;
                                                ScanlineSpan span_aa = sl_aa.Begin();
                                                num_spans = sl_aa.num_spans();
                                                if (solid)
                                                {
                                                    // Just solid fill
                                                    //-----------------------
                                                    for (; ; )
                                                    {
                                                        RGBA_Bytes c = sh.color(style);
                                                        len = span_aa.len;
                                                        RGBA_Bytes* colors = &pColorSpan[mix_bufferOffset + span_aa.x - min_x];
                                                        byte* covers = &pCovers[span_aa.cover_index];
                                                        do
                                                        {
                                                            if (*covers == cover_full)
                                                            {
                                                                *colors = c;
                                                            }
                                                            else
                                                            {
                                                                colors->add(c, *covers);
                                                            }
                                                            ++colors;
                                                            ++covers;
                                                        }
                                                        while (--len != 0);
                                                        if (--num_spans == 0) break;
                                                        span_aa = sl_aa.GetNextScanlineSpan();
                                                    }
                                                }
                                                else
                                                {
                                                    // Arbitrary span generator
                                                    //-----------------------
                                                    for (; ; )
                                                    {
                                                        len = span_aa.len;
                                                        RGBA_Bytes* colors = &pColorSpan[mix_bufferOffset + span_aa.x - min_x];
                                                        RGBA_Bytes* cspan = pColorSpan;
                                                        sh.generate_span(cspan,
                                                                         span_aa.x,
                                                                         sl_aa.y(),
                                                                         (int)len,
                                                                         style);
                                                        byte* covers = &pCovers[span_aa.cover_index];
                                                        do
                                                        {
                                                            if (*covers == cover_full)
                                                            {
                                                                *colors = *cspan;
                                                            }
                                                            else
                                                            {
                                                                colors->add(*cspan, *covers);
                                                            }
                                                            ++cspan;
                                                            ++colors;
                                                            ++covers;
                                                        }
                                                        while (--len != 0);
                                                        if (--num_spans == 0) break;
                                                        span_aa = sl_aa.GetNextScanlineSpan();
                                                    }
                                                }
                                            }
                                        }

                                        // Emit the blended result as a color hspan
                                        //-------------------------
                                        span_bin = sl_bin.Begin();
                                        num_spans = sl_bin.num_spans();
                                        for (; ; )
                                        {
                                            imageFormat.blend_color_hspan(span_bin.x,
                                                                  sl_bin.y(),
                                                                  (int)span_bin.len,
                                                                  &pColorSpan[mix_bufferOffset + span_bin.x - min_x],
                                                                  null,
                                                                  cover_full);
                                            if (--num_spans == 0) break;
                                            span_bin = sl_bin.GetNextScanlineSpan();
                                        }
                                    } // if(ras.sweep_scanline(sl_bin, -1))
                                } // if(num_styles == 1) ... else
                            } // while((num_styles = ras.sweep_styles()) > 0)
                        }
                    }
                } // if(ras.rewind_scanlines())
            }
#endif
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\ShapePath.cs
using System;

namespace MatterHackers.Agg
{
	public enum CommandHint
	{
        None,
        C4ControlFromPrev,
		C4ControlToPoint,
		C4Point,
        C3ControlFromPrev,
        C3Point,
    }

    [Flags]
    public enum FlagsAndCommand
    {
        Stop = 0x00,
        MoveTo = 0x01,
        LineTo = 0x02,
        Curve3 = 0x03,
        Curve4 = 0x04,
        EndPoly = 0x0F,
        CommandsMask = 0x0F,

        FlagNone = 0x00,
        FlagCCW = 0x10,
        FlagCW = 0x20,
        FlagClose = 0x40,
        FlagsMask = 0xF0
    };
    
	public static class ShapePath
	{
		public static bool IsVertex(FlagsAndCommand c)
		{
			return c >= FlagsAndCommand.MoveTo
				&& c < FlagsAndCommand.EndPoly;
		}

		public static bool is_drawing(FlagsAndCommand c)
		{
			return c >= FlagsAndCommand.LineTo && c < FlagsAndCommand.EndPoly;
		}

		public static bool IsStop(FlagsAndCommand c)
		{
			return c == FlagsAndCommand.Stop;
		}

		public static bool IsMoveTo(FlagsAndCommand c)
		{
			return c == FlagsAndCommand.MoveTo;
		}

		public static bool IsLineTo(FlagsAndCommand c)
		{
			return c == FlagsAndCommand.LineTo;
		}

		public static bool IsCurve(FlagsAndCommand c)
		{
			return c == FlagsAndCommand.Curve3
				|| c == FlagsAndCommand.Curve4;
		}

		public static bool is_curve3(FlagsAndCommand c)
		{
			return c == FlagsAndCommand.Curve3;
		}

		public static bool is_curve4(FlagsAndCommand c)
		{
			return c == FlagsAndCommand.Curve4;
		}

		public static bool is_end_poly(FlagsAndCommand c)
		{
			return (c & FlagsAndCommand.CommandsMask) == FlagsAndCommand.EndPoly;
		}

		public static bool IsClose(FlagsAndCommand c)
		{
			return (c & ~(FlagsAndCommand.FlagCW | FlagsAndCommand.FlagCCW)) ==
				   (FlagsAndCommand.EndPoly | FlagsAndCommand.FlagClose);
		}

		public static bool IsNextPoly(FlagsAndCommand c)
		{
			return IsStop(c) || IsMoveTo(c) || is_end_poly(c);
		}

		public static bool is_cw(FlagsAndCommand c)
		{
			return (c & FlagsAndCommand.FlagCW) != 0;
		}

		public static bool is_ccw(FlagsAndCommand c)
		{
			return (c & FlagsAndCommand.FlagCCW) != 0;
		}

		public static bool is_oriented(FlagsAndCommand c)
		{
			return (c & (FlagsAndCommand.FlagCW | FlagsAndCommand.FlagCCW)) != 0;
		}

		public static bool is_closed(FlagsAndCommand c)
		{
			return (c & FlagsAndCommand.FlagClose) != 0;
		}

		public static FlagsAndCommand get_close_flag(FlagsAndCommand c)
		{
			return (FlagsAndCommand)(c & FlagsAndCommand.FlagClose);
		}

		public static FlagsAndCommand clear_orientation(FlagsAndCommand c)
		{
			return c & ~(FlagsAndCommand.FlagCW | FlagsAndCommand.FlagCCW);
		}

		public static FlagsAndCommand get_orientation(FlagsAndCommand c)
		{
			return c & (FlagsAndCommand.FlagCW | FlagsAndCommand.FlagCCW);
		}

		/*
		//---------------------------------------------------------set_orientation
		public static path_flags_e set_orientation(int c, path_flags_e o)
		{
			return clear_orientation(c) | o;
		}
		 */

		static public void shorten_path(MatterHackers.Agg.VertexSequence vs, double s)
		{
			shorten_path(vs, s, 0);
		}

		static public void shorten_path(VertexSequence vs, double s, int closed)
		{
			if (s > 0.0 && vs.Count > 1)
			{
				double d;
				int n = (int)(vs.Count - 2);
				while (n != 0)
				{
					d = vs[n].dist;
					if (d > s) break;
					vs.RemoveLast();
					s -= d;
					--n;
				}
				if (vs.Count < 2)
				{
					vs.Clear();
				}
				else
				{
					n = (int)vs.Count - 1;
					VertexDistance prev = vs[n - 1];
					VertexDistance last = vs[n];
					d = (prev.dist - s) / prev.dist;
					double x = prev.x + (last.x - prev.x) * d;
					double y = prev.y + (last.y - prev.y) * d;
					last.x = x;
					last.y = y;
					if (!prev.IsEqual(last)) vs.RemoveLast();
					vs.close(closed != 0);
				}
			}
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Spans\agg_span_allocator.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
namespace MatterHackers.Agg
{
	//----------------------------------------------------------span_allocator
	public class span_allocator
	{
		private ArrayPOD<Color> m_span;

		public span_allocator()
		{
			m_span = new ArrayPOD<Color>(255);
		}

		//--------------------------------------------------------------------
		public ArrayPOD<Color> allocate(int span_len)
		{
			if (span_len > m_span.Size())
			{
				// To reduce the number of reallocs we align the
				// span_len to 256 color elements.
				// Well, I just like this number and it looks reasonable.
				//-----------------------
				m_span.Resize((((int)span_len + 255) >> 8) << 8);
			}
			return m_span;
		}

		public ArrayPOD<Color> span()
		{
			return m_span;
		}

		public int max_span_len()
		{
			return m_span.Size();
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Spans\agg_span_gradient.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------

namespace MatterHackers.Agg
{
	public interface IGradient
	{
		int calculate(int x, int y, int d);
	};

	public interface IColorFunction
	{
		int size();

		Color this[int v]
		{
			get;
		}
	};

	//==========================================================span_gradient
	public class span_gradient : ISpanGenerator
	{
		public const int gradient_subpixel_shift = 4;                              //-----gradient_subpixel_shift
		public const int gradient_subpixel_scale = 1 << gradient_subpixel_shift;   //-----gradient_subpixel_scale
		public const int gradient_subpixel_mask = gradient_subpixel_scale - 1;    //-----gradient_subpixel_mask

		public const int subpixelShift = 8;

		public const int downscale_shift = subpixelShift - gradient_subpixel_shift;

		private ISpanInterpolator m_interpolator;
		private IGradient m_gradient_function;
		private IColorFunction m_color_function;
		private int m_d1;
		private int m_d2;

		//--------------------------------------------------------------------
		public span_gradient()
		{
		}

		//--------------------------------------------------------------------
		public span_gradient(ISpanInterpolator inter,
					  IGradient gradient_function,
					  IColorFunction color_function,
					  double d1, double d2)
		{
			m_interpolator = inter;
			m_gradient_function = gradient_function;
			m_color_function = color_function;
			m_d1 = (Util.iround(d1 * gradient_subpixel_scale));
			m_d2 = (Util.iround(d2 * gradient_subpixel_scale));
		}

		//--------------------------------------------------------------------
		public ISpanInterpolator interpolator()
		{
			return m_interpolator;
		}

		public IGradient gradient_function()
		{
			return m_gradient_function;
		}

		public IColorFunction color_function()
		{
			return m_color_function;
		}

		public double d1()
		{
			return (double)(m_d1) / gradient_subpixel_scale;
		}

		public double d2()
		{
			return (double)(m_d2) / gradient_subpixel_scale;
		}

		//--------------------------------------------------------------------
		public void interpolator(ISpanInterpolator i)
		{
			m_interpolator = i;
		}

		public void gradient_function(IGradient gf)
		{
			m_gradient_function = gf;
		}

		public void color_function(IColorFunction cf)
		{
			m_color_function = cf;
		}

		public void d1(double v)
		{
			m_d1 = Util.iround(v * gradient_subpixel_scale);
		}

		public void d2(double v)
		{
			m_d2 = Util.iround(v * gradient_subpixel_scale);
		}

		//--------------------------------------------------------------------
		public void prepare()
		{
		}

		//--------------------------------------------------------------------
		public void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			int dd = m_d2 - m_d1;
			if (dd < 1) dd = 1;
			m_interpolator.begin(x + 0.5, y + 0.5, len);
			do
			{
				m_interpolator.coordinates(out x, out y);
				int d = m_gradient_function.calculate(x >> downscale_shift,
													   y >> downscale_shift, m_d2);
				d = ((d - m_d1) * (int)m_color_function.size()) / dd;
				if (d < 0) d = 0;
				if (d >= (int)m_color_function.size())
				{
					d = m_color_function.size() - 1;
				}

				span[spanIndex++] = m_color_function[d];
				m_interpolator.Next();
			}
			while (--len != 0);
		}
	};

	//=====================================================gradient_linear_color
	public struct gradient_linear_color : IColorFunction
	{
		private Color m_c1;
		private Color m_c2;
		private int m_size;

		public gradient_linear_color(Color c1, Color c2)
			: this(c1, c2, 256)
		{
		}

		public gradient_linear_color(Color c1, Color c2, int size)
		{
			m_c1 = c1;
			m_c2 = c2;
			m_size = size;
		}

		public int size()
		{
			return m_size;
		}

		public Color this[int v]
		{
			get
			{
				return m_c1.gradient(m_c2, (double)(v) / (double)(m_size - 1));
			}
		}

		public void colors(Color c1, Color c2)
		{
			colors(c1, c2, 256);
		}

		public void colors(Color c1, Color c2, int size)
		{
			m_c1 = c1;
			m_c2 = c2;
			m_size = size;
		}
	};

	//==========================================================gradient_circle
	public class gradient_circle : IGradient
	{
		// Actually the same as radial. Just for compatibility
		public int calculate(int x, int y, int d)
		{
			return (int)(agg_math.fast_sqrt((int)(x * x + y * y)));
		}
	};

	//==========================================================gradient_radial
	public class gradient_radial : IGradient
	{
		public int calculate(int x, int y, int d)
		{
			return (int)(System.Math.Sqrt(x * x + y * y));
			//return (int)(agg_math.fast_sqrt((int)(x * x + y * y)));
		}
	}

	//========================================================gradient_radial_d
	public class gradient_radial_d : IGradient
	{
		public int calculate(int x, int y, int d)
		{
			return (int)Util.uround(System.Math.Sqrt((double)(x) * (double)(x) + (double)(y) * (double)(y)));
		}
	};

	//====================================================gradient_radial_focus
	public class gradient_radial_focus : IGradient
	{
		private int m_r;
		private int m_fx;
		private int m_fy;
		private double m_r2;
		private double m_fx2;
		private double m_fy2;
		private double m_mul;

		//---------------------------------------------------------------------
		public gradient_radial_focus()
		{
			m_r = (100 * span_gradient.gradient_subpixel_scale);
			m_fx = (0);
			m_fy = (0);
			update_values();
		}

		//---------------------------------------------------------------------
		public gradient_radial_focus(double r, double fx, double fy)
		{
			m_r = (Util.iround(r * span_gradient.gradient_subpixel_scale));
			m_fx = (Util.iround(fx * span_gradient.gradient_subpixel_scale));
			m_fy = (Util.iround(fy * span_gradient.gradient_subpixel_scale));
			update_values();
		}

		//---------------------------------------------------------------------
		public void init(double r, double fx, double fy)
		{
			m_r = Util.iround(r * span_gradient.gradient_subpixel_scale);
			m_fx = Util.iround(fx * span_gradient.gradient_subpixel_scale);
			m_fy = Util.iround(fy * span_gradient.gradient_subpixel_scale);
			update_values();
		}

		//---------------------------------------------------------------------
		public double radius()
		{
			return (double)(m_r) / span_gradient.gradient_subpixel_scale;
		}

		public double focus_x()
		{
			return (double)(m_fx) / span_gradient.gradient_subpixel_scale;
		}

		public double focus_y()
		{
			return (double)(m_fy) / span_gradient.gradient_subpixel_scale;
		}

		//---------------------------------------------------------------------
		public int calculate(int x, int y, int d)
		{
			double dx = x - m_fx;
			double dy = y - m_fy;
			double d2 = dx * m_fy - dy * m_fx;
			double d3 = m_r2 * (dx * dx + dy * dy) - d2 * d2;
			return Util.iround((dx * m_fx + dy * m_fy + System.Math.Sqrt(System.Math.Abs(d3))) * m_mul);
		}

		//---------------------------------------------------------------------
		private void update_values()
		{
			// Calculate the invariant values. In case the focal center
			// lies exactly on the gradient circle the divisor degenerates
			// into zero. In this case we just move the focal center by
			// one subpixel unit possibly in the direction to the origin (0,0)
			// and calculate the values again.
			//-------------------------
			m_r2 = (double)(m_r) * (double)(m_r);
			m_fx2 = (double)(m_fx) * (double)(m_fx);
			m_fy2 = (double)(m_fy) * (double)(m_fy);
			double d = (m_r2 - (m_fx2 + m_fy2));
			if (d == 0)
			{
				if (m_fx != 0)
				{
					if (m_fx < 0) ++m_fx; else --m_fx;
				}

				if (m_fy != 0)
				{
					if (m_fy < 0) ++m_fy; else --m_fy;
				}

				m_fx2 = (double)(m_fx) * (double)(m_fx);
				m_fy2 = (double)(m_fy) * (double)(m_fy);
				d = (m_r2 - (m_fx2 + m_fy2));
			}
			m_mul = m_r / d;
		}
	};

	//==============================================================gradient_x
	public class gradient_x : IGradient
	{
		public int calculate(int x, int y, int d)
		{
			return x;
		}
	};

	//==============================================================gradient_y
	public class gradient_y : IGradient
	{
		public int calculate(int x, int y, int d)
		{
			return y;
		}
	};

	//========================================================gradient_diamond
	public class gradient_diamond : IGradient
	{
		public int calculate(int x, int y, int d)
		{
			int ax = System.Math.Abs(x);
			int ay = System.Math.Abs(y);
			return ax > ay ? ax : ay;
		}
	};

	//=============================================================gradient_xy
	public class gradient_xy : IGradient
	{
		public int calculate(int x, int y, int d)
		{
			return System.Math.Abs(x) * System.Math.Abs(y) / d;
		}
	};

	//========================================================gradient_sqrt_xy
	public class gradient_sqrt_xy : IGradient
	{
		public int calculate(int x, int y, int d)
		{
			//return (int)System.Math.Sqrt((int)(System.Math.Abs(x) * System.Math.Abs(y)));
			return (int)agg_math.fast_sqrt((int)(System.Math.Abs(x) * System.Math.Abs(y)));
		}
	};

	//==========================================================gradient_conic
	public class gradient_conic : IGradient
	{
		public int calculate(int x, int y, int d)
		{
			return (int)Util.uround(System.Math.Abs(System.Math.Atan2((double)(y), (double)(x))) * (double)(d) / System.Math.PI);
		}
	};

	//=================================================gradient_repeat_adaptor
	public class gradient_repeat_adaptor : IGradient
	{
		private IGradient m_gradient;

		public gradient_repeat_adaptor(IGradient gradient)
		{
			m_gradient = gradient;
		}

		public int calculate(int x, int y, int d)
		{
			int ret = m_gradient.calculate(x, y, d) % d;
			if (ret < 0) ret += d;
			return ret;
		}
	};

	//================================================gradient_reflect_adaptor
	public class gradient_reflect_adaptor : IGradient
	{
		private IGradient m_gradient;

		public gradient_reflect_adaptor(IGradient gradient)
		{
			m_gradient = gradient;
		}

		public int calculate(int x, int y, int d)
		{
			int d2 = d << 1;
			int ret = m_gradient.calculate(x, y, d) % d2;
			if (ret < 0) ret += d2;
			if (ret >= d) ret = d2 - ret;
			return ret;
		}
	};

	public class gradient_clamp_adaptor : IGradient
	{
		private IGradient m_gradient;

		public gradient_clamp_adaptor(IGradient gradient)
		{
			m_gradient = gradient;
		}

		public int calculate(int x, int y, int d)
		{
			int ret = m_gradient.calculate(x, y, d);
			if (ret < 0) ret = 0;
			if (ret > d) ret = d;
			return ret;
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Spans\agg_span_image_filter.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Image transformations with filtering. Span generator base class
//
//----------------------------------------------------------------------------
using image_subpixel_scale_e = MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e;

namespace MatterHackers.Agg
{
	public interface ISpanGenerator
	{
		void prepare();

		void generate(Color[] span, int spanIndex, int x, int y, int len);
	};

	public abstract class span_image_filter : ISpanGenerator
	{
		private IImageBufferAccessor imageBufferAccessor;
		protected ISpanInterpolator m_interpolator;
		protected ImageFilterLookUpTable m_filter;
		private double m_dx_dbl;
		private double m_dy_dbl;
		private int m_dx_int;
		private int m_dy_int;

		public span_image_filter()
		{
		}

		public span_image_filter(IImageBufferAccessor src,
			ISpanInterpolator interpolator)
			: this(src, interpolator, null)
		{
		}

		public span_image_filter(IImageBufferAccessor src,
			ISpanInterpolator interpolator, ImageFilterLookUpTable filter)
		{
			imageBufferAccessor = src;
			m_interpolator = interpolator;
			m_filter = (filter);
			m_dx_dbl = (0.5);
			m_dy_dbl = (0.5);
			m_dx_int = ((int)image_subpixel_scale_e.image_subpixel_scale / 2);
			m_dy_int = ((int)image_subpixel_scale_e.image_subpixel_scale / 2);
		}

		public void attach(IImageBufferAccessor v)
		{
			imageBufferAccessor = v;
		}

		public abstract void generate(Color[] span, int spanIndex, int x, int y, int len);

		public IImageBufferAccessor GetImageBufferAccessor()
		{
			return imageBufferAccessor;
		}

		public ImageFilterLookUpTable filter()
		{
			return m_filter;
		}

		public int filter_dx_int()
		{
			return (int)m_dx_int;
		}

		public int filter_dy_int()
		{
			return (int)m_dy_int;
		}

		public double filter_dx_dbl()
		{
			return m_dx_dbl;
		}

		public double filter_dy_dbl()
		{
			return m_dy_dbl;
		}

		public void interpolator(ISpanInterpolator v)
		{
			m_interpolator = v;
		}

		public void filter(ImageFilterLookUpTable v)
		{
			m_filter = v;
		}

		public void filter_offset(double dx, double dy)
		{
			m_dx_dbl = dx;
			m_dy_dbl = dy;
			m_dx_int = (int)Util.iround(dx * (int)image_subpixel_scale_e.image_subpixel_scale);
			m_dy_int = (int)Util.iround(dy * (int)image_subpixel_scale_e.image_subpixel_scale);
		}

		public void filter_offset(double d)
		{
			filter_offset(d, d);
		}

		public ISpanInterpolator interpolator()
		{
			return m_interpolator;
		}

		public void prepare()
		{
		}
	}

	public interface ISpanGeneratorFloat
	{
		void prepare();

		void generate(ColorF[] span, int spanIndex, int x, int y, int len);
	};

	public abstract class span_image_filter_float : ISpanGeneratorFloat
	{
		private IImageBufferAccessorFloat m_ImageBufferAccessor;
		protected ISpanInterpolatorFloat m_interpolator;
		protected IImageFilterFunction m_filterFunction;
		private float m_dx_dbl;
		private float m_dy_dbl;

		public span_image_filter_float()
		{
		}

		public span_image_filter_float(IImageBufferAccessorFloat src,
			ISpanInterpolatorFloat interpolator)
			: this(src, interpolator, null)
		{
		}

		public span_image_filter_float(IImageBufferAccessorFloat src,
			ISpanInterpolatorFloat interpolator, IImageFilterFunction filterFunction)
		{
			m_ImageBufferAccessor = src;
			m_interpolator = interpolator;
			m_filterFunction = filterFunction;
			m_dx_dbl = (0.5f);
			m_dy_dbl = (0.5f);
		}

		public void attach(IImageBufferAccessorFloat v)
		{
			m_ImageBufferAccessor = v;
		}

		public abstract void generate(ColorF[] span, int spanIndex, int x, int y, int len);

		public IImageBufferAccessorFloat source()
		{
			return m_ImageBufferAccessor;
		}

		public IImageFilterFunction filterFunction()
		{
			return m_filterFunction;
		}

		public float filter_dx_dbl()
		{
			return m_dx_dbl;
		}

		public float filter_dy_dbl()
		{
			return m_dy_dbl;
		}

		public void interpolator(ISpanInterpolatorFloat v)
		{
			m_interpolator = v;
		}

		public void filterFunction(IImageFilterFunction v)
		{
			m_filterFunction = v;
		}

		public void filter_offset(float dx, float dy)
		{
			m_dx_dbl = dx;
			m_dy_dbl = dy;
		}

		public void filter_offset(float d)
		{
			filter_offset(d, d);
		}

		public ISpanInterpolatorFloat interpolator()
		{
			return m_interpolator;
		}

		public void prepare()
		{
		}
	}

	/*

	//==============================================span_image_resample_affine
	//template<class Source>
	public class span_image_resample_affine :
		span_image_filter//<Source, span_interpolator_linear<trans_affine> >
	{
		//typedef Source IImageAccessor;
		//typedef span_interpolator_linear<trans_affine> ISpanInterpolator;
		//typedef span_image_filter<source_type, ISpanInterpolator> base_type;

		//--------------------------------------------------------------------
		public span_image_resample_affine()
		{
			m_scale_limit=(200.0);
			m_blur_x=(1.0);
			m_blur_y=(1.0);
		}

		//--------------------------------------------------------------------
		public span_image_resample_affine(IImageAccessor src,
								   ISpanInterpolator inter,
								   ImageFilterLookUpTable filter) : base(src, inter, filter)
		{
			m_scale_limit(200.0);
			m_blur_x(1.0);
			m_blur_y(1.0);
		}

		//--------------------------------------------------------------------
		public int  scale_limit() { return uround(m_scale_limit); }
		public void scale_limit(int v)  { m_scale_limit = v; }

		//--------------------------------------------------------------------
		public double blur_x() { return m_blur_x; }
		public double blur_y() { return m_blur_y; }
		public void blur_x(double v) { m_blur_x = v; }
		public void blur_y(double v) { m_blur_y = v; }
		public void blur(double v) { m_blur_x = m_blur_y = v; }

		//--------------------------------------------------------------------
		public void prepare()
		{
			double scale_x;
			double scale_y;

			base_type::interpolator().transformer().scaling_abs(&scale_x, &scale_y);

			if(scale_x * scale_y > m_scale_limit)
			{
				scale_x = scale_x * m_scale_limit / (scale_x * scale_y);
				scale_y = scale_y * m_scale_limit / (scale_x * scale_y);
			}

			if(scale_x < 1) scale_x = 1;
			if(scale_y < 1) scale_y = 1;

			if(scale_x > m_scale_limit) scale_x = m_scale_limit;
			if(scale_y > m_scale_limit) scale_y = m_scale_limit;

			scale_x *= m_blur_x;
			scale_y *= m_blur_y;

			if(scale_x < 1) scale_x = 1;
			if(scale_y < 1) scale_y = 1;

			m_rx     = uround(    scale_x * (double)(image_subpixel_scale));
			m_rx_inv = uround(1.0/scale_x * (double)(image_subpixel_scale));

			m_ry     = uround(    scale_y * (double)(image_subpixel_scale));
			m_ry_inv = uround(1.0/scale_y * (double)(image_subpixel_scale));
		}

		protected int m_rx;
		protected int m_ry;
		protected int m_rx_inv;
		protected int m_ry_inv;

		private double m_scale_limit;
		private double m_blur_x;
		private double m_blur_y;
	};

	 */

	//=====================================================span_image_resample
	public abstract class span_image_resample
		: span_image_filter
	{
		public span_image_resample(IImageBufferAccessor src,
							ISpanInterpolator inter,
							ImageFilterLookUpTable filter)
			: base(src, inter, filter)
		{
			m_scale_limit = (20);
			m_blur_x = ((int)image_subpixel_scale_e.image_subpixel_scale);
			m_blur_y = ((int)image_subpixel_scale_e.image_subpixel_scale);
		}

		//public abstract void prepare();
		//public abstract unsafe void generate(rgba8* span, int x, int y, int len);

		//--------------------------------------------------------------------
		private int scale_limit()
		{
			return m_scale_limit;
		}

		private void scale_limit(int v)
		{
			m_scale_limit = v;
		}

		//--------------------------------------------------------------------
		private double blur_x()
		{
			return (double)(m_blur_x) / (double)((int)image_subpixel_scale_e.image_subpixel_scale);
		}

		private double blur_y()
		{
			return (double)(m_blur_y) / (double)((int)image_subpixel_scale_e.image_subpixel_scale);
		}

		private void blur_x(double v)
		{
			m_blur_x = (int)Util.uround(v * (double)((int)image_subpixel_scale_e.image_subpixel_scale));
		}

		private void blur_y(double v)
		{
			m_blur_y = (int)Util.uround(v * (double)((int)image_subpixel_scale_e.image_subpixel_scale));
		}

		public void blur(double v)
		{
			m_blur_x = m_blur_y = (int)Util.uround(v * (double)((int)image_subpixel_scale_e.image_subpixel_scale));
		}

		protected void adjust_scale(ref int rx, ref int ry)
		{
			if (rx < (int)image_subpixel_scale_e.image_subpixel_scale) rx = (int)image_subpixel_scale_e.image_subpixel_scale;
			if (ry < (int)image_subpixel_scale_e.image_subpixel_scale) ry = (int)image_subpixel_scale_e.image_subpixel_scale;
			if (rx > (int)image_subpixel_scale_e.image_subpixel_scale * m_scale_limit)
			{
				rx = (int)image_subpixel_scale_e.image_subpixel_scale * m_scale_limit;
			}
			if (ry > (int)image_subpixel_scale_e.image_subpixel_scale * m_scale_limit)
			{
				ry = (int)image_subpixel_scale_e.image_subpixel_scale * m_scale_limit;
			}
			rx = (rx * m_blur_x) >> (int)image_subpixel_scale_e.image_subpixel_shift;
			ry = (ry * m_blur_y) >> (int)image_subpixel_scale_e.image_subpixel_shift;
			if (rx < (int)image_subpixel_scale_e.image_subpixel_scale) rx = (int)image_subpixel_scale_e.image_subpixel_scale;
			if (ry < (int)image_subpixel_scale_e.image_subpixel_scale) ry = (int)image_subpixel_scale_e.image_subpixel_scale;
		}

		private int m_scale_limit;
		private int m_blur_x;
		private int m_blur_y;
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Spans\agg_span_image_filter_gray.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
#define USE_UNSAFE_CODE

using MatterHackers.Agg.Image;
using System;
using image_subpixel_scale_e = MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e;

namespace MatterHackers.Agg
{
	// it should be easy to write a 90 rotating or mirroring filter too. LBB 2012/01/14
	public class span_image_filter_gray_nn_stepXby1 : span_image_filter
	{
		private const int base_shift = 8;
		private const int base_scale = (int)(1 << base_shift);
		private const int base_mask = base_scale - 1;

		public span_image_filter_gray_nn_stepXby1(IImageBufferAccessor sourceAccessor, ISpanInterpolator spanInterpolator)
			: base(sourceAccessor, spanInterpolator, null)
		{
		}

		public override void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			ImageBuffer SourceRenderingBuffer = (ImageBuffer)GetImageBufferAccessor().SourceImage;
			int bytesBetweenPixelsInclusive = SourceRenderingBuffer.GetBytesBetweenPixelsInclusive();
			if (SourceRenderingBuffer.BitDepth != 8)
			{
				throw new NotSupportedException("The source is expected to be 32 bit.");
			}
			ISpanInterpolator spanInterpolator = interpolator();
			spanInterpolator.begin(x + filter_dx_dbl(), y + filter_dy_dbl(), len);
			int x_hr;
			int y_hr;
			spanInterpolator.coordinates(out x_hr, out y_hr);
			int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
			int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
			int bufferIndex;
			bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

			byte[] fg_ptr = SourceRenderingBuffer.GetBuffer();
#if USE_UNSAFE_CODE
			unsafe
			{
				fixed (byte* pSource = fg_ptr)
				{
					do
					{
						span[spanIndex].red = pSource[bufferIndex];
						span[spanIndex].green = pSource[bufferIndex];
						span[spanIndex].blue = pSource[bufferIndex];
						span[spanIndex].alpha = 255;
						spanIndex++;
						bufferIndex += bytesBetweenPixelsInclusive;
					} while (--len != 0);
				}
			}
#else
            do
            {
                throw new Exception("this code is for 32 bit");
                color.m_B = fg_ptr[bufferIndex++];
                color.m_G = fg_ptr[bufferIndex++];
                color.m_R = fg_ptr[bufferIndex++];
                color.m_A = fg_ptr[bufferIndex++];
                span[spanIndex++] = color;
            } while (--len != 0);
#endif
		}
	}

	/*
		//==============================================span_image_filter_gray_nn
		//template<class Source, class Interpolator>
		public class span_image_filter_gray_nn : span_image_filter // <Source, Interpolator>
		{
			//typedef Source source_type;
			//typedef typename source_type::color_type color_type;
			//typedef Interpolator interpolator_type;
			//typedef span_image_filter<source_type, interpolator_type> base_type;
			//typedef typename color_type::value_type value_type;
			//typedef typename color_type::calc_type calc_type;
			enum base_scale_e
			{
				base_shift = 8,//color_type::base_shift,
				base_mask  = 255//color_type::base_mask
			};

			//--------------------------------------------------------------------
			public span_image_filter_gray_nn() {}
			public span_image_filter_gray_nn(source_type src, interpolator_type inter) :
				base(src, inter, 0)
			{}

			//--------------------------------------------------------------------
			public void generate(color_type* span, int x, int y, unsigned len)
			{
				base_type::interpolator().begin(x + base_type::filter_dx_dbl(),
												y + base_type::filter_dy_dbl(), len);
				do
				{
					base_type::interpolator().coordinates(&x, &y);
					span->v = *(value_type*)
						base_type::source().span(x >> image_subpixel_shift,
												 y >> image_subpixel_shift,
												 1);
					span->a = base_mask;
					++span;
					++base_type::interpolator();
				} while(--len);
			}
		};

		//=========================================span_image_filter_gray_bilinear
		//template<class Source, class Interpolator>
		public class span_image_filter_gray_bilinear : span_image_filter // <Source, Interpolator>
		{
			//typedef Source source_type;
			//typedef typename source_type::color_type color_type;
			//typedef Interpolator interpolator_type;
			//typedef span_image_filter<source_type, interpolator_type> base_type;
			//typedef typename color_type::value_type value_type;
			//typedef typename color_type::calc_type calc_type;
			enum base_scale_e
			{
				base_shift = 8,//color_type::base_shift,
				base_mask  = 255//color_type::base_mask
			};

			//--------------------------------------------------------------------
			public span_image_filter_gray_bilinear() {}
			public span_image_filter_gray_bilinear(source_type src,
											interpolator_type inter) :
				base(src, inter, 0)
			{}

			//--------------------------------------------------------------------
			public void generate(color_type* span, int x, int y, unsigned len)
			{
				base_type::interpolator().begin(x + base_type::filter_dx_dbl(),
												y + base_type::filter_dy_dbl(), len);
				calc_type fg;
				value_type *fg_ptr;
				do
				{
					int x_hr;
					int y_hr;

					base_type::interpolator().coordinates(&x_hr, &y_hr);

					x_hr -= base_type::filter_dx_int();
					y_hr -= base_type::filter_dy_int();

					int x_lr = x_hr >> image_subpixel_shift;
					int y_lr = y_hr >> image_subpixel_shift;

					fg = image_subpixel_scale * image_subpixel_scale / 2;

					x_hr &= image_subpixel_mask;
					y_hr &= image_subpixel_mask;

					fg_ptr = (value_type*)base_type::source().span(x_lr, y_lr, 2);
					fg    += *fg_ptr * (image_subpixel_scale - x_hr) * (image_subpixel_scale - y_hr);

					fg_ptr = (value_type*)base_type::source().next_x();
					fg    += *fg_ptr * x_hr * (image_subpixel_scale - y_hr);

					fg_ptr = (value_type*)base_type::source().next_y();
					fg    += *fg_ptr * (image_subpixel_scale - x_hr) * y_hr;

					fg_ptr = (value_type*)base_type::source().next_x();
					fg    += *fg_ptr * x_hr * y_hr;

					span->v = value_type(fg >> (image_subpixel_shift * 2));
					span->a = base_mask;
					++span;
					++base_type::interpolator();
				} while(--len);
			}
		};

		//====================================span_image_filter_gray_bilinear_clip
		//template<class Source, class Interpolator>
		public class span_image_filter_gray_bilinear_clip : span_image_filter // <Source, Interpolator>
		{
			//typedef Source source_type;
			//typedef typename source_type::color_type color_type;
			//typedef Interpolator interpolator_type;
			//typedef span_image_filter<source_type, interpolator_type> base_type;
			//typedef typename color_type::value_type value_type;
			//typedef typename color_type::calc_type calc_type;
			enum base_scale_e
			{
				base_shift = 8,//color_type::base_shift,
				base_mask  = 255//color_type::base_mask
			};

			//--------------------------------------------------------------------
			public span_image_filter_gray_bilinear_clip() {}
			public span_image_filter_gray_bilinear_clip(source_type src,
												 color_type back_color,
												 interpolator_type inter) :
				base(src, inter, 0)
			{
				m_back_color = (back_color);
			}
			public color_type background_color() { return m_back_color; }
			public void background_color(color_type v)   { m_back_color = v; }

			//--------------------------------------------------------------------
			public void generate(color_type* span, int x, int y, unsigned len)
			{
				base_type::interpolator().begin(x + base_type::filter_dx_dbl(),
												y + base_type::filter_dy_dbl(), len);
				calc_type fg;
				calc_type src_alpha;
				value_type back_v = m_back_color.v;
				value_type back_a = m_back_color.a;

				value_type *fg_ptr;

				int maxx = base_type::source().width() - 1;
				int maxy = base_type::source().height() - 1;

				do
				{
					int x_hr;
					int y_hr;

					base_type::interpolator().coordinates(&x_hr, &y_hr);

					x_hr -= base_type::filter_dx_int();
					y_hr -= base_type::filter_dy_int();

					int x_lr = x_hr >> image_subpixel_shift;
					int y_lr = y_hr >> image_subpixel_shift;

					if(x_lr >= 0    && y_lr >= 0 &&
					   x_lr <  maxx && y_lr <  maxy)
					{
						fg = image_subpixel_scale * image_subpixel_scale / 2;

						x_hr &= image_subpixel_mask;
						y_hr &= image_subpixel_mask;
						fg_ptr = (value_type*)base_type::source().row_ptr(y_lr) + x_lr;

						fg += *fg_ptr++ * (image_subpixel_scale - x_hr) * (image_subpixel_scale - y_hr);
						fg += *fg_ptr++ * (image_subpixel_scale - y_hr) * x_hr;

						++y_lr;
						fg_ptr = (value_type*)base_type::source().row_ptr(y_lr) + x_lr;

						fg += *fg_ptr++ * (image_subpixel_scale - x_hr) * y_hr;
						fg += *fg_ptr++ * x_hr * y_hr;

						fg >>= image_subpixel_shift * 2;
						src_alpha = base_mask;
					}
					else
					{
						unsigned weight;
						if(x_lr < -1   || y_lr < -1 ||
						   x_lr > maxx || y_lr > maxy)
						{
							fg        = back_v;
							src_alpha = back_a;
						}
						else
						{
							fg =
							src_alpha = image_subpixel_scale * image_subpixel_scale / 2;

							x_hr &= image_subpixel_mask;
							y_hr &= image_subpixel_mask;

							weight = (image_subpixel_scale - x_hr) *
									 (image_subpixel_scale - y_hr);
							if(x_lr >= 0    && y_lr >= 0 &&
							   x_lr <= maxx && y_lr <= maxy)
							{
								fg += weight *
									*((value_type*)base_type::source().row_ptr(y_lr) + x_lr);
								src_alpha += weight * base_mask;
							}
							else
							{
								fg        += back_v * weight;
								src_alpha += back_a * weight;
							}

							x_lr++;

							weight = x_hr * (image_subpixel_scale - y_hr);
							if(x_lr >= 0    && y_lr >= 0 &&
							   x_lr <= maxx && y_lr <= maxy)
							{
								fg += weight *
									*((value_type*)base_type::source().row_ptr(y_lr) + x_lr);
								src_alpha += weight * base_mask;
							}
							else
							{
								fg        += back_v * weight;
								src_alpha += back_a * weight;
							}

							x_lr--;
							y_lr++;

							weight = (image_subpixel_scale - x_hr) * y_hr;
							if(x_lr >= 0    && y_lr >= 0 &&
							   x_lr <= maxx && y_lr <= maxy)
							{
								fg += weight *
									*((value_type*)base_type::source().row_ptr(y_lr) + x_lr);
								src_alpha += weight * base_mask;
							}
							else
							{
								fg        += back_v * weight;
								src_alpha += back_a * weight;
							}

							x_lr++;

							weight = x_hr * y_hr;
							if(x_lr >= 0    && y_lr >= 0 &&
							   x_lr <= maxx && y_lr <= maxy)
							{
								fg += weight *
									*((value_type*)base_type::source().row_ptr(y_lr) + x_lr);
								src_alpha += weight * base_mask;
							}
							else
							{
								fg        += back_v * weight;
								src_alpha += back_a * weight;
							}

							fg        >>= image_subpixel_shift * 2;
							src_alpha >>= image_subpixel_shift * 2;
						}
					}

					span->v = (value_type)fg;
					span->a = (value_type)src_alpha;
					++span;
					++base_type::interpolator();
				} while(--len);
			}

			color_type m_back_color;
		};

		//==============================================span_image_filter_gray_2x2
		//template<class Source, class Interpolator>
		public class span_image_filter_gray_2x2 : span_image_filter//<Source, Interpolator>
		{
			//typedef Source source_type;
			//typedef typename source_type::color_type color_type;
			//typedef Interpolator interpolator_type;
			//typedef span_image_filter<source_type, interpolator_type> base_type;
			//typedef typename color_type::value_type value_type;
			//typedef typename color_type::calc_type calc_type;
			enum base_scale_e
			{
				base_shift = 8,//color_type::base_shift,
				base_mask  = 255//color_type::base_mask
			};

			//--------------------------------------------------------------------
			public span_image_filter_gray_2x2() {}
			public span_image_filter_gray_2x2(source_type src,
									   interpolator_type inter,
									   image_filter_lut filter) :
				base(src, inter, &filter)
			{}

			//--------------------------------------------------------------------
			public void generate(color_type* span, int x, int y, unsigned len)
			{
				base_type::interpolator().begin(x + base_type::filter_dx_dbl(),
												y + base_type::filter_dy_dbl(), len);

				calc_type fg;

				value_type *fg_ptr;
				int16* weight_array = base_type::filter().weight_array() +
											((base_type::filter().diameter()/2 - 1) <<
											  image_subpixel_shift);
				do
				{
					int x_hr;
					int y_hr;

					base_type::interpolator().coordinates(&x_hr, &y_hr);

					x_hr -= base_type::filter_dx_int();
					y_hr -= base_type::filter_dy_int();

					int x_lr = x_hr >> image_subpixel_shift;
					int y_lr = y_hr >> image_subpixel_shift;

					unsigned weight;
					fg = image_filter_scale / 2;

					x_hr &= image_subpixel_mask;
					y_hr &= image_subpixel_mask;

					fg_ptr = (value_type*)base_type::source().span(x_lr, y_lr, 2);
					weight = (weight_array[x_hr + image_subpixel_scale] *
							  weight_array[y_hr + image_subpixel_scale] +
							  image_filter_scale / 2) >>
							  image_filter_shift;
					fg += weight * *fg_ptr;

					fg_ptr = (value_type*)base_type::source().next_x();
					weight = (weight_array[x_hr] *
							  weight_array[y_hr + image_subpixel_scale] +
							  image_filter_scale / 2) >>
							  image_filter_shift;
					fg += weight * *fg_ptr;

					fg_ptr = (value_type*)base_type::source().next_y();
					weight = (weight_array[x_hr + image_subpixel_scale] *
							  weight_array[y_hr] +
							  image_filter_scale / 2) >>
							  image_filter_shift;
					fg += weight * *fg_ptr;

					fg_ptr = (value_type*)base_type::source().next_x();
					weight = (weight_array[x_hr] *
							  weight_array[y_hr] +
							  image_filter_scale / 2) >>
							  image_filter_shift;
					fg += weight * *fg_ptr;

					fg >>= image_filter_shift;
					if(fg > base_mask) fg = base_mask;

					span->v = (value_type)fg;
					span->a = base_mask;
					++span;
					++base_type::interpolator();
				} while(--len);
			}
		};

		//==================================================span_image_filter_gray
		//template<class Source, class Interpolator>
		public class span_image_filter_gray : span_image_filter//<Source, Interpolator>
		{
			//typedef Source source_type;
			//typedef typename source_type::color_type color_type;
			//typedef Interpolator interpolator_type;
			//typedef span_image_filter<source_type, interpolator_type> base_type;
			//typedef typename color_type::value_type value_type;
			//typedef typename color_type::calc_type calc_type;
			enum base_scale_e
			{
				base_shift = 8,//color_type::base_shift,
				base_mask  = 255//color_type::base_mask
			};

			//--------------------------------------------------------------------
			public span_image_filter_gray() {}
			public span_image_filter_gray(source_type src,
								   interpolator_type inter,
								   image_filter_lut filter) :
				base(src, inter, filter)
			{}

			//--------------------------------------------------------------------
			public void generate(color_type* span, int x, int y, unsigned len)
			{
				base_type::interpolator().begin(x + base_type::filter_dx_dbl(),
												y + base_type::filter_dy_dbl(), len);

				int fg;
				value_type *fg_ptr;

				unsigned     diameter     = base_type::filter().diameter();
				int          start        = base_type::filter().start();
				int16* weight_array = base_type::filter().weight_array();

				int x_count;
				int weight_y;

				do
				{
					base_type::interpolator().coordinates(&x, &y);

					x -= base_type::filter_dx_int();
					y -= base_type::filter_dy_int();

					int x_hr = x;
					int y_hr = y;

					int x_lr = x_hr >> image_subpixel_shift;
					int y_lr = y_hr >> image_subpixel_shift;

					fg = image_filter_scale / 2;

					int x_fract = x_hr & image_subpixel_mask;
					unsigned y_count = diameter;

					y_hr = image_subpixel_mask - (y_hr & image_subpixel_mask);
					fg_ptr = (value_type*)base_type::source().span(x_lr + start,
																		 y_lr + start,
																		 diameter);
					for(;;)
					{
						x_count  = diameter;
						weight_y = weight_array[y_hr];
						x_hr = image_subpixel_mask - x_fract;
						for(;;)
						{
							fg += *fg_ptr *
								  ((weight_y * weight_array[x_hr] +
									image_filter_scale / 2) >>
									image_filter_shift);
							if(--x_count == 0) break;
							x_hr  += image_subpixel_scale;
							fg_ptr = (value_type*)base_type::source().next_x();
						}

						if(--y_count == 0) break;
						y_hr  += image_subpixel_scale;
						fg_ptr = (value_type*)base_type::source().next_y();
					}

					fg >>= image_filter_shift;
					if(fg < 0) fg = 0;
					if(fg > base_mask) fg = base_mask;
					span->v = (value_type)fg;
					span->a = base_mask;

					++span;
					++base_type::interpolator();
				} while(--len);
			}
		};

		//=========================================span_image_resample_gray_affine
		//template<class Source>
		public class span_image_resample_gray_affine : span_image_resample_affine//<Source>
		{
			//typedef Source source_type;
			//typedef typename source_type::color_type color_type;
			//typedef span_image_resample_affine<source_type> base_type;
			//typedef typename base_type::interpolator_type interpolator_type;
			//typedef typename color_type::value_type value_type;
			//typedef typename color_type::long_type long_type;
			enum base_scale_e
			{
				base_shift      = 8,//color_type::base_shift,
				base_mask       = 255,//color_type::base_mask,
				downscale_shift = image_filter_shift
			};

			//--------------------------------------------------------------------
			public span_image_resample_gray_affine() {}
			public span_image_resample_gray_affine(source_type src,
											interpolator_type inter,
											image_filter_lut filter) :
				base(src, inter, filter)
			{}

			//--------------------------------------------------------------------
			public void generate(color_type* span, int x, int y, unsigned len)
			{
				base_type::interpolator().begin(x + base_type::filter_dx_dbl(),
												y + base_type::filter_dy_dbl(), len);

				long_type fg;

				int diameter     = base_type::filter().diameter();
				int filter_scale = diameter << image_subpixel_shift;
				int radius_x     = (diameter * base_type::m_rx) >> 1;
				int radius_y     = (diameter * base_type::m_ry) >> 1;
				int len_x_lr     =
					(diameter * base_type::m_rx + image_subpixel_mask) >>
						image_subpixel_shift;

				int16* weight_array = base_type::filter().weight_array();

				do
				{
					base_type::interpolator().coordinates(&x, &y);

					x += base_type::filter_dx_int() - radius_x;
					y += base_type::filter_dy_int() - radius_y;

					fg = image_filter_scale / 2;

					int y_lr = y >> image_subpixel_shift;
					int y_hr = ((image_subpixel_mask - (y & image_subpixel_mask)) *
									base_type::m_ry_inv) >>
										image_subpixel_shift;
					int total_weight = 0;
					int x_lr = x >> image_subpixel_shift;
					int x_hr = ((image_subpixel_mask - (x & image_subpixel_mask)) *
									base_type::m_rx_inv) >>
										image_subpixel_shift;

					int x_hr2 = x_hr;
					value_type* fg_ptr =
						(value_type*)base_type::source().span(x_lr, y_lr, len_x_lr);
					for(;;)
					{
						int weight_y = weight_array[y_hr];
						x_hr = x_hr2;
						for(;;)
						{
							int weight = (weight_y * weight_array[x_hr] +
										 image_filter_scale / 2) >>
										 downscale_shift;

							fg += *fg_ptr * weight;
							total_weight += weight;
							x_hr  += base_type::m_rx_inv;
							if(x_hr >= filter_scale) break;
							fg_ptr = (value_type*)base_type::source().next_x();
						}
						y_hr += base_type::m_ry_inv;
						if(y_hr >= filter_scale) break;
						fg_ptr = (value_type*)base_type::source().next_y();
					}

					fg /= total_weight;
					if(fg < 0) fg = 0;
					if(fg > base_mask) fg = base_mask;

					span->v = (value_type)fg;
					span->a = base_mask;

					++span;
					++base_type::interpolator();
				} while(--len);
			}
		};

		//================================================span_image_resample_gray
		//template<class Source, class Interpolator>
		public class span_image_resample_gray : span_image_resample//<Source, Interpolator>
		{
			//typedef Source source_type;
			//typedef typename source_type::color_type color_type;
			//typedef Interpolator interpolator_type;
			//typedef span_image_resample<source_type, interpolator_type> base_type;
			//typedef typename color_type::value_type value_type;
			//typedef typename color_type::long_type long_type;
			enum base_scale_e
			{
				base_shift = 8,//color_type::base_shift,
				base_mask  = 255,//color_type::base_mask,
				downscale_shift = image_filter_shift
			};

			//--------------------------------------------------------------------
			public span_image_resample_gray() {}
			public span_image_resample_gray(source_type src,
									 interpolator_type inter,
									 image_filter_lut filter) :
				base(src, inter, filter)
			{}

			//--------------------------------------------------------------------
			public void generate(color_type* span, int x, int y, unsigned len)
			{
				base_type::interpolator().begin(x + base_type::filter_dx_dbl(),
												y + base_type::filter_dy_dbl(), len);
				long_type fg;

				int diameter = base_type::filter().diameter();
				int filter_scale = diameter << image_subpixel_shift;

				int16* weight_array = base_type::filter().weight_array();
				do
				{
					int rx;
					int ry;
					int rx_inv = image_subpixel_scale;
					int ry_inv = image_subpixel_scale;
					base_type::interpolator().coordinates(&x,  &y);
					base_type::interpolator().local_scale(&rx, &ry);
					base_type::adjust_scale(&rx, &ry);

					rx_inv = image_subpixel_scale * image_subpixel_scale / rx;
					ry_inv = image_subpixel_scale * image_subpixel_scale / ry;

					int radius_x = (diameter * rx) >> 1;
					int radius_y = (diameter * ry) >> 1;
					int len_x_lr =
						(diameter * rx + image_subpixel_mask) >>
							image_subpixel_shift;

					x += base_type::filter_dx_int() - radius_x;
					y += base_type::filter_dy_int() - radius_y;

					fg = image_filter_scale / 2;

					int y_lr = y >> image_subpixel_shift;
					int y_hr = ((image_subpixel_mask - (y & image_subpixel_mask)) *
								   ry_inv) >>
									   image_subpixel_shift;
					int total_weight = 0;
					int x_lr = x >> image_subpixel_shift;
					int x_hr = ((image_subpixel_mask - (x & image_subpixel_mask)) *
								   rx_inv) >>
									   image_subpixel_shift;
					int x_hr2 = x_hr;
					value_type* fg_ptr =
						(value_type*)base_type::source().span(x_lr, y_lr, len_x_lr);

					for(;;)
					{
						int weight_y = weight_array[y_hr];
						x_hr = x_hr2;
						for(;;)
						{
							int weight = (weight_y * weight_array[x_hr] +
										 image_filter_scale / 2) >>
										 downscale_shift;
							fg += *fg_ptr * weight;
							total_weight += weight;
							x_hr  += rx_inv;
							if(x_hr >= filter_scale) break;
							fg_ptr = (value_type*)base_type::source().next_x();
						}
						y_hr += ry_inv;
						if(y_hr >= filter_scale) break;
						fg_ptr = (value_type*)base_type::source().next_y();
					}

					fg /= total_weight;
					if(fg < 0) fg = 0;
					if(fg > base_mask) fg = base_mask;

					span->v = (value_type)fg;
					span->a = base_mask;

					++span;
					++base_type::interpolator();
				} while(--len);
			}
		};
		 */
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Spans\agg_span_image_filter_rgb.cs
using MatterHackers.Agg.Image;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
using System;
using image_filter_scale_e = MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e;
using image_subpixel_scale_e = MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e;

namespace MatterHackers.Agg
{
	// it should be easy to write a 90 rotating or mirroring filter too. LBB 2012/01/14
	public class span_image_filter_rgb_nn_stepXby1 : span_image_filter
	{
		private const int base_shift = 8;
		private const int base_scale = (int)(1 << base_shift);
		private const int base_mask = base_scale - 1;

		public span_image_filter_rgb_nn_stepXby1(IImageBufferAccessor sourceAccessor, ISpanInterpolator spanInterpolator)
			: base(sourceAccessor, spanInterpolator, null)
		{
		}

		public override void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			ImageBuffer SourceRenderingBuffer = (ImageBuffer)GetImageBufferAccessor().SourceImage;
			if (SourceRenderingBuffer.BitDepth != 24)
			{
				throw new NotSupportedException("The source is expected to be 32 bit.");
			}
			ISpanInterpolator spanInterpolator = interpolator();
			spanInterpolator.begin(x + filter_dx_dbl(), y + filter_dy_dbl(), len);
			int x_hr;
			int y_hr;
			spanInterpolator.coordinates(out x_hr, out y_hr);
			int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
			int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
			int bufferIndex;
			bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

			byte[] fg_ptr = SourceRenderingBuffer.GetBuffer();
#if USE_UNSAFE_CODE
            unsafe
            {
                fixed (byte* pSource = fg_ptr)
                {
                    do
                    {
                        span[spanIndex++] = *(RGBA_Bytes*)&(pSource[bufferIndex]);
                        bufferIndex += 4;
                    } while (--len != 0);
                }
            }
#else
			Color color = Color.White;
			do
			{
				color.blue = fg_ptr[bufferIndex++];
				color.green = fg_ptr[bufferIndex++];
				color.red = fg_ptr[bufferIndex++];
				span[spanIndex++] = color;
			} while (--len != 0);
#endif
		}
	}

	//===============================================span_image_filter_rgb_nn
	public class span_image_filter_rgb_nn : span_image_filter
	{
		private const int base_shift = 8;
		private const int base_scale = (int)(1 << base_shift);
		private const int base_mask = base_scale - 1;

		//--------------------------------------------------------------------
		public span_image_filter_rgb_nn(IImageBufferAccessor src, ISpanInterpolator inter)
			: base(src, inter, null)
		{
		}

		public override void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			ImageBuffer SourceRenderingBuffer = (ImageBuffer)GetImageBufferAccessor().SourceImage;
			if (SourceRenderingBuffer.BitDepth != 24)
			{
				throw new NotSupportedException("The source is expected to be 32 bit.");
			}
			ISpanInterpolator spanInterpolator = interpolator();
			spanInterpolator.begin(x + filter_dx_dbl(), y + filter_dy_dbl(), len);
			int offset;
			byte[] fg_ptr = SourceRenderingBuffer.GetBuffer(out offset);
			do
			{
				int x_hr;
				int y_hr;
				spanInterpolator.coordinates(out x_hr, out y_hr);
				int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
				int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
				int bufferIndex;
				bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);
				Color color;
				color.blue = fg_ptr[bufferIndex++];
				color.green = fg_ptr[bufferIndex++];
				color.red = fg_ptr[bufferIndex++];
				color.alpha = 255;
				span[spanIndex] = color;
				spanIndex++;
				spanInterpolator.Next();
			} while (--len != 0);
		}
	};

	//==========================================span_image_filter_rgb_bilinear
	public class span_image_filter_rgb_bilinear : span_image_filter
	{
		private const int base_shift = 8;
		private const int base_scale = (int)(1 << base_shift);
		private const int base_mask = base_scale - 1;

		//--------------------------------------------------------------------
		public span_image_filter_rgb_bilinear(IImageBufferAccessor src,
											ISpanInterpolator inter)
			: base(src, inter, null)
		{
			if (src.SourceImage.GetBytesBetweenPixelsInclusive() != 3)
			{
				throw new System.NotSupportedException("span_image_filter_rgb must have a 24 bit DestImage");
			}
		}

		public override void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

			ImageBuffer SourceRenderingBuffer = (ImageBuffer)base.GetImageBufferAccessor().SourceImage;
			ISpanInterpolator spanInterpolator = base.interpolator();
			int bufferIndex;
			byte[] fg_ptr = SourceRenderingBuffer.GetBuffer(out bufferIndex);

			unchecked
			{
				do
				{
					int tempR;
					int tempG;
					int tempB;

					int x_hr;
					int y_hr;

					spanInterpolator.coordinates(out x_hr, out y_hr);

					x_hr -= base.filter_dx_int();
					y_hr -= base.filter_dy_int();

					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
					int weight;

					tempR =
					tempG =
					tempB = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;

					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;
					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;

					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *
							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
					bufferIndex += 3;

					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

					y_lr++;
					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);
					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
					bufferIndex += 3;

					weight = (x_hr * y_hr);
					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;

					Color color;
					color.red = (byte)tempR;
					color.green = (byte)tempG;
					color.blue = (byte)tempB;
					color.alpha = 255;
					span[spanIndex] = color;
					spanIndex++;
					spanInterpolator.Next();
				} while (--len != 0);
			}
		}

		private void BlendInFilterPixel(int[] fg, ref int src_alpha, int back_r, int back_g, int back_b, int back_a, ImageBuffer SourceRenderingBuffer, int maxx, int maxy, int x_lr, int y_lr, int weight)
		{
			throw new NotImplementedException(); /*
            int[] fg_ptr;
            int bufferIndex;
            unchecked
            {
                if ((uint)x_lr <= (uint)maxx && (uint)y_lr <= (uint)maxy)
                {
                    fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr, y_lr, out bufferIndex);

                    fg[0] += (weight * (fg_ptr[bufferIndex] & (int)RGBA_Bytes.m_R) >> (int)RGBA_Bytes.Shift.R);
                    fg[1] += (weight * (fg_ptr[bufferIndex] & (int)RGBA_Bytes.m_G) >> (int)RGBA_Bytes.Shift.G);
                    fg[2] += (weight * (fg_ptr[bufferIndex] & (int)RGBA_Bytes.m_G) >> (int)RGBA_Bytes.Shift.B);
                    src_alpha += weight * base_mask;
                }
                else
                {
                    fg[0] += (weight * back_r);
                    fg[1] += (weight * back_g);
                    fg[2] += (weight * back_b);
                    src_alpha += back_a * weight;
                }
            }
                                                      */
		}
	};

	//=====================================span_image_filter_rgb_bilinear_clip
	public class span_image_filter_rgb_bilinear_clip : span_image_filter
	{
		private Color m_OutsideSourceColor;

		private const int base_shift = 8;
		private const int base_scale = (int)(1 << base_shift);
		private const int base_mask = base_scale - 1;

		//--------------------------------------------------------------------
		public span_image_filter_rgb_bilinear_clip(IImageBufferAccessor src,
											IColorType back_color,
											ISpanInterpolator inter)
			: base(src, inter, null)
		{
			m_OutsideSourceColor = back_color.ToColor();
		}

		public IColorType background_color()
		{
			return m_OutsideSourceColor;
		}

		public void background_color(IColorType v)
		{
			m_OutsideSourceColor = v.ToColor();
		}

		public override void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

			int[] accumulatedColor = new int[3];
			int sourceAlpha;

			int back_r = m_OutsideSourceColor.red;
			int back_g = m_OutsideSourceColor.green;
			int back_b = m_OutsideSourceColor.blue;
			int back_a = m_OutsideSourceColor.alpha;

			int bufferIndex;
			byte[] fg_ptr;

			ImageBuffer SourceRenderingBuffer = (ImageBuffer)base.GetImageBufferAccessor().SourceImage;
			int maxx = (int)SourceRenderingBuffer.Width - 1;
			int maxy = (int)SourceRenderingBuffer.Height - 1;
			ISpanInterpolator spanInterpolator = base.interpolator();

			unchecked
			{
				do
				{
					int x_hr;
					int y_hr;

					spanInterpolator.coordinates(out x_hr, out y_hr);

					x_hr -= base.filter_dx_int();
					y_hr -= base.filter_dy_int();

					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
					int weight;

					if (x_lr >= 0 && y_lr >= 0 &&
					   x_lr < maxx && y_lr < maxy)
					{
						accumulatedColor[0] =
						accumulatedColor[1] =
						accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;

						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;
						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;

						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr, y_lr, out bufferIndex);

						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *
								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

						bufferIndex += 3;
						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

						y_lr++;
						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr, y_lr, out bufferIndex);

						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);
						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

						bufferIndex += 3;
						weight = (x_hr * y_hr);
						accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
						accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
						accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;

						sourceAlpha = base_mask;
					}
					else
					{
						if (x_lr < -1 || y_lr < -1 ||
						   x_lr > maxx || y_lr > maxy)
						{
							accumulatedColor[0] = back_r;
							accumulatedColor[1] = back_g;
							accumulatedColor[2] = back_b;
							sourceAlpha = back_a;
						}
						else
						{
							accumulatedColor[0] =
							accumulatedColor[1] =
							accumulatedColor[2] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;
							sourceAlpha = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;

							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;
							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;

							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *
									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
							BlendInFilterPixel(accumulatedColor, ref sourceAlpha, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);

							x_lr++;

							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
							BlendInFilterPixel(accumulatedColor, ref sourceAlpha, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);

							x_lr--;
							y_lr++;

							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);
							BlendInFilterPixel(accumulatedColor, ref sourceAlpha, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);

							x_lr++;

							weight = (x_hr * y_hr);
							BlendInFilterPixel(accumulatedColor, ref sourceAlpha, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);

							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
							sourceAlpha >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
						}
					}

					span[spanIndex].red = (byte)accumulatedColor[0];
					span[spanIndex].green = (byte)accumulatedColor[1];
					span[spanIndex].blue = (byte)accumulatedColor[2];
					span[spanIndex].alpha = (byte)sourceAlpha;
					spanIndex++;
					spanInterpolator.Next();
				} while (--len != 0);
			}
		}

		private void BlendInFilterPixel(int[] accumulatedColor, ref int sourceAlpha, int back_r, int back_g, int back_b, int back_a, ImageBuffer SourceRenderingBuffer, int maxx, int maxy, int x_lr, int y_lr, int weight)
		{
			byte[] fg_ptr;
			unchecked
			{
				if ((uint)x_lr <= (uint)maxx && (uint)y_lr <= (uint)maxy)
				{
					int bufferIndex;
					fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr, y_lr, out bufferIndex);

					accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
					accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
					accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
					sourceAlpha += weight * base_mask;
				}
				else
				{
					accumulatedColor[0] += back_r * weight;
					accumulatedColor[1] += back_g * weight;
					accumulatedColor[2] += back_b * weight;
					sourceAlpha += back_a * weight;
				}
			}
		}
	};

	//===================================================span_image_filter_rgb
	public class span_image_filter_rgb : span_image_filter
	{
		private const int base_mask = 255;

		//--------------------------------------------------------------------
		public span_image_filter_rgb(IImageBufferAccessor src, ISpanInterpolator inter, ImageFilterLookUpTable filter)
			: base(src, inter, filter)
		{
			if (src.SourceImage.GetBytesBetweenPixelsInclusive() != 3)
			{
				throw new System.NotSupportedException("span_image_filter_rgb must have a 24 bit DestImage");
			}
		}

		public override void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

			int f_r, f_g, f_b;

			byte[] fg_ptr;

			int diameter = m_filter.diameter();
			int start = m_filter.start();
			int[] weight_array = m_filter.weight_array();

			int x_count;
			int weight_y;

			ISpanInterpolator spanInterpolator = base.interpolator();

			do
			{
				spanInterpolator.coordinates(out x, out y);

				x -= base.filter_dx_int();
				y -= base.filter_dy_int();

				int x_hr = x;
				int y_hr = y;

				int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
				int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;

				f_b = f_g = f_r = (int)image_filter_scale_e.image_filter_scale / 2;

				int x_fract = x_hr & (int)image_subpixel_scale_e.image_subpixel_mask;
				int y_count = diameter;

				y_hr = (int)image_subpixel_scale_e.image_subpixel_mask - (y_hr & (int)image_subpixel_scale_e.image_subpixel_mask);

				int bufferIndex;
				fg_ptr = GetImageBufferAccessor().span(x_lr + start, y_lr + start, diameter, out bufferIndex);
				for (; ; )
				{
					x_count = (int)diameter;
					weight_y = weight_array[y_hr];
					x_hr = (int)image_subpixel_scale_e.image_subpixel_mask - x_fract;
					for (; ; )
					{
						int weight = (weight_y * weight_array[x_hr] +
									 (int)image_filter_scale_e.image_filter_scale / 2) >>
									 (int)image_filter_scale_e.image_filter_shift;

						f_b += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
						f_g += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
						f_r += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

						if (--x_count == 0) break;
						x_hr += (int)image_subpixel_scale_e.image_subpixel_scale;
						GetImageBufferAccessor().next_x(out bufferIndex);
					}

					if (--y_count == 0) break;
					y_hr += (int)image_subpixel_scale_e.image_subpixel_scale;
					fg_ptr = GetImageBufferAccessor().next_y(out bufferIndex);
				}

				f_b >>= (int)image_filter_scale_e.image_filter_shift;
				f_g >>= (int)image_filter_scale_e.image_filter_shift;
				f_r >>= (int)image_filter_scale_e.image_filter_shift;

				unchecked
				{
					if ((uint)f_b > base_mask)
					{
						if (f_b < 0) f_b = 0;
						if (f_b > base_mask) f_b = (int)base_mask;
					}

					if ((uint)f_g > base_mask)
					{
						if (f_g < 0) f_g = 0;
						if (f_g > base_mask) f_g = (int)base_mask;
					}

					if ((uint)f_r > base_mask)
					{
						if (f_r < 0) f_r = 0;
						if (f_r > base_mask) f_r = (int)base_mask;
					}
				}

				span[spanIndex].alpha = (byte)base_mask;
				span[spanIndex].red = (byte)f_b;
				span[spanIndex].green = (byte)f_g;
				span[spanIndex].blue = (byte)f_r;

				spanIndex++;
				spanInterpolator.Next();
			} while (--len != 0);
		}
	};

	//===============================================span_image_filter_rgb_2x2
	public class span_image_filter_rgb_2x2 : span_image_filter
	{
		private const int base_mask = 255;

		//--------------------------------------------------------------------
		public span_image_filter_rgb_2x2(IImageBufferAccessor src, ISpanInterpolator inter, ImageFilterLookUpTable filter)
			: base(src, inter, filter)
		{
		}

		public override void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			throw new NotImplementedException(); /*
            ISpanInterpolator spanInterpolator = base.interpolator();
            spanInterpolator.begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

            int[] fg = new int[3];

            int[] fg_ptr;
            int bufferIndex;
            int[] weight_array = filter().weight_array();
            int weightArrayIndex = ((filter().diameter() / 2 - 1) << (int)image_subpixel_scale_e.image_subpixel_shift);

            do
            {
                int x_hr;
                int y_hr;

                spanInterpolator.coordinates(out x_hr, out y_hr);

                x_hr -= filter_dx_int();
                y_hr -= filter_dy_int();

                int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
                int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;

                int weight;
                fg[0] = fg[1] = fg[2] = (int)image_filter_scale_e.image_filter_scale / 2;

                x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;
                y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;

                fg_ptr = source().span(x_lr, y_lr, 2, out bufferIndex);
                weight = ((weight_array[x_hr + (int)image_subpixel_scale_e.image_subpixel_scale] *
                          weight_array[y_hr + (int)image_subpixel_scale_e.image_subpixel_scale] +
                          (int)image_filter_scale_e.image_filter_scale / 2) >>
                          (int)image_filter_scale_e.image_filter_shift);
                fg[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                fg[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                fg[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                fg_ptr = source().next_x(out bufferIndex);
                weight = ((weight_array[x_hr] *
                          weight_array[y_hr + (int)image_subpixel_scale_e.image_subpixel_scale] +
                          (int)image_filter_scale_e.image_filter_scale / 2) >>
                          (int)image_filter_scale_e.image_filter_shift);
                fg[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                fg[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                fg[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                fg_ptr = source().next_y(out bufferIndex);
                weight = ((weight_array[x_hr + (int)image_subpixel_scale_e.image_subpixel_scale] *
                          weight_array[y_hr] +
                          (int)image_filter_scale_e.image_filter_scale / 2) >>
                          (int)image_filter_scale_e.image_filter_shift);
                fg[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                fg[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                fg[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                fg_ptr = source().next_x(out bufferIndex);
                weight = ((weight_array[x_hr] *
                          weight_array[y_hr] +
                          (int)image_filter_scale_e.image_filter_scale / 2) >>
                          (int)image_filter_scale_e.image_filter_shift);
                fg[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                fg[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                fg[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                fg[0] >>= (int)image_filter_scale_e.image_filter_shift;
                fg[1] >>= (int)image_filter_scale_e.image_filter_shift;
                fg[2] >>= (int)image_filter_scale_e.image_filter_shift;

                if (fg[0] > base_mask) fg[0] = (int)base_mask;
                if (fg[1] > base_mask) fg[1] = (int)base_mask;
                if (fg[2] > base_mask) fg[2] = (int)base_mask;

                span[spanIndex].m_ARGBData = base_mask << (int)RGBA_Bytes.Shift.A | fg[0] << (int)RGBA_Bytes.Shift.R | fg[1] << (int)RGBA_Bytes.Shift.G | fg[2] << (int)RGBA_Bytes.Shift.B;

                spanIndex++;
                spanInterpolator.Next();
            } while (--len != 0);
                                                      */
		}
	};

	/*
	//==========================================span_image_resample_rgb_affine
	template<class Source>
	class span_image_resample_rgb_affine :
	public span_image_resample_affine<Source>
	{
	public:
		typedef Source source_type;
		typedef typename source_type::color_type color_type;
		typedef typename source_type::order_type order_type;
		typedef span_image_resample_affine<source_type> base_type;
		typedef typename base_type::interpolator_type interpolator_type;
		typedef typename color_type::value_type value_type;
		typedef typename color_type::long_type long_type;
		enum base_scale_e
		{
			base_shift      = 8,//color_type::base_shift,
			base_mask       = 255,//color_type::base_mask,
			downscale_shift = image_filter_shift
		};

		//--------------------------------------------------------------------
		span_image_resample_rgb_affine() {}
		span_image_resample_rgb_affine(source_type& src,
									   interpolator_type& inter,
									   const ImageFilterLookUpTable& filter) :
			base(src, inter, filter)
		{}

		//--------------------------------------------------------------------
		void generate(color_type* span, int x, int y, unsigned len)
		{
			base_type::interpolator().begin(x + base_type::filter_dx_dbl(),
											y + base_type::filter_dy_dbl(), len);

			long_type fg[3];

			int diameter     = base_type::filter().diameter();
			int filter_scale = diameter << image_subpixel_shift;
			int radius_x     = (diameter * base_type::m_rx) >> 1;
			int radius_y     = (diameter * base_type::m_ry) >> 1;
			int len_x_lr     =
				(diameter * base_type::m_rx + image_subpixel_mask) >>
					image_subpixel_shift;

			const int16* weight_array = base_type::filter().weight_array();

			do
			{
				base_type::interpolator().coordinates(&x, &y);

				x += base_type::filter_dx_int() - radius_x;
				y += base_type::filter_dy_int() - radius_y;

				fg[0] = fg[1] = fg[2] = image_filter_scale / 2;

				int y_lr = y >> image_subpixel_shift;
				int y_hr = ((image_subpixel_mask - (y & image_subpixel_mask)) *
								base_type::m_ry_inv) >>
									image_subpixel_shift;
				int total_weight = 0;
				int x_lr = x >> image_subpixel_shift;
				int x_hr = ((image_subpixel_mask - (x & image_subpixel_mask)) *
								base_type::m_rx_inv) >>
									image_subpixel_shift;

				int x_hr2 = x_hr;
				const value_type* fg_ptr =
					source().pix_ptr(x_lr, y_lr, len_x_lr);
				for(;;)
				{
					int weight_y = weight_array[y_hr];
					x_hr = x_hr2;
					for(;;)
					{
						int weight = (weight_y * weight_array[x_hr] +
									 image_filter_scale / 2) >>
									 downscale_shift;

						fg[0] += *fg_ptr++ * weight;
						fg[1] += *fg_ptr++ * weight;
						fg[2] += *fg_ptr   * weight;
						total_weight += weight;
						x_hr  += base_type::m_rx_inv;
						if(x_hr >= filter_scale) break;
						fg_ptr = SourceRenderingBuffer.next_x();
					}
					y_hr += base_type::m_ry_inv;
					if(y_hr >= filter_scale) break;
					fg_ptr = SourceRenderingBuffer.next_y();
				}

				fg[0] /= total_weight;
				fg[1] /= total_weight;
				fg[2] /= total_weight;

				if(fg[0] < 0) fg[0] = 0;
				if(fg[1] < 0) fg[1] = 0;
				if(fg[2] < 0) fg[2] = 0;

				if(fg[order_type::R] > base_mask) fg[order_type::R] = base_mask;
				if(fg[order_type::G] > base_mask) fg[order_type::G] = base_mask;
				if(fg[order_type::B] > base_mask) fg[order_type::B] = base_mask;

				span->r = (value_type)fg[order_type::R];
				span->g = (value_type)fg[order_type::G];
				span->b = (value_type)fg[order_type::B];
				span->a = base_mask;

				span++;
				++base_type::interpolator();
			} while(--len);
		}
	};
	 */

	//=================================================span_image_resample_rgb
	public class span_image_resample_rgb
		: span_image_resample
	{
		private const int base_mask = 255;
		private const int downscale_shift = (int)ImageFilterLookUpTable.image_filter_scale_e.image_filter_shift;

		//--------------------------------------------------------------------
		public span_image_resample_rgb(IImageBufferAccessor src,
							ISpanInterpolator inter,
							ImageFilterLookUpTable filter) :
			base(src, inter, filter)
		{
			if (src.SourceImage.GetRecieveBlender().NumPixelBits != 24)
			{
				throw new System.FormatException("You have to use a rgb blender with span_image_resample_rgb");
			}
		}

		public override void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			ISpanInterpolator spanInterpolator = base.interpolator();
			spanInterpolator.begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

			int[] fg = new int[3];

			byte[] fg_ptr;
			int[] weightArray = filter().weight_array();
			int diameter = (int)base.filter().diameter();
			int filter_scale = diameter << (int)image_subpixel_scale_e.image_subpixel_shift;

			int[] weight_array = weightArray;

			do
			{
				int rx;
				int ry;
				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;
				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;
				spanInterpolator.coordinates(out x, out y);
				spanInterpolator.local_scale(out rx, out ry);
				base.adjust_scale(ref rx, ref ry);

				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;
				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;

				int radius_x = (diameter * rx) >> 1;
				int radius_y = (diameter * ry) >> 1;
				int len_x_lr =
					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>
						(int)(int)image_subpixel_scale_e.image_subpixel_shift;

				x += base.filter_dx_int() - radius_x;
				y += base.filter_dy_int() - radius_y;

				fg[0] = fg[1] = fg[2] = (int)image_filter_scale_e.image_filter_scale / 2;

				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;
				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *
							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;
				int total_weight = 0;
				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;
				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *
							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;
				int x_hr2 = x_hr;
				int sourceIndex;
				fg_ptr = base.GetImageBufferAccessor().span(x_lr, y_lr, len_x_lr, out sourceIndex);

				for (; ; )
				{
					int weight_y = weight_array[y_hr];
					x_hr = x_hr2;
					for (; ; )
					{
						int weight = (weight_y * weight_array[x_hr] +
									 (int)image_filter_scale_e.image_filter_scale / 2) >>
									 downscale_shift;
						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;
						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;
						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;
						total_weight += weight;
						x_hr += rx_inv;
						if (x_hr >= filter_scale) break;
						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);
					}
					y_hr += ry_inv;
					if (y_hr >= filter_scale)
					{
						break;
					}

					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);
				}

				fg[0] /= total_weight;
				fg[1] /= total_weight;
				fg[2] /= total_weight;

				if (fg[0] < 0) fg[0] = 0;
				if (fg[1] < 0) fg[1] = 0;
				if (fg[2] < 0) fg[2] = 0;

				if (fg[0] > base_mask) fg[0] = base_mask;
				if (fg[1] > base_mask) fg[1] = base_mask;
				if (fg[2] > base_mask) fg[2] = base_mask;

				span[spanIndex].alpha = base_mask;
				span[spanIndex].red = (byte)fg[0];
				span[spanIndex].green = (byte)fg[1];
				span[spanIndex].blue = (byte)fg[2];

				spanIndex++;
				interpolator().Next();
			} while (--len != 0);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Spans\agg_span_image_filter_rgba.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
#define USE_UNSAFE_CODE

using MatterHackers.Agg.Image;
using MatterHackers.VectorMath;
using System;
using image_filter_scale_e = MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e;
using image_subpixel_scale_e = MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e;

namespace MatterHackers.Agg
{
	// it should be easy to write a 90 rotating or mirroring filter too. LBB 2012/01/14
	public class span_image_filter_rgba_nn_stepXby1 : span_image_filter
	{
		private const int base_shift = 8;
		private const int base_scale = (int)(1 << base_shift);
		private const int base_mask = base_scale - 1;

		public span_image_filter_rgba_nn_stepXby1(IImageBufferAccessor sourceAccessor, ISpanInterpolator spanInterpolator)
			: base(sourceAccessor, spanInterpolator, null)
		{
		}

		public override void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			ImageBuffer SourceRenderingBuffer = (ImageBuffer)GetImageBufferAccessor().SourceImage;
			if (SourceRenderingBuffer.BitDepth != 32)
			{
				throw new NotSupportedException("The source is expected to be 32 bit.");
			}
			ISpanInterpolator spanInterpolator = interpolator();
			spanInterpolator.begin(x + filter_dx_dbl(), y + filter_dy_dbl(), len);
			int x_hr;
			int y_hr;
			spanInterpolator.coordinates(out x_hr, out y_hr);
			int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
			int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
			int bufferIndex;
			bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

			byte[] fg_ptr = SourceRenderingBuffer.GetBuffer();
#if USE_UNSAFE_CODE
			unsafe
			{
				fixed (byte* pSource = fg_ptr)
				{
					do
					{
						span[spanIndex++] = *(Color*)&(pSource[bufferIndex]);
						bufferIndex += 4;
					} while (--len != 0);
				}
			}
#else
            RGBA_Bytes color = new RGBA_Bytes();
            do
            {
                color.blue = fg_ptr[bufferIndex++];
                color.green = fg_ptr[bufferIndex++];
                color.red = fg_ptr[bufferIndex++];
                color.alpha = fg_ptr[bufferIndex++];
                span[spanIndex++] = color;
            } while (--len != 0);
#endif
		}
	}

	//==============================================span_image_filter_rgba_nn
	public class span_image_filter_rgba_nn : span_image_filter
	{
		private const int baseShift = 8;
		private const int baseScale = (int)(1 << baseShift);
		private const int baseMask = baseScale - 1;

		public span_image_filter_rgba_nn(IImageBufferAccessor sourceAccessor, ISpanInterpolator spanInterpolator)
			: base(sourceAccessor, spanInterpolator, null)
		{
		}

		public override void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			ImageBuffer SourceRenderingBuffer = (ImageBuffer)GetImageBufferAccessor().SourceImage;
			if (SourceRenderingBuffer.BitDepth != 32)
			{
				throw new NotSupportedException("The source is expected to be 32 bit.");
			}
			ISpanInterpolator spanInterpolator = interpolator();
			spanInterpolator.begin(x + filter_dx_dbl(), y + filter_dy_dbl(), len);
			byte[] fg_ptr = SourceRenderingBuffer.GetBuffer();
			do
			{
				int x_hr;
				int y_hr;
				spanInterpolator.coordinates(out x_hr, out y_hr);
				int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
				int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
				int bufferIndex;
				bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);
				Color color;
				color.blue = fg_ptr[bufferIndex++];
				color.green = fg_ptr[bufferIndex++];
				color.red = fg_ptr[bufferIndex++];
				color.alpha = fg_ptr[bufferIndex++];
				span[spanIndex] = color;
				spanIndex++;
				spanInterpolator.Next();
			} while (--len != 0);
		}
	};

	public class span_image_filter_rgba_bilinear : span_image_filter
	{
		private const int base_shift = 8;
		private const int base_scale = (int)(1 << base_shift);
		private const int base_mask = base_scale - 1;

		public span_image_filter_rgba_bilinear(IImageBufferAccessor src, ISpanInterpolator inter)
			: base(src, inter, null)
		{
		}

#if false
            public void generate(out RGBA_Bytes destPixel, int x, int y)
            {
                base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), 1);

                int* fg = stackalloc int[4];

                byte* fg_ptr;

                IImage imageSource = base.source().DestImage;
                int maxx = (int)imageSource.Width() - 1;
                int maxy = (int)imageSource.Height() - 1;
                ISpanInterpolator spanInterpolator = base.interpolator();

                unchecked
                {
                    int x_hr;
                    int y_hr;

                    spanInterpolator.coordinates(out x_hr, out y_hr);

                    x_hr -= base.filter_dx_int();
                    y_hr -= base.filter_dy_int();

                    int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
                    int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;

                    int weight;

                    fg[0] = fg[1] = fg[2] = fg[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;

                    x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;
                    y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;

                    fg_ptr = imageSource.GetPixelPointerY(y_lr) + (x_lr * 4);

                    weight = (int)(((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *
                             ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
                    fg[0] += weight * fg_ptr[0];
                    fg[1] += weight * fg_ptr[1];
                    fg[2] += weight * fg_ptr[2];
                    fg[3] += weight * fg_ptr[3];

                    weight = (int)(x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
                    fg[0] += weight * fg_ptr[4];
                    fg[1] += weight * fg_ptr[5];
                    fg[2] += weight * fg_ptr[6];
                    fg[3] += weight * fg_ptr[7];

                    ++y_lr;
                    fg_ptr = imageSource.GetPixelPointerY(y_lr) + (x_lr * 4);

                    weight = (int)(((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);
                    fg[0] += weight * fg_ptr[0];
                    fg[1] += weight * fg_ptr[1];
                    fg[2] += weight * fg_ptr[2];
                    fg[3] += weight * fg_ptr[3];

                    weight = (int)(x_hr * y_hr);
                    fg[0] += weight * fg_ptr[4];
                    fg[1] += weight * fg_ptr[5];
                    fg[2] += weight * fg_ptr[6];
                    fg[3] += weight * fg_ptr[7];

                    fg[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
                    fg[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
                    fg[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
                    fg[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;

                    destPixel.m_R = (byte)fg[OrderR];
                    destPixel.m_G = (byte)fg[OrderG];
                    destPixel.m_B = (byte)fg[ImageBuffer.OrderB];
                    destPixel.m_A = (byte)fg[OrderA];
                }
            }
#endif

		public override void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

			ImageBuffer SourceRenderingBuffer = (ImageBuffer)base.GetImageBufferAccessor().SourceImage;
			ISpanInterpolator spanInterpolator = base.interpolator();
			int bufferIndex;
			byte[] fg_ptr = SourceRenderingBuffer.GetBuffer(out bufferIndex);

			unchecked
			{
				do
				{
					int tempR;
					int tempG;
					int tempB;
					int tempA;

					int x_hr;
					int y_hr;

					spanInterpolator.coordinates(out x_hr, out y_hr);

					x_hr -= base.filter_dx_int();
					y_hr -= base.filter_dy_int();

					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
					int weight;

					tempR =
					tempG =
					tempB =
					tempA = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;

					x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;
					y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;

					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *
							 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
					bufferIndex += 4;

					weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];

					y_lr++;
					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

					weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);
					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
					bufferIndex += 4;

					weight = (x_hr * y_hr);
					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];

					tempR >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
					tempG >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
					tempB >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
					tempA >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;

					Color color;
					color.red = (byte)tempR;
					color.green = (byte)tempG;
					color.blue = (byte)tempB;
					color.alpha = (byte)255;// tempA;
					span[spanIndex] = color;
					spanIndex++;
					spanInterpolator.Next();
				} while (--len != 0);
			}
		}
	}

	public class span_image_filter_rgba_bilinear_float : span_image_filter_float
	{
		public span_image_filter_rgba_bilinear_float(IImageBufferAccessorFloat src, ISpanInterpolatorFloat inter)
			: base(src, inter, null)
		{
		}

		public override void generate(ColorF[] span, int spanIndex, int x, int y, int len)
		{
			base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

			ImageBufferFloat SourceRenderingBuffer = (ImageBufferFloat)base.source().SourceImage;
			ISpanInterpolatorFloat spanInterpolator = base.interpolator();
			int bufferIndex;
			float[] fg_ptr = SourceRenderingBuffer.GetBuffer(out bufferIndex);

			unchecked
			{
				do
				{
					float tempR;
					float tempG;
					float tempB;
					float tempA;

					float x_hr;
					float y_hr;

					spanInterpolator.coordinates(out x_hr, out y_hr);

					x_hr -= base.filter_dx_dbl();
					y_hr -= base.filter_dy_dbl();

					int x_lr = (int)x_hr;
					int y_lr = (int)y_hr;
					float weight;

					tempR = tempG = tempB = tempA = 0;

					x_hr -= x_lr;
					y_hr -= y_lr;

					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

#if false
                    unsafe
                    {
                        fixed (float* pSource = fg_ptr)
                        {
                            Vector4f tempFinal = new Vector4f(0.0f, 0.0f, 0.0f, 0.0f);

                            Vector4f color0 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 0]);
                            weight = (1.0f - x_hr) * (1.0f - y_hr);
                            Vector4f weight4f = new Vector4f(weight, weight, weight, weight);
                            tempFinal = tempFinal + weight4f * color0;

                            Vector4f color1 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 4]);
                            weight = (x_hr) * (1.0f - y_hr);
                            weight4f = new Vector4f(weight, weight, weight, weight);
                            tempFinal = tempFinal + weight4f * color1;

                            y_lr++;
                            bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

                            Vector4f color2 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 0]);
                            weight = (1.0f - x_hr) * (y_hr);
                            weight4f = new Vector4f(weight, weight, weight, weight);
                            tempFinal = tempFinal + weight4f * color2;

                            Vector4f color3 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 4]);
                            weight = (x_hr) * (y_hr);
                            weight4f = new Vector4f(weight, weight, weight, weight);
                            tempFinal = tempFinal + weight4f * color3;

                            RGBA_Floats color;
                            color.m_B = tempFinal.X;
                            color.m_G = tempFinal.Y;
                            color.m_R = tempFinal.Z;
                            color.m_A = tempFinal.W;
                            span[spanIndex] = color;
                        }
                    }
#else
					weight = (1.0f - x_hr) * (1.0f - y_hr);
					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
					bufferIndex += 4;

					weight = (x_hr) * (1.0f - y_hr);
					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];

					y_lr++;
					bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

					weight = (1.0f - x_hr) * (y_hr);
					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
					bufferIndex += 4;

					weight = (x_hr) * (y_hr);
					tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
					tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
					tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
					tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];

					ColorF color;
					color.red = tempR;
					color.green = tempG;
					color.blue = tempB;
					color.alpha = tempA;
					span[spanIndex] = color;
#endif
					spanIndex++;
					spanInterpolator.Next();
				} while (--len != 0);
			}
		}
	};

	//====================================span_image_filter_rgba_bilinear_clip
	public class span_image_filter_rgba_bilinear_clip : span_image_filter
	{
		private Color m_OutsideSourceColor;

		private const int base_shift = 8;
		private const int base_scale = (int)(1 << base_shift);
		private const int base_mask = base_scale - 1;

		public span_image_filter_rgba_bilinear_clip(IImageBufferAccessor src,
			IColorType back_color, ISpanInterpolator inter)
			: base(src, inter, null)
		{
			m_OutsideSourceColor = back_color.ToColor();
		}

		public IColorType background_color()
		{
			return m_OutsideSourceColor;
		}

		public void background_color(IColorType v)
		{
			m_OutsideSourceColor = v.ToColor();
		}

		public override void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			ImageBuffer SourceRenderingBuffer = (ImageBuffer)base.GetImageBufferAccessor().SourceImage;
			int bufferIndex;
			byte[] fg_ptr;

			if (base.m_interpolator.GetType() == typeof(MatterHackers.Agg.span_interpolator_linear)
				&& ((MatterHackers.Agg.span_interpolator_linear)base.m_interpolator).transformer().GetType() == typeof(MatterHackers.Agg.Transform.Affine)
			&& ((MatterHackers.Agg.Transform.Affine)((MatterHackers.Agg.span_interpolator_linear)base.m_interpolator).transformer()).is_identity())
			{
				fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x, y, out bufferIndex);
				//unsafe
				{
#if true
					do
					{
						span[spanIndex].blue = (byte)fg_ptr[bufferIndex++];
						span[spanIndex].green = (byte)fg_ptr[bufferIndex++];
						span[spanIndex].red = (byte)fg_ptr[bufferIndex++];
						span[spanIndex].alpha = (byte)fg_ptr[bufferIndex++];
						++spanIndex;
					} while (--len != 0);
#else
                        fixed (byte* pSource = &fg_ptr[bufferIndex])
                        {
                            int* pSourceInt = (int*)pSource;
                            fixed (RGBA_Bytes* pDest = &span[spanIndex])
                            {
                                int* pDestInt = (int*)pDest;
                                do
                                {
                                    *pDestInt++ = *pSourceInt++;
                                } while (--len != 0);
                            }
                        }
#endif
				}

				return;
			}

			base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

			int[] accumulatedColor = new int[4];

			int back_r = m_OutsideSourceColor.red;
			int back_g = m_OutsideSourceColor.green;
			int back_b = m_OutsideSourceColor.blue;
			int back_a = m_OutsideSourceColor.alpha;

			int distanceBetweenPixelsInclusive = base.GetImageBufferAccessor().SourceImage.GetBytesBetweenPixelsInclusive();
			int maxx = (int)SourceRenderingBuffer.Width - 1;
			int maxy = (int)SourceRenderingBuffer.Height - 1;
			ISpanInterpolator spanInterpolator = base.interpolator();

			unchecked
			{
				do
				{
					int x_hr;
					int y_hr;

					spanInterpolator.coordinates(out x_hr, out y_hr);

					x_hr -= base.filter_dx_int();
					y_hr -= base.filter_dy_int();

					int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
					int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
					int weight;

					if (x_lr >= 0 && y_lr >= 0 &&
					   x_lr < maxx && y_lr < maxy)
					{
						accumulatedColor[0] =
						accumulatedColor[1] =
						accumulatedColor[2] =
						accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;

						x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;
						y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;

						fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr, y_lr, out bufferIndex);

						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *
								 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
						if (weight > base_mask)
						{
							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
						}

						weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
						if (weight > base_mask)
						{
							bufferIndex += distanceBetweenPixelsInclusive;
							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
						}

						weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);
						if (weight > base_mask)
						{
							++y_lr;
							fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr, y_lr, out bufferIndex);
							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
						}
						weight = (x_hr * y_hr);
						if (weight > base_mask)
						{
							bufferIndex += distanceBetweenPixelsInclusive;
							accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
							accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
							accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
							accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
						}
						accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
						accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
						accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
						accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
					}
					else
					{
						if (x_lr < -1 || y_lr < -1 ||
						   x_lr > maxx || y_lr > maxy)
						{
							accumulatedColor[0] = back_r;
							accumulatedColor[1] = back_g;
							accumulatedColor[2] = back_b;
							accumulatedColor[3] = back_a;
						}
						else
						{
							accumulatedColor[0] =
							accumulatedColor[1] =
							accumulatedColor[2] =
							accumulatedColor[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;

							x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;
							y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;

							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *
									 ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
							if (weight > base_mask)
							{
								BlendInFilterPixel(accumulatedColor, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);
							}

							x_lr++;

							weight = (x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
							if (weight > base_mask)
							{
								BlendInFilterPixel(accumulatedColor, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);
							}

							x_lr--;
							y_lr++;

							weight = (((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);
							if (weight > base_mask)
							{
								BlendInFilterPixel(accumulatedColor, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);
							}

							x_lr++;

							weight = (x_hr * y_hr);
							if (weight > base_mask)
							{
								BlendInFilterPixel(accumulatedColor, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);
							}

							accumulatedColor[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
							accumulatedColor[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
							accumulatedColor[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
							accumulatedColor[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
						}
					}

					span[spanIndex].red = (byte)accumulatedColor[0];
					span[spanIndex].green = (byte)accumulatedColor[1];
					span[spanIndex].blue = (byte)accumulatedColor[2];
					span[spanIndex].alpha = (byte)accumulatedColor[3];
					++spanIndex;
					spanInterpolator.Next();
				} while (--len != 0);
			}
		}

		private void BlendInFilterPixel(int[] accumulatedColor, int back_r, int back_g, int back_b, int back_a, IImageByte SourceRenderingBuffer, int maxx, int maxy, int x_lr, int y_lr, int weight)
		{
			byte[] fg_ptr;
			unchecked
			{
				if ((uint)x_lr <= (uint)maxx && (uint)y_lr <= (uint)maxy)
				{
					int bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);
					fg_ptr = SourceRenderingBuffer.GetBuffer();

					accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
					accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
					accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
					accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
				}
				else
				{
					accumulatedColor[0] += back_r * weight;
					accumulatedColor[1] += back_g * weight;
					accumulatedColor[2] += back_b * weight;
					accumulatedColor[3] += back_a * weight;
				}
			}
		}
	};

	/*

	//==============================================span_image_filter_rgba_2x2
	//template<class Source, class Interpolator>
	public class span_image_filter_rgba_2x2 : span_image_filter//<Source, Interpolator>
	{
		//typedef Source source_type;
		//typedef typename source_type::color_type color_type;
		//typedef typename source_type::order_type order_type;
		//typedef Interpolator interpolator_type;
		//typedef span_image_filter<source_type, interpolator_type> base_type;
		//typedef typename color_type::value_type value_type;
		//typedef typename color_type::calc_type calc_type;
		enum base_scale_e
		{
			base_shift = 8, //color_type::base_shift,
			base_mask  = 255,//color_type::base_mask
		};

		//--------------------------------------------------------------------
		public span_image_filter_rgba_2x2() {}
		public span_image_filter_rgba_2x2(pixfmt_alpha_blend_bgra32 src,
								   interpolator_type inter,
								   ImageFilterLookUpTable filter) :
			base(src, inter, filter)
		{}

		//--------------------------------------------------------------------
		public void generate(color_type* span, int x, int y, unsigned len)
		{
			base.interpolator().begin(x + base.filter_dx_dbl(),
											y + base.filter_dy_dbl(), len);

			calc_type fg[4];

			byte *fg_ptr;
			int16* weight_array = base.filter().weight_array() +
										((base.filter().diameter()/2 - 1) <<
										  image_subpixel_shift);

			do
			{
				int x_hr;
				int y_hr;

				base.interpolator().coordinates(&x_hr, &y_hr);

				x_hr -= base.filter_dx_int();
				y_hr -= base.filter_dy_int();

				int x_lr = x_hr >> image_subpixel_shift;
				int y_lr = y_hr >> image_subpixel_shift;

				unsigned weight;
				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;

				x_hr &= image_subpixel_mask;
				y_hr &= image_subpixel_mask;

				fg_ptr = base.source().span(x_lr, y_lr, 2);
				weight = (weight_array[x_hr + image_subpixel_scale] *
						  weight_array[y_hr + image_subpixel_scale] +
						  (int)image_filter_scale_e.image_filter_scale / 2) >>
						  image_filter_shift;
				fg[0] += weight * *fg_ptr++;
				fg[1] += weight * *fg_ptr++;
				fg[2] += weight * *fg_ptr++;
				fg[3] += weight * *fg_ptr;

				fg_ptr = base.source().next_x();
				weight = (weight_array[x_hr] *
						  weight_array[y_hr + image_subpixel_scale] +
						  (int)image_filter_scale_e.image_filter_scale / 2) >>
						  image_filter_shift;
				fg[0] += weight * *fg_ptr++;
				fg[1] += weight * *fg_ptr++;
				fg[2] += weight * *fg_ptr++;
				fg[3] += weight * *fg_ptr;

				fg_ptr = base.source().next_y();
				weight = (weight_array[x_hr + image_subpixel_scale] *
						  weight_array[y_hr] +
						  (int)image_filter_scale_e.image_filter_scale / 2) >>
						  image_filter_shift;
				fg[0] += weight * *fg_ptr++;
				fg[1] += weight * *fg_ptr++;
				fg[2] += weight * *fg_ptr++;
				fg[3] += weight * *fg_ptr;

				fg_ptr = base.source().next_x();
				weight = (weight_array[x_hr] *
						  weight_array[y_hr] +
						  (int)image_filter_scale_e.image_filter_scale / 2) >>
						  image_filter_shift;
				fg[0] += weight * *fg_ptr++;
				fg[1] += weight * *fg_ptr++;
				fg[2] += weight * *fg_ptr++;
				fg[3] += weight * *fg_ptr;

				fg[0] >>= image_filter_shift;
				fg[1] >>= image_filter_shift;
				fg[2] >>= image_filter_shift;
				fg[3] >>= image_filter_shift;

				if(fg[ImageBuffer.OrderA] > base_mask)         fg[ImageBuffer.OrderA] = base_mask;
				if(fg[ImageBuffer.OrderR] > fg[ImageBuffer.OrderA]) fg[ImageBuffer.OrderR] = fg[ImageBuffer.OrderA];
				if(fg[ImageBuffer.OrderG] > fg[ImageBuffer.OrderA]) fg[ImageBuffer.OrderG] = fg[ImageBuffer.OrderA];
				if(fg[ImageBuffer.OrderB] > fg[ImageBuffer.OrderA]) fg[ImageBuffer.OrderB] = fg[ImageBuffer.OrderA];

				span->r = (byte)fg[ImageBuffer.OrderR];
				span->g = (byte)fg[ImageBuffer.OrderG];
				span->b = (byte)fg[ImageBuffer.OrderB];
				span->a = (byte)fg[ImageBuffer.OrderA];
				++span;
				++base.interpolator();
			} while(--len);
		}
	};
*/

	public class span_image_filter_rgba : span_image_filter
	{
		private const int base_mask = 255;

		//--------------------------------------------------------------------
		public span_image_filter_rgba(IImageBufferAccessor src, ISpanInterpolator inter, ImageFilterLookUpTable filter)
			: base(src, inter, filter)
		{
			if (src.SourceImage.GetBytesBetweenPixelsInclusive() != 4)
			{
				throw new System.NotSupportedException("span_image_filter_rgba must have a 32 bit DestImage");
			}
		}

		public override void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

			int f_r, f_g, f_b, f_a;

			byte[] fg_ptr;

			int diameter = m_filter.diameter();
			int start = m_filter.start();
			int[] weight_array = m_filter.weight_array();

			int x_count;
			int weight_y;

			ISpanInterpolator spanInterpolator = base.interpolator();
			IImageBufferAccessor sourceAccessor = GetImageBufferAccessor();

			do
			{
				spanInterpolator.coordinates(out x, out y);

				x -= base.filter_dx_int();
				y -= base.filter_dy_int();

				int x_hr = x;
				int y_hr = y;

				int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
				int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;

				f_b = f_g = f_r = f_a = (int)image_filter_scale_e.image_filter_scale / 2;

				int x_fract = x_hr & (int)image_subpixel_scale_e.image_subpixel_mask;
				int y_count = diameter;

				y_hr = (int)image_subpixel_scale_e.image_subpixel_mask - (y_hr & (int)image_subpixel_scale_e.image_subpixel_mask);

				int bufferIndex;
				fg_ptr = sourceAccessor.span(x_lr + start, y_lr + start, diameter, out bufferIndex);
				for (; ; )
				{
					x_count = (int)diameter;
					weight_y = weight_array[y_hr];
					x_hr = (int)image_subpixel_scale_e.image_subpixel_mask - x_fract;
					for (; ; )
					{
						int weight = (weight_y * weight_array[x_hr] +
									 (int)image_filter_scale_e.image_filter_scale / 2) >>
									 (int)image_filter_scale_e.image_filter_shift;

						f_b += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
						f_g += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
						f_r += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
						f_a += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];

						if (--x_count == 0) break;
						x_hr += (int)image_subpixel_scale_e.image_subpixel_scale;
						sourceAccessor.next_x(out bufferIndex);
					}

					if (--y_count == 0) break;
					y_hr += (int)image_subpixel_scale_e.image_subpixel_scale;
					fg_ptr = sourceAccessor.next_y(out bufferIndex);
				}

				f_b >>= (int)image_filter_scale_e.image_filter_shift;
				f_g >>= (int)image_filter_scale_e.image_filter_shift;
				f_r >>= (int)image_filter_scale_e.image_filter_shift;
				f_a >>= (int)image_filter_scale_e.image_filter_shift;

				unchecked
				{
					if ((uint)f_b > base_mask)
					{
						if (f_b < 0) f_b = 0;
						if (f_b > base_mask) f_b = (int)base_mask;
					}

					if ((uint)f_g > base_mask)
					{
						if (f_g < 0) f_g = 0;
						if (f_g > base_mask) f_g = (int)base_mask;
					}

					if ((uint)f_r > base_mask)
					{
						if (f_r < 0) f_r = 0;
						if (f_r > base_mask) f_r = (int)base_mask;
					}

					if ((uint)f_a > base_mask)
					{
						if (f_a < 0) f_a = 0;
						if (f_a > base_mask) f_a = (int)base_mask;
					}
				}

				span[spanIndex].red = (byte)f_b;
				span[spanIndex].green = (byte)f_g;
				span[spanIndex].blue = (byte)f_r;
				span[spanIndex].alpha = (byte)f_a;

				spanIndex++;
				spanInterpolator.Next();
			} while (--len != 0);
		}
	};

	public class span_image_filter_rgba_float : span_image_filter_float
	{
		public span_image_filter_rgba_float(IImageBufferAccessorFloat src, ISpanInterpolatorFloat inter, IImageFilterFunction filterFunction)
			: base(src, inter, filterFunction)
		{
			if (src.SourceImage.GetFloatsBetweenPixelsInclusive() != 4)
			{
				throw new System.NotSupportedException("span_image_filter_rgba must have a 32 bit DestImage");
			}
		}

		public override void generate(ColorF[] span, int spanIndex, int xInt, int yInt, int len)
		{
			base.interpolator().begin(xInt + base.filter_dx_dbl(), yInt + base.filter_dy_dbl(), len);

			float f_r, f_g, f_b, f_a;

			float[] fg_ptr;

			int radius = (int)m_filterFunction.radius();
			int diameter = radius * 2;
			int start = -(int)(diameter / 2 - 1);

			int x_count;

			ISpanInterpolatorFloat spanInterpolator = base.interpolator();
			IImageBufferAccessorFloat sourceAccessor = source();

			do
			{
				float x = xInt;
				float y = yInt;
				spanInterpolator.coordinates(out x, out y);
				//x -= (float)base.filter_dx_dbl();
				//y -= (float)base.filter_dy_dbl();
				int sourceXInt = (int)x;
				int sourceYInt = (int)y;
				Vector2 sourceOrigin = new Vector2(x, y);
				Vector2 sourceSample = new Vector2(sourceXInt + start, sourceYInt + start);

				f_b = f_g = f_r = f_a = 0;

				int y_count = diameter;

				int bufferIndex;
				fg_ptr = sourceAccessor.span(sourceXInt + start, sourceYInt + start, diameter, out bufferIndex);
				float totalWeight = 0.0f;
				for (; ; )
				{
					float yweight = (float)m_filterFunction.calc_weight(System.Math.Sqrt((sourceSample.Y - sourceOrigin.Y) * (sourceSample.Y - sourceOrigin.Y)));
					x_count = (int)diameter;
					for (; ; )
					{
						float xweight = (float)m_filterFunction.calc_weight(System.Math.Sqrt((sourceSample.X - sourceOrigin.X) * (sourceSample.X - sourceOrigin.X)));
						float weight = xweight * yweight;

						f_r += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
						f_g += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
						f_b += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
						f_a += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];

						totalWeight += weight;
						sourceSample.X += 1;
						if (--x_count == 0) break;
						sourceAccessor.next_x(out bufferIndex);
					}

					sourceSample.X -= diameter;

					if (--y_count == 0) break;
					sourceSample.Y += 1;
					fg_ptr = sourceAccessor.next_y(out bufferIndex);
				}

				if (f_b < 0) f_b = 0; if (f_b > 1) f_b = 1;
				if (f_r < 0) f_r = 0; if (f_r > 1) f_r = 1;
				if (f_g < 0) f_g = 0; if (f_g > 1) f_g = 1;

				span[spanIndex].red = f_r;
				span[spanIndex].green = f_g;
				span[spanIndex].blue = f_b;
				span[spanIndex].alpha = 1;// f_a;

				spanIndex++;
				spanInterpolator.Next();
			} while (--len != 0);
		}
	};

	/*

		//========================================span_image_resample_rgba_affine
		public class span_image_resample_rgba_affine : span_image_resample_affine
		{
			//typedef Source source_type;
			//typedef typename source_type::color_type color_type;
			//typedef typename source_type::order_type order_type;
			//typedef span_image_resample_affine<source_type> base_type;
			//typedef typename base.interpolator_type interpolator_type;
			//typedef typename color_type::value_type value_type;
			//typedef typename color_type::long_type long_type;
			enum base_scale_e
			{
				base_shift      = 8, //color_type::base_shift,
				base_mask       = 255,//color_type::base_mask,
				downscale_shift = image_filter_shift
			};

			//--------------------------------------------------------------------
			public span_image_resample_rgba_affine() {}
			public span_image_resample_rgba_affine(pixfmt_alpha_blend_bgra32 src,
											interpolator_type inter,
											ImageFilterLookUpTable filter) :
				base(src, inter, filter)
			{}

			//--------------------------------------------------------------------
			public void generate(color_type* span, int x, int y, unsigned len)
			{
				base.interpolator().begin(x + base.filter_dx_dbl(),
												y + base.filter_dy_dbl(), len);

				long_type fg[4];

				int diameter     = base.filter().diameter();
				int filter_scale = diameter << image_subpixel_shift;
				int radius_x     = (diameter * base.m_rx) >> 1;
				int radius_y     = (diameter * base.m_ry) >> 1;
				int len_x_lr     =
					(diameter * base.m_rx + image_subpixel_mask) >>
						image_subpixel_shift;

				int16* weight_array = base.filter().weight_array();

				do
				{
					base.interpolator().coordinates(&x, &y);

					x += base.filter_dx_int() - radius_x;
					y += base.filter_dy_int() - radius_y;

					fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;

					int y_lr = y >> image_subpixel_shift;
					int y_hr = ((image_subpixel_mask - (y & image_subpixel_mask)) *
									base.m_ry_inv) >>
										image_subpixel_shift;
					int total_weight = 0;
					int x_lr = x >> image_subpixel_shift;
					int x_hr = ((image_subpixel_mask - (x & image_subpixel_mask)) *
									base.m_rx_inv) >>
										image_subpixel_shift;

					int x_hr2 = x_hr;
					byte* fg_ptr = base.source().span(x_lr, y_lr, len_x_lr);
					for(;;)
					{
						int weight_y = weight_array[y_hr];
						x_hr = x_hr2;
						for(;;)
						{
							int weight = (weight_y * weight_array[x_hr] +
										 (int)image_filter_scale_e.image_filter_scale / 2) >>
										 downscale_shift;

							fg[0] += *fg_ptr++ * weight;
							fg[1] += *fg_ptr++ * weight;
							fg[2] += *fg_ptr++ * weight;
							fg[3] += *fg_ptr++ * weight;
							total_weight += weight;
							x_hr  += base.m_rx_inv;
							if(x_hr >= filter_scale) break;
							fg_ptr = base.source().next_x();
						}
						y_hr += base.m_ry_inv;
						if(y_hr >= filter_scale) break;
						fg_ptr = base.source().next_y();
					}

					fg[0] /= total_weight;
					fg[1] /= total_weight;
					fg[2] /= total_weight;
					fg[3] /= total_weight;

					if(fg[0] < 0) fg[0] = 0;
					if(fg[1] < 0) fg[1] = 0;
					if(fg[2] < 0) fg[2] = 0;
					if(fg[3] < 0) fg[3] = 0;

					if(fg[ImageBuffer.OrderA] > base_mask)         fg[ImageBuffer.OrderA] = base_mask;
					if(fg[ImageBuffer.OrderR] > fg[ImageBuffer.OrderA]) fg[ImageBuffer.OrderR] = fg[ImageBuffer.OrderA];
					if(fg[ImageBuffer.OrderG] > fg[ImageBuffer.OrderA]) fg[ImageBuffer.OrderG] = fg[ImageBuffer.OrderA];
					if(fg[ImageBuffer.OrderB] > fg[ImageBuffer.OrderA]) fg[ImageBuffer.OrderB] = fg[ImageBuffer.OrderA];

					span->r = (byte)fg[ImageBuffer.OrderR];
					span->g = (byte)fg[ImageBuffer.OrderG];
					span->b = (byte)fg[ImageBuffer.OrderB];
					span->a = (byte)fg[ImageBuffer.OrderA];

					++span;
					++base.interpolator();
				} while(--len);
			}
		};
		 */

	//==============================================span_image_resample_rgba
	public class span_image_resample_rgba
		: span_image_resample
	{
		private const int base_mask = 255;
		private const int downscale_shift = (int)ImageFilterLookUpTable.image_filter_scale_e.image_filter_shift;

		//--------------------------------------------------------------------
		public span_image_resample_rgba(IImageBufferAccessor src,
							ISpanInterpolator inter,
							ImageFilterLookUpTable filter) :
			base(src, inter, filter)
		{
			if (src.SourceImage.GetRecieveBlender().NumPixelBits != 32)
			{
				throw new System.FormatException("You have to use a rgba blender with span_image_resample_rgba");
			}
		}

		//--------------------------------------------------------------------
		public override void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			ISpanInterpolator spanInterpolator = base.interpolator();
			spanInterpolator.begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

			int[] fg = new int[4];

			byte[] fg_ptr;
			int[] weightArray = filter().weight_array();
			int diameter = (int)base.filter().diameter();
			int filter_scale = diameter << (int)image_subpixel_scale_e.image_subpixel_shift;

			int[] weight_array = weightArray;

			do
			{
				int rx;
				int ry;
				int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;
				int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;
				spanInterpolator.coordinates(out x, out y);
				spanInterpolator.local_scale(out rx, out ry);
				base.adjust_scale(ref rx, ref ry);

				rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;
				ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;

				int radius_x = (diameter * rx) >> 1;
				int radius_y = (diameter * ry) >> 1;
				int len_x_lr =
					(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>
						(int)(int)image_subpixel_scale_e.image_subpixel_shift;

				x += base.filter_dx_int() - radius_x;
				y += base.filter_dy_int() - radius_y;

				fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;

				int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;
				int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *
							   ry_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;
				int total_weight = 0;
				int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;
				int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *
							   rx_inv) >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;
				int x_hr2 = x_hr;
				int sourceIndex;
				fg_ptr = base.GetImageBufferAccessor().span(x_lr, y_lr, len_x_lr, out sourceIndex);

				for (; ; )
				{
					int weight_y = weight_array[y_hr];
					x_hr = x_hr2;
					for (; ; )
					{
						int weight = (weight_y * weight_array[x_hr] +
									 (int)image_filter_scale_e.image_filter_scale / 2) >>
									 downscale_shift;
						fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;
						fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;
						fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;
						fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;
						total_weight += weight;
						x_hr += rx_inv;
						if (x_hr >= filter_scale) break;
						fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);
					}
					y_hr += ry_inv;
					if (y_hr >= filter_scale)
					{
						break;
					}

					fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);
				}

				fg[0] /= total_weight;
				fg[1] /= total_weight;
				fg[2] /= total_weight;
				fg[3] /= total_weight;

				if (fg[0] < 0) fg[0] = 0;
				if (fg[1] < 0) fg[1] = 0;
				if (fg[2] < 0) fg[2] = 0;
				if (fg[3] < 0) fg[3] = 0;

				if (fg[0] > base_mask) fg[0] = base_mask;
				if (fg[1] > base_mask) fg[1] = base_mask;
				if (fg[2] > base_mask) fg[2] = base_mask;
				if (fg[3] > base_mask) fg[3] = base_mask;

				span[spanIndex].red = (byte)fg[0];
				span[spanIndex].green = (byte)fg[1];
				span[spanIndex].blue = (byte)fg[2];
				span[spanIndex].alpha = (byte)fg[3];

				spanIndex++;
				interpolator().Next();
			} while (--len != 0);
		}

		/*
					ISpanInterpolator spanInterpolator = base.interpolator();
					spanInterpolator.begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

					int* fg = stackalloc int[4];

					byte* fg_ptr;
					fixed (int* pWeightArray = filter().weight_array())
					{
						int diameter = (int)base.filter().diameter();
						int filter_scale = diameter << (int)image_subpixel_scale_e.image_subpixel_shift;

						int* weight_array = pWeightArray;

						do
						{
							int rx;
							int ry;
							int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;
							int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;
							spanInterpolator.coordinates(out x, out y);
							spanInterpolator.local_scale(out rx, out ry);
							base.adjust_scale(ref rx, ref ry);

							rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;
							ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;

							int radius_x = (diameter * rx) >> 1;
							int radius_y = (diameter * ry) >> 1;
							int len_x_lr =
								(diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>
									(int)(int)image_subpixel_scale_e.image_subpixel_shift;

							x += base.filter_dx_int() - radius_x;
							y += base.filter_dy_int() - radius_y;

							fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;

							int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;
							int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) *
										   ry_inv) >>
											   (int)(int)image_subpixel_scale_e.image_subpixel_shift;
							int total_weight = 0;
							int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;
							int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) *
										   rx_inv) >>
											   (int)(int)image_subpixel_scale_e.image_subpixel_shift;
							int x_hr2 = x_hr;
							fg_ptr = base.source().span(x_lr, y_lr, (int)len_x_lr);

							for(;;)
							{
								int weight_y = weight_array[y_hr];
								x_hr = x_hr2;
								for(;;)
								{
									int weight = (weight_y * weight_array[x_hr] +
												 (int)image_filter_scale_e.image_filter_scale / 2) >>
												 downscale_shift;
									fg[0] += *fg_ptr++ * weight;
									fg[1] += *fg_ptr++ * weight;
									fg[2] += *fg_ptr++ * weight;
									fg[3] += *fg_ptr++ * weight;
									total_weight += weight;
									x_hr  += rx_inv;
									if(x_hr >= filter_scale) break;
									fg_ptr = base.source().next_x();
								}
								y_hr += ry_inv;
								if (y_hr >= filter_scale)
								{
									break;
								}

								fg_ptr = base.source().next_y();
							}

							fg[0] /= total_weight;
							fg[1] /= total_weight;
							fg[2] /= total_weight;
							fg[3] /= total_weight;

							if(fg[0] < 0) fg[0] = 0;
							if(fg[1] < 0) fg[1] = 0;
							if(fg[2] < 0) fg[2] = 0;
							if(fg[3] < 0) fg[3] = 0;

							if(fg[0] > fg[0]) fg[0] = fg[0];
							if(fg[1] > fg[1]) fg[1] = fg[1];
							if(fg[2] > fg[2]) fg[2] = fg[2];
							if (fg[3] > base_mask) fg[3] = base_mask;

							span->R_Byte = (byte)fg[ImageBuffer.OrderR];
							span->G_Byte = (byte)fg[ImageBuffer.OrderG];
							span->B_Byte = (byte)fg[ImageBuffer.OrderB];
							span->A_Byte = (byte)fg[ImageBuffer.OrderA];

							++span;
							interpolator().Next();
						} while(--len != 0);
					}
															  */
	};
}

//#endif

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Spans\agg_span_interpolator_linear.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg
{
	public interface ISpanInterpolator
	{
		void begin(double x, double y, int len);

		void coordinates(out int x, out int y);

		void Next();

		Transform.ITransform transformer();

		void transformer(Transform.ITransform trans);

		void resynchronize(double xe, double ye, int len);

		void local_scale(out int x, out int y);
	};

	//================================================span_interpolator_linear
	public sealed class span_interpolator_linear : ISpanInterpolator
	{
		private Transform.ITransform m_trans;
		private dda2_line_interpolator m_li_x;
		private dda2_line_interpolator m_li_y;

		public enum subpixel_scale_e
		{
			SubpixelShift = 8,
			subpixel_shift = SubpixelShift,
			subpixel_scale = 1 << subpixel_shift
		};

		//--------------------------------------------------------------------
		public span_interpolator_linear()
		{
		}

		public span_interpolator_linear(Transform.ITransform trans)
		{
			m_trans = trans;
		}

		public span_interpolator_linear(Transform.ITransform trans, double x, double y, int len)
		{
			m_trans = trans;
			begin(x, y, len);
		}

		//----------------------------------------------------------------
		public Transform.ITransform transformer()
		{
			return m_trans;
		}

		public void transformer(Transform.ITransform trans)
		{
			m_trans = trans;
		}

		public void local_scale(out int x, out int y)
		{
			throw new System.NotImplementedException();
		}

		//----------------------------------------------------------------
		public void begin(double x, double y, int len)
		{
			double tx;
			double ty;

			tx = x;
			ty = y;
			m_trans.Transform(ref tx, ref ty);
			int x1 = Util.iround(tx * (double)subpixel_scale_e.subpixel_scale);
			int y1 = Util.iround(ty * (double)subpixel_scale_e.subpixel_scale);

			tx = x + len;
			ty = y;
			m_trans.Transform(ref tx, ref ty);
			int x2 = Util.iround(tx * (double)subpixel_scale_e.subpixel_scale);
			int y2 = Util.iround(ty * (double)subpixel_scale_e.subpixel_scale);

			m_li_x = new dda2_line_interpolator(x1, x2, (int)len);
			m_li_y = new dda2_line_interpolator(y1, y2, (int)len);
		}

		//----------------------------------------------------------------
		public void resynchronize(double xe, double ye, int len)
		{
			m_trans.Transform(ref xe, ref ye);
			m_li_x = new dda2_line_interpolator(m_li_x.y(), Util.iround(xe * (double)subpixel_scale_e.subpixel_scale), (int)len);
			m_li_y = new dda2_line_interpolator(m_li_y.y(), Util.iround(ye * (double)subpixel_scale_e.subpixel_scale), (int)len);
		}

		//----------------------------------------------------------------
		//public void operator++()
		public void Next()
		{
			m_li_x.Next();
			m_li_y.Next();
		}

		//----------------------------------------------------------------
		public void coordinates(out int x, out int y)
		{
			x = m_li_x.y();
			y = m_li_y.y();
		}
	};

	public interface ISpanInterpolatorFloat
	{
		void begin(double x, double y, int len);

		void coordinates(out float x, out float y);

		void Next();

		Transform.ITransform transformer();

		void transformer(Transform.ITransform trans);

		void resynchronize(double xe, double ye, int len);

		void local_scale(out double x, out double y);
	};

	//================================================span_interpolator_linear
	public sealed class span_interpolator_linear_float : ISpanInterpolatorFloat
	{
		private Transform.ITransform m_trans;
		private float currentX;
		private float stepX;
		private float currentY;
		private float stepY;

		public span_interpolator_linear_float()
		{
		}

		public span_interpolator_linear_float(Transform.ITransform trans)
		{
			m_trans = trans;
		}

		public span_interpolator_linear_float(Transform.ITransform trans, double x, double y, int len)
		{
			m_trans = trans;
			begin(x, y, len);
		}

		//----------------------------------------------------------------
		public Transform.ITransform transformer()
		{
			return m_trans;
		}

		public void transformer(Transform.ITransform trans)
		{
			m_trans = trans;
		}

		public void local_scale(out double x, out double y)
		{
			throw new System.NotImplementedException();
		}

		//----------------------------------------------------------------
		public void begin(double x, double y, int len)
		{
			double tx;
			double ty;

			tx = x;
			ty = y;
			m_trans.Transform(ref tx, ref ty);
			currentX = (float)tx;
			currentY = (float)ty;

			tx = x + len;
			ty = y;
			m_trans.Transform(ref tx, ref ty);
			stepX = (float)((tx - currentX) / len);
			stepY = (float)((ty - currentY) / len);
		}

		//----------------------------------------------------------------
		public void resynchronize(double xe, double ye, int len)
		{
			throw new NotImplementedException();
			//m_trans.transform(ref xe, ref ye);
			//m_li_x = new dda2_line_interpolator(m_li_x.y(), agg_basics.iround(xe * (double)subpixel_scale_e.subpixel_scale), (int)len);
			//m_li_y = new dda2_line_interpolator(m_li_y.y(), agg_basics.iround(ye * (double)subpixel_scale_e.subpixel_scale), (int)len);
		}

		//----------------------------------------------------------------
		//public void operator++()
		public void Next()
		{
			currentX += stepX;
			currentY += stepY;
		}

		//----------------------------------------------------------------
		public void coordinates(out float x, out float y)
		{
			x = (float)currentX;
			y = (float)currentY;
		}
	};

	/*
		//=====================================span_interpolator_linear_subdiv
		template<class Transformer = ITransformer, int SubpixelShift = 8>
		class span_interpolator_linear_subdiv
		{
		public:
			typedef Transformer trans_type;

			enum subpixel_scale_e
			{
				subpixel_shift = SubpixelShift,
				subpixel_scale = 1 << subpixel_shift
			};

			//----------------------------------------------------------------
			span_interpolator_linear_subdiv() :
				m_subdiv_shift(4),
				m_subdiv_size(1 << m_subdiv_shift),
				m_subdiv_mask(m_subdiv_size - 1) {}

			span_interpolator_linear_subdiv(const trans_type& trans,
											int subdiv_shift = 4) :
				m_subdiv_shift(subdiv_shift),
				m_subdiv_size(1 << m_subdiv_shift),
				m_subdiv_mask(m_subdiv_size - 1),
				m_trans(&trans) {}

			span_interpolator_linear_subdiv(const trans_type& trans,
											double x, double y, int len,
											int subdiv_shift = 4) :
				m_subdiv_shift(subdiv_shift),
				m_subdiv_size(1 << m_subdiv_shift),
				m_subdiv_mask(m_subdiv_size - 1),
				m_trans(&trans)
			{
				begin(x, y, len);
			}

			//----------------------------------------------------------------
			const trans_type& transformer() const { return *m_trans; }
			void transformer(const trans_type& trans) { m_trans = &trans; }

			//----------------------------------------------------------------
			int subdiv_shift() const { return m_subdiv_shift; }
			void subdiv_shift(int shift)
			{
				m_subdiv_shift = shift;
				m_subdiv_size = 1 << m_subdiv_shift;
				m_subdiv_mask = m_subdiv_size - 1;
			}

			//----------------------------------------------------------------
			void begin(double x, double y, int len)
			{
				double tx;
				double ty;
				m_pos   = 1;
				m_src_x = iround(x * subpixel_scale) + subpixel_scale;
				m_src_y = y;
				m_len   = len;

				if(len > m_subdiv_size) len = m_subdiv_size;
				tx = x;
				ty = y;
				m_trans->transform(&tx, &ty);
				int x1 = iround(tx * subpixel_scale);
				int y1 = iround(ty * subpixel_scale);

				tx = x + len;
				ty = y;
				m_trans->transform(&tx, &ty);

				m_li_x = dda2_line_interpolator(x1, iround(tx * subpixel_scale), len);
				m_li_y = dda2_line_interpolator(y1, iround(ty * subpixel_scale), len);
			}

			//----------------------------------------------------------------
			void operator++()
			{
				++m_li_x;
				++m_li_y;
				if(m_pos >= m_subdiv_size)
				{
					int len = m_len;
					if(len > m_subdiv_size) len = m_subdiv_size;
					double tx = double(m_src_x) / double(subpixel_scale) + len;
					double ty = m_src_y;
					m_trans->transform(&tx, &ty);
					m_li_x = dda2_line_interpolator(m_li_x.y(), iround(tx * subpixel_scale), len);
					m_li_y = dda2_line_interpolator(m_li_y.y(), iround(ty * subpixel_scale), len);
					m_pos = 0;
				}
				m_src_x += subpixel_scale;
				++m_pos;
				--m_len;
			}

			//----------------------------------------------------------------
			void coordinates(int* x, int* y) const
			{
				*x = m_li_x.y();
				*y = m_li_y.y();
			}

		private:
			int m_subdiv_shift;
			int m_subdiv_size;
			int m_subdiv_mask;
			const trans_type* m_trans;
			dda2_line_interpolator m_li_x;
			dda2_line_interpolator m_li_y;
			int      m_src_x;
			double   m_src_y;
			int m_pos;
			int m_len;
		};

	 */
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Spans\agg_span_interpolator_persp.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg
{
	/*
	//===========================================span_interpolator_persp_exact
	//template<int SubpixelShift = 8>
	class span_interpolator_persp_exact
	{
	public:
		typedef trans_perspective trans_type;
		typedef trans_perspective::iterator_x iterator_type;
		enum subpixel_scale_e
		{
			subpixel_shift = SubpixelShift,
			subpixel_scale = 1 << subpixel_shift
		};

		//--------------------------------------------------------------------
		span_interpolator_persp_exact() {}

		//--------------------------------------------------------------------
		// Arbitrary quadrangle transformations
		span_interpolator_persp_exact(double[] src, double[] dst)
		{
			quad_to_quad(src, dst);
		}

		//--------------------------------------------------------------------
		// Direct transformations
		span_interpolator_persp_exact(double x1, double y1,
									  double x2, double y2,
									  double[] quad)
		{
			rect_to_quad(x1, y1, x2, y2, quad);
		}

		//--------------------------------------------------------------------
		// Reverse transformations
		span_interpolator_persp_exact(double[] quad,
									  double x1, double y1,
									  double x2, double y2)
		{
			quad_to_rect(quad, x1, y1, x2, y2);
		}

		//--------------------------------------------------------------------
		// Set the transformations using two arbitrary quadrangles.
		void quad_to_quad(double[] src, double[] dst)
		{
			m_trans_dir.quad_to_quad(src, dst);
			m_trans_inv.quad_to_quad(dst, src);
		}

		//--------------------------------------------------------------------
		// Set the direct transformations, i.e., rectangle -> quadrangle
		void rect_to_quad(double x1, double y1, double x2, double y2,
						  double[] quad)
		{
			double src[8];
			src[0] = src[6] = x1;
			src[2] = src[4] = x2;
			src[1] = src[3] = y1;
			src[5] = src[7] = y2;
			quad_to_quad(src, quad);
		}

		//--------------------------------------------------------------------
		// Set the reverse transformations, i.e., quadrangle -> rectangle
		void quad_to_rect(double[] quad,
						  double x1, double y1, double x2, double y2)
		{
			double dst[8];
			dst[0] = dst[6] = x1;
			dst[2] = dst[4] = x2;
			dst[1] = dst[3] = y1;
			dst[5] = dst[7] = y2;
			quad_to_quad(quad, dst);
		}

		//--------------------------------------------------------------------
		// Check if the equations were solved successfully
		bool is_valid() { return m_trans_dir.is_valid(); }

		//----------------------------------------------------------------
		void begin(double x, double y, int len)
		{
			m_iterator = m_trans_dir.begin(x, y, 1.0);
			double xt = m_iterator.x;
			double yt = m_iterator.y;

			double dx;
			double dy;
			double delta = 1/(double)subpixel_scale;
			dx = xt + delta;
			dy = yt;
			m_trans_inv.transform(&dx, &dy);
			dx -= x;
			dy -= y;
			int sx1 = agg_basics.uround(subpixel_scale/Math.Sqrt(dx*dx + dy*dy)) >> subpixel_shift;
			dx = xt;
			dy = yt + delta;
			m_trans_inv.transform(&dx, &dy);
			dx -= x;
			dy -= y;
			int sy1 = agg_basics.uround(subpixel_scale/Math.Sqrt(dx*dx + dy*dy)) >> subpixel_shift;

			x += len;
			xt = x;
			yt = y;
			m_trans_dir.transform(&xt, &yt);

			dx = xt + delta;
			dy = yt;
			m_trans_inv.transform(&dx, &dy);
			dx -= x;
			dy -= y;
			int sx2 = agg_basics.uround(subpixel_scale/Math.Sqrt(dx*dx + dy*dy)) >> subpixel_shift;
			dx = xt;
			dy = yt + delta;
			m_trans_inv.transform(&dx, &dy);
			dx -= x;
			dy -= y;
			int sy2 = agg_basics.uround(subpixel_scale/Math.Sqrt(dx*dx + dy*dy)) >> subpixel_shift;

			m_scale_x = dda2_line_interpolator(sx1, sx2, len);
			m_scale_y = dda2_line_interpolator(sy1, sy2, len);
		}

		//----------------------------------------------------------------
		void resynchronize(double xe, double ye, int len)
		{
			// Assume x1,y1 are equal to the ones at the previous end point
			int sx1 = m_scale_x.y();
			int sy1 = m_scale_y.y();

			// Calculate transformed coordinates at x2,y2
			double xt = xe;
			double yt = ye;
			m_trans_dir.transform(&xt, &yt);

			double delta = 1/(double)subpixel_scale;
			double dx;
			double dy;

			// Calculate scale by X at x2,y2
			dx = xt + delta;
			dy = yt;
			m_trans_inv.transform(&dx, &dy);
			dx -= xe;
			dy -= ye;
			int sx2 = agg_basics.uround(subpixel_scale/Math.Sqrt(dx*dx + dy*dy)) >> subpixel_shift;

			// Calculate scale by Y at x2,y2
			dx = xt;
			dy = yt + delta;
			m_trans_inv.transform(&dx, &dy);
			dx -= xe;
			dy -= ye;
			int sy2 = agg_basics.uround(subpixel_scale/Math.Sqrt(dx*dx + dy*dy)) >> subpixel_shift;

			// Initialize the interpolators
			m_scale_x = dda2_line_interpolator(sx1, sx2, len);
			m_scale_y = dda2_line_interpolator(sy1, sy2, len);
		}

		//----------------------------------------------------------------
		void operator++()
		{
			++m_iterator;
			++m_scale_x;
			++m_scale_y;
		}

		//----------------------------------------------------------------
		void coordinates(int* x, int* y)
		{
			*x = agg_basics.iround(m_iterator.x * subpixel_scale);
			*y = agg_basics.iround(m_iterator.y * subpixel_scale);
		}

		//----------------------------------------------------------------
		void local_scale(int* x, int* y)
		{
			*x = m_scale_x.y();
			*y = m_scale_y.y();
		}

		//----------------------------------------------------------------
		void transform(double[] x, double[] y)
		{
			m_trans_dir.transform(x, y);
		}

	private:
		trans_type             m_trans_dir;
		trans_type             m_trans_inv;
		iterator_type          m_iterator;
		dda2_line_interpolator m_scale_x;
		dda2_line_interpolator m_scale_y;
	};
	 */

	//============================================span_interpolator_persp_lerp
	//template<int SubpixelShift = 8>
	public class span_interpolator_persp_lerp : ISpanInterpolator
	{
		private Transform.Perspective m_trans_dir;
		private Transform.Perspective m_trans_inv;
		private dda2_line_interpolator m_coord_x;
		private dda2_line_interpolator m_coord_y;
		private dda2_line_interpolator m_scale_x;
		private dda2_line_interpolator m_scale_y;

		private const int subpixel_shift = 8;
		private const int subpixel_scale = 1 << subpixel_shift;

		//--------------------------------------------------------------------
		public span_interpolator_persp_lerp()
		{
			m_trans_dir = new Transform.Perspective();
			m_trans_inv = new Transform.Perspective();
		}

		//--------------------------------------------------------------------
		// Arbitrary quadrangle transformations
		public span_interpolator_persp_lerp(double[] src, double[] dst)
			: this()
		{
			quad_to_quad(src, dst);
		}

		//--------------------------------------------------------------------
		// Direct transformations
		public span_interpolator_persp_lerp(double x1, double y1,
									 double x2, double y2,
									 double[] quad)
			: this()
		{
			rect_to_quad(x1, y1, x2, y2, quad);
		}

		//--------------------------------------------------------------------
		// Reverse transformations
		public span_interpolator_persp_lerp(double[] quad,
									 double x1, double y1,
									 double x2, double y2)
			: this()
		{
			quad_to_rect(quad, x1, y1, x2, y2);
		}

		//--------------------------------------------------------------------
		// Set the transformations using two arbitrary quadrangles.
		public void quad_to_quad(double[] src, double[] dst)
		{
			m_trans_dir.quad_to_quad(src, dst);
			m_trans_inv.quad_to_quad(dst, src);
		}

		//--------------------------------------------------------------------
		// Set the direct transformations, i.e., rectangle -> quadrangle
		public void rect_to_quad(double x1, double y1, double x2, double y2, double[] quad)
		{
			double[] src = new double[8];
			src[0] = src[6] = x1;
			src[2] = src[4] = x2;
			src[1] = src[3] = y1;
			src[5] = src[7] = y2;
			quad_to_quad(src, quad);
		}

		//--------------------------------------------------------------------
		// Set the reverse transformations, i.e., quadrangle -> rectangle
		public void quad_to_rect(double[] quad,
						  double x1, double y1, double x2, double y2)
		{
			double[] dst = new double[8];
			dst[0] = dst[6] = x1;
			dst[2] = dst[4] = x2;
			dst[1] = dst[3] = y1;
			dst[5] = dst[7] = y2;
			quad_to_quad(quad, dst);
		}

		//--------------------------------------------------------------------
		// Check if the equations were solved successfully
		public bool is_valid()
		{
			return m_trans_dir.is_valid();
		}

		//----------------------------------------------------------------
		public void begin(double x, double y, int len)
		{
			// Calculate transformed coordinates at x1,y1
			double xt = x;
			double yt = y;
			m_trans_dir.Transform(ref xt, ref yt);
			int x1 = Util.iround(xt * subpixel_scale);
			int y1 = Util.iround(yt * subpixel_scale);

			double dx;
			double dy;
			double delta = 1 / (double)subpixel_scale;

			// Calculate scale by X at x1,y1
			dx = xt + delta;
			dy = yt;
			m_trans_inv.Transform(ref dx, ref dy);
			dx -= x;
			dy -= y;
			int sx1 = (int)Util.uround(subpixel_scale / Math.Sqrt(dx * dx + dy * dy)) >> subpixel_shift;

			// Calculate scale by Y at x1,y1
			dx = xt;
			dy = yt + delta;
			m_trans_inv.Transform(ref dx, ref dy);
			dx -= x;
			dy -= y;
			int sy1 = (int)Util.uround(subpixel_scale / Math.Sqrt(dx * dx + dy * dy)) >> subpixel_shift;

			// Calculate transformed coordinates at x2,y2
			x += len;
			xt = x;
			yt = y;
			m_trans_dir.Transform(ref xt, ref yt);
			int x2 = Util.iround(xt * subpixel_scale);
			int y2 = Util.iround(yt * subpixel_scale);

			// Calculate scale by X at x2,y2
			dx = xt + delta;
			dy = yt;
			m_trans_inv.Transform(ref dx, ref dy);
			dx -= x;
			dy -= y;
			int sx2 = (int)Util.uround(subpixel_scale / Math.Sqrt(dx * dx + dy * dy)) >> subpixel_shift;

			// Calculate scale by Y at x2,y2
			dx = xt;
			dy = yt + delta;
			m_trans_inv.Transform(ref dx, ref dy);
			dx -= x;
			dy -= y;
			int sy2 = (int)Util.uround(subpixel_scale / Math.Sqrt(dx * dx + dy * dy)) >> subpixel_shift;

			// Initialize the interpolators
			m_coord_x = new dda2_line_interpolator(x1, x2, (int)len);
			m_coord_y = new dda2_line_interpolator(y1, y2, (int)len);
			m_scale_x = new dda2_line_interpolator(sx1, sx2, (int)len);
			m_scale_y = new dda2_line_interpolator(sy1, sy2, (int)len);
		}

		//----------------------------------------------------------------
		public void resynchronize(double xe, double ye, int len)
		{
			// Assume x1,y1 are equal to the ones at the previous end point
			int x1 = m_coord_x.y();
			int y1 = m_coord_y.y();
			int sx1 = m_scale_x.y();
			int sy1 = m_scale_y.y();

			// Calculate transformed coordinates at x2,y2
			double xt = xe;
			double yt = ye;
			m_trans_dir.Transform(ref xt, ref yt);
			int x2 = Util.iround(xt * subpixel_scale);
			int y2 = Util.iround(yt * subpixel_scale);

			double delta = 1 / (double)subpixel_scale;
			double dx;
			double dy;

			// Calculate scale by X at x2,y2
			dx = xt + delta;
			dy = yt;
			m_trans_inv.Transform(ref dx, ref dy);
			dx -= xe;
			dy -= ye;
			int sx2 = (int)Util.uround(subpixel_scale / Math.Sqrt(dx * dx + dy * dy)) >> subpixel_shift;

			// Calculate scale by Y at x2,y2
			dx = xt;
			dy = yt + delta;
			m_trans_inv.Transform(ref dx, ref dy);
			dx -= xe;
			dy -= ye;
			int sy2 = (int)Util.uround(subpixel_scale / Math.Sqrt(dx * dx + dy * dy)) >> subpixel_shift;

			// Initialize the interpolators
			m_coord_x = new dda2_line_interpolator(x1, x2, (int)len);
			m_coord_y = new dda2_line_interpolator(y1, y2, (int)len);
			m_scale_x = new dda2_line_interpolator(sx1, sx2, (int)len);
			m_scale_y = new dda2_line_interpolator(sy1, sy2, (int)len);
		}

		public Transform.ITransform transformer()
		{
			throw new System.NotImplementedException();
		}

		public void transformer(Transform.ITransform trans)
		{
			throw new System.NotImplementedException();
		}

		//----------------------------------------------------------------
		public void Next()
		{
			m_coord_x.Next();
			m_coord_y.Next();
			m_scale_x.Next();
			m_scale_y.Next();
		}

		//----------------------------------------------------------------
		public void coordinates(out int x, out int y)
		{
			x = m_coord_x.y();
			y = m_coord_y.y();
		}

		//----------------------------------------------------------------
		public void local_scale(out int x, out int y)
		{
			x = m_scale_x.y();
			y = m_scale_y.y();
		}

		//----------------------------------------------------------------
		public void transform(ref double x, ref double y)
		{
			m_trans_dir.Transform(ref x, ref y);
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Spans\agg_span_subdiv_adaptor.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------

namespace MatterHackers.Agg
{
	//=================================================span_subdiv_adaptor
	public class span_subdiv_adaptor : ISpanInterpolator
	{
		private int m_subdiv_shift;
		private int m_subdiv_size;
		private int m_subdiv_mask;
		private ISpanInterpolator m_interpolator;
		private int m_src_x;
		private double m_src_y;
		private int m_pos;
		private int m_len;

		private const int subpixel_shift = 8;
		private const int subpixel_scale = 1 << subpixel_shift;

		//----------------------------------------------------------------
		public span_subdiv_adaptor(ISpanInterpolator interpolator)
			: this(interpolator, 4)
		{
		}

		public span_subdiv_adaptor(ISpanInterpolator interpolator, int subdiv_shift)
		{
			m_subdiv_shift = subdiv_shift;
			m_subdiv_size = 1 << m_subdiv_shift;
			m_subdiv_mask = m_subdiv_size - 1;
			m_interpolator = interpolator;
		}

		public span_subdiv_adaptor(ISpanInterpolator interpolator,
							 double x, double y, int len,
							 int subdiv_shift)
			: this(interpolator, subdiv_shift)
		{
			begin(x, y, len);
		}

		public void resynchronize(double xe, double ye, int len)
		{
			throw new System.NotImplementedException();
		}

		//----------------------------------------------------------------
		public ISpanInterpolator interpolator()
		{
			return m_interpolator;
		}

		public void interpolator(ISpanInterpolator intr)
		{
			m_interpolator = intr;
		}

		//----------------------------------------------------------------
		public Transform.ITransform transformer()
		{
			return m_interpolator.transformer();
		}

		public void transformer(Transform.ITransform trans)
		{
			m_interpolator.transformer(trans);
		}

		//----------------------------------------------------------------
		public int subdiv_shift()
		{
			return m_subdiv_shift;
		}

		public void subdiv_shift(int shift)
		{
			m_subdiv_shift = shift;
			m_subdiv_size = 1 << m_subdiv_shift;
			m_subdiv_mask = m_subdiv_size - 1;
		}

		//----------------------------------------------------------------
		public void begin(double x, double y, int len)
		{
			m_pos = 1;
			m_src_x = Util.iround(x * subpixel_scale) + subpixel_scale;
			m_src_y = y;
			m_len = len;
			if (len > m_subdiv_size) len = (int)m_subdiv_size;
			m_interpolator.begin(x, y, len);
		}

		//----------------------------------------------------------------
		public void Next()
		{
			m_interpolator.Next();
			if (m_pos >= m_subdiv_size)
			{
				int len = m_len;
				if (len > m_subdiv_size) len = (int)m_subdiv_size;
				m_interpolator.resynchronize((double)m_src_x / (double)subpixel_scale + len,
											  m_src_y,
											  len);
				m_pos = 0;
			}
			m_src_x += subpixel_scale;
			++m_pos;
			--m_len;
		}

		//----------------------------------------------------------------
		public void coordinates(out int x, out int y)
		{
			m_interpolator.coordinates(out x, out y);
		}

		//----------------------------------------------------------------
		public void local_scale(out int x, out int y)
		{
			m_interpolator.local_scale(out x, out y);
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\StringEventArgs.cs
using System;

namespace MatterHackers.Agg
{
	public class StringEventArgs : EventArgs
	{
		public string Data { get; }

		public StringEventArgs(string data)
		{
			this.Data = data;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\SvgTools\SVGParser.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007-2011
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
//
// Class FontSVG.cs
//
//----------------------------------------------------------------------------
using HtmlAgilityPack;
using MatterHackers.Agg.Transform;
using MatterHackers.Agg.VertexSource;
using MatterHackers.VectorMath;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;

namespace MatterHackers.Agg.SvgTools
{
    public static class SvgParser
    {
        private static HashSet<char> validNumberStartingCharacters = new HashSet<char> { '-', '.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };

        private static HashSet<char> validSkipCharacters = new HashSet<char> { ' ', '\t', '\n', '\r', ',' };

        public static List<ColoredVertexSource> Parse(string filePath, bool flipY)
        {
            using (var stream = File.OpenRead(filePath))
            {
                return Parse(stream, flipY);
            }
        }

        public static List<ColoredVertexSource> Parse(Stream stream, bool flipY)
        {
            var svgDocument = new HtmlDocument();
            svgDocument.Load(stream);

            // get the viewBox
            var viewBox = svgDocument.DocumentNode.SelectSingleNode("//svg").Attributes["viewBox"].Value;

            // if we want to parse size at some point
            if (!string.IsNullOrEmpty(viewBox))
            {
                var segments = viewBox.Split(' ');
                int.TryParse(segments[2], out int width);
                int.TryParse(segments[3], out int height);
            }

            var items = new List<ColoredVertexSource>();

            VertexStorage FlipIfRequired(VertexStorage source)
            {
                if (flipY)
                {
                    var flip = Affine.NewScaling(1, -1);
                    return new VertexStorage(new VertexSourceApplyTransform(source, flip));
                }

                return source;
            }

            // process all the paths and polygons
            if (svgDocument.DocumentNode.Descendants("path").Any())
            {
                foreach (var pathNode in svgDocument.DocumentNode.SelectNodes("//path"))
                {
                    var pathDString = pathNode.Attributes["d"].Value;
                    var vertexStorage = new VertexStorage(pathDString);

                    // get the fill color
                    var fillColor = Color.Black;
                    
                    // First check for direct fill attribute
                    if (pathNode.Attributes["fill"] != null)
                    {
                        var fillString = pathNode.Attributes["fill"].Value;
                        if (fillString.StartsWith("#"))
                        {
                            fillColor = new Color(fillString);
                        }
                    }
                    // Then check for fill color in style attribute
                    else if (pathNode.Attributes["style"] != null)
                    {
                        var styleString = pathNode.Attributes["style"].Value;
                        var fillMatch = System.Text.RegularExpressions.Regex.Match(styleString, @"fill:\s*#([0-9A-Fa-f]{6})");
                        if (fillMatch.Success)
                        {
                            fillColor = new Color("#" + fillMatch.Groups[1].Value);
                        }
                    }

                    items.Add(new ColoredVertexSource(FlipIfRequired(vertexStorage), fillColor));
                }
            }

            var fastSimpleNumbers = true;
            if (svgDocument.DocumentNode.Descendants("polygon").Any())
            {
                foreach (var polgonNode in svgDocument.DocumentNode.SelectNodes("//polygon"))
                {
                    var pointsString = polgonNode.Attributes["points"].Value;
                    var vertexStorage = new VertexStorage();
                    var parseIndex = 0;
                    bool first = true;
                    do
                    {
                        var x = Util.ParseDouble(pointsString, ref parseIndex, fastSimpleNumbers);
                        var y = Util.ParseDouble(pointsString, ref parseIndex, fastSimpleNumbers);
                        if (first)
                        {
                            vertexStorage.MoveTo(x, y);
                            first = false;
                        }
                        else
                        {
                            vertexStorage.LineTo(x, y);
                        }
                    } while (NextElementIsANumber(pointsString, parseIndex));

                    vertexStorage.ClosePolygon();

                    items.Add(new ColoredVertexSource(FlipIfRequired(vertexStorage), Color.Black));
                }
            }

            return items;
        }

        public static string SvgDString(this IVertexSource vertexSource)
        {
            var dstring = new StringBuilder();
            var curveIndex = 0;
            var lastCommand = FlagsAndCommand.Stop;
            foreach (var vertexData in vertexSource.Vertices())
            {
                if (lastCommand != vertexData.Command)
                {
                    curveIndex = 0;
                }

                switch (vertexData.Command)
                {
                    case FlagsAndCommand.MoveTo:
                        {
                            dstring.Append($"M {vertexData.Position.X:0.###} {vertexData.Position.Y:0.###}");
                            break;
                        }

                    case FlagsAndCommand.LineTo:
                        {
                            dstring.Append($"L {vertexData.Position.X:0.###} {vertexData.Position.Y:0.###}");
                            break;
                        }

                    case FlagsAndCommand.Stop:
                        break;

                    case FlagsAndCommand.FlagClose:
                        {
                            dstring.Append($"Z");
                            break;
                        }

                    case FlagsAndCommand.Curve3:
                        {
                            switch (curveIndex)
                            {
                                case 0:
                                    {
                                        dstring.Append($"Q {vertexData.Position.X:0.###} {vertexData.Position.Y:0.###}");
                                        curveIndex++;
                                    }
                                    break;

                                case 1:
                                    {
                                        dstring.Append($" {vertexData.Position.X:0.###} {vertexData.Position.Y:0.###}");
                                        curveIndex = 0;
                                    }
                                    break;

                                default:
                                    throw new NotImplementedException();
                            }
                        }
                        break;

                    case FlagsAndCommand.Curve4:
                        {
                            switch (curveIndex)
                            {
                                case 0:
                                    {
                                        dstring.Append($"C {vertexData.Position.X:0.###} {vertexData.Position.Y:0.###}");
                                        curveIndex++;
                                    }
                                    break;

                                case 1:
                                    {
                                        dstring.Append($" {vertexData.Position.X:0.###} {vertexData.Position.Y:0.###}");
                                        curveIndex++;
                                    }
                                    break;

                                case 2:
                                    {
                                        dstring.Append($" {vertexData.Position.X:0.###} {vertexData.Position.Y:0.###}");
                                        curveIndex = 0;
                                    }
                                    break;

                                default:
                                    throw new NotImplementedException();
                            }

                        }
                        break;

                    default:
                        if (vertexData.IsClose)
                        {
                            dstring.Append($"Z");
                        }
                        break;
                }

                lastCommand = vertexData.Command;
            }

            var newString = dstring.ToString();

            return newString;
        }

        public static void ParseSvgDString(this VertexStorage vertexStorage, string dString)
        {
            vertexStorage.Clear();

            var fastSimpleNumbers = dString.IndexOf('e') == -1;
            var parseIndex = 0;
            var lastXY = new Vector2();
            var curXY = new Vector2();

            var secondControlPoint = new Vector2();
            var polygonStart = new Vector2();
            

            while (parseIndex < dString.Length)
            {
                var command = dString[parseIndex];
                switch (command)
                {
                    case 'a': // relative arc
                    case 'A': // absolute arc
                        {
                            parseIndex++;
                            do
                            {
                                Vector2 radii;
                                radii.X = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                radii.Y = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                var angle = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                var largeArcFlag = (int)Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                var sweepFlag = (int)Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                curXY.X = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                curXY.Y = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);

                                if (command == 'a')
                                {
                                    curXY += lastXY;
                                }

                                AddArcToPath(vertexStorage,
                                    lastXY,
                                    radii,
                                    angle,
                                    largeArcFlag,
                                    sweepFlag,
                                    curXY);

                                lastXY = curXY;

                                // if the next element is another coordinate than we just continue to add more curves.
                            } while (NextElementIsANumber(dString, parseIndex));
                        }
                        break;

                    case 'c': // curve to relative
                    case 'C': // curve to absolute
                        {
                            parseIndex++;

                            do
                            {
                                Vector2 controlPoint1;
                                controlPoint1.X = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                controlPoint1.Y = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                secondControlPoint.X = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                secondControlPoint.Y = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                curXY.X = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                curXY.Y = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                if (command == 'c')
                                {
                                    controlPoint1 += lastXY;
                                    secondControlPoint += lastXY;
                                    curXY += lastXY;
                                }

                                vertexStorage.Curve4(controlPoint1.X, controlPoint1.Y, secondControlPoint.X, secondControlPoint.Y, curXY.X, curXY.Y);

                                lastXY = curXY;

                                // if the next element is another coordinate than we just continue to add more curves.
                            } while (NextElementIsANumber(dString, parseIndex));
                        }
                        break;

                    case 's': // shorthand/smooth curveto relative
                    case 'S': // shorthand/smooth curveto absolute
                        {
                            parseIndex++;

                            do
                            {
                                Vector2 controlPoint = lastXY;

                                if (vertexStorage[vertexStorage.Count - 1].Command == FlagsAndCommand.Curve4)
                                {
                                    controlPoint = Reflect(secondControlPoint, lastXY);
                                }
                                else
                                {
                                    controlPoint = curXY;
                                }

                                secondControlPoint.X = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                secondControlPoint.Y = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                curXY.X = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                curXY.Y = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                                if (command == 's')
                                {
                                    secondControlPoint += lastXY;
                                    curXY += lastXY;
                                }

                                vertexStorage.Curve4(controlPoint.X, controlPoint.Y, secondControlPoint.X, secondControlPoint.Y, curXY.X, curXY.Y);

                                lastXY = curXY;
                                // if the next element is another coordinate than we just continue to add more curves.
                            } while (NextElementIsANumber(dString, parseIndex));
                        }
                        break;

                    case 'h': // horizontal line to relative
                    case 'H': // horizontal line to absolute
                        parseIndex++;
                        do
                        {
                            curXY.Y = lastXY.Y;
                            curXY.X = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                            if (command == 'h')
                            {
                                curXY.X += lastXY.X;
                            }

                            vertexStorage.HorizontalLineTo(curXY.X);

                            lastXY = curXY;
                        } while (NextElementIsANumber(dString, parseIndex));
                        break;

                    case 'l': // line to relative
                    case 'L': // line to absolute
                        parseIndex++;
                        do
                        {
                            curXY.X = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                            curXY.Y = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                            if (command == 'l')
                            {
                                curXY += lastXY;
                            }

                            vertexStorage.LineTo(curXY.X, curXY.Y);
                            lastXY = curXY;
                        } while (NextElementIsANumber(dString, parseIndex));
                        break;

                    case 'm': // move to relative
                    case 'M': // move to absolute
                        parseIndex++;
                        do
                        {
                            // svg fonts are stored cw and agg expects its shapes to be ccw.  cw shapes are holes.
                            // so we store the position of the start of this polygon so we can flip it when we close it.
                            curXY.X = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                            curXY.Y = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                            if (command == 'm')
                            {
                                curXY += lastXY;
                            }

                            vertexStorage.MoveTo(curXY.X, curXY.Y);
                            polygonStart = curXY;
                            lastXY = curXY;
                        } while (NextElementIsANumber(dString, parseIndex));
                        break;

                    case 'q': // quadratic Bzier curveto relative
                    case 'Q': // quadratic Bzier curveto absolute
                        parseIndex++;
                        do
                        {
                            Vector2 controlPoint;
                            controlPoint.X = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                            controlPoint.Y = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                            curXY.X = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                            curXY.Y = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                            if (command == 'q')
                            {
                                controlPoint += lastXY;
                                curXY += lastXY;
                            }

                            vertexStorage.Curve3(controlPoint.X, controlPoint.Y, curXY.X, curXY.Y);
                        } while (NextElementIsANumber(dString, parseIndex)) ;
                        lastXY = curXY;
                        break;

                    case 't': // Shorthand/smooth quadratic Bzier curveto relative
                    case 'T': // Shorthand/smooth quadratic Bzier curveto absolute
                        parseIndex++;
                        do
                        {
                            curXY.X = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                            curXY.Y = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                            if (command == 't')
                            {
                                curXY += lastXY;
                            }

                            vertexStorage.Curve3(curXY.X, curXY.Y);
                        } while (NextElementIsANumber(dString, parseIndex));
                        lastXY = curXY;
                        break;

                    case 'v': // vertical line to relative
                    case 'V': // vertical line to absolute
                        parseIndex++;
                        curXY.X = lastXY.X;
                        curXY.Y = Util.ParseDouble(dString, ref parseIndex, fastSimpleNumbers);
                        if (command == 'v')
                        {
                            curXY.Y += lastXY.Y;
                        }

                        vertexStorage.VerticalLineTo(curXY.Y);
                        lastXY = curXY;
                        break;

                    case 'z': // close path
                    case 'Z': // close path
                        parseIndex++;
                        vertexStorage.ClosePolygon();
                        lastXY = polygonStart;
                        break;

                    case ' ':
                    case '\t': // tab character
                    case '\n': // some white space we need to skip
                    case '\r':
                        parseIndex++;
                        break;

                    default:
                        throw new NotImplementedException("unrecognized d command '" + command + "'.");
                }
            }
        }

        private static double CalculateVectorAngle(double ux, double uy, double vx, double vy)
        {
            var aTanU = Math.Atan2(uy, ux);
            var aTanV = Math.Atan2(vy, vx);

            if (aTanV >= aTanU)
            {
                return aTanV - aTanU;
            }

            return MathHelper.Tau - (aTanU - aTanV);
        }

        public static void AddArcToPath(VertexStorage vertexStorage, Vector2 start, Vector2 radii, double angleDegrees, int size, int sweep, Vector2 end)
        {
            if (start == end)
            {
                return;
            }

            if (radii.X == 0 && radii.Y == 0)
            {
                vertexStorage.LineTo(end);
                return;
            }

            var sinAngle = Math.Sin(MathHelper.DegreesToRadians(angleDegrees));
            var cosAngle = Math.Cos(MathHelper.DegreesToRadians(angleDegrees));

            var center = (start - end) / 2.0;
            var centerAngle = new Vector2(cosAngle * center.X + sinAngle * center.Y, -sinAngle * center.X + cosAngle * center.Y);

            var numerator = radii.X * radii.X * radii.Y * radii.Y - radii.X * radii.X * centerAngle.Y * centerAngle.Y - radii.Y * radii.Y * centerAngle.X * centerAngle.X;

            double root;
            if (numerator < 0.0)
            {
                var s = Math.Sqrt(1.0 - numerator / (radii.X * radii.X * radii.Y * radii.Y));

                radii *= s;
                root = 0.0;
            }
            else
            {
                root = ((size == 1 && sweep == 1)
                    || (size == 0 && sweep == 0) ? -1.0 : 1.0) * Math.Sqrt(numerator / (radii.X * radii.X * centerAngle.Y * centerAngle.Y + radii.Y * radii.Y * centerAngle.X * centerAngle.X));
            }

            var cxdash = root * radii.X * centerAngle.Y / radii.Y;
            var cydash = -root * radii.Y * centerAngle.X / radii.X;

            var cx = cosAngle * cxdash - sinAngle * cydash + (start.X + end.X) / 2.0;
            var cy = sinAngle * cxdash + cosAngle * cydash + (start.Y + end.Y) / 2.0;

            var vectorAngle1 = CalculateVectorAngle(1.0, 0.0, (centerAngle.X - cxdash) / radii.X, (centerAngle.Y - cydash) / radii.Y);
            var vectorAngleD = CalculateVectorAngle((centerAngle.X - cxdash) / radii.X, (centerAngle.Y - cydash) / radii.Y, (-centerAngle.X - cxdash) / radii.X, (-centerAngle.Y - cydash) / radii.Y);

            if (sweep == 0 && vectorAngleD > 0)
            {
                vectorAngleD -= 2.0 * Math.PI;
            }
            else if (sweep == 1 && vectorAngleD < 0)
            {
                vectorAngleD += 2.0 * Math.PI;
            }

            var segments = (int)Math.Ceiling((double)Math.Abs(vectorAngleD / (Math.PI / 2.0)));
            var delta = vectorAngleD / segments;
            var t = 8.0 / 3.0 * Math.Sin(delta / 4.0) * Math.Sin(delta / 4.0) / Math.Sin(delta / 2.0);

            for (var i = 0; i < segments; ++i)
            {
                var cosTheta1 = Math.Cos(vectorAngle1);
                var sinTheta1 = Math.Sin(vectorAngle1);
                var theta2 = vectorAngle1 + delta;
                var cosTheta2 = Math.Cos(theta2);
                var sinTheta2 = Math.Sin(theta2);

                var endpoint = new Vector2(cosAngle * radii.X * cosTheta2 - sinAngle * radii.Y * sinTheta2 + cx,
                                           sinAngle * radii.X * cosTheta2 + cosAngle * radii.Y * sinTheta2 + cy);

                var dx1 = t * (-cosAngle * radii.X * sinTheta1 - sinAngle * radii.Y * cosTheta1);
                var dy1 = t * (-sinAngle * radii.X * sinTheta1 + cosAngle * radii.Y * cosTheta1);

                var dxe = t * (cosAngle * radii.X * sinTheta2 + sinAngle * radii.Y * cosTheta2);
                var dye = t * (sinAngle * radii.X * sinTheta2 - cosAngle * radii.Y * cosTheta2);

                vertexStorage.Curve4(start.X + dx1, start.Y + dy1, endpoint.X + dxe, endpoint.Y + dye, endpoint.X, endpoint.Y);

                vectorAngle1 = theta2;
                start = endpoint;
            }
        }

        private static bool NextElementIsANumber(string dString, int parseIndex)
        {
            while (parseIndex < dString.Length
                && validSkipCharacters.Contains(dString[parseIndex]))
            {
                parseIndex++;
            }

            if (parseIndex < dString.Length
                && validNumberStartingCharacters.Contains(dString[parseIndex]))
            {
                return true;
            }

            return false;
        }

        public static void RenderDebug(this IVertexSource vertexSource, Graphics2D graphics)
        {
            IEnumerator<VertexData> vertexDataEnumerator = vertexSource.Vertices().GetEnumerator();
            VertexData lastPosition = new VertexData();
            while (vertexDataEnumerator.MoveNext())
            {
                VertexData vertexData = vertexDataEnumerator.Current;

                switch (vertexData.Command)
                {
                    case FlagsAndCommand.Stop:
                        break;
                        
                    case FlagsAndCommand.MoveTo:
                        break;
                        
                    case FlagsAndCommand.LineTo:
                        break;
                        
                    case FlagsAndCommand.Curve3:
                        break;
                        
                    case FlagsAndCommand.Curve4:
                        {
                            vertexDataEnumerator.MoveNext();
                            var vertexDataControl2 = vertexDataEnumerator.Current;
                            vertexDataEnumerator.MoveNext();
                            var vertexDataEnd = vertexDataEnumerator.Current;

                            graphics.Line(lastPosition.Position, vertexData.Position, Color.Green);
                            graphics.Line(vertexDataControl2.Position, vertexDataEnd.Position, Color.Green);
                            graphics.Circle(vertexData.Position, 5, Color.Red);
                            graphics.Circle(vertexDataControl2.Position, 5, Color.Red);
                            vertexData = vertexDataEnd;
                        }
                        break;
                        
                    case FlagsAndCommand.EndPoly:
                        break;
                        
                    case FlagsAndCommand.FlagCCW:
                        break;
                        
                    case FlagsAndCommand.FlagCW:
                        break;
                        
                    case FlagsAndCommand.FlagClose:
                        break;
                        
                    case FlagsAndCommand.FlagsMask:
                        break;
                }

                lastPosition = vertexData;
            }
        }

        private static Vector2 Reflect(Vector2 point, Vector2 mirror)
        {
            double x, y, dx, dy;
            dx = Math.Abs(mirror.X - point.X);
            dy = Math.Abs(mirror.Y - point.Y);

            if (mirror.X >= point.X)
            {
                x = mirror.X + dx;
            }
            else
            {
                x = mirror.X - dx;
            }
            if (mirror.Y >= point.Y)
            {
                y = mirror.Y + dy;
            }
            else
            {
                y = mirror.Y - dy;
            }

            return new Vector2(x, y);
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Transform\Affine.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Affine transformation classes.
//
//----------------------------------------------------------------------------
//#ifndef AGG_TRANS_AFFINE_INCLUDED
//#define AGG_TRANS_AFFINE_INCLUDED

using MatterHackers.VectorMath;

//#include <math.h>
//#include "agg_basics.h"
using System;

namespace MatterHackers.Agg.Transform
{
	//============================================================trans_affine
	//
	// See Implementation agg_trans_affine.cpp
	//
	// Affine transformation are linear transformations in Cartesian coordinates
	// (strictly speaking not only in Cartesian, but for the beginning we will
	// think so). They are rotation, scaling, translation and skewing.
	// After any affine transformation a line segment remains a line segment
	// and it will never become a curve.
	//
	// There will be no math about matrix calculations, since it has been
	// described many times. Ask yourself a very simple question:
	// "why do we need to understand and use some matrix stuff instead of just
	// rotating, scaling and so on". The answers are:
	//
	// 1. Any combination of transformations can be done by only 4 multiplications
	//    and 4 additions in floating point.
	// 2. One matrix transformation is equivalent to the number of consecutive
	//    discrete transformations, i.e. the matrix "accumulates" all transformations
	//    in the order of their settings. Suppose we have 4 transformations:
	//       * rotate by 30 degrees,
	//       * scale X to 2.0,
	//       * scale Y to 1.5,
	//       * move to (100, 100).
	//    The result will depend on the order of these transformations,
	//    and the advantage of matrix is that the sequence of discrete calls:
	//    rotate(30), scaleX(2.0), scaleY(1.5), move(100,100)
	//    will have exactly the same result as the following matrix transformations:
	//
	//    affine_matrix m;
	//    m *= rotate_matrix(30);
	//    m *= scaleX_matrix(2.0);
	//    m *= scaleY_matrix(1.5);
	//    m *= move_matrix(100,100);
	//
	//    m.transform_my_point_at_last(x, y);
	//
	// What is the good of it? In real life we will set-up the matrix only once
	// and then transform many points, let alone the convenience to set any
	// combination of transformations.
	//
	// So, how to use it? Very easy - literally as it's shown above. Not quite,
	// let us write a correct example:
	//
	// agg::trans_affine m;
	// m *= agg::trans_affine_rotation(30.0 * 3.1415926 / 180.0);
	// m *= agg::trans_affine_scaling(2.0, 1.5);
	// m *= agg::trans_affine_translation(100.0, 100.0);
	// m.transform(&x, &y);
	//
	// The affine matrix is all you need to perform any linear transformation,
	// but all transformations have origin point (0,0). It means that we need to
	// use 2 translations if we want to rotate something around (100,100):
	//
	// m *= agg::trans_affine_translation(-100.0, -100.0);         // move to (0,0)
	// m *= agg::trans_affine_rotation(30.0 * 3.1415926 / 180.0);  // rotate
	// m *= agg::trans_affine_translation(100.0, 100.0);           // move back to (100,100)
	//----------------------------------------------------------------------
	public struct Affine : ITransform
	{
		static public readonly double affine_epsilon = 1e-14;

		public double sx, shy, shx, sy, tx, ty;

		//------------------------------------------ Construction
		public Affine(Affine copyFrom)
		{
			sx = copyFrom.sx;
			shy = copyFrom.shy;
			shx = copyFrom.shx;
			sy = copyFrom.sy;
			tx = copyFrom.tx;
			ty = copyFrom.ty;
		}

		// Custom matrix. Usually used in derived classes
		public Affine(double v0, double v1, double v2,
					 double v3, double v4, double v5)
		{
			sx = v0;
			shy = v1;
			shx = v2;
			sy = v3;
			tx = v4;
			ty = v5;
		}

		// Custom matrix from m[6]
		public Affine(double[] m)
		{
			sx = m[0];
			shy = m[1];
			shx = m[2];
			sy = m[3];
			tx = m[4];
			ty = m[5];
		}

		// Identity matrix
		public static Affine NewIdentity()
		{
			Affine newAffine = new Affine();
			newAffine.sx = 1.0;
			newAffine.shy = 0.0;
			newAffine.shx = 0.0;
			newAffine.sy = 1.0;
			newAffine.tx = 0.0;
			newAffine.ty = 0.0;

			return newAffine;
		}

		//====================================================trans_affine_rotation
		// Rotation matrix. sin() and cos() are calculated twice for the same angle.
		// There's no harm because the performance of sin()/cos() is very good on all
		// modern processors. Besides, this operation is not going to be invoked too
		// often.
		public static Affine NewRotation(double AngleRadians)
		{
			return new Affine(Math.Cos(AngleRadians), Math.Sin(AngleRadians), -Math.Sin(AngleRadians), Math.Cos(AngleRadians), 0.0, 0.0);
		}

		//====================================================trans_affine_scaling
		// Scaling matrix. x, y - scale coefficients by X and Y respectively
		public static Affine NewScaling(double Scale)
		{
			return new Affine(Scale, 0.0, 0.0, Scale, 0.0, 0.0);
		}

		public static Affine NewScaling(double x, double y)
		{
			return new Affine(x, 0.0, 0.0, y, 0.0, 0.0);
		}

		public static Affine NewTranslation(double x, double y)
		{
			return new Affine(1.0, 0.0, 0.0, 1.0, x, y);
		}

		public static Affine NewTranslation(Vector2 offset)
		{
			return new Affine(1.0, 0.0, 0.0, 1.0, offset.X, offset.Y);
		}

		public static Affine NewSkewing(double x, double y)
		{
			return new Affine(1.0, Math.Tan(y), Math.Tan(x), 1.0, 0.0, 0.0);
		}

		/*
		//===============================================trans_affine_line_segment
		// Rotate, Scale and Translate, associating 0...dist with line segment
		// x1,y1,x2,y2
		public static Affine NewScaling(double x, double y)
		{
			return new Affine(x, 0.0, 0.0, y, 0.0, 0.0);
		}
		public sealed class trans_affine_line_segment : Affine
		{
			public trans_affine_line_segment(double x1, double y1, double x2, double y2,
									  double dist)
			{
				double dx = x2 - x1;
				double dy = y2 - y1;
				if (dist > 0.0)
				{
					//multiply(trans_affine_scaling(sqrt(dx * dx + dy * dy) / dist));
				}
				//multiply(trans_affine_rotation(Math.Atan2(dy, dx)));
				//multiply(trans_affine_translation(x1, y1));
			}
		};

		//============================================trans_affine_reflection_unit
		// Reflection matrix. Reflect coordinates across the line through
		// the origin containing the unit vector (ux, uy).
		// Contributed by John Horigan
		public static Affine NewScaling(double x, double y)
		{
			return new Affine(x, 0.0, 0.0, y, 0.0, 0.0);
		}
		public class trans_affine_reflection_unit : Affine
		{
			public trans_affine_reflection_unit(double ux, double uy)
				:
			  base(2.0 * ux * ux - 1.0,
						   2.0 * ux * uy,
						   2.0 * ux * uy,
						   2.0 * uy * uy - 1.0,
						   0.0, 0.0)
			{ }
		};

		//=================================================trans_affine_reflection
		// Reflection matrix. Reflect coordinates across the line through
		// the origin at the angle a or containing the non-unit vector (x, y).
		// Contributed by John Horigan
		public static Affine NewScaling(double x, double y)
		{
			return new Affine(x, 0.0, 0.0, y, 0.0, 0.0);
		}
		public sealed class trans_affine_reflection : trans_affine_reflection_unit
		{
			public trans_affine_reflection(double a)
				:
			  base(Math.Cos(a), Math.Sin(a))
			{ }

			public trans_affine_reflection(double x, double y)
				:
			  base(x / Math.Sqrt(x * x + y * y), y / Math.Sqrt(x * x + y * y))
			{ }
		};
		 */

		/*
		// Rectangle to a parallelogram.
		trans_affine(double x1, double y1, double x2, double y2, double* parl)
		{
			rect_to_parl(x1, y1, x2, y2, parl);
		}

		// Parallelogram to a rectangle.
		trans_affine(double* parl,
					 double x1, double y1, double x2, double y2)
		{
			parl_to_rect(parl, x1, y1, x2, y2);
		}

		// Arbitrary parallelogram transformation.
		trans_affine(double* src, double* dst)
		{
			parl_to_parl(src, dst);
		}

		//---------------------------------- Parallelogram transformations
		// transform a parallelogram to another one. Src and dst are
		// pointers to arrays of three points (double[6], x1,y1,...) that
		// identify three corners of the parallelograms assuming implicit
		// fourth point. The arguments are arrays of double[6] mapped
		// to x1,y1, x2,y2, x3,y3  where the coordinates are:
		//        *-----------------*
		//       /          (x3,y3)/
		//      /                 /
		//     /(x1,y1)   (x2,y2)/
		//    *-----------------*
		trans_affine parl_to_parl(double* src, double* dst)
		{
			sx  = src[2] - src[0];
			shy = src[3] - src[1];
			shx = src[4] - src[0];
			sy  = src[5] - src[1];
			tx  = src[0];
			ty  = src[1];
			invert();
			multiply(trans_affine(dst[2] - dst[0], dst[3] - dst[1],
				dst[4] - dst[0], dst[5] - dst[1],
				dst[0], dst[1]));
			return *this;
		}

		trans_affine rect_to_parl(double x1, double y1,
			double x2, double y2,
			double* parl)
		{
			double src[6];
			src[0] = x1; src[1] = y1;
			src[2] = x2; src[3] = y1;
			src[4] = x2; src[5] = y2;
			parl_to_parl(src, parl);
			return *this;
		}

		trans_affine parl_to_rect(double* parl,
			double x1, double y1,
			double x2, double y2)
		{
			double dst[6];
			dst[0] = x1; dst[1] = y1;
			dst[2] = x2; dst[3] = y1;
			dst[4] = x2; dst[5] = y2;
			parl_to_parl(parl, dst);
			return *this;
		}

		 */

		//------------------------------------------ Operations
		// Reset - load an identity matrix
		public void identity()
		{
			sx = sy = 1.0;
			shy = shx = tx = ty = 0.0;
		}

		// Direct transformations operations
		public void translate(double x, double y)
		{
			tx += x;
			ty += y;
		}

		public void rotate(double AngleRadians)
		{
			double ca = Math.Cos(AngleRadians);
			double sa = Math.Sin(AngleRadians);
			double t0 = sx * ca - shy * sa;
			double t2 = shx * ca - sy * sa;
			double t4 = tx * ca - ty * sa;
			shy = sx * sa + shy * ca;
			sy = shx * sa + sy * ca;
			ty = tx * sa + ty * ca;
			sx = t0;
			shx = t2;
			tx = t4;
		}

		public void scale(double x, double y)
		{
			double mm0 = x; // Possible hint for the optimizer
			double mm3 = y;
			sx *= mm0;
			shx *= mm0;
			tx *= mm0;
			shy *= mm3;
			sy *= mm3;
			ty *= mm3;
		}

		public void scale(double scaleAmount)
		{
			sx *= scaleAmount;
			shx *= scaleAmount;
			tx *= scaleAmount;
			shy *= scaleAmount;
			sy *= scaleAmount;
			ty *= scaleAmount;
		}

		// Multiply matrix to another one
		private void multiply(Affine m)
		{
			double t0 = sx * m.sx + shy * m.shx;
			double t2 = shx * m.sx + sy * m.shx;
			double t4 = tx * m.sx + ty * m.shx + m.tx;
			shy = sx * m.shy + shy * m.sy;
			sy = shx * m.shy + sy * m.sy;
			ty = tx * m.shy + ty * m.sy + m.ty;
			sx = t0;
			shx = t2;
			tx = t4;
		}

		/*

		// Multiply "m" to "this" and assign the result to "this"
		trans_affine premultiply(trans_affine m)
		{
			trans_affine t = m;
			return *this = t.multiply(*this);
		}

		// Multiply matrix to inverse of another one
		trans_affine multiply_inv(trans_affine m)
		{
			trans_affine t = m;
			t.invert();
			return multiply(t);
		}

		// Multiply inverse of "m" to "this" and assign the result to "this"
		trans_affine premultiply_inv(trans_affine m)
		{
			trans_affine t = m;
			t.invert();
			return *this = t.multiply(*this);
		}
		 */

		// Invert matrix. Do not try to invert degenerate matrices,
		// there's no check for validity. If you set scale to 0 and
		// then try to invert matrix, expect unpredictable result.
		public void invert()
		{
			double d = determinant_reciprocal();

			double t0 = sy * d;
			sy = sx * d;
			shy = -shy * d;
			shx = -shx * d;

			double t4 = -tx * t0 - ty * shx;
			ty = -tx * shy - ty * sy;

			sx = t0;
			tx = t4;
		}

		/*

		// Mirroring around X
		trans_affine flip_x()
		{
			sx  = -sx;
			shy = -shy;
			tx  = -tx;
			return *this;
		}

		// Mirroring around Y
		trans_affine flip_y()
		{
			shx = -shx;
			sy  = -sy;
			ty  = -ty;
			return *this;
		}

		//------------------------------------------- Load/Store
		// Store matrix to an array [6] of double
		void store_to(double* m)
		{
			*m++ = sx; *m++ = shy; *m++ = shx; *m++ = sy; *m++ = tx; *m++ = ty;
		}

		// Load matrix from an array [6] of double
		trans_affine load_from(double* m)
		{
			sx = *m++; shy = *m++; shx = *m++; sy = *m++; tx = *m++;  ty = *m++;
			return *this;
		}

		//------------------------------------------- Operators

		 */

		// Multiply the matrix by another one and return
		// the result in a separate matrix.
		public static Affine operator *(Affine a, Affine b)
		{
			Affine temp = new Affine(a);
			temp.multiply(b);
			return temp;
		}

        public override string ToString()
        {
            return $"sx: {sx}, sy: {sy}, tx: {tx}, ty: {ty}";
        }

        public static Affine operator +(Affine a, Vector2 b)
		{
			Affine temp = new Affine(a);
			temp.tx += b.X;
			temp.ty += b.Y;
			return temp;
		}

		/*

		// Multiply the matrix by inverse of another one
		// and return the result in a separate matrix.
		static trans_affine operator / (trans_affine a, trans_affine b)
		{
			return new trans_affine(a).multiply_inv(b);
		}

		// Calculate and return the inverse matrix
		static trans_affine operator ~ (trans_affine a)
		{
			new trans_affine(a).invert();
		}

		// Equal operator with default epsilon
		static bool operator == (trans_affine a, trans_affine b)
		{
			return a.is_equal(b, affine_epsilon);
		}

		// Not Equal operator with default epsilon
		static bool operator != (trans_affine a, trans_affine b)
		{
			return !a.is_equal(b, affine_epsilon);
		}

		 */

		//-------------------------------------------- Transformations
		// Direct transformation of x and y
		public void Transform(ref double x, ref double y)
		{
			double tempX = x;
			x = tempX * sx + y * shx + tx;
			y = tempX * shy + y * sy + ty;
		}

		public void transform(ref Vector2 pointToTransform)
		{
			Transform(ref pointToTransform.X, ref pointToTransform.Y);
		}

		public Vector2 Transform(Vector2 vectorIn)
		{
			var temp = vectorIn;
			Transform(ref temp.X, ref temp.Y);
			return temp;
		}

		public void transform(ref RectangleDouble rectToTransform)
		{
			Transform(ref rectToTransform.Left, ref rectToTransform.Bottom);
			Transform(ref rectToTransform.Right, ref rectToTransform.Top);
		}

		/*

		// Direct transformation of x and y, 2x2 matrix only, no translation
		void transform_2x2(double* x, double* y)
		{
			register double tmp = *x;
			*x = tmp * sx  + *y * shx;
			*y = tmp * shy + *y * sy;
		}

		 */


		public Vector2 InverseTransform(Vector2 vectorIn)
		{
			var temp = vectorIn;
			inverse_transform(ref temp.X, ref temp.Y);
			return temp;
		}

		// Inverse transformation of x and y. It works slower than the
		// direct transformation. For massive operations it's better to
		// invert() the matrix and then use direct transformations.
		public void inverse_transform(ref double x, ref double y)
		{
			double d = determinant_reciprocal();
			double a = (x - tx) * d;
			double b = (y - ty) * d;
			x = a * sy - b * shx;
			y = b * sx - a * shy;
		}

		public void inverse_transform(ref Vector2 pointToTransform)
		{
			inverse_transform(ref pointToTransform.X, ref pointToTransform.Y);
		}

		/*

		//-------------------------------------------- Auxiliary
		// Calculate the determinant of matrix
		double determinant()
		{
			return sx * sy - shy * shx;
		}

		 */

		// Calculate the reciprocal of the determinant
		private double determinant_reciprocal()
		{
			return 1.0 / (sx * sy - shy * shx);
		}

		// Get the average scale (by X and Y).
		// Basically used to calculate the approximation_scale when
		// decomposing curves into line segments.
		public double GetScale()
		{
			double x = 0.707106781 * sx + 0.707106781 * shx;
			double y = 0.707106781 * shy + 0.707106781 * sy;
			return Math.Sqrt(x * x + y * y);
		}

		// Check to see if the matrix is not degenerate
		public bool is_valid(double epsilon)
		{
			return Math.Abs(sx) > epsilon && Math.Abs(sy) > epsilon;
		}

		// Check to see if it's an identity matrix
		public bool is_identity()
		{
			return is_identity(affine_epsilon);
		}

		public bool is_identity(double epsilon)
		{
			return Util.is_equal_eps(sx, 1.0, epsilon) &&
				Util.is_equal_eps(shy, 0.0, epsilon) &&
				Util.is_equal_eps(shx, 0.0, epsilon) &&
				Util.is_equal_eps(sy, 1.0, epsilon) &&
				Util.is_equal_eps(tx, 0.0, epsilon) &&
				Util.is_equal_eps(ty, 0.0, epsilon);
		}

		// Check to see if two matrices are equal
		public bool is_equal(Affine m, double epsilon)
		{
			return Util.is_equal_eps(sx, m.sx, epsilon) &&
				Util.is_equal_eps(shy, m.shy, epsilon) &&
				Util.is_equal_eps(shx, m.shx, epsilon) &&
				Util.is_equal_eps(sy, m.sy, epsilon) &&
				Util.is_equal_eps(tx, m.tx, epsilon) &&
				Util.is_equal_eps(ty, m.ty, epsilon);
		}

		// Determine the major parameters. Use with caution considering
		// possible degenerate cases.
		public double rotation()
		{
			double x1 = 0.0;
			double y1 = 0.0;
			double x2 = 1.0;
			double y2 = 0.0;
			Transform(ref x1, ref y1);
			Transform(ref x2, ref y2);
			return Math.Atan2(y2 - y1, x2 - x1);
		}

		public void translation(out double dx, out double dy)
		{
			dx = tx;
			dy = ty;
		}

		public void scaling(out double x, out double y)
		{
			double x1 = 0.0;
			double y1 = 0.0;
			double x2 = 1.0;
			double y2 = 1.0;
			Affine t = new Affine(this);
			t *= NewRotation(-rotation());
			t.Transform(ref x1, ref y1);
			t.Transform(ref x2, ref y2);
			x = x2 - x1;
			y = y2 - y1;
		}

		public void scaling_abs(out double x, out double y)
		{
			// Used to calculate scaling coefficients in image resampling.
			// When there is considerable shear this method gives us much
			// better estimation than just sx, sy.
			x = Math.Sqrt(sx * sx + shx * shx);
			y = Math.Sqrt(shy * shy + sy * sy);
		}
	}}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Transform\Bilinear.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Bilinear 2D transformations
//
//----------------------------------------------------------------------------

namespace MatterHackers.Agg.Transform
{
	//==========================================================trans_bilinear
	public sealed class Bilinear : ITransform
	{
		private double[,] m_mtx = new double[4, 2];
		private bool m_valid;

		//--------------------------------------------------------------------
		public Bilinear()
		{
			m_valid = (false);
		}

		//--------------------------------------------------------------------
		// Arbitrary quadrangle transformations
		public Bilinear(double[] src, double[] dst)
		{
			quad_to_quad(src, dst);
		}

		//--------------------------------------------------------------------
		// Direct transformations
		public Bilinear(double x1, double y1, double x2, double y2, double[] quad)
		{
			rect_to_quad(x1, y1, x2, y2, quad);
		}

		//--------------------------------------------------------------------
		// Reverse transformations
		public Bilinear(double[] quad,
					   double x1, double y1, double x2, double y2)
		{
			quad_to_rect(quad, x1, y1, x2, y2);
		}

		//--------------------------------------------------------------------
		// Set the transformations using two arbitrary quadrangles.
		public void quad_to_quad(double[] src, double[] dst)
		{
			double[,] left = new double[4, 4];
			double[,] right = new double[4, 2];

			uint i;
			for (i = 0; i < 4; i++)
			{
				uint ix = i * 2;
				uint iy = ix + 1;
				left[i, 0] = 1.0;
				left[i, 1] = src[ix] * src[iy];
				left[i, 2] = src[ix];
				left[i, 3] = src[iy];

				right[i, 0] = dst[ix];
				right[i, 1] = dst[iy];
			}
			m_valid = simul_eq.solve(left, right, m_mtx);
		}

		//--------------------------------------------------------------------
		// Set the direct transformations, i.e., rectangle -> quadrangle
		public void rect_to_quad(double x1, double y1, double x2, double y2,
						  double[] quad)
		{
			double[] src = new double[8];
			src[0] = src[6] = x1;
			src[2] = src[4] = x2;
			src[1] = src[3] = y1;
			src[5] = src[7] = y2;
			quad_to_quad(src, quad);
		}

		//--------------------------------------------------------------------
		// Set the reverse transformations, i.e., quadrangle -> rectangle
		public void quad_to_rect(double[] quad,
						  double x1, double y1, double x2, double y2)
		{
			double[] dst = new double[8];
			dst[0] = dst[6] = x1;
			dst[2] = dst[4] = x2;
			dst[1] = dst[3] = y1;
			dst[5] = dst[7] = y2;
			quad_to_quad(quad, dst);
		}

		//--------------------------------------------------------------------
		// Check if the equations were solved successfully
		public bool is_valid()
		{
			return m_valid;
		}

		//--------------------------------------------------------------------
		// Transform a point (x, y)
		public void Transform(ref double x, ref double y)
		{
			double tx = x;
			double ty = y;
			double xy = tx * ty;
			x = m_mtx[0, 0] + m_mtx[1, 0] * xy + m_mtx[2, 0] * tx + m_mtx[3, 0] * ty;
			y = m_mtx[0, 1] + m_mtx[1, 1] * xy + m_mtx[2, 1] * tx + m_mtx[3, 1] * ty;
		}

		//--------------------------------------------------------------------
		public sealed class iterator_x
		{
			private double inc_x;
			private double inc_y;

			public double x;
			public double y;

			public iterator_x()
			{
			}

			public iterator_x(double tx, double ty, double step, double[,] m)
			{
				inc_x = (m[1, 0] * step * ty + m[2, 0] * step);
				inc_y = (m[1, 1] * step * ty + m[2, 1] * step);
				x = (m[0, 0] + m[1, 0] * tx * ty + m[2, 0] * tx + m[3, 0] * ty);
				y = (m[0, 1] + m[1, 1] * tx * ty + m[2, 1] * tx + m[3, 1] * ty);
			}

			public static iterator_x operator ++(iterator_x a)
			{
				a.x += a.inc_x;
				a.y += a.inc_y;

				return a;
			}
		};

		public iterator_x begin(double x, double y, double step)
		{
			return new iterator_x(x, y, step, m_mtx);
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Transform\ITransform.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
namespace MatterHackers.Agg.Transform
{
	public interface ITransform
	{
		void Transform(ref double x, ref double y);
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Transform\Perspective.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Perspective 2D transformations
//
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg.Transform
{
	//=======================================================trans_perspective
	public sealed class Perspective : ITransform
	{
		static public readonly double affine_epsilon = 1e-14;
		public double sx, shy, w0, shx, sy, w1, tx, ty, w2;

		//-------------------------------------------------------ruction
		// Identity matrix
		public Perspective()
		{
			sx = (1); shy = (0); w0 = (0);
			shx = (0); sy = (1); w1 = (0);
			tx = (0); ty = (0); w2 = (1);
		}

		// Custom matrix
		public Perspective(double v0, double v1, double v2,
						  double v3, double v4, double v5,
						  double v6, double v7, double v8)
		{
			sx = (v0); shy = (v1); w0 = (v2);
			shx = (v3); sy = (v4); w1 = (v5);
			tx = (v6); ty = (v7); w2 = (v8);
		}

		// Custom matrix from m[9]
		public Perspective(double[] m)
		{
			sx = (m[0]); shy = (m[1]); w0 = (m[2]);
			shx = (m[3]); sy = (m[4]); w1 = (m[5]);
			tx = (m[6]); ty = (m[7]); w2 = (m[8]);
		}

		// From affine
		public Perspective(Affine a)
		{
			sx = (a.sx); shy = (a.shy); w0 = (0);
			shx = (a.shx); sy = (a.sy); w1 = (0);
			tx = (a.tx); ty = (a.ty); w2 = (1);
		}

		// From trans_perspective
		public Perspective(Perspective a)
		{
			sx = (a.sx); shy = (a.shy); w0 = a.w0;
			shx = (a.shx); sy = (a.sy); w1 = a.w1;
			tx = (a.tx); ty = (a.ty); w2 = a.w2;
		}

		// Rectangle to quadrilateral
		public Perspective(double x1, double y1, double x2, double y2, double[] quad)
		{
			rect_to_quad(x1, y1, x2, y2, quad);
		}

		// Quadrilateral to rectangle
		public Perspective(double[] quad, double x1, double y1, double x2, double y2)
		{
			quad_to_rect(quad, x1, y1, x2, y2);
		}

		// Arbitrary quadrilateral transformations
		public Perspective(double[] src, double[] dst)
		{
			quad_to_quad(src, dst);
		}

		public void Set(Perspective Other)
		{
			sx = Other.sx;
			shy = Other.shy;
			w0 = Other.w0;
			shx = Other.shx;
			sy = Other.sy;
			w1 = Other.w1;
			tx = Other.tx;
			ty = Other.ty;
			w2 = Other.w2;
		}

		//-------------------------------------- Quadrilateral transformations
		// The arguments are double[8] that are mapped to quadrilaterals:
		// x1,y1, x2,y2, x3,y3, x4,y4
		public bool quad_to_quad(double[] qs, double[] qd)
		{
			Perspective p = new Perspective();
			if (!quad_to_square(qs)) return false;
			if (!p.square_to_quad(qd)) return false;
			multiply(p);
			return true;
		}

		public bool rect_to_quad(double x1, double y1, double x2, double y2, double[] q)
		{
			double[] r = new double[8];
			r[0] = r[6] = x1;
			r[2] = r[4] = x2;
			r[1] = r[3] = y1;
			r[5] = r[7] = y2;
			return quad_to_quad(r, q);
		}

		public bool quad_to_rect(double[] q, double x1, double y1, double x2, double y2)
		{
			double[] r = new double[8];
			r[0] = r[6] = x1;
			r[2] = r[4] = x2;
			r[1] = r[3] = y1;
			r[5] = r[7] = y2;
			return quad_to_quad(q, r);
		}

		// Map square (0,0,1,1) to the quadrilateral and vice versa
		public bool square_to_quad(double[] q)
		{
			double dx = q[0] - q[2] + q[4] - q[6];
			double dy = q[1] - q[3] + q[5] - q[7];
			if (dx == 0.0 && dy == 0.0)
			{
				// Affine case (parallelogram)
				//---------------
				sx = q[2] - q[0];
				shy = q[3] - q[1];
				w0 = 0.0;
				shx = q[4] - q[2];
				sy = q[5] - q[3];
				w1 = 0.0;
				tx = q[0];
				ty = q[1];
				w2 = 1.0;
			}
			else
			{
				double dx1 = q[2] - q[4];
				double dy1 = q[3] - q[5];
				double dx2 = q[6] - q[4];
				double dy2 = q[7] - q[5];
				double den = dx1 * dy2 - dx2 * dy1;
				if (den == 0.0)
				{
					// Singular case
					//---------------
					sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;
					return false;
				}
				// General case
				//---------------
				double u = (dx * dy2 - dy * dx2) / den;
				double v = (dy * dx1 - dx * dy1) / den;
				sx = q[2] - q[0] + u * q[2];
				shy = q[3] - q[1] + u * q[3];
				w0 = u;
				shx = q[6] - q[0] + v * q[6];
				sy = q[7] - q[1] + v * q[7];
				w1 = v;
				tx = q[0];
				ty = q[1];
				w2 = 1.0;
			}
			return true;
		}

		public bool quad_to_square(double[] q)
		{
			if (!square_to_quad(q)) return false;
			invert();
			return true;
		}

		//--------------------------------------------------------- Operations
		public Perspective from_affine(Affine a)
		{
			sx = a.sx; shy = a.shy; w0 = 0;
			shx = a.shx; sy = a.sy; w1 = 0;
			tx = a.tx; ty = a.ty; w2 = 1;
			return this;
		}

		// Reset - load an identity matrix
		public Perspective reset()
		{
			sx = 1; shy = 0; w0 = 0;
			shx = 0; sy = 1; w1 = 0;
			tx = 0; ty = 0; w2 = 1;
			return this;
		}

		// Invert matrix. Returns false in degenerate case
		public bool invert()
		{
			double d0 = sy * w2 - w1 * ty;
			double d1 = w0 * ty - shy * w2;
			double d2 = shy * w1 - w0 * sy;
			double d = sx * d0 + shx * d1 + tx * d2;
			if (d == 0.0)
			{
				sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;
				return false;
			}
			d = 1.0 / d;
			Perspective a = new Perspective(this);
			sx = d * d0;
			shy = d * d1;
			w0 = d * d2;
			shx = d * (a.w1 * a.tx - a.shx * a.w2);
			sy = d * (a.sx * a.w2 - a.w0 * a.tx);
			w1 = d * (a.w0 * a.shx - a.sx * a.w1);
			tx = d * (a.shx * a.ty - a.sy * a.tx);
			ty = d * (a.shy * a.tx - a.sx * a.ty);
			w2 = d * (a.sx * a.sy - a.shy * a.shx);
			return true;
		}

		// Direct transformations operations
		public Perspective translate(double x, double y)
		{
			tx += x;
			ty += y;
			return this;
		}

		public Perspective rotate(double a)
		{
			multiply(Affine.NewRotation(a));
			return this;
		}

		public Perspective scale(double s)
		{
			multiply(Affine.NewScaling(s));
			return this;
		}

		public Perspective scale(double x, double y)
		{
			multiply(Affine.NewScaling(x, y));
			return this;
		}

		public Perspective multiply(Perspective a)
		{
			Perspective b = new Perspective(this);
			sx = a.sx * b.sx + a.shx * b.shy + a.tx * b.w0;
			shx = a.sx * b.shx + a.shx * b.sy + a.tx * b.w1;
			tx = a.sx * b.tx + a.shx * b.ty + a.tx * b.w2;
			shy = a.shy * b.sx + a.sy * b.shy + a.ty * b.w0;
			sy = a.shy * b.shx + a.sy * b.sy + a.ty * b.w1;
			ty = a.shy * b.tx + a.sy * b.ty + a.ty * b.w2;
			w0 = a.w0 * b.sx + a.w1 * b.shy + a.w2 * b.w0;
			w1 = a.w0 * b.shx + a.w1 * b.sy + a.w2 * b.w1;
			w2 = a.w0 * b.tx + a.w1 * b.ty + a.w2 * b.w2;
			return this;
		}

		//------------------------------------------------------------------------
		public Perspective multiply(Affine a)
		{
			Perspective b = new Perspective(this);
			sx = a.sx * b.sx + a.shx * b.shy + a.tx * b.w0;
			shx = a.sx * b.shx + a.shx * b.sy + a.tx * b.w1;
			tx = a.sx * b.tx + a.shx * b.ty + a.tx * b.w2;
			shy = a.shy * b.sx + a.sy * b.shy + a.ty * b.w0;
			sy = a.shy * b.shx + a.sy * b.sy + a.ty * b.w1;
			ty = a.shy * b.tx + a.sy * b.ty + a.ty * b.w2;
			return this;
		}

		//------------------------------------------------------------------------
		public Perspective premultiply(Perspective b)
		{
			Perspective a = new Perspective(this);
			sx = a.sx * b.sx + a.shx * b.shy + a.tx * b.w0;
			shx = a.sx * b.shx + a.shx * b.sy + a.tx * b.w1;
			tx = a.sx * b.tx + a.shx * b.ty + a.tx * b.w2;
			shy = a.shy * b.sx + a.sy * b.shy + a.ty * b.w0;
			sy = a.shy * b.shx + a.sy * b.sy + a.ty * b.w1;
			ty = a.shy * b.tx + a.sy * b.ty + a.ty * b.w2;
			w0 = a.w0 * b.sx + a.w1 * b.shy + a.w2 * b.w0;
			w1 = a.w0 * b.shx + a.w1 * b.sy + a.w2 * b.w1;
			w2 = a.w0 * b.tx + a.w1 * b.ty + a.w2 * b.w2;
			return this;
		}

		//------------------------------------------------------------------------
		public Perspective premultiply(Affine b)
		{
			Perspective a = new Perspective(this);
			sx = a.sx * b.sx + a.shx * b.shy;
			shx = a.sx * b.shx + a.shx * b.sy;
			tx = a.sx * b.tx + a.shx * b.ty + a.tx;
			shy = a.shy * b.sx + a.sy * b.shy;
			sy = a.shy * b.shx + a.sy * b.sy;
			ty = a.shy * b.tx + a.sy * b.ty + a.ty;
			w0 = a.w0 * b.sx + a.w1 * b.shy;
			w1 = a.w0 * b.shx + a.w1 * b.sy;
			w2 = a.w0 * b.tx + a.w1 * b.ty + a.w2;
			return this;
		}

		//------------------------------------------------------------------------
		public Perspective multiply_inv(Perspective m)
		{
			Perspective t = m;
			t.invert();
			return multiply(t);
		}

		//------------------------------------------------------------------------
		public Perspective trans_perspectivemultiply_inv(Affine m)
		{
			Affine t = m;
			t.invert();
			return multiply(t);
		}

		//------------------------------------------------------------------------
		public Perspective premultiply_inv(Perspective m)
		{
			Perspective t = m;
			t.invert();
			Set(t.multiply(this));
			return this;
		}

		// Multiply inverse of "m" by "this" and assign the result to "this"
		public Perspective premultiply_inv(Affine m)
		{
			Perspective t = new Perspective(m);
			t.invert();
			Set(t.multiply(this));
			return this;
		}

		//--------------------------------------------------------- Load/Store
		public void store_to(double[] m)
		{
			m[0] = sx; m[1] = shy; m[2] = w0;
			m[3] = shx; m[4] = sy; m[5] = w1;
			m[6] = tx; m[7] = ty; m[8] = w2;
		}

		//------------------------------------------------------------------------
		public Perspective load_from(double[] m)
		{
			sx = m[0]; shy = m[1]; w0 = m[2];
			shx = m[3]; sy = m[4]; w1 = m[5];
			tx = m[6]; ty = m[7]; w2 = m[8];
			return this;
		}

		//---------------------------------------------------------- Operators
		// Multiply the matrix by another one and return the result in a separate matrix.
		public static Perspective operator *(Perspective a, Perspective b)
		{
			Perspective temp = a;
			temp.multiply(b);

			return temp;
		}

		// Multiply the matrix by another one and return the result in a separate matrix.
		public static Perspective operator *(Perspective a, Affine b)
		{
			Perspective temp = a;
			temp.multiply(b);

			return temp;
		}

		// Multiply the matrix by inverse of another one and return the result in a separate matrix.
		public static Perspective operator /(Perspective a, Perspective b)
		{
			Perspective temp = a;
			temp.multiply_inv(b);

			return temp;
		}

		// Calculate and return the inverse matrix
		public static Perspective operator ~(Perspective b)
		{
			Perspective ret = b;
			ret.invert();
			return ret;
		}

		// Equal operator with default epsilon
		public static bool operator ==(Perspective a, Perspective b)
		{
			return a.is_equal(b, affine_epsilon);
		}

		// Not Equal operator with default epsilon
		public static bool operator !=(Perspective a, Perspective b)
		{
			return !a.is_equal(b, affine_epsilon);
		}

		public override bool Equals(object obj)
		{
			return base.Equals(obj);
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		//---------------------------------------------------- Transformations
		// Direct transformation of x and y
		public void Transform(ref double px, ref double py)
		{
			double x = px;
			double y = py;
			double m = 1.0 / (x * w0 + y * w1 + w2);
			px = m * (x * sx + y * shx + tx);
			py = m * (x * shy + y * sy + ty);
		}

		// Direct transformation of x and y, affine part only
		public void transform_affine(ref double x, ref double y)
		{
			double tmp = x;
			x = tmp * sx + y * shx + tx;
			y = tmp * shy + y * sy + ty;
		}

		// Direct transformation of x and y, 2x2 matrix only, no translation
		public void transform_2x2(ref double x, ref double y)
		{
			double tmp = x;
			x = tmp * sx + y * shx;
			y = tmp * shy + y * sy;
		}

		// Inverse transformation of x and y. It works slow because
		// it explicitly inverts the matrix on every call. For massive
		// operations it's better to invert() the matrix and then use
		// direct transformations.
		public void inverse_transform(ref double x, ref double y)
		{
			Perspective t = new Perspective(this);
			if (t.invert()) t.Transform(ref x, ref y);
		}

		//---------------------------------------------------------- Auxiliary
		public double determinant()
		{
			return sx * (sy * w2 - ty * w1) +
				   shx * (ty * w0 - shy * w2) +
				   tx * (shy * w1 - sy * w0);
		}

		public double determinant_reciprocal()
		{
			return 1.0 / determinant();
		}

		public bool is_valid()
		{
			return is_valid(affine_epsilon);
		}

		public bool is_valid(double epsilon)
		{
			return Math.Abs(sx) > epsilon && Math.Abs(sy) > epsilon && Math.Abs(w2) > epsilon;
		}

		public bool is_identity()
		{
			return is_identity(affine_epsilon);
		}

		public bool is_identity(double epsilon)
		{
			return Util.is_equal_eps(sx, 1.0, epsilon) &&
				   Util.is_equal_eps(shy, 0.0, epsilon) &&
				   Util.is_equal_eps(w0, 0.0, epsilon) &&
				   Util.is_equal_eps(shx, 0.0, epsilon) &&
				   Util.is_equal_eps(sy, 1.0, epsilon) &&
				   Util.is_equal_eps(w1, 0.0, epsilon) &&
				   Util.is_equal_eps(tx, 0.0, epsilon) &&
				   Util.is_equal_eps(ty, 0.0, epsilon) &&
				   Util.is_equal_eps(w2, 1.0, epsilon);
		}

		public bool is_equal(Perspective m)
		{
			return is_equal(m, affine_epsilon);
		}

		public bool is_equal(Perspective m, double epsilon)
		{
			return Util.is_equal_eps(sx, m.sx, epsilon) &&
				   Util.is_equal_eps(shy, m.shy, epsilon) &&
				   Util.is_equal_eps(w0, m.w0, epsilon) &&
				   Util.is_equal_eps(shx, m.shx, epsilon) &&
				   Util.is_equal_eps(sy, m.sy, epsilon) &&
				   Util.is_equal_eps(w1, m.w1, epsilon) &&
				   Util.is_equal_eps(tx, m.tx, epsilon) &&
				   Util.is_equal_eps(ty, m.ty, epsilon) &&
				   Util.is_equal_eps(w2, m.w2, epsilon);
		}

		// Determine the major affine parameters. Use with caution
		// considering possible degenerate cases.
		public double scale()
		{
			double x = 0.707106781 * sx + 0.707106781 * shx;
			double y = 0.707106781 * shy + 0.707106781 * sy;
			return Math.Sqrt(x * x + y * y);
		}

		public double rotation()
		{
			double x1 = 0.0;
			double y1 = 0.0;
			double x2 = 1.0;
			double y2 = 0.0;
			Transform(ref x1, ref y1);
			Transform(ref x2, ref y2);
			return Math.Atan2(y2 - y1, x2 - x1);
		}

		public void translation(out double dx, out double dy)
		{
			dx = tx;
			dy = ty;
		}

		public void scaling(out double x, out double y)
		{
			double x1 = 0.0;
			double y1 = 0.0;
			double x2 = 1.0;
			double y2 = 1.0;
			Perspective t = new Perspective(this);
			t *= Affine.NewRotation(-rotation());
			t.Transform(ref x1, ref y1);
			t.Transform(ref x2, ref y2);
			x = x2 - x1;
			y = y2 - y1;
		}

		public void scaling_abs(out double x, out double y)
		{
			x = Math.Sqrt(sx * sx + shx * shx);
			y = Math.Sqrt(shy * shy + sy * sy);
		}

		//--------------------------------------------------------------------
		public sealed class iterator_x
		{
			private double den;
			private double den_step;
			private double nom_x;
			private double nom_x_step;
			private double nom_y;
			private double nom_y_step;

			public double x;
			public double y;

			public iterator_x()
			{
			}

			public iterator_x(double px, double py, double step, Perspective m)
			{
				den = (px * m.w0 + py * m.w1 + m.w2);
				den_step = (m.w0 * step);
				nom_x = (px * m.sx + py * m.shx + m.tx);
				nom_x_step = (step * m.sx);
				nom_y = (px * m.shy + py * m.sy + m.ty);
				nom_y_step = (step * m.shy);
				x = (nom_x / den);
				y = (nom_y / den);
			}

			public static iterator_x operator ++(iterator_x a)
			{
				a.den += a.den_step;
				a.nom_x += a.nom_x_step;
				a.nom_y += a.nom_y_step;
				double d = 1.0 / a.den;
				a.x = a.nom_x * d;
				a.y = a.nom_y * d;

				return a;
			}
		};

		//--------------------------------------------------------------------
		public iterator_x begin(double x, double y, double step)
		{
			return new iterator_x(x, y, step, this);
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Transform\Viewport.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Viewport transformer - simple orthogonal conversions from world coordinates
//                        to screen (device) ones.
//
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg.Transform
{
	//----------------------------------------------------------trans_viewport
	public sealed class Viewport
	{
		private double m_world_x1;
		private double m_world_y1;
		private double m_world_x2;
		private double m_world_y2;
		private double m_device_x1;
		private double m_device_y1;
		private double m_device_x2;
		private double m_device_y2;
		private aspect_ratio_e m_aspect;
		private bool m_is_valid;
		private double m_align_x;
		private double m_align_y;
		private double m_wx1;
		private double m_wy1;
		private double m_wx2;
		private double m_wy2;
		private double m_dx1;
		private double m_dy1;
		private double m_kx;
		private double m_ky;

		public enum aspect_ratio_e
		{
			aspect_ratio_stretch,
			aspect_ratio_meet,
			aspect_ratio_slice
		};

		//-------------------------------------------------------------------
		public Viewport()
		{
			m_world_x1 = (0.0);
			m_world_y1 = (0.0);
			m_world_x2 = (1.0);
			m_world_y2 = (1.0);
			m_device_x1 = (0.0);
			m_device_y1 = (0.0);
			m_device_x2 = (1.0);
			m_device_y2 = (1.0);
			m_aspect = aspect_ratio_e.aspect_ratio_stretch;
			m_is_valid = (true);
			m_align_x = (0.5);
			m_align_y = (0.5);
			m_wx1 = (0.0);
			m_wy1 = (0.0);
			m_wx2 = (1.0);
			m_wy2 = (1.0);
			m_dx1 = (0.0);
			m_dy1 = (0.0);
			m_kx = (1.0);
			m_ky = (1.0);
		}

		//-------------------------------------------------------------------
		public void preserve_aspect_ratio(double alignx,
								   double aligny,
								   aspect_ratio_e aspect)
		{
			m_align_x = alignx;
			m_align_y = aligny;
			m_aspect = aspect;
			update();
		}

		//-------------------------------------------------------------------
		public void device_viewport(double x1, double y1, double x2, double y2)
		{
			m_device_x1 = x1;
			m_device_y1 = y1;
			m_device_x2 = x2;
			m_device_y2 = y2;
			update();
		}

		//-------------------------------------------------------------------
		public void world_viewport(double x1, double y1, double x2, double y2)
		{
			m_world_x1 = x1;
			m_world_y1 = y1;
			m_world_x2 = x2;
			m_world_y2 = y2;
			update();
		}

		//-------------------------------------------------------------------
		public void device_viewport(out double x1, out double y1, out double x2, out double y2)
		{
			x1 = m_device_x1;
			y1 = m_device_y1;
			x2 = m_device_x2;
			y2 = m_device_y2;
		}

		//-------------------------------------------------------------------
		public void world_viewport(out double x1, out double y1, out double x2, out double y2)
		{
			x1 = m_world_x1;
			y1 = m_world_y1;
			x2 = m_world_x2;
			y2 = m_world_y2;
		}

		//-------------------------------------------------------------------
		public void world_viewport_actual(out double x1, out double y1,
								   out double x2, out double y2)
		{
			x1 = m_wx1;
			y1 = m_wy1;
			x2 = m_wx2;
			y2 = m_wy2;
		}

		//-------------------------------------------------------------------
		public bool is_valid()
		{
			return m_is_valid;
		}

		public double align_x()
		{
			return m_align_x;
		}

		public double align_y()
		{
			return m_align_y;
		}

		public aspect_ratio_e aspect_ratio()
		{
			return m_aspect;
		}

		//-------------------------------------------------------------------
		public void transform(ref double x, ref double y)
		{
			x = (x - m_wx1) * m_kx + m_dx1;
			y = (y - m_wy1) * m_ky + m_dy1;
		}

		//-------------------------------------------------------------------
		public void transform_scale_only(ref double x, ref double y)
		{
			x *= m_kx;
			y *= m_ky;
		}

		//-------------------------------------------------------------------
		public void inverse_transform(ref double x, ref double y)
		{
			x = (x - m_dx1) / m_kx + m_wx1;
			y = (y - m_dy1) / m_ky + m_wy1;
		}

		//-------------------------------------------------------------------
		public void inverse_transform_scale_only(ref double x, ref double y)
		{
			x /= m_kx;
			y /= m_ky;
		}

		//-------------------------------------------------------------------
		public double device_dx()
		{
			return m_dx1 - m_wx1 * m_kx;
		}

		public double device_dy()
		{
			return m_dy1 - m_wy1 * m_ky;
		}

		//-------------------------------------------------------------------
		public double scale_x()
		{
			return m_kx;
		}

		//-------------------------------------------------------------------
		public double scale_y()
		{
			return m_ky;
		}

		//-------------------------------------------------------------------
		public double scale()
		{
			return (m_kx + m_ky) * 0.5;
		}

		//-------------------------------------------------------------------
		public Affine to_affine()
		{
			Affine mtx = Affine.NewTranslation(-m_wx1, -m_wy1);
			mtx *= Affine.NewScaling(m_kx, m_ky);
			mtx *= Affine.NewTranslation(m_dx1, m_dy1);
			return mtx;
		}

		//-------------------------------------------------------------------
		public Affine to_affine_scale_only()
		{
			return Affine.NewScaling(m_kx, m_ky);
		}

		private void update()
		{
			double epsilon = 1e-30;
			if (Math.Abs(m_world_x1 - m_world_x2) < epsilon ||
			   Math.Abs(m_world_y1 - m_world_y2) < epsilon ||
			   Math.Abs(m_device_x1 - m_device_x2) < epsilon ||
			   Math.Abs(m_device_y1 - m_device_y2) < epsilon)
			{
				m_wx1 = m_world_x1;
				m_wy1 = m_world_y1;
				m_wx2 = m_world_x1 + 1.0;
				m_wy2 = m_world_y2 + 1.0;
				m_dx1 = m_device_x1;
				m_dy1 = m_device_y1;
				m_kx = 1.0;
				m_ky = 1.0;
				m_is_valid = false;
				return;
			}

			double world_x1 = m_world_x1;
			double world_y1 = m_world_y1;
			double world_x2 = m_world_x2;
			double world_y2 = m_world_y2;
			double device_x1 = m_device_x1;
			double device_y1 = m_device_y1;
			double device_x2 = m_device_x2;
			double device_y2 = m_device_y2;
			if (m_aspect != aspect_ratio_e.aspect_ratio_stretch)
			{
				double d;
				m_kx = (device_x2 - device_x1) / (world_x2 - world_x1);
				m_ky = (device_y2 - device_y1) / (world_y2 - world_y1);

				if ((m_aspect == aspect_ratio_e.aspect_ratio_meet) == (m_kx < m_ky))
				{
					d = (world_y2 - world_y1) * m_ky / m_kx;
					world_y1 += (world_y2 - world_y1 - d) * m_align_y;
					world_y2 = world_y1 + d;
				}
				else
				{
					d = (world_x2 - world_x1) * m_kx / m_ky;
					world_x1 += (world_x2 - world_x1 - d) * m_align_x;
					world_x2 = world_x1 + d;
				}
			}
			m_wx1 = world_x1;
			m_wy1 = world_y1;
			m_wx2 = world_x2;
			m_wy2 = world_y2;
			m_dx1 = device_x1;
			m_dy1 = device_y1;
			m_kx = (device_x2 - device_x1) / (world_x2 - world_x1);
			m_ky = (device_y2 - device_y1) / (world_y2 - world_y1);
			m_is_valid = true;
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\Util.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
// #define USE_UNSAFE // no real code for this yet

using MatterHackers.Agg.Image;
using MatterHackers.Agg.RasterizerScanline;
using MatterHackers.Agg.Transform;
using MatterHackers.Agg.VertexSource;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using static MatterHackers.Agg.ScanlineRasterizer;
using static System.Net.WebRequestMethods;

namespace MatterHackers.Agg
{
    static public class Util
    {
        //----------------------------------------------------------filling_rule_e
        public enum filling_rule_e
        {
            fill_non_zero,
            fill_even_odd
        }

        public static double GetRatio(double startRatio, double endRatio, int index, int count)
        {
            return startRatio + (endRatio - startRatio) * index / count;
        }

        public static double GetRatio(double startRatio, double endRatio, double partialRatio)
        {
            return startRatio + (endRatio - startRatio) * partialRatio;
        }


        public static void memcpy(byte[] dest, int destIndex, byte[] source, int sourceIndex, int count)
        {
#if USE_UNSAFE
#else
            for (int i = 0; i < count; i++)
            {
                dest[destIndex + i] = source[sourceIndex + i];
            }
#endif
        }

        public static string AddQueryPram(string url, string key, string value)
        {
            if (url.Contains("?"))
            {
                return url + "&" + key + "=" + value;
            }
            else
            {
                return url + "?" + key + "=" + value;
            }
        }

        public static double ParseDouble(string source, bool fastSimpleNumbers)
        {
            int startIndex = 0;
            return ParseDouble(source, ref startIndex, fastSimpleNumbers);
        }

        // private static Regex numberRegex = new Regex(@"[-+]?[0-9]*\.?[0-9]+");
        private static Regex numberRegex = new Regex(@"[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?");

        private static double GetNextNumber(string source, ref int startIndex)
        {
            Match numberMatch = numberRegex.Match(source, startIndex);
            string returnString = numberMatch.Value;
            startIndex = numberMatch.Index + numberMatch.Length;
            double returnVal;
            double.TryParse(returnString, NumberStyles.Number, CultureInfo.InvariantCulture, out returnVal);
            return returnVal;
        }

        public static void CopyFilesWithProgress(IEnumerable<string> sourceFiles,
            string destinationPath,
            Action<double, string> reporter,
            CancellationTokenSource cancellationToken,
            string copyProgressMessage = "Copying")
        {
            var count = sourceFiles.Count();
            var i = 0;
            foreach (var file in sourceFiles)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    break;
                }
                var destination = Path.Combine(destinationPath, Path.GetFileName(file));
                var completedRatio = (double)i / count;
                CopyFileWithProgress(file, destination, (ratio, message) => reporter?.Invoke(completedRatio + ratio / count, message), copyProgressMessage);
                i++;
            }
            reporter?.Invoke(1, copyProgressMessage);
        }

        public static void CopyFileWithProgress(string sourceFile, string destinationFile, Action<double, string> reporter, string copyProgressMessage = "Copying")
        {
            const int bufferSize = 1024 * 1024; // 1MB buffer
            byte[] buffer = new byte[bufferSize];
            int bytesRead;

            using (FileStream sourceStream = new FileStream(sourceFile, FileMode.Open, FileAccess.Read))
            {
                long totalBytes = sourceStream.Length;
                using (FileStream destinationStream = new FileStream(destinationFile, FileMode.Create, FileAccess.Write))
                {
                    while ((bytesRead = sourceStream.Read(buffer, 0, bufferSize)) > 0)
                    {
                        destinationStream.Write(buffer, 0, bytesRead);
                        reporter?.Invoke((double)destinationStream.Position / totalBytes, copyProgressMessage);
                    }
                }
            }
        }

        public static double ParseDouble(string source, ref int startIndex, bool fastSimpleNumbers)
        {
#if true
            if (fastSimpleNumbers)
            {
                return ParseDoubleFast(source, ref startIndex);
            }

            return GetNextNumber(source, ref startIndex);
#else
			int startIndexNew = startIndex;
			double newNumber = agg_basics.ParseDoubleFast(source, ref startIndexNew);
			int startIndexOld = startIndex;
			double oldNumber = GetNextNumber(source, ref startIndexOld);
			if (Math.Abs(newNumber - oldNumber) > .0001
				|| startIndexNew != startIndexOld)
			{
				int a = 0;
			}

			startIndex = startIndexNew;
			return newNumber;
#endif
        }

        private static Regex fileNameNumberMatch = new Regex("\\(\\d+\\)\\s*$", RegexOptions.Compiled);
        private static Regex fileNameUnderscoreNumberMatch = new Regex("_\\d+\\s*$", RegexOptions.Compiled);

        /// <summary>
        /// The GetNonCollidingFileName method in the Util class is used to generate a non-colliding 
        /// file name by appending a unique number to the original file name.
        /// </summary>
        /// <param name="pathAndFilename"></param>
        /// <returns>The name</returns>
        public static string GetNonCollidingFileName(string pathAndFilename)
        {
            string extension = Path.GetExtension(pathAndFilename);

            // get the file name without the path
            string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(Path.GetFileName(pathAndFilename));

            var directory = Path.GetDirectoryName(pathAndFilename);
            var existingSimilarFilenames = Directory.GetFiles(directory, "*.*");
            // remove all the file extensions
            existingSimilarFilenames = existingSimilarFilenames.Select(f => Path.GetFileNameWithoutExtension(f)).ToArray();

            var validName = Util.GetNonCollidingName(fileNameWithoutExtension, new HashSet<string>(existingSimilarFilenames));

            // return the validName with path and extension
            return Path.Combine(directory, validName) + extension;
        }

        public static string GetNonCollidingName(string desiredName, HashSet<string> listToCheck, bool lookForParens = true)
        {
            return GetNonCollidingName(desiredName, (name) => !listToCheck.Contains(name), lookForParens);
        }

        public static string GetNonCollidingName(string desiredName, Func<string, bool> isUnique, bool lookForParens = true)
        {
            if (desiredName == null)
            {
                desiredName = "No Name";
            }

            if (isUnique(desiredName))
            {
                return desiredName;
            }
            else
            {
                if (lookForParens)
                {
                    // Drop bracketed number sections from our source filename to ensure we don't generate something like "file (1) (1).amf"
                    if (desiredName.Contains("("))
                    {
                        desiredName = fileNameNumberMatch.Replace(desiredName, "").Trim();
                    }

                    int nextNumberToTry = 1;
                    string candidateName;

                    do
                    {
                        candidateName = $"{desiredName} ({nextNumberToTry++})";
                    } while (!isUnique(candidateName));

                    return candidateName;
                }
                else
                {
                    // Drop the number sections from our source filename to ensure we don't generate something like "file_1_1.amf"
                    desiredName = fileNameUnderscoreNumberMatch.Replace(desiredName, "").Trim();

                    int nextNumberToTry = 1;
                    string candidateName;

                    do
                    {
                        candidateName = $"{desiredName}_{nextNumberToTry++}";
                    } while (!isUnique(candidateName));

                    return candidateName;
                }
            }
        }

        private static double ParseDoubleFast(string source, ref int startIndex)
        {
            int length = source.Length;
            bool negative = false;
            long currentIntPart = 0;
            int fractionDigits = 0;
            long currentFractionPart = 0;
            bool foundNumber = false;

            // find the number start
            while (startIndex < length)
            {
                char next = source[startIndex];
                if (next == '.' || next == '-' || next == '+' || (next >= '0' && next <= '9'))
                {
                    if (next == '.')
                    {
                        break;
                    }

                    if (next == '-')
                    {
                        negative = true;
                    }
                    else if (next == '+')
                    {
                        // this does nothing but lets us get to the else for numbers
                    }
                    else
                    {
                        currentIntPart = next - '0';
                        foundNumber = true;
                    }

                    startIndex++;
                    break;
                }

                startIndex++;
            }

            // accumulate the int part
            while (startIndex < length)
            {
                char next = source[startIndex];
                if (next >= '0' && next <= '9')
                {
                    currentIntPart = (currentIntPart * 10) + next - '0';
                    foundNumber = true;
                }
                else if (next == '.')
                {
                    foundNumber = true;
                    startIndex++;
                    // parse out the fractional part
                    while (startIndex < length)
                    {
                        char nextFraction = source[startIndex];
                        if (nextFraction >= '0' && nextFraction <= '9')
                        {
                            fractionDigits++;
                            currentFractionPart = (currentFractionPart * 10) + nextFraction - '0';
                        }
                        else // we are done
                        {
                            break;
                        }

                        startIndex++;
                    }

                    break;
                }
                else if (!foundNumber && next == ' ')
                {
                    // happy to skip spaces
                }
                else // we are done
                {
                    break;
                }

                startIndex++;
            }

            if (fractionDigits > 0)
            {
                double fractionNumber = currentIntPart + (currentFractionPart / Math.Pow(10.0, fractionDigits));
                if (negative)
                {
                    return -fractionNumber;
                }

                return fractionNumber;
            }
            else
            {
                if (negative)
                {
                    return -currentIntPart;
                }

                return currentIntPart;
            }
        }

        public static int Clamp(int value, int min, int max)
        {
            bool changed = false;
            return Clamp(value, min, max, ref changed);
        }

        public static int Clamp(int value, int min, int max, ref bool changed)
        {
            min = Math.Min(min, max);

            if (value < min)
            {
                value = min;
                changed = true;
            }

            if (value > max)
            {
                value = max;
                changed = true;
            }

            return value;
        }

        public static double Clamp(double value, double min, double max)
        {
            bool changed = false;
            return Clamp(value, min, max, ref changed);
        }

        public static double Clamp(double value, double min, double max, ref bool changed)
        {
            min = Math.Min(min, max);

            if (value < min)
            {
                value = min;
                changed = true;
            }

            if (value > max)
            {
                value = max;
                changed = true;
            }

            return value;
        }

        public static byte[] GetBytes(string str)
        {
            byte[] bytes = new byte[str.Length * sizeof(char)];
            System.Buffer.BlockCopy(str.ToCharArray(), 0, bytes, 0, bytes.Length);
            return bytes;
        }

        public static ulong GetLongHashCode(this string data, ulong hash = 14695981039346656037)
        {
            return ComputeHash(GetBytes(data), hash);
        }

        public static ulong GetLongHashCode(this int data, ulong hash = 14695981039346656037)
        {
            return ComputeHash(BitConverter.GetBytes(data), hash);
        }

        public static ulong GetLongHashCode(this double data, ulong hash = 14695981039346656037)
        {
            return ComputeHash(BitConverter.GetBytes(data), hash);
        }

        public static ulong GetLongHashCode(this ulong data, ulong hash = 14695981039346656037)
        {
            return ComputeHash(BitConverter.GetBytes(data), hash);
        }

        public static ulong GetLongHashCode(this long data, ulong hash = 14695981039346656037)
        {
            return ComputeHash(BitConverter.GetBytes(data), hash);
        }
        public static ulong GetLongHashCode(this byte[] data, ulong hash = 14695981039346656037)
        {
            return ComputeHash(data, hash);
        }

        // FNV-1a (64-bit) non-cryptographic hash function.
        // Adapted from: http://github.com/jakedouglas/fnv-java
        public static ulong ComputeHash(byte[] bytes, ulong hash = 14695981039346656037)
        {
            const ulong fnv64Prime = 0x100000001b3;

            for (var i = 0; i < bytes.Length; i++)
            {
                hash = hash ^ bytes[i];
                hash *= fnv64Prime;
            }

            return hash;
        }

        public static void memcpy(int[] dest, int destIndex, int[] source, int sourceIndex, int count)
        {
            for (int i = 0; i < count; i++)
            {
                dest[destIndex + i] = source[sourceIndex + i];
            }
        }

        public static void memcpy(float[] dest, int destIndex, float[] source, int sourceIndex, int count)
        {
            for (int i = 0; i < count; i++)
            {
                dest[destIndex++] = source[sourceIndex++];
            }
        }

        public static void memmove(byte[] dest, int destIndex, byte[] source, int sourceIndex, int count)
        {
            if (dest == source
                && destIndex == sourceIndex)
            {
                // there is nothing to do it is already the same
                return;
            }

            if (source != dest
                || destIndex < sourceIndex)
            {
                memcpy(dest, destIndex, source, sourceIndex, count);
            }
            else
            {
                for (int i = count - 1; i >= 0; i--)
                {
                    dest[destIndex + i] = source[sourceIndex + i];
                }
            }
        }

        public static void memmove(int[] dest, int destIndex, int[] source, int sourceIndex, int count)
        {
            if (source != dest
                || destIndex < sourceIndex)
            {
                memcpy(dest, destIndex, source, sourceIndex, count);
            }
            else
            {
                throw new Exception("this code needs to be tested");
                /*
				for (int i = Count-1; i > 0; i--)
				{
					dest[destIndex + i] = source[sourceIndex + i];
				}
				 */
            }
        }

        public static void memmove(float[] dest, int destIndex, float[] source, int sourceIndex, int count)
        {
            if (source != dest
                || destIndex < sourceIndex)
            {
                memcpy(dest, destIndex, source, sourceIndex, count);
            }
            else
            {
                throw new Exception("this code needs to be tested");
                /*
				for (int i = Count-1; i > 0; i--)
				{
					dest[destIndex + i] = source[sourceIndex + i];
				}
				 */
            }
        }

        public static void memset(int[] dest, int destIndex, int val, int count)
        {
            for (int i = 0; i < count; i++)
            {
                dest[destIndex + i] = val;
            }
        }

        public static void memset(byte[] dest, int destIndex, byte byteVal, int count)
        {
            for (int i = 0; i < count; i++)
            {
                dest[destIndex + i] = byteVal;
            }
        }

        public static void MemClear(int[] dest, int destIndex, int count)
        {
            for (int i = 0; i < count; i++)
            {
                dest[destIndex + i] = 0;
            }
        }

        public static void MemClear(byte[] dest, int destIndex, int count)
        {
            for (int i = 0; i < count; i++)
            {
                dest[destIndex + i] = 0;
            }

            /*
			// dword align to dest
			while (((int)pDest & 3) != 0
				&& Count > 0)
			{
				*pDest++ = 0;
				Count--;
			}

			int NumLongs = Count / 4;

			while (NumLongs-- > 0)
			{
				*((int*)pDest) = 0;

				pDest += 4;
			}

			switch (Count & 3)
			{
				case 3:
					pDest[2] = 0;
					goto case 2;
				case 2:
					pDest[1] = 0;
					goto case 1;
				case 1:
					pDest[0] = 0;
					break;
			}
			 */
        }

        public static bool is_equal_eps(double v1, double v2, double epsilon)
        {
            return Math.Abs(v1 - v2) <= (double)epsilon;
        }

        //------------------------------------------------------------------deg2rad
        public static double deg2rad(double deg)
        {
            return deg * Math.PI / 180.0;
        }

        //------------------------------------------------------------------rad2deg
        public static double rad2deg(double rad)
        {
            return rad * 180.0 / Math.PI;
        }

        public static int iround(double v)
        {
            unchecked
            {
                return (int)((v < 0.0) ? v - 0.5 : v + 0.5);
            }
        }

        public static int iround(double v, int saturationLimit)
        {
            if (v < (double)-saturationLimit)
            {
                return -saturationLimit;
            }

            if (v > (double)saturationLimit)
            {
                return saturationLimit;
            }

            return iround(v);
        }

        public static int uround(double v)
        {
            return (int)(uint)(v + 0.5);
        }

        public static int ufloor(double v)
        {
            return (int)(uint)v;
        }

        public static int uceil(double v)
        {
            return (int)(uint)Math.Ceiling(v);
        }

        //----------------------------------------------------poly_subpixel_scale_e
        // These constants determine the subpixel accuracy, to be more precise,
        // the number of bits of the fractional part of the coordinates.
        // The possible coordinate capacity in bits can be calculated by formula:
        // sizeof(int) * 8 - poly_subpixel_shift, i.e, for 32-bit integers and
        // 8-bits fractional part the capacity is 24 bits.
        public enum poly_subpixel_scale_e
        {
            poly_subpixel_shift = 8,                      //----poly_subpixel_shift
            poly_subpixel_scale = 1 << poly_subpixel_shift, //----poly_subpixel_scale
            poly_subpixel_mask = poly_subpixel_scale - 1,  //----poly_subpixel_mask
        }

        public static ImageBuffer TrasparentToColorGradientX(int width, int height, Color color, int distance)
        {
            var innerGradient = new gradient_x();
            var outerGradient = new gradient_clamp_adaptor(innerGradient); // gradient_repeat_adaptor/gradient_reflect_adaptor/gradient_clamp_adaptor

            var rect = new RoundedRect(new RectangleDouble(0, 0, width, height), 0);

            var ras = new ScanlineRasterizer();
            ras.add_path(rect);

            var imageBuffer = new ImageBuffer(width, height);
            imageBuffer.SetRecieveBlender(new BlenderPreMultBGRA());

            var scanlineRenderer = new ScanlineRenderer();
            scanlineRenderer.GenerateAndRender(
                ras,
                new scanline_unpacked_8(),
                imageBuffer,
                new span_allocator(),
                new span_gradient(
                    new span_interpolator_linear(Affine.NewIdentity()),
                    outerGradient,
                    new GradientColors(Enumerable.Range(0, 256).Select(i => new Color(color, i))), // steps from full transparency color to solid color
                    0,
                    distance));

            return imageBuffer;
        }

        private class GradientColors : IColorFunction
        {
            private List<Color> colors;

            public GradientColors(IEnumerable<Color> colors)
            {
                this.colors = new List<Color>(colors);
            }

            public Color this[int v] => colors[v];

            public int size() => colors.Count;
        }

        public static bool GetFirstNumberAfter(string stringToCheckAfter, string stringWithNumber, ref int readValue, int startIndex = 0, string stopCheckingString = ";")
        {
            return GetFirstNumberAfter(stringToCheckAfter, stringWithNumber, ref readValue, out _, startIndex, stopCheckingString);
        }

        public static string GetLineWithoutChecksum(string inLine)
        {
            if (inLine.StartsWith("N"))
            {
                int lineNumber = 0;
                if (Util.GetFirstNumberAfter("N", inLine, ref lineNumber, out int numberEnd))
                {
                    var outLine = inLine.Substring(numberEnd).Trim();
                    int checksumStart = outLine.IndexOf('*');
                    if (checksumStart != -1)
                    {
                        return outLine.Substring(0, checksumStart);
                    }
                }
            }

            return inLine;
        }

        public static bool GetFirstNumberAfter(string stringToCheckAfter, string stringWithNumber, ref int readValue, out int numberEnd, int startIndex = 0, string stopCheckingString = ";")
        {
            double doubleValue = readValue;
            if (GetFirstNumberAfter(stringToCheckAfter, stringWithNumber, ref doubleValue, out numberEnd, startIndex, stopCheckingString))
            {
                readValue = (int)doubleValue;
                return true;
            }

            return false;
        }

        public static bool GetFirstNumberAfter(string stringToCheckAfter, string stringWithNumber, ref double readValue, int startIndex = 0, string stopCheckingString = ";")
        {
            return GetFirstNumberAfter(stringToCheckAfter, stringWithNumber, ref readValue, out _, startIndex, stopCheckingString);
        }

        public static bool GetFirstNumberAfter(string stringToCheckAfter, string stringWithNumber, ref double readValue, out int numberEnd, int startIndex = 0, string stopCheckingString = ";")
        {
            int stringPos = stringWithNumber.IndexOf(stringToCheckAfter, Math.Min(stringWithNumber.Length, startIndex));
            int stopPos = stringWithNumber.IndexOf(stopCheckingString);
            if (stringPos != -1
                && (stopPos == -1 || stringPos < stopPos || string.IsNullOrEmpty(stopCheckingString)))
            {
                stringPos += stringToCheckAfter.Length;
                readValue = Util.ParseDouble(stringWithNumber, ref stringPos, true);
                numberEnd = stringPos;

                return true;
            }

            numberEnd = -1;
            return false;
        }

        public static bool GetFirstStringAfter(string stringToCheckAfter, string fullStringToLookIn, string separatorString, ref string nextString, int startIndex = 0)
        {
            int stringPos = fullStringToLookIn.IndexOf(stringToCheckAfter, startIndex);
            if (stringPos != -1)
            {
                int separatorPos = fullStringToLookIn.IndexOf(separatorString, stringPos);
                if (separatorPos != -1)
                {
                    nextString = fullStringToLookIn.Substring(stringPos + stringToCheckAfter.Length, separatorPos - (stringPos + stringToCheckAfter.Length));
                    return true;
                }
            }

            return false;
        }

        public static string ReplaceNumberAfter(char charToReplaceAfter, string stringWithNumber, double numberToPutIn)
        {
            int charPos = stringWithNumber.IndexOf(charToReplaceAfter);
            if (charPos != -1)
            {
                int spacePos = stringWithNumber.IndexOf(" ", charPos);
                if (spacePos == -1)
                {
                    string newString = string.Format("{0}{1:0.#####}", stringWithNumber.Substring(0, charPos + 1), numberToPutIn);
                    return newString;
                }
                else
                {
                    string newString = string.Format("{0}{1:0.#####}{2}", stringWithNumber.Substring(0, charPos + 1), numberToPutIn, stringWithNumber.Substring(spacePos));
                    return newString;
                }
            }

            return stringWithNumber;
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VectorClipper.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//#ifndef AGG_RASTERIZER_SL_CLIP_INCLUDED
//#define AGG_RASTERIZER_SL_CLIP_INCLUDED

//#include "agg_clip_liang_barsky.h"

using poly_subpixel_scale_e = MatterHackers.Agg.Util.poly_subpixel_scale_e;

namespace MatterHackers.Agg
{
	//--------------------------------------------------------poly_max_coord_e
	internal enum poly_max_coord_e
	{
		poly_max_coord = (1 << 30) - 1 //----poly_max_coord
	};

	public class VectorClipper
	{
		public RectangleInt clipBox;
		private int m_x1;
		private int m_y1;
		private int m_f1;
		private bool m_clipping;

		private int mul_div(double a, double b, double c)
		{
			return Util.iround(a * b / c);
		}

		private int xi(int v)
		{
			return v;
		}

		private int yi(int v)
		{
			return v;
		}

		public int upscale(double v)
		{
			return Util.iround(v * (int)poly_subpixel_scale_e.poly_subpixel_scale);
		}

		public int downscale(int v)
		{
			return v / (int)poly_subpixel_scale_e.poly_subpixel_scale;
		}

		//--------------------------------------------------------------------
		public VectorClipper()
		{
			clipBox = new RectangleInt(0, 0, 0, 0);
			m_x1 = (0);
			m_y1 = (0);
			m_f1 = (0);
			m_clipping = (false);
		}

		//--------------------------------------------------------------------
		public void reset_clipping()
		{
			m_clipping = false;
		}

		//--------------------------------------------------------------------
		public void clip_box(int x1, int y1, int x2, int y2)
		{
			clipBox = new RectangleInt(x1, y1, x2, y2);
			clipBox.normalize();
			m_clipping = true;
		}

		//--------------------------------------------------------------------
		public void move_to(int x1, int y1)
		{
			m_x1 = x1;
			m_y1 = y1;
			if (m_clipping)
			{
				m_f1 = ClipLiangBarsky.clipping_flags(x1, y1, clipBox);
			}
		}

		//------------------------------------------------------------------------
		private void line_clip_y(RasterizerCellsAa ras,
									int x1, int y1,
									int x2, int y2,
									int f1, int f2)
		{
			f1 &= 10;
			f2 &= 10;
			if ((f1 | f2) == 0)
			{
				// Fully visible
				ras.line(x1, y1, x2, y2);
			}
			else
			{
				if (f1 == f2)
				{
					// Invisible by Y
					return;
				}

				int tx1 = x1;
				int ty1 = y1;
				int tx2 = x2;
				int ty2 = y2;

				if ((f1 & 8) != 0) // y1 < clip.y1
				{
					tx1 = x1 + mul_div(clipBox.Bottom - y1, x2 - x1, y2 - y1);
					ty1 = clipBox.Bottom;
				}

				if ((f1 & 2) != 0) // y1 > clip.y2
				{
					tx1 = x1 + mul_div(clipBox.Top - y1, x2 - x1, y2 - y1);
					ty1 = clipBox.Top;
				}

				if ((f2 & 8) != 0) // y2 < clip.y1
				{
					tx2 = x1 + mul_div(clipBox.Bottom - y1, x2 - x1, y2 - y1);
					ty2 = clipBox.Bottom;
				}

				if ((f2 & 2) != 0) // y2 > clip.y2
				{
					tx2 = x1 + mul_div(clipBox.Top - y1, x2 - x1, y2 - y1);
					ty2 = clipBox.Top;
				}

				ras.line(tx1, ty1, tx2, ty2);
			}
		}

		//--------------------------------------------------------------------
		public void line_to(RasterizerCellsAa ras, int x2, int y2)
		{
			if (m_clipping)
			{
				int f2 = ClipLiangBarsky.clipping_flags(x2, y2, clipBox);

				if ((m_f1 & 10) == (f2 & 10) && (m_f1 & 10) != 0)
				{
					// Invisible by Y
					m_x1 = x2;
					m_y1 = y2;
					m_f1 = f2;
					return;
				}

				int x1 = m_x1;
				int y1 = m_y1;
				int f1 = m_f1;
				int y3, y4;
				int f3, f4;

				switch (((f1 & 5) << 1) | (f2 & 5))
				{
					case 0: // Visible by X
						line_clip_y(ras, x1, y1, x2, y2, f1, f2);
						break;

					case 1: // x2 > clip.x2
						y3 = y1 + mul_div(clipBox.Right - x1, y2 - y1, x2 - x1);
						f3 = ClipLiangBarsky.clipping_flags_y(y3, clipBox);
						line_clip_y(ras, x1, y1, clipBox.Right, y3, f1, f3);
						line_clip_y(ras, clipBox.Right, y3, clipBox.Right, y2, f3, f2);
						break;

					case 2: // x1 > clip.x2
						y3 = y1 + mul_div(clipBox.Right - x1, y2 - y1, x2 - x1);
						f3 = ClipLiangBarsky.clipping_flags_y(y3, clipBox);
						line_clip_y(ras, clipBox.Right, y1, clipBox.Right, y3, f1, f3);
						line_clip_y(ras, clipBox.Right, y3, x2, y2, f3, f2);
						break;

					case 3: // x1 > clip.x2 && x2 > clip.x2
						line_clip_y(ras, clipBox.Right, y1, clipBox.Right, y2, f1, f2);
						break;

					case 4: // x2 < clip.x1
						y3 = y1 + mul_div(clipBox.Left - x1, y2 - y1, x2 - x1);
						f3 = ClipLiangBarsky.clipping_flags_y(y3, clipBox);
						line_clip_y(ras, x1, y1, clipBox.Left, y3, f1, f3);
						line_clip_y(ras, clipBox.Left, y3, clipBox.Left, y2, f3, f2);
						break;

					case 6: // x1 > clip.x2 && x2 < clip.x1
						y3 = y1 + mul_div(clipBox.Right - x1, y2 - y1, x2 - x1);
						y4 = y1 + mul_div(clipBox.Left - x1, y2 - y1, x2 - x1);
						f3 = ClipLiangBarsky.clipping_flags_y(y3, clipBox);
						f4 = ClipLiangBarsky.clipping_flags_y(y4, clipBox);
						line_clip_y(ras, clipBox.Right, y1, clipBox.Right, y3, f1, f3);
						line_clip_y(ras, clipBox.Right, y3, clipBox.Left, y4, f3, f4);
						line_clip_y(ras, clipBox.Left, y4, clipBox.Left, y2, f4, f2);
						break;

					case 8: // x1 < clip.x1
						y3 = y1 + mul_div(clipBox.Left - x1, y2 - y1, x2 - x1);
						f3 = ClipLiangBarsky.clipping_flags_y(y3, clipBox);
						line_clip_y(ras, clipBox.Left, y1, clipBox.Left, y3, f1, f3);
						line_clip_y(ras, clipBox.Left, y3, x2, y2, f3, f2);
						break;

					case 9:  // x1 < clip.x1 && x2 > clip.x2
						y3 = y1 + mul_div(clipBox.Left - x1, y2 - y1, x2 - x1);
						y4 = y1 + mul_div(clipBox.Right - x1, y2 - y1, x2 - x1);
						f3 = ClipLiangBarsky.clipping_flags_y(y3, clipBox);
						f4 = ClipLiangBarsky.clipping_flags_y(y4, clipBox);
						line_clip_y(ras, clipBox.Left, y1, clipBox.Left, y3, f1, f3);
						line_clip_y(ras, clipBox.Left, y3, clipBox.Right, y4, f3, f4);
						line_clip_y(ras, clipBox.Right, y4, clipBox.Right, y2, f4, f2);
						break;

					case 12: // x1 < clip.x1 && x2 < clip.x1
						line_clip_y(ras, clipBox.Left, y1, clipBox.Left, y2, f1, f2);
						break;
				}
				m_f1 = f2;
			}
			else
			{
				ras.line(m_x1, m_y1,
						 x2, y2);
			}
			m_x1 = x2;
			m_y1 = y2;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\agg_curves.cs
using MatterHackers.VectorMath;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
// Copyright (C) 2005 Tony Juricic (tonygeek@yahoo.com)
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using FlagsAndCommand = MatterHackers.Agg.FlagsAndCommand;

namespace MatterHackers.Agg.VertexSource
{
	public static class Curves
	{
		//--------------------------------------------curve_approximation_method_e
		public enum CurveApproximationMethod
		{
			curve_inc,
			curve_div
		}

		public static readonly double curve_distance_epsilon = 1e-30;
		public static readonly double curve_collinearity_epsilon = 1e-30;
		public static readonly double curve_angle_tolerance_epsilon = 0.01;

		public enum curve_recursion_limit_e { curve_recursion_limit = 32 };

		//-------------------------------------------------------catrom_to_bezier
		public static curve4_points catrom_to_bezier(double x1, double y1,
											  double x2, double y2,
											  double x3, double y3,
											  double x4, double y4)
		{
			// Trans. matrix Catmull-Rom to Bezier
			//
			//  0       1       0       0
			//  -1/6    1       1/6     0
			//  0       1/6     1       -1/6
			//  0       0       1       0
			//
			return new curve4_points(
				x2,
				y2,
				(-x1 + 6 * x2 + x3) / 6,
				(-y1 + 6 * y2 + y3) / 6,
				(x2 + 6 * x3 - x4) / 6,
				(y2 + 6 * y3 - y4) / 6,
				x3,
				y3);
		}

		//-----------------------------------------------------------------------
		public static curve4_points
		catrom_to_bezier(curve4_points cp)
		{
			return catrom_to_bezier(cp[0], cp[1], cp[2], cp[3],
									cp[4], cp[5], cp[6], cp[7]);
		}

		//-----------------------------------------------------ubspline_to_bezier
		public static curve4_points ubspline_to_bezier(double x1, double y1,
												double x2, double y2,
												double x3, double y3,
												double x4, double y4)
		{
			// Trans. matrix Uniform BSpline to Bezier
			//
			//  1/6     4/6     1/6     0
			//  0       4/6     2/6     0
			//  0       2/6     4/6     0
			//  0       1/6     4/6     1/6
			//
			return new curve4_points(
				(x1 + 4 * x2 + x3) / 6,
				(y1 + 4 * y2 + y3) / 6,
				(4 * x2 + 2 * x3) / 6,
				(4 * y2 + 2 * y3) / 6,
				(2 * x2 + 4 * x3) / 6,
				(2 * y2 + 4 * y3) / 6,
				(x2 + 4 * x3 + x4) / 6,
				(y2 + 4 * y3 + y4) / 6);
		}

		//-----------------------------------------------------------------------
		public static curve4_points
		ubspline_to_bezier(curve4_points cp)
		{
			return ubspline_to_bezier(cp[0], cp[1], cp[2], cp[3],
									  cp[4], cp[5], cp[6], cp[7]);
		}

		//------------------------------------------------------hermite_to_bezier
		public static curve4_points hermite_to_bezier(double x1, double y1,
											   double x2, double y2,
											   double x3, double y3,
											   double x4, double y4)
		{
			// Trans. matrix Hermite to Bezier
			//
			//  1       0       0       0
			//  1       0       1/3     0
			//  0       1       0       -1/3
			//  0       1       0       0
			//
			return new curve4_points(
				x1,
				y1,
				(3 * x1 + x3) / 3,
				(3 * y1 + y3) / 3,
				(3 * x2 - x4) / 3,
				(3 * y2 - y4) / 3,
				x2,
				y2);
		}

		//-----------------------------------------------------------------------
		public static curve4_points
		hermite_to_bezier(curve4_points cp)
		{
			return hermite_to_bezier(cp[0], cp[1], cp[2], cp[3],
									 cp[4], cp[5], cp[6], cp[7]);
		}
	}

	//--------------------------------------------------------------curve3_inc
	public sealed class curve3_inc
	{
		private int m_num_steps;
		private int m_step;
		private double m_scale;
		private double m_start_x;
		private double m_start_y;
		private double m_end_x;
		private double m_end_y;
		private double m_fx;
		private double m_fy;
		private double m_dfx;
		private double m_dfy;
		private double m_ddfx;
		private double m_ddfy;
		private double m_saved_fx;
		private double m_saved_fy;
		private double m_saved_dfx;
		private double m_saved_dfy;

		public curve3_inc()
		{
			m_num_steps = 0;
			m_step = 0;
			m_scale = 1.0;
		}

		public curve3_inc(double x1, double y1,
				   double x2, double y2,
				   double x3, double y3)
		{
			m_num_steps = 0;
			m_step = 0;
			m_scale = 1.0;
			init(x1, y1, x2, y2, x3, y3);
		}

		public void reset()
		{
			m_num_steps = 0; m_step = -1;
		}

		public void init(double x1, double y1,
				  double cx, double cy,
				  double x2, double y2)
		{
			m_start_x = x1;
			m_start_y = y1;
			m_end_x = x2;
			m_end_y = y2;

			double dx1 = cx - x1;
			double dy1 = cy - y1;
			double dx2 = x2 - cx;
			double dy2 = y2 - cy;

			double len = Math.Sqrt(dx1 * dx1 + dy1 * dy1) + Math.Sqrt(dx2 * dx2 + dy2 * dy2);

			m_num_steps = Util.uround(len * 0.25 * m_scale);

			if (m_num_steps < 4)
			{
				m_num_steps = 4;
			}

			double subdivide_step = 1.0 / m_num_steps;
			double subdivide_step2 = subdivide_step * subdivide_step;

			double tmpx = (x1 - cx * 2.0 + x2) * subdivide_step2;
			double tmpy = (y1 - cy * 2.0 + y2) * subdivide_step2;

			m_saved_fx = m_fx = x1;
			m_saved_fy = m_fy = y1;

			m_saved_dfx = m_dfx = tmpx + (cx - x1) * (2.0 * subdivide_step);
			m_saved_dfy = m_dfy = tmpy + (cy - y1) * (2.0 * subdivide_step);

			m_ddfx = tmpx * 2.0;
			m_ddfy = tmpy * 2.0;

			m_step = m_num_steps;
		}

		public void approximation_method(Curves.CurveApproximationMethod method)
		{
		}

		public Curves.CurveApproximationMethod approximation_method()
		{
			return Curves.CurveApproximationMethod.curve_inc;
		}

		public void approximation_scale(double s)
		{
			m_scale = s;
		}

		public double approximation_scale()
		{
			return m_scale;
		}

		public void angle_tolerance(double angle)
		{
		}

		public double angle_tolerance()
		{
			return 0.0;
		}

		public void cusp_limit(double limit)
		{
		}

		public double cusp_limit()
		{
			return 0.0;
		}

		public IEnumerable<VertexData> Vertices()
		{
			throw new NotImplementedException();
		}

		public void rewind(int path_id)
		{
			if (m_num_steps == 0)
			{
				m_step = -1;
				return;
			}
			m_step = m_num_steps;
			m_fx = m_saved_fx;
			m_fy = m_saved_fy;
			m_dfx = m_saved_dfx;
			m_dfy = m_saved_dfy;
		}

		public FlagsAndCommand vertex(out double x, out double y)
		{
			if (m_step < 0)
			{
				x = 0;
				y = 0;
				return FlagsAndCommand.Stop;
			}
			if (m_step == m_num_steps)
			{
				x = m_start_x;
				y = m_start_y;
				--m_step;
				return FlagsAndCommand.MoveTo;
			}
			if (m_step == 0)
			{
				x = m_end_x;
				y = m_end_y;
				--m_step;
				return FlagsAndCommand.LineTo;
			}
			m_fx += m_dfx;
			m_fy += m_dfy;
			m_dfx += m_ddfx;
			m_dfy += m_ddfy;
			x = m_fx;
			y = m_fy;
			--m_step;
			return FlagsAndCommand.LineTo;
		}
	}

	//-------------------------------------------------------------curve3_div
	public sealed class curve3_div
	{
		private double m_approximation_scale;
		private double m_distance_tolerance_square;
		private double m_angle_tolerance;
		private int m_count;
		private VectorPOD<Vector2> m_points;

		public curve3_div()
		{
			m_points = new VectorPOD<Vector2>();
			m_approximation_scale = 1.0;
			m_angle_tolerance = 0.0;
			m_count = 0;
		}

		public curve3_div(double x1, double y1,
				   double cx, double cy,
				   double x2, double y2)
		{
			m_approximation_scale = 1.0;
			m_angle_tolerance = 0.0;
			m_count = 0;
			init(x1, y1, cx, cy, x2, y2);
		}

		public void reset()
		{
			m_points.Clear(); m_count = 0;
		}

		public void init(double x1, double y1,
				  double cx, double cy,
				  double x2, double y2)
		{
			m_points.Clear();
			m_distance_tolerance_square = 0.5 / m_approximation_scale;
			m_distance_tolerance_square *= m_distance_tolerance_square;
			bezier(x1, y1, cx, cy, x2, y2);
			m_count = 0;
		}

		public void approximation_method(Curves.CurveApproximationMethod method)
		{
		}

		public Curves.CurveApproximationMethod approximation_method()
		{
			return Curves.CurveApproximationMethod.curve_div;
		}

		public void approximation_scale(double s)
		{
			m_approximation_scale = s;
		}

		public double approximation_scale()
		{
			return m_approximation_scale;
		}

		public void angle_tolerance(double a)
		{
			m_angle_tolerance = a;
		}

		public double angle_tolerance()
		{
			return m_angle_tolerance;
		}

		public void cusp_limit(double limit)
		{
		}

		public double cusp_limit()
		{
			return 0.0;
		}

		public IEnumerable<VertexData> Vertices()
		{
			for (int i = 0; i < m_points.Count; i++)
			{
				if (i == 0)
				{
					yield return new VertexData(FlagsAndCommand.MoveTo, m_points[i]);
				}
				else
				{
					yield return new VertexData(FlagsAndCommand.LineTo, m_points[i]);
				}
			}

			yield return new VertexData(FlagsAndCommand.Stop, new Vector2());
		}

		public void rewind(int idx)
		{
			m_count = 0;
		}

		public FlagsAndCommand vertex(out double x, out double y)
		{
			if (m_count >= m_points.Count)
			{
				x = 0;
				y = 0;
				return FlagsAndCommand.Stop;
			}

			Vector2 p = m_points[m_count++];
			x = p.X;
			y = p.Y;
			return (m_count == 1) ? FlagsAndCommand.MoveTo : FlagsAndCommand.LineTo;
		}

		private void bezier(double x1, double y1,
					double x2, double y2,
					double x3, double y3)
		{
			m_points.Add(new Vector2(x1, y1));
			recursive_bezier(x1, y1, x2, y2, x3, y3, 0);
			m_points.Add(new Vector2(x3, y3));
		}

		private void recursive_bezier(double x1, double y1,
							  double x2, double y2,
							  double x3, double y3,
							  int level)
		{
			if (level > (int)Curves.curve_recursion_limit_e.curve_recursion_limit)
			{
				return;
			}

			// Calculate all the mid-points of the line segments
			//----------------------
			double x12 = (x1 + x2) / 2;
			double y12 = (y1 + y2) / 2;
			double x23 = (x2 + x3) / 2;
			double y23 = (y2 + y3) / 2;
			double x123 = (x12 + x23) / 2;
			double y123 = (y12 + y23) / 2;

			double dx = x3 - x1;
			double dy = y3 - y1;
			double d = Math.Abs((x2 - x3) * dy - (y2 - y3) * dx);
			double da;

			if (d > Curves.curve_collinearity_epsilon)
			{
				// Regular case
				//-----------------
				if (d * d <= m_distance_tolerance_square * (dx * dx + dy * dy))
				{
					// If the curvature doesn't exceed the distance_tolerance value
					// we tend to finish subdivisions.
					//----------------------
					if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)
					{
						m_points.Add(new Vector2(x123, y123));
						return;
					}

					// Angle & Cusp Condition
					//----------------------
					da = Math.Abs(Math.Atan2(y3 - y2, x3 - x2) - Math.Atan2(y2 - y1, x2 - x1));
					if (da >= Math.PI) da = 2 * Math.PI - da;

					if (da < m_angle_tolerance)
					{
						// Finally we can stop the recursion
						//----------------------
						m_points.Add(new Vector2(x123, y123));
						return;
					}
				}
			}
			else
			{
				// Collinear case
				//------------------
				da = dx * dx + dy * dy;
				if (da == 0)
				{
					d = agg_math.calc_sq_distance(x1, y1, x2, y2);
				}
				else
				{
					d = ((x2 - x1) * dx + (y2 - y1) * dy) / da;
					if (d > 0 && d < 1)
					{
						// Simple collinear case, 1---2---3
						// We can leave just two endpoints
						return;
					}
					if (d <= 0) d = agg_math.calc_sq_distance(x2, y2, x1, y1);
					else if (d >= 1) d = agg_math.calc_sq_distance(x2, y2, x3, y3);
					else d = agg_math.calc_sq_distance(x2, y2, x1 + d * dx, y1 + d * dy);
				}
				if (d < m_distance_tolerance_square)
				{
					m_points.Add(new Vector2(x2, y2));
					return;
				}
			}

			// Continue subdivision
			//----------------------
			recursive_bezier(x1, y1, x12, y12, x123, y123, level + 1);
			recursive_bezier(x123, y123, x23, y23, x3, y3, level + 1);
		}
	}

	//-------------------------------------------------------------curve4_points
	public sealed class curve4_points
	{
		private double[] cp = new double[8];

		public curve4_points()
		{
		}

		public curve4_points(double x1, double y1,
					  double x2, double y2,
					  double x3, double y3,
					  double x4, double y4)
		{
			cp[0] = x1; cp[1] = y1; cp[2] = x2; cp[3] = y2;
			cp[4] = x3; cp[5] = y3; cp[6] = x4; cp[7] = y4;
		}

		public void init(double x1, double y1,
				  double x2, double y2,
				  double x3, double y3,
				  double x4, double y4)
		{
			cp[0] = x1; cp[1] = y1; cp[2] = x2; cp[3] = y2;
			cp[4] = x3; cp[5] = y3; cp[6] = x4; cp[7] = y4;
		}

		public double this[int i]
		{
			get
			{
				return cp[i];
			}
		}

		//double  operator [] (int i){ return cp[i]; }
		//double& operator [] (int i)       { return cp[i]; }
	}

	//-------------------------------------------------------------curve4_inc
	public sealed class Curve4Increment
	{
		private int numSteps;
		private int remainingSteps;
		private double scale;
		private Vector2 start;
		private Vector2 end;
		private double m_fx;
		private double m_fy;
		private double m_dfx;
		private double m_dfy;
		private double m_ddfx;
		private double m_ddfy;
		private double m_dddfx;
		private double m_dddfy;
		private double m_saved_fx;
		private double m_saved_fy;
		private double m_saved_dfx;
		private double m_saved_dfy;
		private double m_saved_ddfx;
		private double m_saved_ddfy;

		public Curve4Increment()
		{
			numSteps = 0;
			remainingSteps = 0;
			scale = 1.0;
		}

		public Curve4Increment(double xStart, double yStart,
				  double xControl1, double yControl1,
				  double xControl2, double yControl2,
				  double xEnd, double yEnd)
		{
			numSteps = 0;
			remainingSteps = 0;
			scale = 1.0;
			Init(xStart, yStart, xControl1, yControl1, xControl2, yControl2, xEnd, yEnd);
		}

		public Curve4Increment(curve4_points cp)
		{
			numSteps = 0;
			remainingSteps = 0;
			scale = 1.0;
			Init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
		}

		public void Reset()
		{
			numSteps = 0;
			remainingSteps = -1;
		}

		public void Init(double xStart, double yStart,
				  double xContorl1, double yControl1,
				  double xControl2, double yControl2,
				  double xEnd, double yEnd)
		{
			double dx1 = xContorl1 - xStart;
			double dy1 = yControl1 - yStart;
			double dx2 = xControl2 - xContorl1;
			double dy2 = yControl2 - yControl1;
			double dx3 = xEnd - xControl2;
			double dy3 = yEnd - yControl2;

			double len = (Math.Sqrt(dx1 * dx1 + dy1 * dy1) +
						  Math.Sqrt(dx2 * dx2 + dy2 * dy2) +
						  Math.Sqrt(dx3 * dx3 + dy3 * dy3)) * 0.25 * scale;

			Init(xStart, yStart,
				  xContorl1, yControl1,
				  xControl2, yControl2,
				  xEnd, yEnd,
				  Util.uround(len));
		}

        public void Init(double xStart, double yStart,
				  double xContorl1, double yControl1,
				  double xControl2, double yControl2,
				  double xEnd, double yEnd,
				  int numSteps)
		{
			start.X = xStart;
			start.Y = yStart;
			end.X = xEnd;
			end.Y = yEnd;

			this.numSteps = numSteps;

			if (numSteps < 4)
			{
				numSteps = 4;
			}

			double subdivide_step = 1.0 / numSteps;
			double subdivide_step2 = subdivide_step * subdivide_step;
			double subdivide_step3 = subdivide_step * subdivide_step * subdivide_step;

			double pre1 = 3.0 * subdivide_step;
			double pre2 = 3.0 * subdivide_step2;
			double pre4 = 6.0 * subdivide_step2;
			double pre5 = 6.0 * subdivide_step3;

			double tmp1x = xStart - xContorl1 * 2.0 + xControl2;
			double tmp1y = yStart - yControl1 * 2.0 + yControl2;

			double tmp2x = (xContorl1 - xControl2) * 3.0 - xStart + xEnd;
			double tmp2y = (yControl1 - yControl2) * 3.0 - yStart + yEnd;

			m_saved_fx = m_fx = xStart;
			m_saved_fy = m_fy = yStart;

			m_saved_dfx = m_dfx = (xContorl1 - xStart) * pre1 + tmp1x * pre2 + tmp2x * subdivide_step3;
			m_saved_dfy = m_dfy = (yControl1 - yStart) * pre1 + tmp1y * pre2 + tmp2y * subdivide_step3;

			m_saved_ddfx = m_ddfx = tmp1x * pre4 + tmp2x * pre5;
			m_saved_ddfy = m_ddfy = tmp1y * pre4 + tmp2y * pre5;

			m_dddfx = tmp2x * pre5;
			m_dddfy = tmp2y * pre5;

			remainingSteps = numSteps;
		}

		public void Init(curve4_points cp)
		{
			Init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
		}

		public void approximation_scale(double s)
		{
			scale = s;
		}

		public double approximation_scale()
		{
			return scale;
		}

		public void angle_tolerance(double angle)
		{
		}

		public double angle_tolerance()
		{
			return 0.0;
		}

		public void cusp_limit(double limit)
		{
		}

		public double cusp_limit()
		{
			return 0.0;
		}

		public IEnumerable<VertexData> Vertices()
		{
			throw new NotImplementedException();
		}

		public void rewind(int path_id)
		{
			if (numSteps == 0)
			{
				remainingSteps = -1;
				return;
			}
            
			remainingSteps = numSteps;
			m_fx = m_saved_fx;
			m_fy = m_saved_fy;
			m_dfx = m_saved_dfx;
			m_dfy = m_saved_dfy;
			m_ddfx = m_saved_ddfx;
			m_ddfy = m_saved_ddfy;
		}

		public FlagsAndCommand Vertex(out double x, out double y)
		{
			if (remainingSteps < 0)
			{
				x = 0;
				y = 0;
				return FlagsAndCommand.Stop;
			}

			if (remainingSteps == numSteps)
			{
				x = start.X;
				y = start.Y;
				--remainingSteps;
				return FlagsAndCommand.MoveTo;
			}

			if (remainingSteps == 0)
			{
				x = end.X;
				y = end.Y;
				--remainingSteps;
				return FlagsAndCommand.LineTo;
			}

			m_fx += m_dfx;
			m_fy += m_dfy;
			m_dfx += m_ddfx;
			m_dfy += m_ddfy;
			m_ddfx += m_dddfx;
			m_ddfy += m_dddfy;

			x = m_fx;
			y = m_fy;
			--remainingSteps;
			return FlagsAndCommand.LineTo;
		}
	}

	//-------------------------------------------------------------curve4_div
	public sealed class curve4_div
	{
		private double m_approximation_scale;
		private double m_distance_tolerance_square;
		private double m_angle_tolerance;
		private double m_cusp_limit;
		private int m_count;
		private VectorPOD<Vector2> m_points;

		public curve4_div()
		{
			m_points = new VectorPOD<Vector2>();
			m_approximation_scale = 1.0;
			m_angle_tolerance = 0.0;
			m_cusp_limit = 0.0;
			m_count = 0;
		}

		public curve4_div(double x1, double y1,
				   double x2, double y2,
				   double x3, double y3,
				   double x4, double y4)
		{
			m_approximation_scale = 1.0;
			m_angle_tolerance = 0.0;
			m_cusp_limit = 0.0;
			m_count = 0;
			init(x1, y1, x2, y2, x3, y3, x4, y4);
		}

		public curve4_div(curve4_points cp)
		{
			m_approximation_scale = 1.0;
			m_angle_tolerance = 0.0;
			m_count = 0;
			init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
		}

		public void reset()
		{
			m_points.Clear(); m_count = 0;
		}

		public void init(double x1, double y1,
				  double x2, double y2,
				  double x3, double y3,
				  double x4, double y4)
		{
			m_points.Clear();
			m_distance_tolerance_square = 0.5 / m_approximation_scale;
			m_distance_tolerance_square *= m_distance_tolerance_square;
			bezier(x1, y1, x2, y2, x3, y3, x4, y4);
			m_count = 0;
		}

		public void init(curve4_points cp)
		{
			init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
		}

		public void approximation_method(Curves.CurveApproximationMethod method)
		{
		}

		public Curves.CurveApproximationMethod approximation_method()
		{
			return Curves.CurveApproximationMethod.curve_div;
		}

		public void approximation_scale(double s)
		{
			m_approximation_scale = s;
		}

		public double approximation_scale()
		{
			return m_approximation_scale;
		}

		public void angle_tolerance(double a)
		{
			m_angle_tolerance = a;
		}

		public double angle_tolerance()
		{
			return m_angle_tolerance;
		}

		public void cusp_limit(double v)
		{
			m_cusp_limit = (v == 0.0) ? 0.0 : Math.PI - v;
		}

		public double cusp_limit()
		{
			return (m_cusp_limit == 0.0) ? 0.0 : Math.PI - m_cusp_limit;
		}

		public IEnumerable<VertexData> Vertices()
		{
			VertexData vertexData = new VertexData();
			vertexData.Command = FlagsAndCommand.MoveTo;
			vertexData.Position = m_points[0];
			yield return vertexData;

			vertexData.Command = FlagsAndCommand.LineTo;
			for (int i = 1; i < m_points.Count; i++)
			{
				vertexData.Position = m_points[i];
				yield return vertexData;
			}

			vertexData.Command = FlagsAndCommand.Stop;
			vertexData.Position = new Vector2();
			yield return vertexData;
		}

		public void rewind(int idx)
		{
			m_count = 0;
		}

		public FlagsAndCommand vertex(out double x, out double y)
		{
			if (m_count >= m_points.Count)
			{
				x = 0;
				y = 0;
				return FlagsAndCommand.Stop;
			}
			Vector2 p = m_points[m_count++];
			x = p.X;
			y = p.Y;
			return (m_count == 1) ? FlagsAndCommand.MoveTo : FlagsAndCommand.LineTo;
		}

		private void bezier(double x1, double y1,
					double x2, double y2,
					double x3, double y3,
					double x4, double y4)
		{
			m_points.Add(new Vector2(x1, y1));
			recursive_bezier(x1, y1, x2, y2, x3, y3, x4, y4, 0);
			m_points.Add(new Vector2(x4, y4));
		}

		private void recursive_bezier(double x1, double y1,
							  double x2, double y2,
							  double x3, double y3,
							  double x4, double y4,
							  int level)
		{
			if (level > (int)Curves.curve_recursion_limit_e.curve_recursion_limit)
			{
				return;
			}

			// Calculate all the mid-points of the line segments
			//----------------------
			double x12 = (x1 + x2) / 2;
			double y12 = (y1 + y2) / 2;
			double x23 = (x2 + x3) / 2;
			double y23 = (y2 + y3) / 2;
			double x34 = (x3 + x4) / 2;
			double y34 = (y3 + y4) / 2;
			double x123 = (x12 + x23) / 2;
			double y123 = (y12 + y23) / 2;
			double x234 = (x23 + x34) / 2;
			double y234 = (y23 + y34) / 2;
			double x1234 = (x123 + x234) / 2;
			double y1234 = (y123 + y234) / 2;

			// Try to approximate the full cubic curve by a single straight line
			//------------------
			double dx = x4 - x1;
			double dy = y4 - y1;

			double d2 = Math.Abs((x2 - x4) * dy - (y2 - y4) * dx);
			double d3 = Math.Abs((x3 - x4) * dy - (y3 - y4) * dx);
			double da1, da2, k;

			int SwitchCase = 0;
			if (d2 > Curves.curve_collinearity_epsilon)
			{
				SwitchCase = 2;
			}
			if (d3 > Curves.curve_collinearity_epsilon)
			{
				SwitchCase++;
			}

			switch (SwitchCase)
			{
				case 0:
					// All collinear OR p1==p4
					//----------------------
					k = dx * dx + dy * dy;
					if (k == 0)
					{
						d2 = agg_math.calc_sq_distance(x1, y1, x2, y2);
						d3 = agg_math.calc_sq_distance(x4, y4, x3, y3);
					}
					else
					{
						k = 1 / k;
						da1 = x2 - x1;
						da2 = y2 - y1;
						d2 = k * (da1 * dx + da2 * dy);
						da1 = x3 - x1;
						da2 = y3 - y1;
						d3 = k * (da1 * dx + da2 * dy);
						if (d2 > 0 && d2 < 1 && d3 > 0 && d3 < 1)
						{
							// Simple collinear case, 1---2---3---4
							// We can leave just two endpoints
							return;
						}
						if (d2 <= 0) d2 = agg_math.calc_sq_distance(x2, y2, x1, y1);
						else if (d2 >= 1) d2 = agg_math.calc_sq_distance(x2, y2, x4, y4);
						else d2 = agg_math.calc_sq_distance(x2, y2, x1 + d2 * dx, y1 + d2 * dy);

						if (d3 <= 0) d3 = agg_math.calc_sq_distance(x3, y3, x1, y1);
						else if (d3 >= 1) d3 = agg_math.calc_sq_distance(x3, y3, x4, y4);
						else d3 = agg_math.calc_sq_distance(x3, y3, x1 + d3 * dx, y1 + d3 * dy);
					}
					if (d2 > d3)
					{
						if (d2 < m_distance_tolerance_square)
						{
							m_points.Add(new Vector2(x2, y2));
							return;
						}
					}
					else
					{
						if (d3 < m_distance_tolerance_square)
						{
							m_points.Add(new Vector2(x3, y3));
							return;
						}
					}
					break;

				case 1:
					// p1,p2,p4 are collinear, p3 is significant
					//----------------------
					if (d3 * d3 <= m_distance_tolerance_square * (dx * dx + dy * dy))
					{
						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)
						{
							m_points.Add(new Vector2(x23, y23));
							return;
						}

						// Angle Condition
						//----------------------
						da1 = Math.Abs(Math.Atan2(y4 - y3, x4 - x3) - Math.Atan2(y3 - y2, x3 - x2));
						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;

						if (da1 < m_angle_tolerance)
						{
							m_points.Add(new Vector2(x2, y2));
							m_points.Add(new Vector2(x3, y3));
							return;
						}

						if (m_cusp_limit != 0.0)
						{
							if (da1 > m_cusp_limit)
							{
								m_points.Add(new Vector2(x3, y3));
								return;
							}
						}
					}
					break;

				case 2:
					// p1,p3,p4 are collinear, p2 is significant
					//----------------------
					if (d2 * d2 <= m_distance_tolerance_square * (dx * dx + dy * dy))
					{
						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)
						{
							m_points.Add(new Vector2(x23, y23));
							return;
						}

						// Angle Condition
						//----------------------
						da1 = Math.Abs(Math.Atan2(y3 - y2, x3 - x2) - Math.Atan2(y2 - y1, x2 - x1));
						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;

						if (da1 < m_angle_tolerance)
						{
							m_points.Add(new Vector2(x2, y2));
							m_points.Add(new Vector2(x3, y3));
							return;
						}

						if (m_cusp_limit != 0.0)
						{
							if (da1 > m_cusp_limit)
							{
								m_points.Add(new Vector2(x2, y2));
								return;
							}
						}
					}
					break;

				case 3:
					// Regular case
					//-----------------
					if ((d2 + d3) * (d2 + d3) <= m_distance_tolerance_square * (dx * dx + dy * dy))
					{
						// If the curvature doesn't exceed the distance_tolerance value
						// we tend to finish subdivisions.
						//----------------------
						if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)
						{
							m_points.Add(new Vector2(x23, y23));
							return;
						}

						// Angle & Cusp Condition
						//----------------------
						k = Math.Atan2(y3 - y2, x3 - x2);
						da1 = Math.Abs(k - Math.Atan2(y2 - y1, x2 - x1));
						da2 = Math.Abs(Math.Atan2(y4 - y3, x4 - x3) - k);
						if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;
						if (da2 >= Math.PI) da2 = 2 * Math.PI - da2;

						if (da1 + da2 < m_angle_tolerance)
						{
							// Finally we can stop the recursion
							//----------------------
							m_points.Add(new Vector2(x23, y23));
							return;
						}

						if (m_cusp_limit != 0.0)
						{
							if (da1 > m_cusp_limit)
							{
								m_points.Add(new Vector2(x2, y2));
								return;
							}

							if (da2 > m_cusp_limit)
							{
								m_points.Add(new Vector2(x3, y3));
								return;
							}
						}
					}
					break;
			}

			// Continue subdivision
			//----------------------
			recursive_bezier(x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1);
			recursive_bezier(x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1);
		}
	}

	//-----------------------------------------------------------------curve3
	public sealed class Curve3 : IVertexSource
	{
		private curve3_inc m_curve_inc = new curve3_inc();
		private curve3_div m_curve_div = new curve3_div();
		private Curves.CurveApproximationMethod m_approximation_method;

		public Curve3()
		{
			m_approximation_method = Curves.CurveApproximationMethod.curve_div;
		}

		public Curve3(double x1, double y1,
			   double cx, double cy,
			   double x2, double y2)
			: base()
		{
			m_approximation_method = Curves.CurveApproximationMethod.curve_div;
			init(x1, y1, cx, cy, x2, y2);
		}

		public void reset()
		{
			m_curve_inc.reset();
			m_curve_div.reset();
		}

		public void init(double x1, double y1,
			   double cx, double cy,
			   double x2, double y2)
		{
			if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
			{
				m_curve_inc.init(x1, y1, cx, cy, x2, y2);
			}
			else
			{
				m_curve_div.init(x1, y1, cx, cy, x2, y2);
			}
		}

		public void approximation_method(Curves.CurveApproximationMethod v)
		{
			m_approximation_method = v;
		}

		public Curves.CurveApproximationMethod approximation_method()
		{
			return m_approximation_method;
		}

        public ulong GetLongHashCode(ulong hash = 14695981039346656037)
        {
            foreach (var vertex in this.Vertices())
            {
                hash = vertex.GetLongHashCode(hash);
            }

            return hash;
        }

        public void approximation_scale(double s)
		{
			m_curve_inc.approximation_scale(s);
			m_curve_div.approximation_scale(s);
		}

		public double approximation_scale()
		{
			return m_curve_inc.approximation_scale();
		}

		public void angle_tolerance(double a)
		{
			m_curve_div.angle_tolerance(a);
		}

		public double angle_tolerance()
		{
			return m_curve_div.angle_tolerance();
		}

		public void cusp_limit(double v)
		{
			m_curve_div.cusp_limit(v);
		}

		public double cusp_limit()
		{
			return m_curve_div.cusp_limit();
		}

		public IEnumerable<VertexData> Vertices()
		{
			if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
			{
				foreach (VertexData vertexData in m_curve_inc.Vertices())
				{
					yield return vertexData;
				}
			}
			else
			{
				foreach (VertexData vertexData in m_curve_div.Vertices())
				{
					yield return vertexData;
				}
			}
		}

		public void Rewind(int path_id)
		{
			if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
			{
				m_curve_inc.rewind(path_id);
			}
			else
			{
				m_curve_div.rewind(path_id);
			}
		}

		public FlagsAndCommand Vertex(out double x, out double y)
		{
			if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
			{
				return m_curve_inc.vertex(out x, out y);
			}
			return m_curve_div.vertex(out x, out y);
		}
	}

	//-----------------------------------------------------------------curve4
	public sealed class Curve4 : IVertexSource
	{
		private Curve4Increment m_curve_inc = new Curve4Increment();
		private curve4_div m_curve_div = new curve4_div();
		private Curves.CurveApproximationMethod m_approximation_method;

		public Curve4()
		{
			m_approximation_method = Curves.CurveApproximationMethod.curve_div;
		}

		public Curve4(double x1, double y1,
			   double cx1, double cy1,
			   double cx2, double cy2,
			   double x2, double y2)
			: base()
		{
			m_approximation_method = Curves.CurveApproximationMethod.curve_div;
			init(x1, y1, cx1, cy1, cx2, cy2, x2, y2);
		}

		public Curve4(curve4_points cp)
		{
			m_approximation_method = Curves.CurveApproximationMethod.curve_div;
			init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
		}

		public void reset()
		{
			m_curve_inc.Reset();
			m_curve_div.reset();
		}

		public void init(double xStart, double yStart,
			   double xControl1, double yControl1,
			   double xControl2, double yControl2,
			   double xEnd, double yEnd)
		{
			if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
			{
				m_curve_inc.Init(xStart, yStart, xControl1, yControl1, xControl2, yControl2, xEnd, yEnd);
			}
			else
			{
				m_curve_div.init(xStart, yStart, xControl1, yControl1, xControl2, yControl2, xEnd, yEnd);
			}
		}

		public void init(curve4_points cp)
		{
			init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
		}

        public ulong GetLongHashCode(ulong hash = 14695981039346656037)
        {
            foreach (var vertex in this.Vertices())
            {
                hash = vertex.GetLongHashCode(hash);
            }

            return hash;
        }

        public void approximation_method(Curves.CurveApproximationMethod v)
		{
			m_approximation_method = v;
		}

		public Curves.CurveApproximationMethod approximation_method()
		{
			return m_approximation_method;
		}

		public void approximation_scale(double s)
		{
			m_curve_inc.approximation_scale(s);
			m_curve_div.approximation_scale(s);
		}

		public double approximation_scale()
		{
			return m_curve_inc.approximation_scale();
		}

		public void angle_tolerance(double v)
		{
			m_curve_div.angle_tolerance(v);
		}

		public double angle_tolerance()
		{
			return m_curve_div.angle_tolerance();
		}

		public void cusp_limit(double v)
		{
			m_curve_div.cusp_limit(v);
		}

		public double cusp_limit()
		{
			return m_curve_div.cusp_limit();
		}

		public IEnumerable<VertexData> Vertices()
		{
			if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
			{
				return m_curve_inc.Vertices();
			}
			else
			{
				return m_curve_div.Vertices();
			}
		}

		public void Rewind(int path_id)
		{
			if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
			{
				m_curve_inc.rewind(path_id);
			}
			else
			{
				m_curve_div.rewind(path_id);
			}
		}

		public FlagsAndCommand Vertex(out double x, out double y)
		{
			if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
			{
				return m_curve_inc.Vertex(out x, out y);
			}
			return m_curve_div.vertex(out x, out y);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\agg_gsv_text.cs
// <auto-generated>
// Hack to disable analyzers and their warnings - too many issues to address
// </auto-generated>
using MatterHackers.VectorMath;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Class gsv_text
//
//----------------------------------------------------------------------------
using System;
using System.Collections.Generic;

namespace MatterHackers.Agg.VertexSource
{
	[Obsolete("All of these should use the new font stuff.  You probably want a StringPrinter or a TextWidget in this spot.")]
	public sealed class gsv_text : IVertexSource
	{
		private enum status
		{
			initial,
			next_char,
			start_glyph,
			glyph
		};

		private double m_StartX;
		private double m_CurrentX;
		private double m_CurrentY;
		private double m_WidthRatioOfHeight;
		private double m_FontSize;
		private double m_SpaceBetweenCharacters;
		private double m_SpaceBetweenLines;
		private string m_Text;
		private int m_CurrentCharacterIndex;
		private byte[] m_font;
		private status m_status;
		private int m_StartOfIndicesIndex;
		private int m_StartOfGlyphsIndex;
		private int m_BeginGlyphIndex;
		private int m_EndGlyphIndex;
		private double m_WidthScaleRatio;
		private double m_HeightScaleRatio;

		public double FontSize
		{
			get
			{
				return m_FontSize;
			}
			set
			{
				m_FontSize = value;
				double base_height = translateIndex(4);
				m_HeightScaleRatio = m_FontSize / base_height;
				m_WidthScaleRatio = m_HeightScaleRatio * m_WidthRatioOfHeight;
			}
		}

		public double AscenderHeight
		{
			get
			{
				return m_FontSize * .15;
			}
		}

		public double DescenderHeight
		{
			get
			{
				return m_FontSize * .2;
			}
		}

		public gsv_text()
		{
			m_font = CGSVDefaultFont.gsv_default_font;
			m_CurrentX = 0.0;
			m_CurrentY = 0.0;
			m_StartX = 0.0;
			m_WidthRatioOfHeight = 1;
			FontSize = 0.0;
			m_SpaceBetweenCharacters = 0.0;
			m_status = status.initial;

			m_SpaceBetweenLines = 0.0;
		}

        /*
		public void font(void* font)
		{
			m_font = font;
			if(m_font == 0) m_font = &m_loaded_font[0];
		}
		 */

        public ulong GetLongHashCode(ulong hash = 14695981039346656037)
        {
            foreach (var vertex in this.Vertices())
            {
                hash = vertex.GetLongHashCode(hash);
            }

            return hash;
        }

        public void load_font(string file)
		{
			throw new System.NotImplementedException();
			/*
			m_loaded_font.resize(0);
			FILE* fd = fopen(file, "rb");
			if(fd)
			{
				int len;

				fseek(fd, 0l, SEEK_END);
				len = ftell(fd);
				fseek(fd, 0l, SEEK_SET);
				if(len > 0)
				{
					m_loaded_font.resize(len);
					fread(&m_loaded_font[0], 1, len, fd);
					m_font = &m_loaded_font[0];
				}
				fclose(fd);
			}
			 */
		}

		// This will set the desired height.  NOTE: The font may not render at the size that you say.
		// It depends on the way the font was originally created.  A 24 Point font may not actually be 24 points high
		public void SetFontSize(double fontSize)
		{
			SetFontSizeAndWidthRatio(fontSize, 1.0);
		}

		public void SetFontSizeAndWidthRatio(double fontSize, double widthRatioOfHeight)
		{
			if (fontSize == 0 || widthRatioOfHeight == 0)
			{
				throw new System.Exception("You can't have a font with 0 width or height.  Nothing will render.");
			}

			m_WidthRatioOfHeight = widthRatioOfHeight;
			FontSize = fontSize;

			m_SpaceBetweenLines = FontSize * 1.5;
		}

		public void SetSpaceBetweenCharacters(double spaceBetweenCharacters)
		{
			m_SpaceBetweenCharacters = spaceBetweenCharacters;
		}

		public void line_space(double spaceBetweenLines)
		{
			m_SpaceBetweenLines = spaceBetweenLines;
		}

		public void start_point(double x, double y)
		{
			m_CurrentX = m_StartX = x;
			m_CurrentY = y;
		}

		public string Text
		{
			get
			{
				return m_Text;
			}
			set
			{
				m_Text = value;
			}
		}

		public void text(string text)
		{
			m_Text = text;
		}

		private ushort translateIndex(int indicesIndex)
		{
			ushort v;
			v = m_font[indicesIndex + 0];
			v |= (ushort)(m_font[indicesIndex + 1] << 8);
			return v;
		}

		public IEnumerable<VertexData> Vertices()
		{
			throw new NotImplementedException();
		}

		public void Rewind(int nothing)
		{
			m_status = status.initial;
			if (m_font == null) return;

			m_StartOfIndicesIndex = translateIndex(0);

			m_StartOfGlyphsIndex = m_StartOfIndicesIndex + 257 * 2; // one for x one for y
			m_CurrentCharacterIndex = 0;
		}

		private void GetSize(char characterToMeasure, out double width, out double height)
		{
			width = 0;
			height = 0;
			if (m_font == null)
			{
				return;
			}

			int maskedChracter = (int)(characterToMeasure & 0xFF);
			if (maskedChracter == '\r' || maskedChracter == '\n')
			{
				height -= (FontSize + m_SpaceBetweenLines);
				return;
			}

			int maskedChracterGlyphIndex = maskedChracter * 2; // we have an x and y in the array so it's * 2.
			int BeginGlyphIndex = m_StartOfGlyphsIndex + translateIndex(m_StartOfIndicesIndex + maskedChracterGlyphIndex);
			int EndGlyphIndex = m_StartOfGlyphsIndex + translateIndex(m_StartOfIndicesIndex + maskedChracterGlyphIndex + 2);

			do
			{
				if (BeginGlyphIndex >= EndGlyphIndex)
				{
					return; // the character has no glyph
				}

				unchecked
				{
					int DeltaX = (sbyte)m_font[BeginGlyphIndex++];
					sbyte yc = (sbyte)m_font[BeginGlyphIndex++];

					yc <<= 1;
					yc >>= 1;
					int DeltaY = (int)(yc);
					width += (double)(DeltaX) * m_WidthScaleRatio;
					height += (double)(DeltaY) * m_HeightScaleRatio;
				}
			} while (true);
		}

		public int GetCharacterIndexToStartBefore(Vector2 position)
		{
			int clostestIndex = -1;
			double clostestDist = double.MaxValue;
			Vector2 offset;
			offset.X = 0;
			offset.Y = 0;
			int characterToMeasureStartIndexInclusive = 0;
			int characterToMeasureEndIndexInclusive = m_Text.Length - 1;
			if (m_Text.Length > 0)
			{
				characterToMeasureStartIndexInclusive = Math.Max(0, Math.Min(characterToMeasureStartIndexInclusive, m_Text.Length - 1));
				characterToMeasureEndIndexInclusive = Math.Max(0, Math.Min(characterToMeasureEndIndexInclusive, m_Text.Length - 1));
				for (int i = characterToMeasureStartIndexInclusive; i <= characterToMeasureEndIndexInclusive; i++)
				{
					Vector2 delta = offset - position;
					double distToChar = delta.Length;
					if (distToChar < clostestDist)
					{
						clostestDist = distToChar;
						clostestIndex = i;
					}

					char singleChar = m_Text[i];
					if (singleChar == '\r' || singleChar == '\n')
					{
						offset.X = 0;
						offset.Y -= FontSize + m_SpaceBetweenLines;
					}
					else
					{
						double sigleWidth;
						double sigleHeight;
						GetSize(singleChar, out sigleWidth, out sigleHeight);
						offset.X += sigleWidth + m_SpaceBetweenCharacters;
						offset.Y += sigleHeight;
					}
				}

				Vector2 lastDelta = offset - position;
				double lastDistToChar = lastDelta.Length;
				if (lastDistToChar < clostestDist)
				{
					clostestDist = lastDistToChar;
					// we need to start after the lats character, or before the character after the last.
					clostestIndex = characterToMeasureEndIndexInclusive + 1;
				}
			}

			return clostestIndex;
		}

		public void GetSize(out Vector2 pixelSize)
		{
			GetSize(0, m_Text.Length - 1, out pixelSize);
		}

		public void GetSize(int characterToMeasureStartIndexInclusive, int characterToMeasureEndIndexInclusive, out Vector2 pixelSize)
		{
			double currentX = 0;
			pixelSize.X = 0;
			pixelSize.Y = 0;
			if (m_Text.Length > 0)
			{
				characterToMeasureStartIndexInclusive = Math.Max(0, Math.Min(characterToMeasureStartIndexInclusive, m_Text.Length - 1));
				characterToMeasureEndIndexInclusive = Math.Max(0, Math.Min(characterToMeasureEndIndexInclusive, m_Text.Length - 1));
				for (int i = characterToMeasureStartIndexInclusive; i <= characterToMeasureEndIndexInclusive; i++)
				{
					char singleChar = m_Text[i];
					if (singleChar == '\r' || singleChar == '\n')
					{
						currentX = 0;
						pixelSize.Y -= FontSize + m_SpaceBetweenLines;
					}
					else
					{
						double sigleWidth;
						double sigleHeight;
						GetSize(singleChar, out sigleWidth, out sigleHeight);
						currentX += sigleWidth + m_SpaceBetweenCharacters;
						pixelSize.X = Math.Max(currentX, pixelSize.X);
						pixelSize.Y += sigleHeight;
					}
				}
			}
		}

		public FlagsAndCommand Vertex(out double x, out double y)
		{
			x = 0;
			y = 0;
			bool quit = false;

			while (!quit)
			{
				switch (m_status)
				{
					case status.initial:
						if (m_font == null)
						{
							quit = true;
							break;
						}
						m_status = status.next_char;
						goto case status.next_char;

					case status.next_char:
						if (m_CurrentCharacterIndex == m_Text.Length)
						{
							quit = true;
							break;
						}
						int maskedChracter = (int)((m_Text[m_CurrentCharacterIndex++]) & 0xFF);
						if (maskedChracter == '\r' || maskedChracter == '\n')
						{
							m_CurrentX = m_StartX;
							m_CurrentY -= FontSize + m_SpaceBetweenLines;
							break;
						}
						int maskedChracterGlyphIndex = maskedChracter * 2; // we have an x and y in the array so it's * 2.
						m_BeginGlyphIndex = m_StartOfGlyphsIndex + translateIndex(m_StartOfIndicesIndex + maskedChracterGlyphIndex);
						m_EndGlyphIndex = m_StartOfGlyphsIndex + translateIndex(m_StartOfIndicesIndex + maskedChracterGlyphIndex + 2);
						m_status = status.start_glyph;
						goto case status.start_glyph;

					case status.start_glyph:
						x = m_CurrentX;
						y = m_CurrentY;
						m_status = status.glyph;
						return FlagsAndCommand.MoveTo;

					case status.glyph:
						if (m_BeginGlyphIndex >= m_EndGlyphIndex)
						{
							m_status = status.next_char;
							m_CurrentX += m_SpaceBetweenCharacters;
							break;
						}

						sbyte IsAMoveTo_Flag;
						unchecked
						{
							int DeltaX = (sbyte)m_font[m_BeginGlyphIndex++];
							sbyte yc = (sbyte)m_font[m_BeginGlyphIndex++];

							IsAMoveTo_Flag = (sbyte)(yc & 0x80);
							yc <<= 1;
							yc >>= 1;
							int DeltaY = (int)(yc);
							m_CurrentX += (double)(DeltaX) * m_WidthScaleRatio;
							m_CurrentY += (double)(DeltaY) * m_HeightScaleRatio;
						}
						x = m_CurrentX;
						y = m_CurrentY;
						if (IsAMoveTo_Flag != 0)
						{
							return FlagsAndCommand.MoveTo;
						}

						return FlagsAndCommand.LineTo;

					default:
						throw new System.Exception("Unknown Status");
				}
			}

			return FlagsAndCommand.Stop;
		}
	};

	internal static class CGSVDefaultFont
	{
		static public byte[] gsv_default_font =
		{
			0x40,0x00,0x6c,0x0f,0x15,0x00,0x0e,0x00,0xf9,0xff,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x0d,0x0a,0x0d,0x0a,0x46,0x6f,0x6e,0x74,0x20,0x28,
			0x63,0x29,0x20,0x4d,0x69,0x63,0x72,0x6f,0x50,0x72,
			0x6f,0x66,0x20,0x32,0x37,0x20,0x53,0x65,0x70,0x74,
			0x65,0x6d,0x62,0x2e,0x31,0x39,0x38,0x39,0x00,0x0d,
			0x0a,0x0d,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x02,0x00,0x12,0x00,0x34,0x00,0x46,0x00,0x94,0x00,
			0xd0,0x00,0x2e,0x01,0x3e,0x01,0x64,0x01,0x8a,0x01,
			0x98,0x01,0xa2,0x01,0xb4,0x01,0xba,0x01,0xc6,0x01,
			0xcc,0x01,0xf0,0x01,0xfa,0x01,0x18,0x02,0x38,0x02,
			0x44,0x02,0x68,0x02,0x98,0x02,0xa2,0x02,0xde,0x02,
			0x0e,0x03,0x24,0x03,0x40,0x03,0x48,0x03,0x52,0x03,
			0x5a,0x03,0x82,0x03,0xec,0x03,0xfa,0x03,0x26,0x04,
			0x4c,0x04,0x6a,0x04,0x7c,0x04,0x8a,0x04,0xb6,0x04,
			0xc4,0x04,0xca,0x04,0xe0,0x04,0xee,0x04,0xf8,0x04,
			0x0a,0x05,0x18,0x05,0x44,0x05,0x5e,0x05,0x8e,0x05,
			0xac,0x05,0xd6,0x05,0xe0,0x05,0xf6,0x05,0x00,0x06,
			0x12,0x06,0x1c,0x06,0x28,0x06,0x36,0x06,0x48,0x06,
			0x4e,0x06,0x60,0x06,0x6e,0x06,0x74,0x06,0x84,0x06,
			0xa6,0x06,0xc8,0x06,0xe6,0x06,0x08,0x07,0x2c,0x07,
			0x3c,0x07,0x68,0x07,0x7c,0x07,0x8c,0x07,0xa2,0x07,
			0xb0,0x07,0xb6,0x07,0xd8,0x07,0xec,0x07,0x10,0x08,
			0x32,0x08,0x54,0x08,0x64,0x08,0x88,0x08,0x98,0x08,
			0xac,0x08,0xb6,0x08,0xc8,0x08,0xd2,0x08,0xe4,0x08,
			0xf2,0x08,0x3e,0x09,0x48,0x09,0x94,0x09,0xc2,0x09,
			0xc4,0x09,0xd0,0x09,0xe2,0x09,0x04,0x0a,0x0e,0x0a,
			0x26,0x0a,0x34,0x0a,0x4a,0x0a,0x66,0x0a,0x70,0x0a,
			0x7e,0x0a,0x8e,0x0a,0x9a,0x0a,0xa6,0x0a,0xb4,0x0a,
			0xd8,0x0a,0xe2,0x0a,0xf6,0x0a,0x18,0x0b,0x22,0x0b,
			0x32,0x0b,0x56,0x0b,0x60,0x0b,0x6e,0x0b,0x7c,0x0b,
			0x8a,0x0b,0x9c,0x0b,0x9e,0x0b,0xb2,0x0b,0xc2,0x0b,
			0xd8,0x0b,0xf4,0x0b,0x08,0x0c,0x30,0x0c,0x56,0x0c,
			0x72,0x0c,0x90,0x0c,0xb2,0x0c,0xce,0x0c,0xe2,0x0c,
			0xfe,0x0c,0x10,0x0d,0x26,0x0d,0x36,0x0d,0x42,0x0d,
			0x4e,0x0d,0x5c,0x0d,0x78,0x0d,0x8c,0x0d,0x8e,0x0d,
			0x90,0x0d,0x92,0x0d,0x94,0x0d,0x96,0x0d,0x98,0x0d,
			0x9a,0x0d,0x9c,0x0d,0x9e,0x0d,0xa0,0x0d,0xa2,0x0d,
			0xa4,0x0d,0xa6,0x0d,0xa8,0x0d,0xaa,0x0d,0xac,0x0d,
			0xae,0x0d,0xb0,0x0d,0xb2,0x0d,0xb4,0x0d,0xb6,0x0d,
			0xb8,0x0d,0xba,0x0d,0xbc,0x0d,0xbe,0x0d,0xc0,0x0d,
			0xc2,0x0d,0xc4,0x0d,0xc6,0x0d,0xc8,0x0d,0xca,0x0d,
			0xcc,0x0d,0xce,0x0d,0xd0,0x0d,0xd2,0x0d,0xd4,0x0d,
			0xd6,0x0d,0xd8,0x0d,0xda,0x0d,0xdc,0x0d,0xde,0x0d,
			0xe0,0x0d,0xe2,0x0d,0xe4,0x0d,0xe6,0x0d,0xe8,0x0d,
			0xea,0x0d,0xec,0x0d,0x0c,0x0e,0x26,0x0e,0x48,0x0e,
			0x64,0x0e,0x88,0x0e,0x92,0x0e,0xa6,0x0e,0xb4,0x0e,
			0xd0,0x0e,0xee,0x0e,0x02,0x0f,0x16,0x0f,0x26,0x0f,
			0x3c,0x0f,0x58,0x0f,0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,
			0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,
			0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,
			0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,0x10,0x80,
			0x05,0x95,0x00,0x72,0x00,0xfb,0xff,0x7f,0x01,0x7f,
			0x01,0x01,0xff,0x01,0x05,0xfe,0x05,0x95,0xff,0x7f,
			0x00,0x7a,0x01,0x86,0xff,0x7a,0x01,0x87,0x01,0x7f,
			0xfe,0x7a,0x0a,0x87,0xff,0x7f,0x00,0x7a,0x01,0x86,
			0xff,0x7a,0x01,0x87,0x01,0x7f,0xfe,0x7a,0x05,0xf2,
			0x0b,0x95,0xf9,0x64,0x0d,0x9c,0xf9,0x64,0xfa,0x91,
			0x0e,0x00,0xf1,0xfa,0x0e,0x00,0x04,0xfc,0x08,0x99,
			0x00,0x63,0x04,0x9d,0x00,0x63,0x04,0x96,0xff,0x7f,
			0x01,0x7f,0x01,0x01,0x00,0x01,0xfe,0x02,0xfd,0x01,
			0xfc,0x00,0xfd,0x7f,0xfe,0x7e,0x00,0x7e,0x01,0x7e,
			0x01,0x7f,0x02,0x7f,0x06,0x7e,0x02,0x7f,0x02,0x7e,
			0xf2,0x89,0x02,0x7e,0x02,0x7f,0x06,0x7e,0x02,0x7f,
			0x01,0x7f,0x01,0x7e,0x00,0x7c,0xfe,0x7e,0xfd,0x7f,
			0xfc,0x00,0xfd,0x01,0xfe,0x02,0x00,0x01,0x01,0x01,
			0x01,0x7f,0xff,0x7f,0x10,0xfd,0x15,0x95,0xee,0x6b,
			0x05,0x95,0x02,0x7e,0x00,0x7e,0xff,0x7e,0xfe,0x7f,
			0xfe,0x00,0xfe,0x02,0x00,0x02,0x01,0x02,0x02,0x01,
			0x02,0x00,0x02,0x7f,0x03,0x7f,0x03,0x00,0x03,0x01,
			0x02,0x01,0xfc,0xf2,0xfe,0x7f,0xff,0x7e,0x00,0x7e,
			0x02,0x7e,0x02,0x00,0x02,0x01,0x01,0x02,0x00,0x02,
			0xfe,0x02,0xfe,0x00,0x07,0xf9,0x15,0x8d,0xff,0x7f,
			0x01,0x7f,0x01,0x01,0x00,0x01,0xff,0x01,0xff,0x00,
			0xff,0x7f,0xff,0x7e,0xfe,0x7b,0xfe,0x7d,0xfe,0x7e,
			0xfe,0x7f,0xfd,0x00,0xfd,0x01,0xff,0x02,0x00,0x03,
			0x01,0x02,0x06,0x04,0x02,0x02,0x01,0x02,0x00,0x02,
			0xff,0x02,0xfe,0x01,0xfe,0x7f,0xff,0x7e,0x00,0x7e,
			0x01,0x7d,0x02,0x7d,0x05,0x79,0x02,0x7e,0x03,0x7f,
			0x01,0x00,0x01,0x01,0x00,0x01,0xf1,0xfe,0xfe,0x01,
			0xff,0x02,0x00,0x03,0x01,0x02,0x02,0x02,0x00,0x86,
			0x01,0x7e,0x08,0x75,0x02,0x7e,0x02,0x7f,0x05,0x80,
			0x05,0x93,0xff,0x01,0x01,0x01,0x01,0x7f,0x00,0x7e,
			0xff,0x7e,0xff,0x7f,0x06,0xf1,0x0b,0x99,0xfe,0x7e,
			0xfe,0x7d,0xfe,0x7c,0xff,0x7b,0x00,0x7c,0x01,0x7b,
			0x02,0x7c,0x02,0x7d,0x02,0x7e,0xfe,0x9e,0xfe,0x7c,
			0xff,0x7d,0xff,0x7b,0x00,0x7c,0x01,0x7b,0x01,0x7d,
			0x02,0x7c,0x05,0x85,0x03,0x99,0x02,0x7e,0x02,0x7d,
			0x02,0x7c,0x01,0x7b,0x00,0x7c,0xff,0x7b,0xfe,0x7c,
			0xfe,0x7d,0xfe,0x7e,0x02,0x9e,0x02,0x7c,0x01,0x7d,
			0x01,0x7b,0x00,0x7c,0xff,0x7b,0xff,0x7d,0xfe,0x7c,
			0x09,0x85,0x08,0x95,0x00,0x74,0xfb,0x89,0x0a,0x7a,
			0x00,0x86,0xf6,0x7a,0x0d,0xf4,0x0d,0x92,0x00,0x6e,
			0xf7,0x89,0x12,0x00,0x04,0xf7,0x06,0x81,0xff,0x7f,
			0xff,0x01,0x01,0x01,0x01,0x7f,0x00,0x7e,0xff,0x7e,
			0xff,0x7f,0x06,0x84,0x04,0x89,0x12,0x00,0x04,0xf7,
			0x05,0x82,0xff,0x7f,0x01,0x7f,0x01,0x01,0xff,0x01,
			0x05,0xfe,0x00,0xfd,0x0e,0x18,0x00,0xeb,0x09,0x95,
			0xfd,0x7f,0xfe,0x7d,0xff,0x7b,0x00,0x7d,0x01,0x7b,
			0x02,0x7d,0x03,0x7f,0x02,0x00,0x03,0x01,0x02,0x03,
			0x01,0x05,0x00,0x03,0xff,0x05,0xfe,0x03,0xfd,0x01,
			0xfe,0x00,0x0b,0xeb,0x06,0x91,0x02,0x01,0x03,0x03,
			0x00,0x6b,0x09,0x80,0x04,0x90,0x00,0x01,0x01,0x02,
			0x01,0x01,0x02,0x01,0x04,0x00,0x02,0x7f,0x01,0x7f,
			0x01,0x7e,0x00,0x7e,0xff,0x7e,0xfe,0x7d,0xf6,0x76,
			0x0e,0x00,0x03,0x80,0x05,0x95,0x0b,0x00,0xfa,0x78,
			0x03,0x00,0x02,0x7f,0x01,0x7f,0x01,0x7d,0x00,0x7e,
			0xff,0x7d,0xfe,0x7e,0xfd,0x7f,0xfd,0x00,0xfd,0x01,
			0xff,0x01,0xff,0x02,0x11,0xfc,0x0d,0x95,0xf6,0x72,
			0x0f,0x00,0xfb,0x8e,0x00,0x6b,0x07,0x80,0x0f,0x95,
			0xf6,0x00,0xff,0x77,0x01,0x01,0x03,0x01,0x03,0x00,
			0x03,0x7f,0x02,0x7e,0x01,0x7d,0x00,0x7e,0xff,0x7d,
			0xfe,0x7e,0xfd,0x7f,0xfd,0x00,0xfd,0x01,0xff,0x01,
			0xff,0x02,0x11,0xfc,0x10,0x92,0xff,0x02,0xfd,0x01,
			0xfe,0x00,0xfd,0x7f,0xfe,0x7d,0xff,0x7b,0x00,0x7b,
			0x01,0x7c,0x02,0x7e,0x03,0x7f,0x01,0x00,0x03,0x01,
			0x02,0x02,0x01,0x03,0x00,0x01,0xff,0x03,0xfe,0x02,
			0xfd,0x01,0xff,0x00,0xfd,0x7f,0xfe,0x7e,0xff,0x7d,
			0x10,0xf9,0x11,0x95,0xf6,0x6b,0xfc,0x95,0x0e,0x00,
			0x03,0xeb,0x08,0x95,0xfd,0x7f,0xff,0x7e,0x00,0x7e,
			0x01,0x7e,0x02,0x7f,0x04,0x7f,0x03,0x7f,0x02,0x7e,
			0x01,0x7e,0x00,0x7d,0xff,0x7e,0xff,0x7f,0xfd,0x7f,
			0xfc,0x00,0xfd,0x01,0xff,0x01,0xff,0x02,0x00,0x03,
			0x01,0x02,0x02,0x02,0x03,0x01,0x04,0x01,0x02,0x01,
			0x01,0x02,0x00,0x02,0xff,0x02,0xfd,0x01,0xfc,0x00,
			0x0c,0xeb,0x10,0x8e,0xff,0x7d,0xfe,0x7e,0xfd,0x7f,
			0xff,0x00,0xfd,0x01,0xfe,0x02,0xff,0x03,0x00,0x01,
			0x01,0x03,0x02,0x02,0x03,0x01,0x01,0x00,0x03,0x7f,
			0x02,0x7e,0x01,0x7c,0x00,0x7b,0xff,0x7b,0xfe,0x7d,
			0xfd,0x7f,0xfe,0x00,0xfd,0x01,0xff,0x02,0x10,0xfd,
			0x05,0x8e,0xff,0x7f,0x01,0x7f,0x01,0x01,0xff,0x01,
			0x00,0xf4,0xff,0x7f,0x01,0x7f,0x01,0x01,0xff,0x01,
			0x05,0xfe,0x05,0x8e,0xff,0x7f,0x01,0x7f,0x01,0x01,
			0xff,0x01,0x01,0xf3,0xff,0x7f,0xff,0x01,0x01,0x01,
			0x01,0x7f,0x00,0x7e,0xff,0x7e,0xff,0x7f,0x06,0x84,
			0x14,0x92,0xf0,0x77,0x10,0x77,0x04,0x80,0x04,0x8c,
			0x12,0x00,0xee,0xfa,0x12,0x00,0x04,0xfa,0x04,0x92,
			0x10,0x77,0xf0,0x77,0x14,0x80,0x03,0x90,0x00,0x01,
			0x01,0x02,0x01,0x01,0x02,0x01,0x04,0x00,0x02,0x7f,
			0x01,0x7f,0x01,0x7e,0x00,0x7e,0xff,0x7e,0xff,0x7f,
			0xfc,0x7e,0x00,0x7d,0x00,0xfb,0xff,0x7f,0x01,0x7f,
			0x01,0x01,0xff,0x01,0x09,0xfe,0x12,0x8d,0xff,0x02,
			0xfe,0x01,0xfd,0x00,0xfe,0x7f,0xff,0x7f,0xff,0x7d,
			0x00,0x7d,0x01,0x7e,0x02,0x7f,0x03,0x00,0x02,0x01,
			0x01,0x02,0xfb,0x88,0xfe,0x7e,0xff,0x7d,0x00,0x7d,
			0x01,0x7e,0x01,0x7f,0x07,0x8b,0xff,0x78,0x00,0x7e,
			0x02,0x7f,0x02,0x00,0x02,0x02,0x01,0x03,0x00,0x02,
			0xff,0x03,0xff,0x02,0xfe,0x02,0xfe,0x01,0xfd,0x01,
			0xfd,0x00,0xfd,0x7f,0xfe,0x7f,0xfe,0x7e,0xff,0x7e,
			0xff,0x7d,0x00,0x7d,0x01,0x7d,0x01,0x7e,0x02,0x7e,
			0x02,0x7f,0x03,0x7f,0x03,0x00,0x03,0x01,0x02,0x01,
			0x01,0x01,0xfe,0x8d,0xff,0x78,0x00,0x7e,0x01,0x7f,
			0x08,0xfb,0x09,0x95,0xf8,0x6b,0x08,0x95,0x08,0x6b,
			0xf3,0x87,0x0a,0x00,0x04,0xf9,0x04,0x95,0x00,0x6b,
			0x00,0x95,0x09,0x00,0x03,0x7f,0x01,0x7f,0x01,0x7e,
			0x00,0x7e,0xff,0x7e,0xff,0x7f,0xfd,0x7f,0xf7,0x80,
			0x09,0x00,0x03,0x7f,0x01,0x7f,0x01,0x7e,0x00,0x7d,
			0xff,0x7e,0xff,0x7f,0xfd,0x7f,0xf7,0x00,0x11,0x80,
			0x12,0x90,0xff,0x02,0xfe,0x02,0xfe,0x01,0xfc,0x00,
			0xfe,0x7f,0xfe,0x7e,0xff,0x7e,0xff,0x7d,0x00,0x7b,
			0x01,0x7d,0x01,0x7e,0x02,0x7e,0x02,0x7f,0x04,0x00,
			0x02,0x01,0x02,0x02,0x01,0x02,0x03,0xfb,0x04,0x95,
			0x00,0x6b,0x00,0x95,0x07,0x00,0x03,0x7f,0x02,0x7e,
			0x01,0x7e,0x01,0x7d,0x00,0x7b,0xff,0x7d,0xff,0x7e,
			0xfe,0x7e,0xfd,0x7f,0xf9,0x00,0x11,0x80,0x04,0x95,
			0x00,0x6b,0x00,0x95,0x0d,0x00,0xf3,0xf6,0x08,0x00,
			0xf8,0xf5,0x0d,0x00,0x02,0x80,0x04,0x95,0x00,0x6b,
			0x00,0x95,0x0d,0x00,0xf3,0xf6,0x08,0x00,0x06,0xf5,
			0x12,0x90,0xff,0x02,0xfe,0x02,0xfe,0x01,0xfc,0x00,
			0xfe,0x7f,0xfe,0x7e,0xff,0x7e,0xff,0x7d,0x00,0x7b,
			0x01,0x7d,0x01,0x7e,0x02,0x7e,0x02,0x7f,0x04,0x00,
			0x02,0x01,0x02,0x02,0x01,0x02,0x00,0x03,0xfb,0x80,
			0x05,0x00,0x03,0xf8,0x04,0x95,0x00,0x6b,0x0e,0x95,
			0x00,0x6b,0xf2,0x8b,0x0e,0x00,0x04,0xf5,0x04,0x95,
			0x00,0x6b,0x04,0x80,0x0c,0x95,0x00,0x70,0xff,0x7d,
			0xff,0x7f,0xfe,0x7f,0xfe,0x00,0xfe,0x01,0xff,0x01,
			0xff,0x03,0x00,0x02,0x0e,0xf9,0x04,0x95,0x00,0x6b,
			0x0e,0x95,0xf2,0x72,0x05,0x85,0x09,0x74,0x03,0x80,
			0x04,0x95,0x00,0x6b,0x00,0x80,0x0c,0x00,0x01,0x80,
			0x04,0x95,0x00,0x6b,0x00,0x95,0x08,0x6b,0x08,0x95,
			0xf8,0x6b,0x08,0x95,0x00,0x6b,0x04,0x80,0x04,0x95,
			0x00,0x6b,0x00,0x95,0x0e,0x6b,0x00,0x95,0x00,0x6b,
			0x04,0x80,0x09,0x95,0xfe,0x7f,0xfe,0x7e,0xff,0x7e,
			0xff,0x7d,0x00,0x7b,0x01,0x7d,0x01,0x7e,0x02,0x7e,
			0x02,0x7f,0x04,0x00,0x02,0x01,0x02,0x02,0x01,0x02,
			0x01,0x03,0x00,0x05,0xff,0x03,0xff,0x02,0xfe,0x02,
			0xfe,0x01,0xfc,0x00,0x0d,0xeb,0x04,0x95,0x00,0x6b,
			0x00,0x95,0x09,0x00,0x03,0x7f,0x01,0x7f,0x01,0x7e,
			0x00,0x7d,0xff,0x7e,0xff,0x7f,0xfd,0x7f,0xf7,0x00,
			0x11,0xf6,0x09,0x95,0xfe,0x7f,0xfe,0x7e,0xff,0x7e,
			0xff,0x7d,0x00,0x7b,0x01,0x7d,0x01,0x7e,0x02,0x7e,
			0x02,0x7f,0x04,0x00,0x02,0x01,0x02,0x02,0x01,0x02,
			0x01,0x03,0x00,0x05,0xff,0x03,0xff,0x02,0xfe,0x02,
			0xfe,0x01,0xfc,0x00,0x03,0xef,0x06,0x7a,0x04,0x82,
			0x04,0x95,0x00,0x6b,0x00,0x95,0x09,0x00,0x03,0x7f,
			0x01,0x7f,0x01,0x7e,0x00,0x7e,0xff,0x7e,0xff,0x7f,
			0xfd,0x7f,0xf7,0x00,0x07,0x80,0x07,0x75,0x03,0x80,
			0x11,0x92,0xfe,0x02,0xfd,0x01,0xfc,0x00,0xfd,0x7f,
			0xfe,0x7e,0x00,0x7e,0x01,0x7e,0x01,0x7f,0x02,0x7f,
			0x06,0x7e,0x02,0x7f,0x01,0x7f,0x01,0x7e,0x00,0x7d,
			0xfe,0x7e,0xfd,0x7f,0xfc,0x00,0xfd,0x01,0xfe,0x02,
			0x11,0xfd,0x08,0x95,0x00,0x6b,0xf9,0x95,0x0e,0x00,
			0x01,0xeb,0x04,0x95,0x00,0x71,0x01,0x7d,0x02,0x7e,
			0x03,0x7f,0x02,0x00,0x03,0x01,0x02,0x02,0x01,0x03,
			0x00,0x0f,0x04,0xeb,0x01,0x95,0x08,0x6b,0x08,0x95,
			0xf8,0x6b,0x09,0x80,0x02,0x95,0x05,0x6b,0x05,0x95,
			0xfb,0x6b,0x05,0x95,0x05,0x6b,0x05,0x95,0xfb,0x6b,
			0x07,0x80,0x03,0x95,0x0e,0x6b,0x00,0x95,0xf2,0x6b,
			0x11,0x80,0x01,0x95,0x08,0x76,0x00,0x75,0x08,0x95,
			0xf8,0x76,0x09,0xf5,0x11,0x95,0xf2,0x6b,0x00,0x95,
			0x0e,0x00,0xf2,0xeb,0x0e,0x00,0x03,0x80,0x03,0x93,
			0x00,0x6c,0x01,0x94,0x00,0x6c,0xff,0x94,0x05,0x00,
			0xfb,0xec,0x05,0x00,0x02,0x81,0x00,0x95,0x0e,0x68,
			0x00,0x83,0x06,0x93,0x00,0x6c,0x01,0x94,0x00,0x6c,
			0xfb,0x94,0x05,0x00,0xfb,0xec,0x05,0x00,0x03,0x81,
			0x03,0x87,0x08,0x05,0x08,0x7b,0xf0,0x80,0x08,0x04,
			0x08,0x7c,0x03,0xf9,0x01,0x80,0x10,0x00,0x01,0x80,
			0x06,0x95,0xff,0x7f,0xff,0x7e,0x00,0x7e,0x01,0x7f,
			0x01,0x01,0xff,0x01,0x05,0xef,0x0f,0x8e,0x00,0x72,
			0x00,0x8b,0xfe,0x02,0xfe,0x01,0xfd,0x00,0xfe,0x7f,
			0xfe,0x7e,0xff,0x7d,0x00,0x7e,0x01,0x7d,0x02,0x7e,
			0x02,0x7f,0x03,0x00,0x02,0x01,0x02,0x02,0x04,0xfd,
			0x04,0x95,0x00,0x6b,0x00,0x8b,0x02,0x02,0x02,0x01,
			0x03,0x00,0x02,0x7f,0x02,0x7e,0x01,0x7d,0x00,0x7e,
			0xff,0x7d,0xfe,0x7e,0xfe,0x7f,0xfd,0x00,0xfe,0x01,
			0xfe,0x02,0x0f,0xfd,0x0f,0x8b,0xfe,0x02,0xfe,0x01,
			0xfd,0x00,0xfe,0x7f,0xfe,0x7e,0xff,0x7d,0x00,0x7e,
			0x01,0x7d,0x02,0x7e,0x02,0x7f,0x03,0x00,0x02,0x01,
			0x02,0x02,0x03,0xfd,0x0f,0x95,0x00,0x6b,0x00,0x8b,
			0xfe,0x02,0xfe,0x01,0xfd,0x00,0xfe,0x7f,0xfe,0x7e,
			0xff,0x7d,0x00,0x7e,0x01,0x7d,0x02,0x7e,0x02,0x7f,
			0x03,0x00,0x02,0x01,0x02,0x02,0x04,0xfd,0x03,0x88,
			0x0c,0x00,0x00,0x02,0xff,0x02,0xff,0x01,0xfe,0x01,
			0xfd,0x00,0xfe,0x7f,0xfe,0x7e,0xff,0x7d,0x00,0x7e,
			0x01,0x7d,0x02,0x7e,0x02,0x7f,0x03,0x00,0x02,0x01,
			0x02,0x02,0x03,0xfd,0x0a,0x95,0xfe,0x00,0xfe,0x7f,
			0xff,0x7d,0x00,0x6f,0xfd,0x8e,0x07,0x00,0x03,0xf2,
			0x0f,0x8e,0x00,0x70,0xff,0x7d,0xff,0x7f,0xfe,0x7f,
			0xfd,0x00,0xfe,0x01,0x09,0x91,0xfe,0x02,0xfe,0x01,
			0xfd,0x00,0xfe,0x7f,0xfe,0x7e,0xff,0x7d,0x00,0x7e,
			0x01,0x7d,0x02,0x7e,0x02,0x7f,0x03,0x00,0x02,0x01,
			0x02,0x02,0x04,0xfd,0x04,0x95,0x00,0x6b,0x00,0x8a,
			0x03,0x03,0x02,0x01,0x03,0x00,0x02,0x7f,0x01,0x7d,
			0x00,0x76,0x04,0x80,0x03,0x95,0x01,0x7f,0x01,0x01,
			0xff,0x01,0xff,0x7f,0x01,0xf9,0x00,0x72,0x04,0x80,
			0x05,0x95,0x01,0x7f,0x01,0x01,0xff,0x01,0xff,0x7f,
			0x01,0xf9,0x00,0x6f,0xff,0x7d,0xfe,0x7f,0xfe,0x00,
			0x09,0x87,0x04,0x95,0x00,0x6b,0x0a,0x8e,0xf6,0x76,
			0x04,0x84,0x07,0x78,0x02,0x80,0x04,0x95,0x00,0x6b,
			0x04,0x80,0x04,0x8e,0x00,0x72,0x00,0x8a,0x03,0x03,
			0x02,0x01,0x03,0x00,0x02,0x7f,0x01,0x7d,0x00,0x76,
			0x00,0x8a,0x03,0x03,0x02,0x01,0x03,0x00,0x02,0x7f,
			0x01,0x7d,0x00,0x76,0x04,0x80,0x04,0x8e,0x00,0x72,
			0x00,0x8a,0x03,0x03,0x02,0x01,0x03,0x00,0x02,0x7f,
			0x01,0x7d,0x00,0x76,0x04,0x80,0x08,0x8e,0xfe,0x7f,
			0xfe,0x7e,0xff,0x7d,0x00,0x7e,0x01,0x7d,0x02,0x7e,
			0x02,0x7f,0x03,0x00,0x02,0x01,0x02,0x02,0x01,0x03,
			0x00,0x02,0xff,0x03,0xfe,0x02,0xfe,0x01,0xfd,0x00,
			0x0b,0xf2,0x04,0x8e,0x00,0x6b,0x00,0x92,0x02,0x02,
			0x02,0x01,0x03,0x00,0x02,0x7f,0x02,0x7e,0x01,0x7d,
			0x00,0x7e,0xff,0x7d,0xfe,0x7e,0xfe,0x7f,0xfd,0x00,
			0xfe,0x01,0xfe,0x02,0x0f,0xfd,0x0f,0x8e,0x00,0x6b,
			0x00,0x92,0xfe,0x02,0xfe,0x01,0xfd,0x00,0xfe,0x7f,
			0xfe,0x7e,0xff,0x7d,0x00,0x7e,0x01,0x7d,0x02,0x7e,
			0x02,0x7f,0x03,0x00,0x02,0x01,0x02,0x02,0x04,0xfd,
			0x04,0x8e,0x00,0x72,0x00,0x88,0x01,0x03,0x02,0x02,
			0x02,0x01,0x03,0x00,0x01,0xf2,0x0e,0x8b,0xff,0x02,
			0xfd,0x01,0xfd,0x00,0xfd,0x7f,0xff,0x7e,0x01,0x7e,
			0x02,0x7f,0x05,0x7f,0x02,0x7f,0x01,0x7e,0x00,0x7f,
			0xff,0x7e,0xfd,0x7f,0xfd,0x00,0xfd,0x01,0xff,0x02,
			0x0e,0xfd,0x05,0x95,0x00,0x6f,0x01,0x7d,0x02,0x7f,
			0x02,0x00,0xf8,0x8e,0x07,0x00,0x03,0xf2,0x04,0x8e,
			0x00,0x76,0x01,0x7d,0x02,0x7f,0x03,0x00,0x02,0x01,
			0x03,0x03,0x00,0x8a,0x00,0x72,0x04,0x80,0x02,0x8e,
			0x06,0x72,0x06,0x8e,0xfa,0x72,0x08,0x80,0x03,0x8e,
			0x04,0x72,0x04,0x8e,0xfc,0x72,0x04,0x8e,0x04,0x72,
			0x04,0x8e,0xfc,0x72,0x07,0x80,0x03,0x8e,0x0b,0x72,
			0x00,0x8e,0xf5,0x72,0x0e,0x80,0x02,0x8e,0x06,0x72,
			0x06,0x8e,0xfa,0x72,0xfe,0x7c,0xfe,0x7e,0xfe,0x7f,
			0xff,0x00,0x0f,0x87,0x0e,0x8e,0xf5,0x72,0x00,0x8e,
			0x0b,0x00,0xf5,0xf2,0x0b,0x00,0x03,0x80,0x09,0x99,
			0xfe,0x7f,0xff,0x7f,0xff,0x7e,0x00,0x7e,0x01,0x7e,
			0x01,0x7f,0x01,0x7e,0x00,0x7e,0xfe,0x7e,0x01,0x8e,
			0xff,0x7e,0x00,0x7e,0x01,0x7e,0x01,0x7f,0x01,0x7e,
			0x00,0x7e,0xff,0x7e,0xfc,0x7e,0x04,0x7e,0x01,0x7e,
			0x00,0x7e,0xff,0x7e,0xff,0x7f,0xff,0x7e,0x00,0x7e,
			0x01,0x7e,0xff,0x8e,0x02,0x7e,0x00,0x7e,0xff,0x7e,
			0xff,0x7f,0xff,0x7e,0x00,0x7e,0x01,0x7e,0x01,0x7f,
			0x02,0x7f,0x05,0x87,0x04,0x95,0x00,0x77,0x00,0xfd,
			0x00,0x77,0x04,0x80,0x05,0x99,0x02,0x7f,0x01,0x7f,
			0x01,0x7e,0x00,0x7e,0xff,0x7e,0xff,0x7f,0xff,0x7e,
			0x00,0x7e,0x02,0x7e,0xff,0x8e,0x01,0x7e,0x00,0x7e,
			0xff,0x7e,0xff,0x7f,0xff,0x7e,0x00,0x7e,0x01,0x7e,
			0x04,0x7e,0xfc,0x7e,0xff,0x7e,0x00,0x7e,0x01,0x7e,
			0x01,0x7f,0x01,0x7e,0x00,0x7e,0xff,0x7e,0x01,0x8e,
			0xfe,0x7e,0x00,0x7e,0x01,0x7e,0x01,0x7f,0x01,0x7e,
			0x00,0x7e,0xff,0x7e,0xff,0x7f,0xfe,0x7f,0x09,0x87,
			0x03,0x86,0x00,0x02,0x01,0x03,0x02,0x01,0x02,0x00,
			0x02,0x7f,0x04,0x7d,0x02,0x7f,0x02,0x00,0x02,0x01,
			0x01,0x02,0xee,0xfe,0x01,0x02,0x02,0x01,0x02,0x00,
			0x02,0x7f,0x04,0x7d,0x02,0x7f,0x02,0x00,0x02,0x01,
			0x01,0x03,0x00,0x02,0x03,0xf4,0x10,0x80,0x03,0x80,
			0x07,0x15,0x08,0x6b,0xfe,0x85,0xf5,0x00,0x10,0xfb,
			0x0d,0x95,0xf6,0x00,0x00,0x6b,0x0a,0x00,0x02,0x02,
			0x00,0x08,0xfe,0x02,0xf6,0x00,0x0e,0xf4,0x03,0x80,
			0x00,0x15,0x0a,0x00,0x02,0x7e,0x00,0x7e,0x00,0x7d,
			0x00,0x7e,0xfe,0x7f,0xf6,0x00,0x0a,0x80,0x02,0x7e,
			0x01,0x7e,0x00,0x7d,0xff,0x7d,0xfe,0x7f,0xf6,0x00,
			0x10,0x80,0x03,0x80,0x00,0x15,0x0c,0x00,0xff,0x7e,
			0x03,0xed,0x03,0xfd,0x00,0x03,0x02,0x00,0x00,0x12,
			0x02,0x03,0x0a,0x00,0x00,0x6b,0x02,0x00,0x00,0x7d,
			0xfe,0x83,0xf4,0x00,0x11,0x80,0x0f,0x80,0xf4,0x00,
			0x00,0x15,0x0c,0x00,0xff,0xf6,0xf5,0x00,0x0f,0xf5,
			0x04,0x95,0x07,0x76,0x00,0x0a,0x07,0x80,0xf9,0x76,
			0x00,0x75,0xf8,0x80,0x07,0x0c,0x09,0xf4,0xf9,0x0c,
			0x09,0xf4,0x03,0x92,0x02,0x03,0x07,0x00,0x03,0x7d,
			0x00,0x7b,0xfc,0x7e,0x04,0x7d,0x00,0x7a,0xfd,0x7e,
			0xf9,0x00,0xfe,0x02,0x06,0x89,0x02,0x00,0x06,0xf5,
			0x03,0x95,0x00,0x6b,0x0c,0x15,0x00,0x6b,0x02,0x80,
			0x03,0x95,0x00,0x6b,0x0c,0x15,0x00,0x6b,0xf8,0x96,
			0x03,0x00,0x07,0xea,0x03,0x80,0x00,0x15,0x0c,0x80,
			0xf7,0x76,0xfd,0x00,0x03,0x80,0x0a,0x75,0x03,0x80,
			0x03,0x80,0x07,0x13,0x02,0x02,0x03,0x00,0x00,0x6b,
			0x02,0x80,0x03,0x80,0x00,0x15,0x09,0x6b,0x09,0x15,
			0x00,0x6b,0x03,0x80,0x03,0x80,0x00,0x15,0x00,0xf6,
			0x0d,0x00,0x00,0x8a,0x00,0x6b,0x03,0x80,0x07,0x80,
			0xfd,0x00,0xff,0x03,0x00,0x04,0x00,0x07,0x00,0x04,
			0x01,0x02,0x03,0x01,0x06,0x00,0x03,0x7f,0x01,0x7e,
			0x01,0x7c,0x00,0x79,0xff,0x7c,0xff,0x7d,0xfd,0x00,
			0xfa,0x00,0x0e,0x80,0x03,0x80,0x00,0x15,0x0c,0x00,
			0x00,0x6b,0x02,0x80,0x03,0x80,0x00,0x15,0x0a,0x00,
			0x02,0x7f,0x01,0x7d,0x00,0x7b,0xff,0x7e,0xfe,0x7f,
			0xf6,0x00,0x10,0xf7,0x11,0x8f,0xff,0x03,0xff,0x02,
			0xfe,0x01,0xfa,0x00,0xfd,0x7f,0xff,0x7e,0x00,0x7c,
			0x00,0x79,0x00,0x7b,0x01,0x7e,0x03,0x00,0x06,0x00,
			0x02,0x00,0x01,0x03,0x01,0x02,0x03,0xfb,0x03,0x95,
			0x0c,0x00,0xfa,0x80,0x00,0x6b,0x09,0x80,0x03,0x95,
			0x00,0x77,0x06,0x7a,0x06,0x06,0x00,0x09,0xfa,0xf1,
			0xfa,0x7a,0x0e,0x80,0x03,0x87,0x00,0x0b,0x02,0x02,
			0x03,0x00,0x02,0x7e,0x01,0x02,0x04,0x00,0x02,0x7e,
			0x00,0x75,0xfe,0x7e,0xfc,0x00,0xff,0x01,0xfe,0x7f,
			0xfd,0x00,0xfe,0x02,0x07,0x8e,0x00,0x6b,0x09,0x80,
			0x03,0x80,0x0e,0x15,0xf2,0x80,0x0e,0x6b,0x03,0x80,
			0x03,0x95,0x00,0x6b,0x0e,0x00,0x00,0x7d,0xfe,0x98,
			0x00,0x6b,0x05,0x80,0x03,0x95,0x00,0x75,0x02,0x7d,
			0x0a,0x00,0x00,0x8e,0x00,0x6b,0x02,0x80,0x03,0x95,
			0x00,0x6b,0x10,0x00,0x00,0x15,0xf8,0x80,0x00,0x6b,
			0x0a,0x80,0x03,0x95,0x00,0x6b,0x10,0x00,0x00,0x15,
			0xf8,0x80,0x00,0x6b,0x0a,0x00,0x00,0x7d,0x02,0x83,
			0x10,0x80,0x03,0x95,0x00,0x6b,0x09,0x00,0x03,0x02,
			0x00,0x08,0xfd,0x02,0xf7,0x00,0x0e,0x89,0x00,0x6b,
			0x03,0x80,0x03,0x95,0x00,0x6b,0x09,0x00,0x03,0x02,
			0x00,0x08,0xfd,0x02,0xf7,0x00,0x0e,0xf4,0x03,0x92,
			0x02,0x03,0x07,0x00,0x03,0x7d,0x00,0x70,0xfd,0x7e,
			0xf9,0x00,0xfe,0x02,0x03,0x89,0x09,0x00,0x02,0xf5,
			0x03,0x80,0x00,0x15,0x00,0xf5,0x07,0x00,0x00,0x08,
			0x02,0x03,0x06,0x00,0x02,0x7d,0x00,0x70,0xfe,0x7e,
			0xfa,0x00,0xfe,0x02,0x00,0x08,0x0c,0xf6,0x0f,0x80,
			0x00,0x15,0xf6,0x00,0xfe,0x7d,0x00,0x79,0x02,0x7e,
			0x0a,0x00,0xf4,0xf7,0x07,0x09,0x07,0xf7,0x03,0x8c,
			0x01,0x02,0x01,0x01,0x05,0x00,0x02,0x7f,0x01,0x7e,
			0x00,0x74,0x00,0x86,0xff,0x01,0xfe,0x01,0xfb,0x00,
			0xff,0x7f,0xff,0x7f,0x00,0x7c,0x01,0x7e,0x01,0x00,
			0x05,0x00,0x02,0x00,0x01,0x02,0x03,0xfe,0x04,0x8e,
			0x02,0x01,0x04,0x00,0x02,0x7f,0x01,0x7e,0x00,0x77,
			0xff,0x7e,0xfe,0x7f,0xfc,0x00,0xfe,0x01,0xff,0x02,
			0x00,0x09,0x01,0x02,0x02,0x02,0x03,0x01,0x02,0x01,
			0x01,0x01,0x01,0x02,0x02,0xeb,0x03,0x80,0x00,0x15,
			0x03,0x00,0x02,0x7e,0x00,0x7b,0xfe,0x7e,0xfd,0x00,
			0x03,0x80,0x04,0x00,0x03,0x7e,0x00,0x78,0xfd,0x7e,
			0xf9,0x00,0x0c,0x80,0x03,0x8c,0x02,0x02,0x02,0x01,
			0x03,0x00,0x02,0x7f,0x01,0x7d,0xfe,0x7e,0xf9,0x7d,
			0xff,0x7e,0x00,0x7d,0x03,0x7f,0x02,0x00,0x03,0x01,
			0x02,0x01,0x02,0xfe,0x0d,0x8c,0xff,0x02,0xfe,0x01,
			0xfc,0x00,0xfe,0x7f,0xff,0x7e,0x00,0x77,0x01,0x7e,
			0x02,0x7f,0x04,0x00,0x02,0x01,0x01,0x02,0x00,0x0f,
			0xff,0x02,0xfe,0x01,0xf9,0x00,0x0c,0xeb,0x03,0x88,
			0x0a,0x00,0x00,0x02,0x00,0x03,0xfe,0x02,0xfa,0x00,
			0xff,0x7e,0xff,0x7d,0x00,0x7b,0x01,0x7c,0x01,0x7f,
			0x06,0x00,0x02,0x02,0x03,0xfe,0x03,0x8f,0x06,0x77,
			0x06,0x09,0xfa,0x80,0x00,0x71,0xff,0x87,0xfb,0x79,
			0x07,0x87,0x05,0x79,0x02,0x80,0x03,0x8d,0x02,0x02,
			0x06,0x00,0x02,0x7e,0x00,0x7d,0xfc,0x7d,0x04,0x7e,
			0x00,0x7d,0xfe,0x7e,0xfa,0x00,0xfe,0x02,0x04,0x85,
			0x02,0x00,0x06,0xf9,0x03,0x8f,0x00,0x73,0x01,0x7e,
			0x07,0x00,0x02,0x02,0x00,0x0d,0x00,0xf3,0x01,0x7e,
			0x03,0x80,0x03,0x8f,0x00,0x73,0x01,0x7e,0x07,0x00,
			0x02,0x02,0x00,0x0d,0x00,0xf3,0x01,0x7e,0xf8,0x90,
			0x03,0x00,0x08,0xf0,0x03,0x80,0x00,0x15,0x00,0xf3,
			0x02,0x00,0x06,0x07,0xfa,0xf9,0x07,0x78,0x03,0x80,
			0x03,0x80,0x04,0x0c,0x02,0x03,0x04,0x00,0x00,0x71,
			0x02,0x80,0x03,0x80,0x00,0x0f,0x06,0x77,0x06,0x09,
			0x00,0x71,0x02,0x80,0x03,0x80,0x00,0x0f,0x0a,0xf1,
			0x00,0x0f,0xf6,0xf8,0x0a,0x00,0x02,0xf9,0x05,0x80,
			0xff,0x01,0xff,0x04,0x00,0x05,0x01,0x03,0x01,0x02,
			0x06,0x00,0x02,0x7e,0x00,0x7d,0x00,0x7b,0x00,0x7c,
			0xfe,0x7f,0xfa,0x00,0x0b,0x80,0x03,0x80,0x00,0x0f,
			0x00,0xfb,0x01,0x03,0x01,0x02,0x05,0x00,0x02,0x7e,
			0x01,0x7d,0x00,0x76,0x03,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x0a,0x8f,0x02,0x7f,0x01,0x7e,0x00,0x76,
			0xff,0x7f,0xfe,0x7f,0xfb,0x00,0xff,0x01,0xff,0x01,
			0x00,0x0a,0x01,0x02,0x01,0x01,0x05,0x00,0xf9,0x80,
			0x00,0x6b,0x0c,0x86,0x0d,0x8a,0xff,0x03,0xfe,0x02,
			0xfb,0x00,0xff,0x7e,0xff,0x7d,0x00,0x7b,0x01,0x7c,
			0x01,0x7f,0x05,0x00,0x02,0x01,0x01,0x03,0x03,0xfc,
			0x03,0x80,0x00,0x0f,0x00,0xfb,0x01,0x03,0x01,0x02,
			0x04,0x00,0x01,0x7e,0x01,0x7d,0x00,0x76,0x00,0x8a,
			0x01,0x03,0x02,0x02,0x03,0x00,0x02,0x7e,0x01,0x7d,
			0x00,0x76,0x03,0x80,0x03,0x8f,0x00,0x74,0x01,0x7e,
			0x02,0x7f,0x04,0x00,0x02,0x01,0x01,0x01,0x00,0x8d,
			0x00,0x6e,0xff,0x7e,0xfe,0x7f,0xfb,0x00,0xfe,0x01,
			0x0c,0x85,0x03,0x8d,0x01,0x02,0x03,0x00,0x02,0x7e,
			0x01,0x02,0x03,0x00,0x02,0x7e,0x00,0x74,0xfe,0x7f,
			0xfd,0x00,0xff,0x01,0xfe,0x7f,0xfd,0x00,0xff,0x01,
			0x00,0x0c,0x06,0x82,0x00,0x6b,0x08,0x86,0x03,0x80,
			0x0a,0x0f,0xf6,0x80,0x0a,0x71,0x03,0x80,0x03,0x8f,
			0x00,0x73,0x01,0x7e,0x07,0x00,0x02,0x02,0x00,0x0d,
			0x00,0xf3,0x01,0x7e,0x00,0x7e,0x03,0x82,0x03,0x8f,
			0x00,0x79,0x02,0x7e,0x08,0x00,0x00,0x89,0x00,0x71,
			0x02,0x80,0x03,0x8f,0x00,0x73,0x01,0x7e,0x03,0x00,
			0x02,0x02,0x00,0x0d,0x00,0xf3,0x01,0x7e,0x03,0x00,
			0x02,0x02,0x00,0x0d,0x00,0xf3,0x01,0x7e,0x03,0x80,
			0x03,0x8f,0x00,0x73,0x01,0x7e,0x03,0x00,0x02,0x02,
			0x00,0x0d,0x00,0xf3,0x01,0x7e,0x03,0x00,0x02,0x02,
			0x00,0x0d,0x00,0xf3,0x01,0x7e,0x00,0x7e,0x03,0x82,
			0x03,0x8d,0x00,0x02,0x02,0x00,0x00,0x71,0x08,0x00,
			0x02,0x02,0x00,0x06,0xfe,0x02,0xf8,0x00,0x0c,0xf6,
			0x03,0x8f,0x00,0x71,0x07,0x00,0x02,0x02,0x00,0x06,
			0xfe,0x02,0xf9,0x00,0x0c,0x85,0x00,0x71,0x02,0x80,
			0x03,0x8f,0x00,0x71,0x07,0x00,0x03,0x02,0x00,0x06,
			0xfd,0x02,0xf9,0x00,0x0c,0xf6,0x03,0x8d,0x02,0x02,
			0x06,0x00,0x02,0x7e,0x00,0x75,0xfe,0x7e,0xfa,0x00,
			0xfe,0x02,0x04,0x85,0x06,0x00,0x02,0xf9,0x03,0x80,
			0x00,0x0f,0x00,0xf8,0x04,0x00,0x00,0x06,0x02,0x02,
			0x04,0x00,0x02,0x7e,0x00,0x75,0xfe,0x7e,0xfc,0x00,
			0xfe,0x02,0x00,0x05,0x0a,0xf9,0x0d,0x80,0x00,0x0f,
			0xf7,0x00,0xff,0x7e,0x00,0x7b,0x01,0x7e,0x09,0x00,
			0xf6,0xfa,0x04,0x06,0x08,0xfa
		};
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\agg_span_gouraud.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;
using System.Collections.Generic;

namespace MatterHackers.Agg.VertexSource
{
	//============================================================span_gouraud
	public class span_gouraud : IVertexSource
	{
		private coord_type[] m_coord = new coord_type[3];
		private double[] m_x = new double[8];
		private double[] m_y = new double[8];
		private FlagsAndCommand[] m_cmd = new FlagsAndCommand[8];
		private int m_vertex;

		public struct coord_type
		{
			public double x;
			public double y;
			public Color color;
		};

		public span_gouraud()
		{
			m_vertex = (0);
			m_cmd[0] = FlagsAndCommand.Stop;
		}

		public span_gouraud(Color c1,
					 Color c2,
					 Color c3,
					 double x1, double y1,
					 double x2, double y2,
					 double x3, double y3,
					 double d)
		{
			m_vertex = (0);
			colors(c1, c2, c3);
			triangle(x1, y1, x2, y2, x3, y3, d);
		}

        public ulong GetLongHashCode(ulong hash = 14695981039346656037)
        {
            foreach (var vertex in this.Vertices())
            {
                hash = vertex.GetLongHashCode(hash);
            }

            return hash;
        }

        public void colors(IColorType c1, IColorType c2, IColorType c3)
		{
			m_coord[0].color = c1.ToColor();
			m_coord[1].color = c2.ToColor();
			m_coord[2].color = c3.ToColor();
		}

		//--------------------------------------------------------------------
		// Sets the triangle and dilates it if needed.
		// The trick here is to calculate beveled joins in the vertices of the
		// triangle and render it as a 6-vertex polygon.
		// It's necessary to achieve numerical stability.
		// However, the coordinates to interpolate colors are calculated
		// as miter joins (calc_intersection).
		public void triangle(double x1, double y1,
					  double x2, double y2,
					  double x3, double y3,
					  double dilation = 0)
		{
			m_coord[0].x = m_x[0] = x1;
			m_coord[0].y = m_y[0] = y1;
			m_coord[1].x = m_x[1] = x2;
			m_coord[1].y = m_y[1] = y2;
			m_coord[2].x = m_x[2] = x3;
			m_coord[2].y = m_y[2] = y3;
			m_cmd[0] = FlagsAndCommand.MoveTo;
			m_cmd[1] = FlagsAndCommand.LineTo;
			m_cmd[2] = FlagsAndCommand.LineTo;
			m_cmd[3] = FlagsAndCommand.Stop;

			if (dilation != 0.0)
			{
				agg_math.dilate_triangle(m_coord[0].x, m_coord[0].y,
								m_coord[1].x, m_coord[1].y,
								m_coord[2].x, m_coord[2].y,
								m_x, m_y, dilation);

				agg_math.calc_intersection(m_x[4], m_y[4], m_x[5], m_y[5],
								  m_x[0], m_y[0], m_x[1], m_y[1],
								  out m_coord[0].x, out m_coord[0].y);

				agg_math.calc_intersection(m_x[0], m_y[0], m_x[1], m_y[1],
								  m_x[2], m_y[2], m_x[3], m_y[3],
								  out m_coord[1].x, out m_coord[1].y);

				agg_math.calc_intersection(m_x[2], m_y[2], m_x[3], m_y[3],
								  m_x[4], m_y[4], m_x[5], m_y[5],
								  out m_coord[2].x, out m_coord[2].y);
				m_cmd[3] = FlagsAndCommand.LineTo;
				m_cmd[4] = FlagsAndCommand.LineTo;
				m_cmd[5] = FlagsAndCommand.LineTo;
				m_cmd[6] = FlagsAndCommand.Stop;
			}
		}

		public IEnumerable<VertexData> Vertices()
		{
			throw new NotImplementedException();
		}

		// Vertex Source Interface to feed the coordinates to the rasterizer
		public void Rewind(int idx)
		{
			m_vertex = 0;
		}

		public FlagsAndCommand Vertex(out double x, out double y)
		{
			x = m_x[m_vertex];
			y = m_y[m_vertex];
			return m_cmd[m_vertex++];
		}

		protected void arrange_vertices(coord_type[] coord)
		{
			coord[0] = m_coord[0];
			coord[1] = m_coord[1];
			coord[2] = m_coord[2];

			if (m_coord[0].y > m_coord[2].y)
			{
				coord[0] = m_coord[2];
				coord[2] = m_coord[0];
			}

			coord_type tmp;
			if (coord[0].y > coord[1].y)
			{
				tmp = coord[1];
				coord[1] = coord[0];
				coord[0] = tmp;
			}

			if (coord[1].y > coord[2].y)
			{
				tmp = coord[2];
				coord[2] = coord[1];
				coord[1] = tmp;
			}
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\agg_span_gouraud_rgba.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
//
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg.VertexSource
{
	//=======================================================span_gouraud_rgba
	public sealed class span_gouraud_rgba : span_gouraud, ISpanGenerator
	{
		private bool m_swap;
		private int m_y2;
		private rgba_calc m_rgba1;
		private rgba_calc m_rgba2;
		private rgba_calc m_rgba3;

		public enum subpixel_scale_e
		{
			subpixel_shift = 4,
			subpixel_scale = 1 << subpixel_shift
		};

		//--------------------------------------------------------------------
		public struct rgba_calc
		{
			public void init(span_gouraud.coord_type c1, span_gouraud.coord_type c2)
			{
				m_x1 = c1.x - 0.5;
				m_y1 = c1.y - 0.5;
				m_dx = c2.x - c1.x;
				double dy = c2.y - c1.y;
				m_1dy = (dy < 1e-5) ? 1e5 : 1.0 / dy;
				m_r1 = (int)c1.color.red;
				m_g1 = (int)c1.color.green;
				m_b1 = (int)c1.color.blue;
				m_a1 = (int)c1.color.alpha;
				m_dr = (int)c2.color.red - m_r1;
				m_dg = (int)c2.color.green - m_g1;
				m_db = (int)c2.color.blue - m_b1;
				m_da = (int)c2.color.alpha - m_a1;
			}

			public void calc(double y)
			{
				double k = (y - m_y1) * m_1dy;
				if (k < 0.0) k = 0.0;
				if (k > 1.0) k = 1.0;
				m_r = m_r1 + Util.iround(m_dr * k);
				m_g = m_g1 + Util.iround(m_dg * k);
				m_b = m_b1 + Util.iround(m_db * k);
				m_a = m_a1 + Util.iround(m_da * k);
				m_x = Util.iround((m_x1 + m_dx * k) * (double)subpixel_scale_e.subpixel_scale);
			}

			public double m_x1;
			public double m_y1;
			public double m_dx;
			public double m_1dy;
			public int m_r1;
			public int m_g1;
			public int m_b1;
			public int m_a1;
			public int m_dr;
			public int m_dg;
			public int m_db;
			public int m_da;
			public int m_r;
			public int m_g;
			public int m_b;
			public int m_a;
			public int m_x;
		};

		//--------------------------------------------------------------------
		public span_gouraud_rgba()
		{
		}

		public span_gouraud_rgba(Color c1,
						  Color c2,
						  Color c3,
						  double x1, double y1,
						  double x2, double y2,
						  double x3, double y3)
			: this(c1, c2, c3, x1, y1, x2, y2, x3, y3, 0)
		{ }

		public span_gouraud_rgba(Color c1,
						  Color c2,
						  Color c3,
						  double x1, double y1,
						  double x2, double y2,
						  double x3, double y3,
						  double d)
			: base(c1, c2, c3, x1, y1, x2, y2, x3, y3, d)
		{ }

		//--------------------------------------------------------------------
		public void prepare()
		{
			coord_type[] coord = new coord_type[3];
			base.arrange_vertices(coord);

			m_y2 = (int)(coord[1].y);

			m_swap = agg_math.cross_product(coord[0].x, coord[0].y,
								   coord[2].x, coord[2].y,
								   coord[1].x, coord[1].y) < 0.0;

			m_rgba1.init(coord[0], coord[2]);
			m_rgba2.init(coord[0], coord[1]);
			m_rgba3.init(coord[1], coord[2]);
		}

		public void generate(Color[] span, int spanIndex, int x, int y, int len)
		{
			m_rgba1.calc(y);//(m_rgba1.m_1dy > 2) ? m_rgba1.m_y1 : y);
			rgba_calc pc1 = m_rgba1;
			rgba_calc pc2 = m_rgba2;

			if (y <= m_y2)
			{
				// Bottom part of the triangle (first subtriangle)
				//-------------------------
				m_rgba2.calc(y + m_rgba2.m_1dy);
			}
			else
			{
				// Upper part (second subtriangle)
				m_rgba3.calc(y - m_rgba3.m_1dy);
				//-------------------------
				pc2 = m_rgba3;
			}

			if (m_swap)
			{
				// It means that the triangle is oriented clockwise,
				// so that we need to swap the controlling structures
				//-------------------------
				rgba_calc t = pc2;
				pc2 = pc1;
				pc1 = t;
			}

			// Get the horizontal length with subpixel accuracy
			// and protect it from division by zero
			//-------------------------
			int nlen = Math.Abs(pc2.m_x - pc1.m_x);
			if (nlen <= 0) nlen = 1;

			dda_line_interpolator r = new dda_line_interpolator(pc1.m_r, pc2.m_r, nlen, 14);
			dda_line_interpolator g = new dda_line_interpolator(pc1.m_g, pc2.m_g, nlen, 14);
			dda_line_interpolator b = new dda_line_interpolator(pc1.m_b, pc2.m_b, nlen, 14);
			dda_line_interpolator a = new dda_line_interpolator(pc1.m_a, pc2.m_a, nlen, 14);

			// Calculate the starting point of the gradient with subpixel
			// accuracy and correct (roll back) the interpolators.
			// This operation will also clip the beginning of the span
			// if necessary.
			//-------------------------
			int start = pc1.m_x - (x << (int)subpixel_scale_e.subpixel_shift);
			r.Prev(start);
			g.Prev(start);
			b.Prev(start);
			a.Prev(start);
			nlen += start;

			int vr, vg, vb, va;
			uint lim = 255;

			// Beginning part of the span. Since we rolled back the
			// interpolators, the color values may have overflowed.
			// So that, we render the beginning part with checking
			// for overflow. It lasts until "start" is positive;
			// typically it's 1-2 pixels, but may be more in some cases.
			//-------------------------
			while (len != 0 && start > 0)
			{
				vr = r.y();
				vg = g.y();
				vb = b.y();
				va = a.y();
				if (vr < 0) vr = 0; if (vr > lim) vr = (int)lim;
				if (vg < 0) vg = 0; if (vg > lim) vg = (int)lim;
				if (vb < 0) vb = 0; if (vb > lim) vb = (int)lim;
				if (va < 0) va = 0; if (va > lim) va = (int)lim;
				span[spanIndex].red = (byte)vr;
				span[spanIndex].green = (byte)vg;
				span[spanIndex].blue = (byte)vb;
				span[spanIndex].alpha = (byte)va;
				r.Next((int)subpixel_scale_e.subpixel_scale);
				g.Next((int)subpixel_scale_e.subpixel_scale);
				b.Next((int)subpixel_scale_e.subpixel_scale);
				a.Next((int)subpixel_scale_e.subpixel_scale);
				nlen -= (int)subpixel_scale_e.subpixel_scale;
				start -= (int)subpixel_scale_e.subpixel_scale;
				++spanIndex;
				--len;
			}

			// Middle part, no checking for overflow.
			// Actual spans can be longer than the calculated length
			// because of anti-aliasing, thus, the interpolators can
			// overflow. But while "nlen" is positive we are safe.
			//-------------------------
			while (len != 0 && nlen > 0)
			{
				span[spanIndex].red = ((byte)r.y());
				span[spanIndex].green = ((byte)g.y());
				span[spanIndex].blue = ((byte)b.y());
				span[spanIndex].alpha = ((byte)a.y());
				r.Next((int)subpixel_scale_e.subpixel_scale);
				g.Next((int)subpixel_scale_e.subpixel_scale);
				b.Next((int)subpixel_scale_e.subpixel_scale);
				a.Next((int)subpixel_scale_e.subpixel_scale);
				nlen -= (int)subpixel_scale_e.subpixel_scale;
				++spanIndex;
				--len;
			}

			// Ending part; checking for overflow.
			// Typically it's 1-2 pixels, but may be more in some cases.
			//-------------------------
			while (len != 0)
			{
				vr = r.y();
				vg = g.y();
				vb = b.y();
				va = a.y();
				if (vr < 0) vr = 0; if (vr > lim) vr = (int)lim;
				if (vg < 0) vg = 0; if (vg > lim) vg = (int)lim;
				if (vb < 0) vb = 0; if (vb > lim) vb = (int)lim;
				if (va < 0) va = 0; if (va > lim) va = (int)lim;
				span[spanIndex].red = ((byte)vr);
				span[spanIndex].green = ((byte)vg);
				span[spanIndex].blue = ((byte)vb);
				span[spanIndex].alpha = ((byte)va);
				r.Next((int)subpixel_scale_e.subpixel_scale);
				g.Next((int)subpixel_scale_e.subpixel_scale);
				b.Next((int)subpixel_scale_e.subpixel_scale);
				a.Next((int)subpixel_scale_e.subpixel_scale);
				++spanIndex;
				--len;
			}
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\ApplyTransform.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System.Collections.Generic;
using MatterHackers.Agg.Transform;

namespace MatterHackers.Agg.VertexSource
{
	public enum AngleType { Degrees, Radians }

	// in the original agg this was conv_transform
	public class VertexSourceApplyTransform : IVertexSourceProxy
	{
		public ITransform TransformToApply { get; private set; }

		public ITransform Transform
		{
			get => TransformToApply;
			set => TransformToApply = value;
		}

		public IVertexSource VertexSource { get; set; }

		public VertexSourceApplyTransform()
		{
		}

		public VertexSourceApplyTransform(ITransform newTransformeToApply)
			: this(null, newTransformeToApply)
		{
		}

        public ulong GetLongHashCode(ulong hash = 14695981039346656037)
        {
            foreach (var vertex in this.Vertices())
            {
                hash = vertex.GetLongHashCode(hash);
            }

            return hash;
        }

        public VertexSourceApplyTransform(IVertexSource vertexSource, ITransform newTransformeToApply)
		{
			VertexSource = vertexSource;
			TransformToApply = newTransformeToApply;
		}

		public void attach(IVertexSource vertexSource)
		{
			VertexSource = vertexSource;
		}

		public IEnumerable<VertexData> Vertices()
		{
			foreach (VertexData vertexData in VertexSource.Vertices())
			{
				VertexData transformedVertex = vertexData;

				if (ShapePath.IsVertex(transformedVertex.Command))
				{
					var position = transformedVertex.Position;
					TransformToApply.Transform(ref position.X, ref position.Y);
					transformedVertex.Position = position;
				}

				yield return transformedVertex;
			}
		}

		public void Rewind(int path_id)
		{
			VertexSource.Rewind(path_id);
		}

		public FlagsAndCommand Vertex(out double x, out double y)
		{
			FlagsAndCommand cmd = VertexSource.Vertex(out x, out y);

			if (ShapePath.IsVertex(cmd))
			{
				TransformToApply.Transform(ref x, ref y);
			}

			return cmd;
		}

		public void SetTransformToApply(ITransform newTransformeToApply)
		{
			TransformToApply = newTransformeToApply;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\Arc.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Arc vertex generator
//
//----------------------------------------------------------------------------
using MatterHackers.VectorMath;
using System;
using System.Collections.Generic;

using FlagsAndCommand = MatterHackers.Agg.FlagsAndCommand;

namespace MatterHackers.Agg.VertexSource
{
	//=====================================================================arc
	//
	// See Implementation agg_arc.cpp
	//
	public class Arc : VertexSourceLegacySupport
	{
		private Direction direction;

		private double endAngle;

		private Vector2 origin;

		private Vector2 radius;

		public double ResolutionScale { get; set; } = 1;

		private double startAngle;

		public Arc()
		{
		}

		public Arc(double originX, double originY,
			 double radiusX, double radiusY,
			 double startAngle, double endAngle,
			 Direction direction = Direction.CounterClockWise,
             int numSegments = 0)
        {
			init(originX, originY, radiusX, radiusY, startAngle, endAngle, direction, numSegments);
		}

		public Arc(Vector2 origin,
			 Vector2 radius,
			 double startAngle,
			 double endAngle,
			 Direction direction = Direction.CounterClockWise)
		{
			init(origin, radius, startAngle, endAngle, direction);
		}

		public Arc(Vector2 origin,
			 double radius,
			 double startAngle,
			 double endAngle,
			 Direction direction = Direction.CounterClockWise)
			: this(origin, new Vector2(radius, radius), startAngle, endAngle, direction)
		{
		}

		public enum Direction
		{
			ClockWise,
			CounterClockWise,
		}

		public void init(double originX, double originY,
			double radiusX, double radiusY,
			double startAngle, double endAngle,
			Direction direction = Direction.CounterClockWise,
            int numSegments = 0)
		{
			init(new Vector2(originX, originY), new Vector2(radiusX, radiusY), startAngle, endAngle, direction, numSegments);
		}

		public void init(Vector2 origin,
			Vector2 radius,
			double startAngle, double endAngle,
			Direction direction = Direction.CounterClockWise,
            int numSegments = 0)
		{
            this.NumSegments = numSegments;
            this.origin = origin;
			this.radius = radius;
			this.startAngle = startAngle;
			this.endAngle = endAngle;
			this.direction = direction;
		}

        /// <summary>
		/// This is the number of segments that will be used in each turn. Set to 0 to use the default of an angle approximation.
		/// </summary>
        public int NumSegments { get; set; } = 0;

        public override IEnumerable<VertexData> Vertices()
		{
            if (NumSegments == 0)
			{
				return DeltaVertices();
            }
			else
			{
                return StepVertices();
            }
        }

        private IEnumerable<VertexData> DeltaVertices()
        {
            double averageRadius = (Math.Abs(radius.X) + Math.Abs(radius.Y)) / 2;
			var flattenedDeltaAngle = Math.Acos(averageRadius / (averageRadius + 0.125 / ResolutionScale)) * 2;
			while (endAngle < startAngle)
			{
				endAngle += Math.PI * 2.0;
			}

			VertexData vertexData = new VertexData();
			vertexData.Command = FlagsAndCommand.MoveTo;
			if (direction == Direction.CounterClockWise)
			{
				vertexData.Position = new Vector2(origin.X + Math.Cos(startAngle) * radius.X, origin.Y + Math.Sin(startAngle) * radius.Y);
				yield return vertexData;

				vertexData.Command = FlagsAndCommand.LineTo;
				double angle = startAngle;
				int numSteps = (int)((endAngle - startAngle) / flattenedDeltaAngle);

				for (int i = 0; i <= numSteps; i++)
				{
					if (angle < endAngle)
					{
						vertexData.Position = new Vector2(origin.X + Math.Cos(angle) * radius.X, origin.Y + Math.Sin(angle) * radius.Y);
						yield return vertexData;

						angle += flattenedDeltaAngle;
					}
				}

				vertexData.Position = new Vector2(origin.X + Math.Cos(endAngle) * radius.X, origin.Y + Math.Sin(endAngle) * radius.Y);
				yield return vertexData;
			}
			else
			{
				vertexData.Position = new Vector2(origin.X + Math.Cos(endAngle) * radius.X, origin.Y + Math.Sin(endAngle) * radius.Y);
				yield return vertexData;

				vertexData.Command = FlagsAndCommand.LineTo;
				double angle = endAngle;
				int numSteps = (int)((endAngle - startAngle) / flattenedDeltaAngle);
				for (int i = 0; i <= numSteps; i++)
				{
					vertexData.Position = new Vector2(origin.X + Math.Cos(angle) * radius.X, origin.Y + Math.Sin(angle) * radius.Y);
					yield return vertexData;

					angle -= flattenedDeltaAngle;
				}

				vertexData.Position = new Vector2(origin.X + Math.Cos(startAngle) * radius.X, origin.Y + Math.Sin(startAngle) * radius.Y);
				yield return vertexData;
			}

			vertexData.Command = FlagsAndCommand.Stop;
			yield return vertexData;
		}

        private IEnumerable<VertexData> StepVertices()
        {
            while (endAngle < startAngle)
            {
                endAngle += Math.PI * 2.0;
            }

            var flattenedDeltaAngle = (endAngle - startAngle) / NumSegments;

            VertexData vertexData = new VertexData();
            vertexData.Command = FlagsAndCommand.MoveTo;
            if (direction == Direction.CounterClockWise)
            {
                vertexData.Position = new Vector2(origin.X + Math.Cos(startAngle) * radius.X, origin.Y + Math.Sin(startAngle) * radius.Y);
                yield return vertexData;

                vertexData.Command = FlagsAndCommand.LineTo;
                double angle = startAngle;

                for (int i = 0; i <= NumSegments; i++)
                {
                    if (angle < endAngle)
                    {
                        vertexData.Position = new Vector2(origin.X + Math.Cos(angle) * radius.X, origin.Y + Math.Sin(angle) * radius.Y);
                        yield return vertexData;

                        angle += flattenedDeltaAngle;
                    }
                }

                vertexData.Position = new Vector2(origin.X + Math.Cos(endAngle) * radius.X, origin.Y + Math.Sin(endAngle) * radius.Y);
                yield return vertexData;
            }
            else
            {
                vertexData.Position = new Vector2(origin.X + Math.Cos(endAngle) * radius.X, origin.Y + Math.Sin(endAngle) * radius.Y);
                yield return vertexData;

                vertexData.Command = FlagsAndCommand.LineTo;
                double angle = endAngle;
                int numSteps = (int)((endAngle - startAngle) / flattenedDeltaAngle);
                for (int i = 0; i <= numSteps; i++)
                {
                    vertexData.Position = new Vector2(origin.X + Math.Cos(angle) * radius.X, origin.Y + Math.Sin(angle) * radius.Y);
                    yield return vertexData;

                    angle -= flattenedDeltaAngle;
                }

                vertexData.Position = new Vector2(origin.X + Math.Cos(startAngle) * radius.X, origin.Y + Math.Sin(startAngle) * radius.Y);
                yield return vertexData;
            }

            vertexData.Command = FlagsAndCommand.Stop;
            yield return vertexData;
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\ConnectedPaths.cs
using MatterHackers.VectorMath;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Rounded rectangle vertex generator
//
//----------------------------------------------------------------------------
using System.Collections.Generic;

namespace MatterHackers.Agg.VertexSource
{
	/// <summary>
	/// This class is used to merge multiple paths into a single IVertexSource path.
	/// This is great to do things like have a path as an outside an a second path that can become an inside hole.
	/// </summary>
	public class CombinePaths : VertexSourceLegacySupport
	{
		public CombinePaths()
		{
		}

		public CombinePaths(IVertexSource a, IVertexSource b)
			: this(new IVertexSource[] { a, b })
		{
		}

		public CombinePaths(IEnumerable<IVertexSource> paths)
		{
			SourcePaths.AddRange(paths);
		}

		public List<IVertexSource> SourcePaths { get; } = new List<IVertexSource>();

		public override IEnumerable<VertexData> Vertices()
		{
			for (int i = 0; i < SourcePaths.Count; i++)
			{
				IVertexSource sourcePath = SourcePaths[i];
				foreach (VertexData vertexData in sourcePath.Vertices())
				{
					// when we hit a stop move on to the next path
					if (ShapePath.IsStop(vertexData.Command))
					{
						break;
					}
					yield return vertexData;
				}
			}

			// and send the actual stop
			yield return new VertexData(FlagsAndCommand.EndPoly | FlagsAndCommand.FlagClose | FlagsAndCommand.FlagCCW, new Vector2());
			yield return new VertexData(FlagsAndCommand.Stop, new Vector2());
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\Contour.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// conv_stroke
//
//----------------------------------------------------------------------------
namespace MatterHackers.Agg.VertexSource
{
	public sealed class Contour : VertexSourceAdapter
	{
		public Contour(IVertexSource vertexSource) :
			base(vertexSource, new ContourGenerator())
		{
		}

		public double ApproximationScale
		{
			get => this.Generator.ApproximationScale;
			set => this.Generator.ApproximationScale = value;
		}

		public bool AutoDetectOrientation
		{
			get => this.Generator.AutoDetectOrientation;
			set => this.Generator.AutoDetectOrientation = value;
		}

		public InnerJoin InnerJoin
		{
			get => this.Generator.InnerJoin;
			set => this.Generator.InnerJoin = value;
		}

		public double InnerMiterLimit
		{
			get => this.Generator.InnerMiterLimit;
			set => this.Generator.InnerMiterLimit = value;
		}

		public LineJoin LineJoin
		{
			get => this.Generator.LineJoin;
			set => this.Generator.LineJoin = value;
		}

		public double MiterLimit
		{
			get => this.Generator.MiterLimit;
			set => this.Generator.MiterLimit = value;
		}

		public double Width
		{
			get => this.Generator.Width;
			set => this.Generator.Width = value;
		}

		public void MiterLimitTheta(double t)
		{
			this.Generator.MiterLimitTheta(t);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\ContourGenerator.cs
using MatterHackers.VectorMath;

namespace MatterHackers.Agg.VertexSource
{
	internal class ContourGenerator : IGenerator
	{
		private bool m_auto_detect;
		private bool m_closed;
		private FlagsAndCommand m_orientation;
		private int m_out_vertex;
		private Vector2Container m_out_vertices;
		private double m_shorten;
		private int m_src_vertex;
		private VertexSequence m_src_vertices;
		private StrokeMath.status_e m_status;
		private StrokeMath m_stroker;
		private double m_width;

		public ContourGenerator()
		{
			m_stroker = new StrokeMath();
			m_width = 1;
			m_src_vertices = new VertexSequence();
			m_out_vertices = new Vector2Container();
			m_status = StrokeMath.status_e.initial;
			m_src_vertex = 0;
			m_closed = false;
			m_orientation = 0;
			m_auto_detect = false;
		}

		public void AddVertex(double x, double y, FlagsAndCommand cmd)
		{
			m_status = StrokeMath.status_e.initial;
			if (ShapePath.IsMoveTo(cmd))
			{
				m_src_vertices.modify_last(new VertexDistance(x, y));
			}
			else
			{
				if (ShapePath.IsVertex(cmd))
				{
					m_src_vertices.Add(new VertexDistance(x, y));
				}
				else
				{
					if (ShapePath.is_end_poly(cmd))
					{
						m_closed = (ShapePath.get_close_flag(cmd) == FlagsAndCommand.FlagClose);
						if (m_orientation == FlagsAndCommand.FlagNone)
						{
							m_orientation = ShapePath.get_orientation(cmd);
						}
					}
				}
			}
		}

		public double ApproximationScale
		{
			get => m_stroker.approximation_scale();
			set => m_stroker.approximation_scale(value);
		}

		public bool AutoDetectOrientation
		{
			get => m_auto_detect;
			set => m_auto_detect = value;
		}

		public InnerJoin InnerJoin
		{
			get => m_stroker.inner_join();
			set => m_stroker.inner_join(value);
		}

		public double InnerMiterLimit
		{
			get => m_stroker.inner_miter_limit();
			set => m_stroker.inner_miter_limit(value);
		}

		public LineCap LineCap
		{
			get => m_stroker.line_cap();
			set => m_stroker.line_cap(value);
		}

		public LineJoin LineJoin
		{
			get => m_stroker.line_join();
			set => m_stroker.line_join(value);
		}

		public double MiterLimit
		{
			get => m_stroker.miter_limit();
			set => m_stroker.miter_limit(value);
		}

		public double Shorten
		{
			get => m_shorten;
			set => m_shorten = value;
		}

		public double Width
		{
			get => m_stroker.width();
			set => m_stroker.width(value);
		}

		public void MiterLimitTheta(double t)
		{
			m_stroker.miter_limit_theta(t);
		}

		// Generator interface
		public void RemoveAll()
		{
			m_src_vertices.Clear();
			m_closed = false;
			m_status = StrokeMath.status_e.initial;
		}

		// Vertex Source Interface
		public void Rewind(int idx)
		{
			if (m_status == StrokeMath.status_e.initial)
			{
				m_src_vertices.close(true);
				if (m_auto_detect)
				{
					if (!ShapePath.is_oriented(m_orientation))
					{
						m_orientation = (agg_math.calc_polygon_area(m_src_vertices) > 0.0) ?
										FlagsAndCommand.FlagCCW :
										FlagsAndCommand.FlagCW;
					}
				}
				if (ShapePath.is_oriented(m_orientation))
				{
					m_stroker.width(ShapePath.is_ccw(m_orientation) ? m_width : -m_width);
				}
			}
			m_status = StrokeMath.status_e.ready;
			m_src_vertex = 0;
		}

		public FlagsAndCommand Vertex(ref double x, ref double y)
		{
			FlagsAndCommand cmd = FlagsAndCommand.LineTo;
			while (!ShapePath.IsStop(cmd))
			{
				switch (m_status)
				{
					case StrokeMath.status_e.initial:
						Rewind(0);
						goto case StrokeMath.status_e.ready;

					case StrokeMath.status_e.ready:
						if (m_src_vertices.Count < 2 + (m_closed ? 1 : 0))
						{
							cmd = FlagsAndCommand.Stop;
							break;
						}
						m_status = StrokeMath.status_e.outline1;
						cmd = FlagsAndCommand.MoveTo;
						m_src_vertex = 0;
						m_out_vertex = 0;
						goto case StrokeMath.status_e.outline1;

					case StrokeMath.status_e.outline1:
						if (m_src_vertex >= m_src_vertices.Count)
						{
							m_status = StrokeMath.status_e.end_poly1;
							break;
						}
						m_stroker.calc_join(m_out_vertices,
											m_src_vertices.prev(m_src_vertex),
											m_src_vertices.curr(m_src_vertex),
											m_src_vertices.next(m_src_vertex),
											m_src_vertices.prev(m_src_vertex).dist,
											m_src_vertices.curr(m_src_vertex).dist);
						++m_src_vertex;
						m_status = StrokeMath.status_e.out_vertices;
						m_out_vertex = 0;
						goto case StrokeMath.status_e.out_vertices;

					case StrokeMath.status_e.out_vertices:
						if (m_out_vertex >= m_out_vertices.Count)
						{
							m_status = StrokeMath.status_e.outline1;
						}
						else
						{
							Vector2 c = m_out_vertices[m_out_vertex++];
							x = c.X;
							y = c.Y;
							return cmd;
						}
						break;

					case StrokeMath.status_e.end_poly1:
						if (!m_closed) return FlagsAndCommand.Stop;
						m_status = StrokeMath.status_e.stop;
						return FlagsAndCommand.EndPoly | FlagsAndCommand.FlagClose | FlagsAndCommand.FlagCCW;

					case StrokeMath.status_e.stop:
						return FlagsAndCommand.Stop;
				}
			}
			return cmd;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\Ellipse.cs
using MatterHackers.VectorMath;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// class ellipse
//
//----------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using FlagsAndCommand = MatterHackers.Agg.FlagsAndCommand;

namespace MatterHackers.Agg.VertexSource
{
	public class Ellipse : VertexSourceLegacySupport
	{
		public double originX;
		public double originY;
		public double radiusX;
		public double radiusY;

		#region resolution
		private double _resolutionScale = 1;
		public double ResolutionScale
		{
			get { return _resolutionScale; }
			set
			{
				_resolutionScale = value;
				calc_num_steps();
			}
		}
		#endregion

		public int NumSteps { get; private set; }
		//private int m_step;
		public bool IsCw;

		public Ellipse()
		{
			originX = 0.0;
			originY = 0.0;
			radiusX = 1.0;
			radiusY = 1.0;
			NumSteps = 4;
			//m_step = 0;
			IsCw = false;
		}

		public Ellipse(Vector2 origin, double Radius)
			: this(origin.X, origin.Y, Radius, Radius, 0, false)
		{
		}

		public Ellipse(Vector2 origin, double RadiusX, double RadiusY, int num_steps = 0, bool cw = false)
			: this(origin.X, origin.Y, RadiusX, RadiusY, num_steps, cw)
		{
		}

		public Ellipse(double OriginX, double OriginY, double RadiusX, double RadiusY, int num_steps = 0, bool cw = false)
		{
			this.originX = OriginX;
			this.originY = OriginY;
			this.radiusX = RadiusX;
			this.radiusY = RadiusY;
			NumSteps = num_steps;
			//m_step = 0;
			IsCw = cw;
			if (NumSteps == 0)
			{
				calc_num_steps();
			}
		}

		public void init(double OriginX, double OriginY, double RadiusX, double RadiusY)
		{
			init(OriginX, OriginY, RadiusX, RadiusY, 0, false);
		}

		public void init(double OriginX, double OriginY, double RadiusX, double RadiusY, int num_steps)
		{
			init(OriginX, OriginY, RadiusX, RadiusY, num_steps, false);
		}

		public void init(double OriginX, double OriginY, double RadiusX, double RadiusY,
				  int num_steps, bool cw)
		{
			originX = OriginX;
			originY = OriginY;
			radiusX = RadiusX;
			radiusY = RadiusY;
			NumSteps = num_steps;
			//m_step = 0;
			IsCw = cw;
			if (NumSteps == 0)
			{
				calc_num_steps();
			}
		}

		public override IEnumerable<VertexData> Vertices()
		{
			VertexData vertexData = new VertexData();
			vertexData.Command = FlagsAndCommand.MoveTo;
			vertexData.Position = new Vector2(originX + radiusX, originY);
			yield return vertexData;

			double anglePerStep = MathHelper.Tau / (double)NumSteps;
			double angle = 0;
			vertexData.Command = FlagsAndCommand.LineTo;
			for (int i = 1; i < NumSteps; i++)
			{
				angle += anglePerStep;

				if (IsCw)
				{
					vertexData.Position = new Vector2(originX + Math.Cos(MathHelper.Tau - angle) * radiusX,
						originY + Math.Sin(MathHelper.Tau - angle) * radiusY);
					yield return vertexData;
				}
				else
				{
					vertexData.Position = new Vector2(originX + Math.Cos(angle) * radiusX, originY + Math.Sin(angle) * radiusY);
					yield return vertexData;
				}
			}

			vertexData.Position = new Vector2();
			vertexData.Command = FlagsAndCommand.EndPoly | FlagsAndCommand.FlagClose | FlagsAndCommand.FlagCCW;
			yield return vertexData;
			vertexData.Command = FlagsAndCommand.Stop;
			yield return vertexData;
		}

		private void calc_num_steps()
		{
			double ra = (Math.Abs(radiusX) + Math.Abs(radiusY)) / 2;
			double da = Math.Acos(ra / (ra + 0.125 / ResolutionScale)) * 2;
			NumSteps = (int)Math.Round(2 * Math.PI / da);
		}
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\FlattenCurve.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// classes conv_curve
//
//----------------------------------------------------------------------------
using System.Collections.Generic;

namespace MatterHackers.Agg.VertexSource
{
	//---------------------------------------------------------------conv_curve
	// Curve converter class. Any path storage can have Bezier curves defined
	// by their control points. There are two types of curves supported: curve3
	// and curve4. Curve3 is a conic Bezier curve with 2 endpoints and 1 control
	// point. Curve4 has 2 control points (4 points in total) and can be used
	// to interpolate more complicated curves. Curve4, unlike curve3 can be used
	// to approximate arcs, both circular and elliptical. Curves are approximated
	// with straight lines and one of the approaches is just to store the whole
	// sequence of vertices that approximate our curve. It takes additional
	// memory, and at the same time the consecutive vertices can be calculated
	// on demand.
	//
	// Initially, path storages are not suppose to keep all the vertices of the
	// curves (although, nothing prevents us from doing so). Instead, path_storage
	// keeps only vertices, needed to calculate a curve on demand. Those vertices
	// are marked with special commands. So, if the path_storage contains curves
	// (which are not real curves yet), and we render this storage directly,
	// all we will see is only 2 or 3 straight line segments (for curve3 and
	// curve4 respectively). If we need to see real curves drawn we need to
	// include this class into the conversion pipeline.
	//
	// Class conv_curve recognizes commands path_cmd_curve3 and path_cmd_curve4
	// and converts these vertices into a move_to/line_to sequence.
	//-----------------------------------------------------------------------
	public class FlattenCurves : VertexSourceLegacySupport
	{
		//private double lastX;
		//private double lastY;
		private Curve3 m_curve3;
		private Curve4 m_curve4;

		public IVertexSource VertexSource
		{
			get;
			set;
		}

		public FlattenCurves(IVertexSource vertexSource)
		{
			m_curve3 = new Curve3();
			m_curve4 = new Curve4();
			VertexSource = vertexSource;
			//lastX = (0.0);
			//lastY = (0.0);
		}

		public double ResolutionScale
		{
			get
			{
				return m_curve4.approximation_scale();
			}

			set
			{
				m_curve3.approximation_scale(value);
				m_curve4.approximation_scale(value);
			}
		}

		public void SetVertexSource(IVertexSource vertexSource)
		{
			VertexSource = vertexSource;
		}

		public Curves.CurveApproximationMethod ApproximationMethod
		{
			set
			{
				m_curve3.approximation_method(value);
				m_curve4.approximation_method(value);
			}

			get
			{
				return m_curve4.approximation_method();
			}
		}

		public double AngleTolerance
		{
			set
			{
				m_curve3.angle_tolerance(value);
				m_curve4.angle_tolerance(value);
			}

			get
			{
				return m_curve4.angle_tolerance();
			}
		}

		public double CuspLimit
		{
			set
			{
				m_curve3.cusp_limit(value);
				m_curve4.cusp_limit(value);
			}

			get
			{
				return m_curve4.cusp_limit();
			}
		}

		public override IEnumerable<VertexData> Vertices()
		{
			if (VertexSource == null)
			{
				yield break;
			}

			VertexData lastPosition = new VertexData();

			IEnumerator<VertexData> vertexDataEnumerator = VertexSource.Vertices().GetEnumerator();
			while (vertexDataEnumerator.MoveNext())
			{
				VertexData vertexData = vertexDataEnumerator.Current;
				switch (vertexData.Command)
				{
					case FlagsAndCommand.Curve3:
						{
							vertexDataEnumerator.MoveNext();
							VertexData vertexDataEnd = vertexDataEnumerator.Current;
							m_curve3.init(lastPosition.Position.X, lastPosition.Position.Y, vertexData.Position.X, vertexData.Position.Y, vertexDataEnd.Position.X, vertexDataEnd.Position.Y);
							IEnumerator<VertexData> curveIterator = m_curve3.Vertices().GetEnumerator();
							curveIterator.MoveNext(); // First call returns path_cmd_move_to
							do
							{
								curveIterator.MoveNext();
								if (ShapePath.IsStop(curveIterator.Current.Command))
								{
									break;
								}
								vertexData = new VertexData(FlagsAndCommand.LineTo, curveIterator.Current.Position);
								yield return vertexData;
								lastPosition = vertexData;
							} while (!ShapePath.IsStop(curveIterator.Current.Command));
						}
						break;

					case FlagsAndCommand.Curve4:
						{
							vertexDataEnumerator.MoveNext();
							var vertexDataControl2 = vertexDataEnumerator.Current;
							vertexDataEnumerator.MoveNext();
							var vertexDataEnd = vertexDataEnumerator.Current;
							m_curve4.init(lastPosition.Position.X, lastPosition.Position.Y,
								vertexData.Position.X, vertexData.Position.Y,
								vertexDataControl2.Position.X, vertexDataControl2.Position.Y,
								vertexDataEnd.Position.X, vertexDataEnd.Position.Y);
							var curveIterator = m_curve4.Vertices().GetEnumerator();
							curveIterator.MoveNext(); // First call returns path_cmd_move_to
							while (!ShapePath.IsStop(vertexData.Command))
							{
								curveIterator.MoveNext();
								if (ShapePath.IsStop(curveIterator.Current.Command))
								{
									break;
								}
								vertexData = new VertexData(FlagsAndCommand.LineTo, curveIterator.Current.Position);
								yield return vertexData;
								lastPosition = vertexData;
							}
						}
						break;

					default:
						yield return vertexData;
						lastPosition = vertexData;
						break;
				}
			}
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\IGenerator.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------

namespace MatterHackers.Agg.VertexSource
{
	public interface IGenerator
	{
		double ApproximationScale { get; set; }

		bool AutoDetectOrientation { get; set; }

		InnerJoin InnerJoin { get; set; }

		double InnerMiterLimit { get; set; }

		LineCap LineCap { get; set; }

		LineJoin LineJoin { get; set; }

		double MiterLimit { get; set; }

		void MiterLimitTheta(double t);

		double Shorten { get; set; }

		double Width { get; set; }

		void RemoveAll();
		void Rewind(int path_id);
		void AddVertex(double x, double y, FlagsAndCommand unknown);

		FlagsAndCommand Vertex(ref double x, ref double y);
	};
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\IVertexSource.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System.Collections.Generic;

namespace MatterHackers.Agg.VertexSource
{
    public interface IVertexSource
    {
        void Rewind(int pathId = 0);

        FlagsAndCommand Vertex(out double x, out double y);

        ulong GetLongHashCode(ulong hash = 14695981039346656037);

        IEnumerable<VertexData> Vertices();
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\IVertexSourceExtensions.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using MatterHackers.Agg.Image;
using MatterHackers.Agg.Image.ThresholdFunctions;
using MatterHackers.Agg.Transform;
using MatterHackers.VectorMath;
using System;
using System.Collections.Generic;
using System.Linq;

namespace MatterHackers.Agg.VertexSource
{
    public static class IVertexSourceExtensions
    {
        public static RectangleDouble GetBounds(this IVertexSource source)
        {
            RectangleDouble bounds = RectangleDouble.ZeroIntersection;
            foreach (var vertex in source.Vertices())
            {
                if (!vertex.IsClose && !vertex.IsStop)
                {
                    bounds.ExpandToInclude(vertex.Position);
                }
            }

            return bounds;
        }

        public static Vector2 GetPointAtRatio(this IVertexSource source, double ratio)
        {
            if (ratio < 0 || ratio > 1)
            {
                throw new ArgumentOutOfRangeException(nameof(ratio), "Ratio must be between 0 and 1 inclusive.");
            }

            double totalLength = 0;
            Vector2 lastVertex = new Vector2(0, 0);

            // Compute the total length of the path.
            foreach (var vertex in source.Vertices())
            {
                if (!vertex.IsClose && !vertex.IsStop)
                {
                    totalLength += (lastVertex - vertex.Position).Length;
                    lastVertex = vertex.Position;
                }
            }

            double targetLength = totalLength * ratio;
            double accumulatedLength = 0;

            Vector2 previousVertex = new Vector2(0, 0);

            // Walk the path again and stop when the accumulated length matches the target.
            foreach (var vertex in source.Vertices())
            {
                if (!vertex.IsClose && !vertex.IsStop)
                {
                    double segmentLength = (previousVertex - vertex.Position).Length;
                    if (accumulatedLength + segmentLength >= targetLength)
                    {
                        // Interpolate between the two points to get the exact position.
                        double remainingLength = targetLength - accumulatedLength;
                        double segmentRatio = remainingLength / segmentLength;

                        return Vector2.Lerp(previousVertex, vertex.Position, segmentRatio);
                    }

                    accumulatedLength += segmentLength;
                    previousVertex = vertex.Position;
                }
            }

            // If for some reason we get here, return the last vertex.
            return lastVertex;
        }

        public static Vector2 GetWeightedCenter(this IVertexSource vertexSource)
        {
            var polygonBounds = vertexSource.GetBounds();

            int width = 128;
            int height = 128;

            // Set the transform to image space
            var polygonsToImageTransform = Affine.NewIdentity();
            // move it to 0, 0
            polygonsToImageTransform *= Affine.NewTranslation(-polygonBounds.Left, -polygonBounds.Bottom);
            // scale to fit cache
            polygonsToImageTransform *= Affine.NewScaling(width / (double)polygonBounds.Width, height / (double)polygonBounds.Height);
            // and move it in 2 pixels
            polygonsToImageTransform *= Affine.NewTranslation(2, 2);

            // and render the polygon to the image
            var imageBuffer = new ImageBuffer(width + 4, height + 4, 8, new blender_gray(1));
            imageBuffer.NewGraphics2D().Render(new VertexSourceApplyTransform(vertexSource, polygonsToImageTransform), Color.White);

            // center for image
            var centerPosition = imageBuffer.GetWeightedCenter(new MapOnMaxIntensity());
            // translate to vertex source coordinates
            polygonsToImageTransform.inverse_transform(ref centerPosition.X, ref centerPosition.Y);

            return centerPosition;
        }

        public static void RenderPath(this IVertexSource source, 
            Graphics2D graphics2D, 
            Color lineColor, double width = 1, 
            bool showHandles = false, Color handleLineColor = default, 
            Color handleColor = default,
            IEnumerable<int> selectedPoints = null,
            Color selectedPointColor = default)
        {
            if(source.Vertices().Count() < 2)
            {
                return;
            }

            // render the flatened curve
            using (new ReportTimer("View3DWidegt.RenderPath"))
            {
                graphics2D.Render(new Stroke(new FlattenCurves(source), width), lineColor);
            }

            if (showHandles)
            {
                if (handleLineColor == default)
                {
                    handleLineColor = lineColor;
                }
                if (handleColor == default)
                {
                    handleColor = lineColor;
                }

                var controlSize = width * 3;

                // iterate the original source looking for curve vertices
                var curveIndex = 0;
                var lastCommand = FlagsAndCommand.Stop;
                var vertices = source.Vertices().ToArray();
                for (int i = 0; i < vertices.Length; i++)
                {
                    var vertexData = vertices[i];
                    if (lastCommand != vertexData.Command)
                    {
                        curveIndex = 0;
                    }

                    if (selectedPoints != null
                        && selectedPoints.Contains(i))
                    {
                        graphics2D.Render(new Stroke(new Ellipse(vertexData.Position, controlSize * 1.5), 2), selectedPointColor);
                    }

                    var prevVertex = vertices[(i - 1 + vertices.Length) % vertices.Length];
                    var nextVertex = vertices[(i + 1) % vertices.Length];
                    switch (vertexData.Command)
                    {
                        case FlagsAndCommand.Curve4:
                            switch (curveIndex)
                            {
                                case 0:
                                    Assert(source.GetCommandHint(i) == CommandHint.C4ControlFromPrev);
                                    // draw the line from the previous vertex to the control point
                                    graphics2D.Line(prevVertex.Position, vertexData.Position, lineColor);
                                    //  draw the control point for the current vertex
                                    graphics2D.Render(new Ellipse(vertexData.Position, controlSize), handleColor);
                                    curveIndex++;
                                    break;

                                case 1:
                                    Assert(source.GetCommandHint(i) == CommandHint.C4ControlToPoint);
                                    // draw the line from the current vertex to the control point
                                    graphics2D.Line(vertexData.Position, nextVertex.Position, lineColor);
                                    // draw the control point for the current vertex
                                    graphics2D.Render(new Ellipse(vertexData.Position, controlSize), handleColor);
                                    curveIndex++;
                                    break;

                                case 2:
                                default:
                                    Assert(source.GetCommandHint(i) == CommandHint.C4Point);
                                    // draw the control point
                                    graphics2D.Render(new Ellipse(vertexData.Position, controlSize), lineColor);
                                    curveIndex = 0;
                                    break;
                            }
                            break;

                        case FlagsAndCommand.Curve3:
                            switch (curveIndex)
                            {
                                case 0:
                                    Assert(source.GetCommandHint(i) == CommandHint.C3ControlFromPrev);
                                    // draw the line from the previous vertex to the control point
                                    graphics2D.Line(prevVertex.Position, vertexData.Position, lineColor);
                                    // draw the line from the control ponit to the next vertex
                                    graphics2D.Line(vertexData.Position, nextVertex.Position, lineColor);
                                    //  draw the control point for the current vertex
                                    graphics2D.Render(new Ellipse(vertexData.Position, controlSize), handleColor);
                                    curveIndex++;
                                    break;

                                case 1:
                                default:
                                    Assert(source.GetCommandHint(i) == CommandHint.C3Point);
                                    // draw the control point
                                    graphics2D.Render(new Ellipse(vertexData.Position, controlSize), lineColor);
                                    curveIndex = 0;
                                    break;
                            }
                            break;

                        default:
                            graphics2D.Render(new Ellipse(vertexData.Position, controlSize), lineColor);
                            break;
                    }

                    lastCommand = vertexData.Command;
                }
            }
        }

        // make this debug only
        private static void Assert(bool condition)
        {
#if DEBUG
            if (!condition)
            {
                throw new NotImplementedException();
            }
#endif
        }

        public static CommandHint GetCommandHint(this IVertexSource vertexSource, int pointIndex)
        {
            var interationIndex = 0;
            var curveIndex = 0;
            var lastCommand = FlagsAndCommand.Stop;
            var commandHint = CommandHint.None;
            foreach (var vertexData in vertexSource.Vertices())
            {
                if (lastCommand != vertexData.Command)
                {
                    curveIndex = 0;
                    lastCommand = vertexData.Command;
                }

                commandHint = CommandHint.None;

                switch (vertexData.Command & FlagsAndCommand.CommandsMask)
                {
                    case FlagsAndCommand.Curve4:
                        switch (curveIndex)
                        {
                            case 0:
                                commandHint = CommandHint.C4ControlFromPrev;
                                curveIndex++;
                                break;

                            case 1:
                                commandHint = CommandHint.C4ControlToPoint;
                                curveIndex++;
                                break;

                            case 2:
                                commandHint = CommandHint.C4Point;
                                curveIndex = 0;
                                break;

                            default:
                                throw new System.Exception("Invalid curve index");
                        }
                        break;

                    case FlagsAndCommand.Curve3:
                        switch (curveIndex)
                        {
                            case 0:
                                commandHint = CommandHint.C3ControlFromPrev;
                                curveIndex++;
                                break;
                            case 1:
                                commandHint = CommandHint.C3Point;
                                curveIndex = 0;
                                break;

                            default:
                                throw new System.Exception("Invalid curve index");
                        }
                        break;
                }

                if (interationIndex == pointIndex)
                {
                    return commandHint;
                }

                interationIndex++;
            }

            return commandHint;
        }

        public static double GetXAtY(this IVertexSource source, double y)
        {
            Vector2? previousVertex = null;

            // These will store the x values for the highest y below the given y
            // and the lowest y above the given y, respectively.
            var highestPoint = new Vector2(double.NegativeInfinity, double.NegativeInfinity);
            var lowestPoint = new Vector2(double.PositiveInfinity, double.PositiveInfinity);

            foreach (var vertex in source.Vertices())
            {
                if (previousVertex.HasValue 
                    && vertex.IsVertex 
                    && vertex.IsLineTo)
                {
                    if ((y >= previousVertex.Value.Y && y <= vertex.Position.Y)
                        || (y <= previousVertex.Value.Y && y >= vertex.Position.Y))
                    {
                        // The y value lies between the y values of the current segment
                        if (previousVertex.Value.Y == vertex.Position.Y)
                        {
                            // If the segment is horizontal, just return any x as all x's will satisfy
                            return previousVertex.Value.X;
                        }

                        // Interpolate to find the x value for the given
                        var deltaFromPrevious = y - previousVertex.Value.Y;
                        var segmentYLength = vertex.Position.Y - previousVertex.Value.Y;
                        double ratioOfLength = deltaFromPrevious / segmentYLength;
                        var segmentXLength = vertex.Position.X - previousVertex.Value.X;
                        var x = previousVertex.Value.X + ratioOfLength * segmentXLength;

                        return x;
                    }
                }

                if (!vertex.IsClose && !vertex.IsStop)
                {
                    if (vertex.Position.Y > highestPoint.Y)
                    {
                        highestPoint = vertex.Position;
                    }
                    if (vertex.Position.Y < lowestPoint.Y)
                    {
                        lowestPoint = vertex.Position;
                    }
                    
                    previousVertex = vertex.Position;
                }
            }

            // If we're out of bounds below the path, return the below bound x value
            if (y < lowestPoint.Y)
            {
                return lowestPoint.X;
            }

            // If we're out of bounds above the path, return the above bound x value
            return highestPoint.X;
        }

        public static IVertexSource Transform(this IVertexSource source, Matrix4X4 matrix)
        {
            RectangleDouble bounds = RectangleDouble.ZeroIntersection;

            var output = new VertexStorage();
            foreach (var vertex in source.Vertices())
            {
                var position = new Vector3(vertex.X, vertex.Y, 0);
                position = position.Transform(matrix);
                output.Add(position.X, position.Y, vertex.Command);
            }

            return output;
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\IVertexSourceProxy.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------

namespace MatterHackers.Agg.VertexSource
{
    public interface IVertexSourceProxy : IVertexSource
    {
        IVertexSource VertexSource { get; set; }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\JoinPaths.cs
using MatterHackers.VectorMath;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Rounded rectangle vertex generator
//
//----------------------------------------------------------------------------
using System.Collections.Generic;

namespace MatterHackers.Agg.VertexSource
{

	/// <summary>
	/// This class is used to strip out the close and first move of multiple paths
	/// so they render as a single set of LineTo (s) and internal MoveTo (s)
	/// </summary>
	public class JoinPaths : VertexSourceLegacySupport
	{
		public JoinPaths()
		{
		}

		public JoinPaths(IVertexSource a, IVertexSource b)
			: this(new IVertexSource[] { a, b })
		{
		}

		public JoinPaths(IEnumerable<IVertexSource> paths)
		{
			SourcePaths.AddRange(paths);
		}

		public List<IVertexSource> SourcePaths { get; } = new List<IVertexSource>();

		public override IEnumerable<VertexData> Vertices()
		{
			for (int i = 0; i < SourcePaths.Count; i++)
			{
				IVertexSource sourcePath = SourcePaths[i];
				bool firstMove = true;
				foreach (VertexData vertexData in sourcePath.Vertices())
				{
					// skip the initial command if it is not the first path and is a moveto.
					if (i > 0
						&& firstMove
						&& ShapePath.IsMoveTo(vertexData.Command))
					{
						continue;
					}

					// when we hit a stop move on to the next path
					if (ShapePath.IsStop(vertexData.Command))
					{
						break;
					}
					yield return vertexData;
				}
			}

			// and send the actual stop
			yield return new VertexData(FlagsAndCommand.EndPoly | FlagsAndCommand.FlagClose | FlagsAndCommand.FlagCCW, new Vector2());
			yield return new VertexData(FlagsAndCommand.Stop, new Vector2());
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\ReversePath.cs
using MatterHackers.VectorMath;
using System;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Rounded rectangle vertex generator
//
//----------------------------------------------------------------------------
using System.Collections.Generic;
using System.Linq;

namespace MatterHackers.Agg.VertexSource
{

	public class ReversePath : VertexSourceLegacySupport
	{
		private bool convertNextToMove;

		public ReversePath(IVertexSource sourcePath)
		{
			SourcePath = sourcePath;
		}

		public IVertexSource SourcePath { get; }

		public override IEnumerable<VertexData> Vertices()
		{
			IVertexSource sourcePath = SourcePath;
			foreach (VertexData vertexData in sourcePath.Vertices().Reverse())
			{
				// when we hit the initial stop. Skip it
				if (vertexData.IsClose || vertexData.IsStop)
				{
					if (vertexData.IsClose)
					{
						convertNextToMove = true;
					}

					continue;
				}

				if (convertNextToMove)
				{
					convertNextToMove = false;

					yield return new VertexData()
					{
						Position = vertexData.Position,
						Command = FlagsAndCommand.MoveTo
					};

					continue;
				}

				yield return vertexData;
			}

			// and send the actual stop
			yield return new VertexData(FlagsAndCommand.EndPoly | FlagsAndCommand.FlagClose | FlagsAndCommand.FlagCCW, new Vector2());
			yield return new VertexData(FlagsAndCommand.Stop, new Vector2());
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\RoundedRect.cs
using MatterHackers.VectorMath;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007-2025 Lars Brubaker
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Rounded rectangle vertex generator
//
//----------------------------------------------------------------------------
using System;
using System.Collections.Generic;

namespace MatterHackers.Agg.VertexSource
{
	//------------------------------------------------------------rounded_rect
	//
	// See Implementation agg_rounded_rect.cpp
	//
	public class RoundedRect : VertexSourceLegacySupport
	{
		private RectangleDouble bounds;
		private Vector2 leftBottomRadius;
		private Vector2 rightBottomRadius;
		private Vector2 rightTopRadius;
		private Vector2 leftTopRadius;

		public double ResolutionScale { get; set; } = 1;

		public RoundedRect(double left, double bottom, double right, double top, double radius = 0)
		{
			bounds = new RectangleDouble(left, bottom, right, top);
			leftBottomRadius.X = radius;
			leftBottomRadius.Y = radius;
			rightBottomRadius.X = radius;
			rightBottomRadius.Y = radius;
			rightTopRadius.X = radius;
			rightTopRadius.Y = radius;
			leftTopRadius.X = radius;
			leftTopRadius.Y = radius;

			if (left > right)
			{
				bounds.Left = right;
				bounds.Right = left;
			}

			if (bottom > top)
			{
				bounds.Bottom = top;
				bounds.Top = bottom;
			}
		}

		public RoundedRect(RectangleDouble bounds, double r)
			: this(bounds.Left, bounds.Bottom, bounds.Right, bounds.Top, r)
		{
		}

		public RoundedRect(RectangleInt bounds, double r)
			: this(bounds.Left, bounds.Bottom, bounds.Right, bounds.Top, r)
		{
		}

		public void rect(double left, double bottom, double right, double top)
		{
			bounds = new RectangleDouble(left, bottom, right, top);
			if (left > right) { bounds.Left = right; bounds.Right = left; }
			if (bottom > top) { bounds.Bottom = top; bounds.Top = bottom; }
		}

		public void radius(double r)
		{
			leftBottomRadius.X = leftBottomRadius.Y = rightBottomRadius.X = rightBottomRadius.Y = rightTopRadius.X = rightTopRadius.Y = leftTopRadius.X = leftTopRadius.Y = r;
		}

		public void radius(double rx, double ry)
		{
			leftBottomRadius.X = rightBottomRadius.X = rightTopRadius.X = leftTopRadius.X = rx;
			leftBottomRadius.Y = rightBottomRadius.Y = rightTopRadius.Y = leftTopRadius.Y = ry;
		}

		public void radius(double leftBottomRadius, double rightBottomRadius, double rightTopRadius, double leftTopRadius)
		{
			this.leftBottomRadius = new Vector2(leftBottomRadius, leftBottomRadius);
			this.rightBottomRadius = new Vector2(rightBottomRadius, rightBottomRadius);
			this.rightTopRadius = new Vector2(rightTopRadius, rightTopRadius);
			this.leftTopRadius = new Vector2(leftTopRadius, leftTopRadius);
		}

		public void radius(double rx1, double ry1, double rx2, double ry2,
							  double rx3, double ry3, double rx4, double ry4)
		{
			leftBottomRadius.X = rx1; leftBottomRadius.Y = ry1; rightBottomRadius.X = rx2; rightBottomRadius.Y = ry2;
			rightTopRadius.X = rx3; rightTopRadius.Y = ry3; leftTopRadius.X = rx4; leftTopRadius.Y = ry4;
		}

		public void normalize_radius()
		{
			double dx = Math.Abs(bounds.Top - bounds.Bottom);
			double dy = Math.Abs(bounds.Right - bounds.Left);

			double k = 1.0;
			double t;
			t = dx / (leftBottomRadius.X + rightBottomRadius.X); if (t < k) k = t;
			t = dx / (rightTopRadius.X + leftTopRadius.X); if (t < k) k = t;
			t = dy / (leftBottomRadius.Y + rightBottomRadius.Y); if (t < k) k = t;
			t = dy / (rightTopRadius.Y + leftTopRadius.Y); if (t < k) k = t;

			if (k < 1.0)
			{
				leftBottomRadius.X *= k; leftBottomRadius.Y *= k; rightBottomRadius.X *= k; rightBottomRadius.Y *= k;
				rightTopRadius.X *= k; rightTopRadius.Y *= k; leftTopRadius.X *= k; leftTopRadius.Y *= k;
			}
		}

        /// <summary>
		/// This is the number of segments that will be used in each turn. Set to 0 to use the default of an angle approximation.
		/// </summary>
        public int NumSegments { get; set; } = 0;
        
		public override IEnumerable<VertexData> Vertices()
		{
			var allPaths = new JoinPaths();

			// Add each corner - either as a single point (if radius = 0) or as an arc
			if (leftBottomRadius.X == 0 && leftBottomRadius.Y == 0)
			{
				// Sharp corner - add single point
				var singlePoint = new VertexStorage();
				singlePoint.Add(bounds.Left, bounds.Bottom, FlagsAndCommand.MoveTo);
				allPaths.SourcePaths.Add(singlePoint);
			}
			else
			{
				// Rounded corner - add arc
				allPaths.SourcePaths.Add(new Arc(bounds.Left + leftBottomRadius.X, bounds.Bottom + leftBottomRadius.Y, 
					leftBottomRadius.X, leftBottomRadius.Y, Math.PI, Math.PI + Math.PI * 0.5, numSegments: NumSegments)
				{
					ResolutionScale = ResolutionScale
				});
			}

			if (rightBottomRadius.X == 0 && rightBottomRadius.Y == 0)
			{
				var singlePoint = new VertexStorage();
				singlePoint.Add(bounds.Right, bounds.Bottom, FlagsAndCommand.LineTo);
				allPaths.SourcePaths.Add(singlePoint);
			}
			else
			{
				allPaths.SourcePaths.Add(new Arc(bounds.Right - rightBottomRadius.X, bounds.Bottom + rightBottomRadius.Y, 
					rightBottomRadius.X, rightBottomRadius.Y, Math.PI + Math.PI * 0.5, 0.0, numSegments: NumSegments)
				{
					ResolutionScale = ResolutionScale
				});
			}

			if (rightTopRadius.X == 0 && rightTopRadius.Y == 0)
			{
				var singlePoint = new VertexStorage();
				singlePoint.Add(bounds.Right, bounds.Top, FlagsAndCommand.LineTo);
				allPaths.SourcePaths.Add(singlePoint);
			}
			else
			{
				allPaths.SourcePaths.Add(new Arc(bounds.Right - rightTopRadius.X, bounds.Top - rightTopRadius.Y, 
					rightTopRadius.X, rightTopRadius.Y, 0.0, Math.PI * 0.5, numSegments: NumSegments)
				{
					ResolutionScale = ResolutionScale
				});
			}

			if (leftTopRadius.X == 0 && leftTopRadius.Y == 0)
			{
				var singlePoint = new VertexStorage();
				singlePoint.Add(bounds.Left, bounds.Top, FlagsAndCommand.LineTo);
				allPaths.SourcePaths.Add(singlePoint);
			}
			else
			{
				allPaths.SourcePaths.Add(new Arc(bounds.Left + leftTopRadius.X, bounds.Top - leftTopRadius.Y, 
					leftTopRadius.X, leftTopRadius.Y, Math.PI * 0.5, Math.PI, numSegments: NumSegments)
				{
					ResolutionScale = ResolutionScale
				});
			}

			return allPaths.Vertices();
		}
	}
}


// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\Stroke.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// conv_stroke
//
//----------------------------------------------------------------------------
namespace MatterHackers.Agg.VertexSource
{
	public sealed class Stroke : VertexSourceAdapter
	{
		public Stroke(IVertexSource vertexSource, double inWidth = 1)
			: base(vertexSource, new StrokeGenerator())
		{
			this.Width = inWidth;
		}

		public double ApproximationScale
		{
			get => this.Generator.ApproximationScale;
			set => this.Generator.ApproximationScale = value;
		}

		public InnerJoin InnerJoin
		{
			get => this.Generator.InnerJoin;
			set => this.Generator.InnerJoin = value;
		}

		public double InnerMiterLimit
		{
			get => this.Generator.InnerMiterLimit;
			set => this.Generator.InnerMiterLimit = value;
		}

		public LineCap LineCap
		{
			get => this.Generator.LineCap;
			set => this.Generator.LineCap = value;
		}

		public LineJoin LineJoin
		{
			get => this.Generator.LineJoin;
			set => this.Generator.LineJoin = value;
		}

		public double MiterLimit
		{
			get => this.Generator.MiterLimit;
			set => this.Generator.MiterLimit = value;
		}

		public double Shorten
		{
			get => this.Generator.Shorten;
			set => this.Generator.Shorten = value;
		}

		public double Width
		{
			get => this.Generator.Width;
			set => this.Generator.Width = value;
		}

		public void MiterLimitTheta(double t)
		{
			this.Generator.MiterLimitTheta(t);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\StrokeGenerator.cs
using MatterHackers.VectorMath;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg.VertexSource
{
	//============================================================vcgen_stroke
	internal class StrokeGenerator : IGenerator
	{
		private int m_closed;
		private int m_out_vertex;
		private Vector2Container m_out_vertices;
		private StrokeMath.status_e m_prev_status;
		private double m_shorten;
		private int m_src_vertex;
		private VertexSequence m_src_vertices;
		private StrokeMath.status_e m_status;
		private StrokeMath m_stroker;

		public StrokeGenerator()
		{
			m_stroker = new StrokeMath();
			m_src_vertices = new VertexSequence();
			m_out_vertices = new Vector2Container();
			m_status = StrokeMath.status_e.initial;
		}

		public void AddVertex(double x, double y, FlagsAndCommand cmd)
		{
			m_status = StrokeMath.status_e.initial;
			if (ShapePath.IsMoveTo(cmd))
			{
				m_src_vertices.modify_last(new VertexDistance(x, y));
			}
			else
			{
				if (ShapePath.IsVertex(cmd))
				{
					m_src_vertices.Add(new VertexDistance(x, y));
				}
				else
				{
					m_closed = (int)ShapePath.get_close_flag(cmd);
				}
			}
		}

		public double ApproximationScale
		{
			get => m_stroker.approximation_scale();
			set => m_stroker.approximation_scale(value);
		}

		// TODO: Needs review - we previously implemented this interface element but threw when accessed. Propose having no effect instead of being destructive
		public bool AutoDetectOrientation { get; set; }
		
		public InnerJoin InnerJoin
		{
			get => m_stroker.inner_join();
			set => m_stroker.inner_join(value);
		}

		public double InnerMiterLimit
		{
			get => m_stroker.inner_miter_limit();
			set => m_stroker.inner_miter_limit(value);
		}

		public LineCap LineCap
		{
			get => m_stroker.line_cap();
			set => m_stroker.line_cap(value);
		}

		public LineJoin LineJoin
		{
			get => m_stroker.line_join();
			set => m_stroker.line_join(value);
		}

		public double MiterLimit
		{
			get => m_stroker.miter_limit();
			set => m_stroker.miter_limit(value);
		}

		public double Shorten
		{
			get => m_shorten;
			set => m_shorten = value;
		}

		public double Width
		{
			get => m_stroker.width();
			set => m_stroker.width(value);
		}

		public void MiterLimitTheta(double t)
		{
			m_stroker.miter_limit_theta(t);
		}

		// Vertex Generator Interface
		public void RemoveAll()
		{
			m_src_vertices.Clear();
			m_closed = 0;
			m_status = StrokeMath.status_e.initial;
		}

		// Vertex Source Interface
		public void Rewind(int idx)
		{
			if (m_status == StrokeMath.status_e.initial)
			{
				m_src_vertices.close(m_closed != 0);
				ShapePath.shorten_path(m_src_vertices, m_shorten, m_closed);
				if (m_src_vertices.Count < 3) m_closed = 0;
			}
			m_status = StrokeMath.status_e.ready;
			m_src_vertex = 0;
			m_out_vertex = 0;
		}

		public FlagsAndCommand Vertex(ref double x, ref double y)
		{
			FlagsAndCommand cmd = FlagsAndCommand.LineTo;
			while (!ShapePath.IsStop(cmd))
			{
				switch (m_status)
				{
					case StrokeMath.status_e.initial:
						Rewind(0);
						goto case StrokeMath.status_e.ready;

					case StrokeMath.status_e.ready:
						if (m_src_vertices.Count < 2 + (m_closed != 0 ? 1 : 0))
						{
							cmd = FlagsAndCommand.Stop;
							break;
						}
						m_status = (m_closed != 0) ? StrokeMath.status_e.outline1 : StrokeMath.status_e.cap1;
						cmd = FlagsAndCommand.MoveTo;
						m_src_vertex = 0;
						m_out_vertex = 0;
						break;

					case StrokeMath.status_e.cap1:
						m_stroker.calc_cap(m_out_vertices, m_src_vertices[0], m_src_vertices[1],
							m_src_vertices[0].dist);
						m_src_vertex = 1;
						m_prev_status = StrokeMath.status_e.outline1;
						m_status = StrokeMath.status_e.out_vertices;
						m_out_vertex = 0;
						break;

					case StrokeMath.status_e.cap2:
						m_stroker.calc_cap(m_out_vertices,
							m_src_vertices[m_src_vertices.Count - 1],
							m_src_vertices[m_src_vertices.Count - 2],
							m_src_vertices[m_src_vertices.Count - 2].dist);
						m_prev_status = StrokeMath.status_e.outline2;
						m_status = StrokeMath.status_e.out_vertices;
						m_out_vertex = 0;
						break;

					case StrokeMath.status_e.outline1:
						if (m_closed != 0)
						{
							if (m_src_vertex >= m_src_vertices.Count)
							{
								m_prev_status = StrokeMath.status_e.close_first;
								m_status = StrokeMath.status_e.end_poly1;
								break;
							}
						}
						else
						{
							if (m_src_vertex >= m_src_vertices.Count - 1)
							{
								m_status = StrokeMath.status_e.cap2;
								break;
							}
						}
						m_stroker.calc_join(m_out_vertices,
							m_src_vertices.prev(m_src_vertex),
							m_src_vertices.curr(m_src_vertex),
							m_src_vertices.next(m_src_vertex),
							m_src_vertices.prev(m_src_vertex).dist,
							m_src_vertices.curr(m_src_vertex).dist);
						++m_src_vertex;
						m_prev_status = m_status;
						m_status = StrokeMath.status_e.out_vertices;
						m_out_vertex = 0;
						break;

					case StrokeMath.status_e.close_first:
						m_status = StrokeMath.status_e.outline2;
						cmd = FlagsAndCommand.MoveTo;
						goto case StrokeMath.status_e.outline2;

					case StrokeMath.status_e.outline2:
						if (m_src_vertex <= (m_closed == 0 ? 1 : 0))
						{
							m_status = StrokeMath.status_e.end_poly2;
							m_prev_status = StrokeMath.status_e.stop;
							break;
						}

						--m_src_vertex;
						m_stroker.calc_join(m_out_vertices,
							m_src_vertices.next(m_src_vertex),
							m_src_vertices.curr(m_src_vertex),
							m_src_vertices.prev(m_src_vertex),
							m_src_vertices.curr(m_src_vertex).dist,
							m_src_vertices.prev(m_src_vertex).dist);

						m_prev_status = m_status;
						m_status = StrokeMath.status_e.out_vertices;
						m_out_vertex = 0;
						break;

					case StrokeMath.status_e.out_vertices:
						if (m_out_vertex >= m_out_vertices.Count)
						{
							m_status = m_prev_status;
						}
						else
						{
							Vector2 c = m_out_vertices[(int)m_out_vertex++];
							x = c.X;
							y = c.Y;
							return cmd;
						}
						break;

					case StrokeMath.status_e.end_poly1:
						m_status = m_prev_status;
						return FlagsAndCommand.EndPoly
							| FlagsAndCommand.FlagClose
							| FlagsAndCommand.FlagCCW;

					case StrokeMath.status_e.end_poly2:
						m_status = m_prev_status;
						return FlagsAndCommand.EndPoly
							| FlagsAndCommand.FlagClose
							| FlagsAndCommand.FlagCW;

					case StrokeMath.status_e.stop:
						cmd = FlagsAndCommand.Stop;
						break;
				}
			}
			return cmd;
		}
	}

	internal class Vector2Container : VectorPOD<Vector2>, IVertexDest
	{
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\StrokeMath.cs
using MatterHackers.VectorMath;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Stroke math
//
//----------------------------------------------------------------------------
using System;

namespace MatterHackers.Agg.VertexSource
{
	public enum LineCap
	{
		Butt,
		Square,
		Round
	}

	public enum LineJoin
	{
		Miter,
		MiterRevert,
		Round,
		Bevel,
		MiterRound
	}

	public enum InnerJoin
	{
		Bevel,
		Miter,
		Jag,
		Round
	}

	public class StrokeMath
	{
		public enum status_e
		{
			initial,
			ready,
			cap1,
			cap2,
			outline1,
			close_first,
			outline2,
			out_vertices,
			end_poly1,
			end_poly2,
			stop
		};

		private double m_width;
		private double m_width_abs;
		private double m_width_eps;
		private int m_width_sign;
		private double m_miter_limit;
		private double m_inner_miter_limit;
		private double m_approx_scale;
		private LineCap m_line_cap;
		private LineJoin m_line_join;
		private InnerJoin m_inner_join;

		public StrokeMath()
		{
			m_width = 0.5;
			m_width_abs = 0.5;
			m_width_eps = 0.5 / 1024.0;
			m_width_sign = 1;
			m_miter_limit = 4.0;
			m_inner_miter_limit = 1.01;
			m_approx_scale = 1.0;
			m_line_cap = LineCap.Butt;
			m_line_join = LineJoin.Miter;
			m_inner_join = InnerJoin.Miter;
		}

		public void line_cap(LineCap lc)
		{
			m_line_cap = lc;
		}

		public void line_join(LineJoin lj)
		{
			m_line_join = lj;
		}

		public void inner_join(InnerJoin ij)
		{
			m_inner_join = ij;
		}

		public LineCap line_cap()
		{
			return m_line_cap;
		}

		public LineJoin line_join()
		{
			return m_line_join;
		}

		public InnerJoin inner_join()
		{
			return m_inner_join;
		}

		public void width(double w)
		{
			m_width = w * 0.5;
			if (m_width < 0)
			{
				m_width_abs = -m_width;
				m_width_sign = -1;
			}
			else
			{
				m_width_abs = m_width;
				m_width_sign = 1;
			}
			m_width_eps = m_width / 1024.0;
		}

		public void miter_limit(double ml)
		{
			m_miter_limit = ml;
		}

		public void miter_limit_theta(double t)
		{
			m_miter_limit = 1.0 / Math.Sin(t * 0.5);
		}

		public void inner_miter_limit(double ml)
		{
			m_inner_miter_limit = ml;
		}

		public void approximation_scale(double aproxScale)
		{
			m_approx_scale = aproxScale;
		}

		public double width()
		{
			return m_width * 2.0;
		}

		public double miter_limit()
		{
			return m_miter_limit;
		}

		public double inner_miter_limit()
		{
			return m_inner_miter_limit;
		}

		public double approximation_scale()
		{
			return m_approx_scale;
		}

		public void calc_cap(IVertexDest vc, VertexDistance v0, VertexDistance v1, double len)
		{
			vc.Clear();

			double dx1 = (v1.y - v0.y) / len;
			double dy1 = (v1.x - v0.x) / len;
			double dx2 = 0;
			double dy2 = 0;

			dx1 *= m_width;
			dy1 *= m_width;

			if (m_line_cap != LineCap.Round)
			{
				if (m_line_cap == LineCap.Square)
				{
					dx2 = dy1 * m_width_sign;
					dy2 = dx1 * m_width_sign;
				}
				add_vertex(vc, v0.x - dx1 - dx2, v0.y + dy1 - dy2);
				add_vertex(vc, v0.x + dx1 - dx2, v0.y - dy1 - dy2);
			}
			else
			{
				double da = Math.Acos(m_width_abs / (m_width_abs + 0.125 / m_approx_scale)) * 2;
				double a1;
				int i;
				int n = (int)(Math.PI / da);

				da = Math.PI / (n + 1);
				add_vertex(vc, v0.x - dx1, v0.y + dy1);
				if (m_width_sign > 0)
				{
					a1 = Math.Atan2(dy1, -dx1);
					a1 += da;
					for (i = 0; i < n; i++)
					{
						add_vertex(vc, v0.x + Math.Cos(a1) * m_width,
									   v0.y + Math.Sin(a1) * m_width);
						a1 += da;
					}
				}
				else
				{
					a1 = Math.Atan2(-dy1, dx1);
					a1 -= da;
					for (i = 0; i < n; i++)
					{
						add_vertex(vc, v0.x + Math.Cos(a1) * m_width,
									   v0.y + Math.Sin(a1) * m_width);
						a1 -= da;
					}
				}
				add_vertex(vc, v0.x + dx1, v0.y - dy1);
			}
		}

		public void calc_join(IVertexDest vc, VertexDistance v0,
										VertexDistance v1,
										VertexDistance v2,
										double len1,
										double len2)
		{
			double dx1 = m_width * (v1.y - v0.y) / len1;
			double dy1 = m_width * (v1.x - v0.x) / len1;
			double dx2 = m_width * (v2.y - v1.y) / len2;
			double dy2 = m_width * (v2.x - v1.x) / len2;

			vc.Clear();

			double cp = agg_math.cross_product(v0.x, v0.y, v1.x, v1.y, v2.x, v2.y);
			if (cp != 0 && (cp > 0) == (m_width > 0))
			{
				// Inner join
				//---------------
				double limit = ((len1 < len2) ? len1 : len2) / m_width_abs;
				if (limit < m_inner_miter_limit)
				{
					limit = m_inner_miter_limit;
				}

				switch (m_inner_join)
				{
					default: // inner_bevel
						add_vertex(vc, v1.x + dx1, v1.y - dy1);
						add_vertex(vc, v1.x + dx2, v1.y - dy2);
						break;

					case InnerJoin.Miter:
						calc_miter(vc,
								   v0, v1, v2, dx1, dy1, dx2, dy2,
								   LineJoin.MiterRevert,
								   limit, 0);
						break;

					case InnerJoin.Jag:
					case InnerJoin.Round:
						cp = (dx1 - dx2) * (dx1 - dx2) + (dy1 - dy2) * (dy1 - dy2);
						if (cp < len1 * len1 && cp < len2 * len2)
						{
							calc_miter(vc,
									   v0, v1, v2, dx1, dy1, dx2, dy2,
									   LineJoin.MiterRevert,
									   limit, 0);
						}
						else
						{
							if (m_inner_join == InnerJoin.Jag)
							{
								add_vertex(vc, v1.x + dx1, v1.y - dy1);
								add_vertex(vc, v1.x, v1.y);
								add_vertex(vc, v1.x + dx2, v1.y - dy2);
							}
							else
							{
								add_vertex(vc, v1.x + dx1, v1.y - dy1);
								add_vertex(vc, v1.x, v1.y);
								calc_arc(vc, v1.x, v1.y, dx2, -dy2, dx1, -dy1);
								add_vertex(vc, v1.x, v1.y);
								add_vertex(vc, v1.x + dx2, v1.y - dy2);
							}
						}
						break;
				}
			}
			else
			{
				// Outer join
				//---------------

				// Calculate the distance between v1 and
				// the central point of the bevel line segment
				//---------------
				double dx = (dx1 + dx2) / 2;
				double dy = (dy1 + dy2) / 2;
				double dbevel = Math.Sqrt(dx * dx + dy * dy);

				if (m_line_join == LineJoin.Round || m_line_join == LineJoin.Bevel)
				{
					// This is an optimization that reduces the number of points
					// in cases of almost collinear segments. If there's no
					// visible difference between bevel and miter joins we'd rather
					// use miter join because it adds only one point instead of two.
					//
					// Here we calculate the middle point between the bevel points
					// and then, the distance between v1 and this middle point.
					// At outer joins this distance always less than stroke width,
					// because it's actually the height of an isosceles triangle of
					// v1 and its two bevel points. If the difference between this
					// width and this value is small (no visible bevel) we can
					// add just one point.
					//
					// The constant in the expression makes the result approximately
					// the same as in round joins and caps. You can safely comment
					// out this entire "if".
					//-------------------
					if (m_approx_scale * (m_width_abs - dbevel) < m_width_eps)
					{
						if (agg_math.calc_intersection(v0.x + dx1, v0.y - dy1,
											 v1.x + dx1, v1.y - dy1,
											 v1.x + dx2, v1.y - dy2,
											 v2.x + dx2, v2.y - dy2,
											 out dx, out dy))
						{
							add_vertex(vc, dx, dy);
						}
						else
						{
							add_vertex(vc, v1.x + dx1, v1.y - dy1);
						}
						return;
					}
				}

				switch (m_line_join)
				{
					case LineJoin.Miter:
					case LineJoin.MiterRevert:
					case LineJoin.MiterRound:
						calc_miter(vc,
								   v0, v1, v2, dx1, dy1, dx2, dy2,
								   m_line_join,
								   m_miter_limit,
								   dbevel);
						break;

					case LineJoin.Round:
						calc_arc(vc, v1.x, v1.y, dx1, -dy1, dx2, -dy2);
						break;

					default: // Bevel join
						add_vertex(vc, v1.x + dx1, v1.y - dy1);
						add_vertex(vc, v1.x + dx2, v1.y - dy2);
						break;
				}
			}
		}

		private void add_vertex(IVertexDest vc, double x, double y)
		{
			vc.Add(new Vector2(x, y));
		}

		private void calc_arc(IVertexDest vc,
					  double x, double y,
					  double dx1, double dy1,
					  double dx2, double dy2)
		{
			double a1 = Math.Atan2(dy1 * m_width_sign, dx1 * m_width_sign);
			double a2 = Math.Atan2(dy2 * m_width_sign, dx2 * m_width_sign);
			double da = a1 - a2;
			int i, n;

			da = Math.Acos(m_width_abs / (m_width_abs + 0.125 / m_approx_scale)) * 2;

			add_vertex(vc, x + dx1, y + dy1);
			if (m_width_sign > 0)
			{
				if (a1 > a2) a2 += 2 * Math.PI;
				n = (int)((a2 - a1) / da);
				da = (a2 - a1) / (n + 1);
				a1 += da;
				for (i = 0; i < n; i++)
				{
					add_vertex(vc, x + Math.Cos(a1) * m_width, y + Math.Sin(a1) * m_width);
					a1 += da;
				}
			}
			else
			{
				if (a1 < a2) a2 -= 2 * Math.PI;
				n = (int)((a1 - a2) / da);
				da = (a1 - a2) / (n + 1);
				a1 -= da;
				for (i = 0; i < n; i++)
				{
					add_vertex(vc, x + Math.Cos(a1) * m_width, y + Math.Sin(a1) * m_width);
					a1 -= da;
				}
			}
			add_vertex(vc, x + dx2, y + dy2);
		}

		private void calc_miter(IVertexDest vc,
						VertexDistance v0,
						VertexDistance v1,
						VertexDistance v2,
						double dx1, double dy1,
						double dx2, double dy2,
						LineJoin lj,
						double mlimit,
						double dbevel)
		{
			double xi = v1.x;
			double yi = v1.y;
			double di = 1;
			double lim = m_width_abs * mlimit;
			bool miter_limit_exceeded = true; // Assume the worst
			bool intersection_failed = true; // Assume the worst

			if (agg_math.calc_intersection(v0.x + dx1, v0.y - dy1,
								 v1.x + dx1, v1.y - dy1,
								 v1.x + dx2, v1.y - dy2,
								 v2.x + dx2, v2.y - dy2,
								 out xi, out yi))
			{
				// Calculation of the intersection succeeded
				//---------------------
				di = agg_math.CalcDistance(v1.x, v1.y, xi, yi);
				if (di <= lim)
				{
					// Inside the miter limit
					//---------------------
					add_vertex(vc, xi, yi);
					miter_limit_exceeded = false;
				}
				intersection_failed = false;
			}
			else
			{
				// Calculation of the intersection failed, most probably
				// the three points lie one straight line.
				// First check if v0 and v2 lie on the opposite sides of vector:
				// (v1.x, v1.y) -> (v1.x+dx1, v1.y-dy1), that is, the perpendicular
				// to the line determined by vertices v0 and v1.
				// This condition determines whether the next line segments continues
				// the previous one or goes back.
				//----------------
				double x2 = v1.x + dx1;
				double y2 = v1.y - dy1;
				if ((agg_math.cross_product(v0.x, v0.y, v1.x, v1.y, x2, y2) < 0.0) ==
				   (agg_math.cross_product(v1.x, v1.y, v2.x, v2.y, x2, y2) < 0.0))
				{
					// This case means that the next segment continues
					// the previous one (straight line)
					//-----------------
					add_vertex(vc, v1.x + dx1, v1.y - dy1);
					miter_limit_exceeded = false;
				}
			}

			if (miter_limit_exceeded)
			{
				// Miter limit exceeded
				//------------------------
				switch (lj)
				{
					case LineJoin.MiterRevert:
						// For the compatibility with SVG, PDF, etc,
						// we use a simple bevel join instead of
						// "smart" bevel
						//-------------------
						add_vertex(vc, v1.x + dx1, v1.y - dy1);
						add_vertex(vc, v1.x + dx2, v1.y - dy2);
						break;

					case LineJoin.MiterRound:
						calc_arc(vc, v1.x, v1.y, dx1, -dy1, dx2, -dy2);
						break;

					default:
						// If no miter-revert, calculate new dx1, dy1, dx2, dy2
						//----------------
						if (intersection_failed)
						{
							mlimit *= m_width_sign;
							add_vertex(vc, v1.x + dx1 + dy1 * mlimit,
										   v1.y - dy1 + dx1 * mlimit);
							add_vertex(vc, v1.x + dx2 - dy2 * mlimit,
										   v1.y - dy2 - dx2 * mlimit);
						}
						else
						{
							double x1 = v1.x + dx1;
							double y1 = v1.y - dy1;
							double x2 = v1.x + dx2;
							double y2 = v1.y - dy2;
							di = (lim - dbevel) / (di - dbevel);
							add_vertex(vc, x1 + (xi - x1) * di,
										   y1 + (yi - y1) * di);
							add_vertex(vc, x2 + (xi - x2) * di,
										   y2 + (yi - y2) * di);
						}
						break;
				}
			}
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\VertexData.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using MatterHackers.VectorMath;
using Newtonsoft.Json;

namespace MatterHackers.Agg.VertexSource
{
    public struct VertexData
    {
        public VertexData(FlagsAndCommand command, Vector2 position, CommandHint hint = CommandHint.None)
        {
            this.Command = command;
            this.Position = position;
            this.Hint = hint;
        }

        public VertexData(FlagsAndCommand command, double x, double y, CommandHint hint = CommandHint.None)
            : this(command, new Vector2(x, y), hint)
        {
        }

        public FlagsAndCommand Command { get; set; }

        [JsonIgnore]
        public bool IsClose => ShapePath.IsClose(Command);

        [JsonIgnore]
        public bool IsLineTo => ShapePath.IsLineTo(Command);

        [JsonIgnore]
        public bool IsMoveTo => ShapePath.IsMoveTo(Command);

        [JsonIgnore]
        public bool IsStop => ShapePath.IsStop(Command);

        [JsonIgnore]
        public bool IsVertex => ShapePath.IsVertex(Command);

        public Vector2 Position { get; set; }
        public CommandHint Hint { get; }

        [JsonIgnore]
        public double X => Position.X;

        [JsonIgnore]
        public double Y => Position.Y;

        public override string ToString()
        {
            if (Hint != CommandHint.None)
            {
                return $"{Command}:{Position} ({Hint})";
            }
            
            return $"{Command}:{Position}";
        }

        public ulong GetLongHashCode(ulong hash = 14695981039346656037)
        {
            hash = Position.GetLongHashCode(hash);
            hash = hash * 1099511628211 + (ulong)Command;

            return hash;
        }
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\VertexSourceAdapter.cs
using MatterHackers.VectorMath;

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System.Collections.Generic;

namespace MatterHackers.Agg.VertexSource
{
	//------------------------------------------------------------null_markers
	public struct null_markers : IMarkers
	{
		public void Clear()
		{
		}

		public void add_vertex(double x, double y, FlagsAndCommand unknown)
		{
		}

		public void prepare_src()
		{
		}

		public void rewind(int unknown)
		{
		}

		public FlagsAndCommand vertex(ref double x, ref double y)
		{
			return FlagsAndCommand.Stop;
		}
	};

	//------------------------------------------------------conv_adaptor_vcgen
	public class VertexSourceAdapter : IVertexSourceProxy
	{
		private IGenerator generator;
		private IMarkers markers;
		private status m_status;
		private FlagsAndCommand m_last_cmd;
		private double m_start_x;
		private double m_start_y;

		public IVertexSource VertexSource { get; set; }

		private enum status
		{
			initial,
			accumulate,
			generate
		};

		public VertexSourceAdapter(IVertexSource vertexSource, IGenerator generator)
		{
			markers = new null_markers();
			this.VertexSource = vertexSource;
			this.generator = generator;
			m_status = status.initial;
		}

        public ulong GetLongHashCode(ulong hash = 14695981039346656037)
        {
            foreach (var vertex in this.Vertices())
            {
                hash = vertex.GetLongHashCode(hash);
            }

            return hash;
        }

        public VertexSourceAdapter(IVertexSource vertexSource, IGenerator generator, IMarkers markers)
			: this(vertexSource, generator)
		{
			this.markers = markers;
		}

		private void Attach(IVertexSource vertexSource)
		{
			this.VertexSource = vertexSource;
		}

		protected IGenerator Generator => generator;

		protected IMarkers Markers => markers;

		public IEnumerable<VertexData> Vertices()
		{
			Rewind(0);
			FlagsAndCommand command = FlagsAndCommand.Stop;
			do
			{
				double x;
				double y;
				command = Vertex(out x, out y);
				yield return new VertexData(command, new Vector2(x, y));
			} while (command != FlagsAndCommand.Stop);
		}

		public void Rewind(int path_id)
		{
			VertexSource.Rewind(path_id);
			m_status = status.initial;
		}

		public FlagsAndCommand Vertex(out double x, out double y)
		{
			x = 0;
			y = 0;
			FlagsAndCommand command = FlagsAndCommand.Stop;
			bool done = false;
			while (!done)
			{
				switch (m_status)
				{
					case status.initial:
						markers.Clear();
						m_last_cmd = VertexSource.Vertex(out m_start_x, out m_start_y);
						m_status = status.accumulate;
						goto case status.accumulate;

					case status.accumulate:
						if (ShapePath.IsStop(m_last_cmd))
						{
							return FlagsAndCommand.Stop;
						}

						generator.RemoveAll();
						generator.AddVertex(m_start_x, m_start_y, FlagsAndCommand.MoveTo);
						markers.add_vertex(m_start_x, m_start_y, FlagsAndCommand.MoveTo);

						for (; ; )
						{
							command = VertexSource.Vertex(out x, out y);
							//DebugFile.Print("x=" + x.ToString() + " y=" + y.ToString() + "\n");
							if (ShapePath.IsVertex(command))
							{
								m_last_cmd = command;
								if (ShapePath.IsMoveTo(command))
								{
									m_start_x = x;
									m_start_y = y;
									break;
								}
								generator.AddVertex(x, y, command);
								markers.add_vertex(x, y, FlagsAndCommand.LineTo);
							}
							else
							{
								if (ShapePath.IsStop(command))
								{
									m_last_cmd = FlagsAndCommand.Stop;
									break;
								}
								if (ShapePath.is_end_poly(command))
								{
									generator.AddVertex(x, y, command);
									break;
								}
							}
						}
						generator.Rewind(0);
						m_status = status.generate;
						goto case status.generate;

					case status.generate:
						command = generator.Vertex(ref x, ref y);
						//DebugFile.Print("x=" + x.ToString() + " y=" + y.ToString() + "\n");
						if (ShapePath.IsStop(command))
						{
							m_status = status.accumulate;
							break;
						}
						done = true;
						break;
				}
			}
			return command;
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\VertexSourceExtensionMethods.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using MatterHackers.Agg.Transform;
using MatterHackers.VectorMath;

namespace MatterHackers.Agg.VertexSource
{
	public static class VertexSourceExtensionMethods
	{
		public static IVertexSource Rotate(this IVertexSource source, double angle, AngleType angleType = AngleType.Radians)
		{
			if (angleType == AngleType.Degrees)
			{
				angle = MathHelper.DegreesToRadians(angle);
			}

			return new VertexSourceApplyTransform(source, Affine.NewRotation(angle));
		}

		public static IVertexSource Translate(this IVertexSource source, Vector2 vector2)
		{
			return source.Translate(vector2.X, vector2.Y);
		}

		public static IVertexSource Translate(this IVertexSource source, double x, double y)
		{
			return new VertexSourceApplyTransform(source, Affine.NewTranslation(x, y));
		}

		public static IVertexSource Scale(this IVertexSource source, double scale)
		{
			return new VertexSourceApplyTransform(source, Affine.NewScaling(scale));
		}

		public static IVertexSource CombineWith(this IVertexSource source, IVertexSource target)
		{
			return new JoinPaths(source, target);
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\VertexSourceIO.cs
using System.IO;

namespace MatterHackers.Agg.VertexSource
{
	public class VertexSourceIO
	{
		public static void Load(VertexStorage vertexSource, string pathAndFileName)
		{
			vertexSource.Clear();
			string[] allLines = File.ReadAllLines(pathAndFileName);
			foreach (string line in allLines)
			{
				string[] elements = line.Split(',');
				double x = double.Parse(elements[0]);
				double y = double.Parse(elements[1]);
				FlagsAndCommand flagsAndCommand = (FlagsAndCommand)System.Enum.Parse(typeof(FlagsAndCommand), elements[2].Trim());
				for (int i = 3; i < elements.Length; i++)
				{
					flagsAndCommand |= (FlagsAndCommand)System.Enum.Parse(typeof(FlagsAndCommand), elements[i].Trim());
				}

				vertexSource.Add(x, y, flagsAndCommand);
			}
		}

		public static void Save(IVertexSource vertexSource, string pathAndFileName, bool oldStyle = true)
		{
			if (oldStyle)
			{
				using (StreamWriter outFile = new StreamWriter(pathAndFileName))
				{
					vertexSource.Rewind(0);
					double x;
					double y;
					FlagsAndCommand flagsAndCommand = vertexSource.Vertex(out x, out y);
					do
					{
						outFile.WriteLine("{0}, {1}, {2}", x, y, flagsAndCommand.ToString());
						flagsAndCommand = vertexSource.Vertex(out x, out y);
					}
					while (flagsAndCommand != FlagsAndCommand.Stop);
				}
			}
			else
			{
				using (StreamWriter outFile = new StreamWriter(pathAndFileName))
				{
					foreach (VertexData vertexData in vertexSource.Vertices())
					{
						outFile.WriteLine("{0}, {1}, {2}", vertexData.Position.X, vertexData.Position.Y, vertexData.Command.ToString());
					}
				}
			}
		}
	}
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\VertexSourceLegacySupport.cs
//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System.Collections.Generic;

namespace MatterHackers.Agg.VertexSource
{
    public abstract class VertexSourceLegacySupport : IVertexSource
    {
        private IEnumerator<VertexData> currentEnumerator;

        public void Rewind(int layerIndex)
        {
            currentEnumerator = Vertices().GetEnumerator();
            currentEnumerator.MoveNext();
        }

        public FlagsAndCommand Vertex(out double x, out double y)
        {
            if (currentEnumerator == null)
            {
                Rewind(0);
            }

            x = currentEnumerator.Current.Position.X;
            y = currentEnumerator.Current.Position.Y;
            FlagsAndCommand command = currentEnumerator.Current.Command;

            currentEnumerator.MoveNext();

            return command;
        }

        public ulong GetLongHashCode(ulong hash = 14695981039346656037)
        {
            foreach (var vertex in this.Vertices())
            {
                hash = vertex.GetLongHashCode(hash);
            }

            return hash;
        }

        public abstract IEnumerable<VertexData> Vertices();
    }
}

// Merged from C:\MyDartProjects\agg\agg-sharp\agg\VertexSource\VertexStorage.cs
using MatterHackers.Agg.SvgTools;
using MatterHackers.VectorMath;
using Newtonsoft.Json;
using System;


//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
using System.Collections.Generic;

namespace MatterHackers.Agg.VertexSource
{
    //---------------------------------------------------------------path_base
    // A container to store vertices with their flags.
    // A path consists of a number of contours separated with "move_to"
    // commands. The path storage can keep and maintain more than one
    // path.
    // To navigate to the beginning of a particular path, use rewind(path_id);
    // Where path_id is what start_new_path() returns. So, when you call
    // start_new_path() you need to store its return value somewhere else
    // to navigate to the path afterwards.
    //
    // See also: vertex_source concept
    //------------------------------------------------------------------------
    public class VertexStorage : IVertexSource, IVertexDest
    {
        private class VertexDataManager
        {
            private int allocatedVertices;
            private VertexData[] vertexData;
            private int numVertices;

            public VertexDataManager()
            {
            }

            public VertexData this[int index]
            {
                get => vertexData[index];
                set => vertexData[index] = value;
            }

            public void AddVertex(double x, double y, FlagsAndCommand CommandAndFlags, CommandHint hint = CommandHint.None)
            {
                int index = numVertices;
                AllocateIfRequired(numVertices);
                vertexData[index] = new VertexData(CommandAndFlags, x, y, hint);

                numVertices++;
            }

            public FlagsAndCommand Command(int index)
            {
                return vertexData[index].Command;
            }

            public void free_all()
            {
                vertexData = null;
                numVertices = 0;
            }

            public FlagsAndCommand LastCommand()
            {
                if (numVertices != 0)
                {
                    return Command(numVertices - 1);
                }

                return FlagsAndCommand.Stop;
            }

            public FlagsAndCommand LastVertex(out double x, out double y)
            {
                if (numVertices != 0)
                {
                    return Vertex(numVertices - 1, out x, out y);
                }

                x = 0;
                y = 0;

                return FlagsAndCommand.Stop;
            }

            public double last_x()
            {
                if (numVertices > 0)
                {
                    int index = numVertices - 1;
                    return vertexData[index].Position.X;
                }

                return 0;
            }

            public double LastY()
            {
                if (numVertices > 0)
                {
                    int index = numVertices - 1;
                    return vertexData[index].Position.Y;
                }

                return 0;
            }

            public void ModifyCommand(int index, FlagsAndCommand CommandAndFlags)
            {
                this.vertexData[index].Command = CommandAndFlags;
            }

            public void ModifyVertex(int index, double x, double y)
            {
                vertexData[index].Position = new Vector2(x, y);
            }

            public void ModifyVertex(int index, double x, double y, FlagsAndCommand CommandAndFlags)
            {
                vertexData[index].Position = new Vector2(x, y);
                vertexData[index].Command = CommandAndFlags;
            }

            public FlagsAndCommand PrevVertex(out double x, out double y)
            {
                if (numVertices > 1)
                {
                    return Vertex(numVertices - 2, out x, out y);
                }

                x = 0;
                y = 0;

                return FlagsAndCommand.Stop;
            }

            public void Clear()
            {
                numVertices = 0;
            }

            public void SwapVertices(int v1, int v2)
            {
                var hold = vertexData[v2];
                vertexData[v2] = vertexData[v1];
                vertexData[v1] = hold;
            }

            public int TotalVertices()
            {
                return numVertices;
            }

            public FlagsAndCommand Vertex(int index, out double x, out double y)
            {
                x = vertexData[index].Position.X;
                y = vertexData[index].Position.Y;
                return vertexData[index].Command;
            }

            private void AllocateIfRequired(int indexToAdd)
            {
                if (indexToAdd < numVertices)
                {
                    return;
                }

                while (indexToAdd >= allocatedVertices)
                {
                    int newSize = allocatedVertices + 256;
                    VertexData[] newVertexData = new VertexData[newSize];

                    if (vertexData != null)
                    {
                        for (int i = 0; i < numVertices; i++)
                        {
                            newVertexData[i] = vertexData[i];
                        }
                    }

                    vertexData = newVertexData;

                    allocatedVertices = newSize;
                }
            }

            /// <summary>
            /// Determines if the given point lies within, on, or outside the polygon defined by vertex data.
            /// Based on "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos.
            /// </summary>
            /// <param name="pointToCheck">The point to check.</param>
            /// <returns>
            /// 0 if point is outside the polygon,
            /// +1 if point is inside the polygon,
            /// -1 if point is on the polygon boundary.
            /// </returns>
            public int CheckPointInPolygon(Vector2 pointToCheck)
            {
                int pointPosition = 0;
                var vertexCount = vertexData.Length;

                // If the polygon has less than 3 vertices, it's not valid, so the point is outside.
                if (vertexCount < 3)
                {
                    return 0;
                }

                var currentVertex = vertexData[0];
                for (int i = 1; i <= vertexCount; ++i)
                {
                    var nextVertex = (i == vertexCount ? vertexData[0] : vertexData[i]);

                    if (nextVertex.Y == pointToCheck.Y)
                    {
                        if ((nextVertex.X == pointToCheck.X) || (currentVertex.Y == pointToCheck.Y && ((nextVertex.X > pointToCheck.X) == (currentVertex.X < pointToCheck.X))))
                        {
                            return -1;
                        }
                    }

                    if ((currentVertex.Y < pointToCheck.Y) != (nextVertex.Y < pointToCheck.Y))
                    {
                        if (currentVertex.X >= pointToCheck.X)
                        {
                            if (nextVertex.X > pointToCheck.X)
                            {
                                pointPosition = 1 - pointPosition;
                            }
                            else
                            {
                                double d = (double)(currentVertex.X - pointToCheck.X) * (nextVertex.Y - pointToCheck.Y) - (double)(nextVertex.X - pointToCheck.X) * (currentVertex.Y - pointToCheck.Y);

                                if (d == 0)
                                {
                                    return -1;
                                }
                                else if ((d > 0) == (nextVertex.Y > currentVertex.Y))
                                {
                                    pointPosition = 1 - pointPosition;
                                }
                            }
                        }
                        else
                        {
                            if (nextVertex.X > pointToCheck.X)
                            {
                                double d = (double)(currentVertex.X - pointToCheck.X) * (nextVertex.Y - pointToCheck.Y) - (double)(nextVertex.X - pointToCheck.X) * (currentVertex.Y - pointToCheck.Y);

                                if (d == 0)
                                {
                                    return -1;
                                }
                                else if ((d > 0) == (nextVertex.Y > currentVertex.Y))
                                {
                                    pointPosition = 1 - pointPosition;
                                }
                            }
                        }
                    }

                    currentVertex = nextVertex;
                }

                return pointPosition;
            }

            public void RemoveAt(int index)
            {
                // remove the vertex and compact the array
                for (int i = index; i < numVertices - 1; i++)
                {
                    vertexData[i] = vertexData[i + 1];
                }

                // remove the last vertex
                numVertices--;
            }
        }

        private int iteratorIndex;
        private VertexDataManager vertexDataManager;

        public VertexStorage()
        {
            vertexDataManager = new VertexDataManager();
        }

        public VertexStorage(string svgDString)
            : this()
        {
            SvgDString = svgDString;
        }

        public VertexStorage(IVertexSource copyFrom)
            : this()
        {
            if (copyFrom != null)
            {
                foreach (var vertex in copyFrom.Vertices())
                {
                    this.Add(vertex.X, vertex.Y, vertex.Command, vertex.Hint);
                }
            }
        }

        [JsonIgnore]
        public int Count
        {
            get
            {
                return vertexDataManager.TotalVertices();
            }
        }

        public ulong GetLongHashCode(ulong hash = 14695981039346656037)
        {
            foreach (var vertex in this.Vertices())
            {
                hash = vertex.GetLongHashCode(hash);
            }

            return hash;
        }

        /// <summary>
        /// Determines if the given point lies within, on, or outside the polygon defined by vertex data.
        /// Based on "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos.
        /// </summary>
        /// <param name="pointToCheck">The point to check.</param>
        /// <returns>
        /// 0 if point is outside the polygon,
        /// +1 if point is inside the polygon,
        /// -1 if point is on the polygon boundary.
        /// </returns>
        public int CheckPointInPolygon(Vector2 pointToCheck)
        {
            return vertexDataManager.CheckPointInPolygon(pointToCheck);
        }

        public static bool OldEqualsNewStyle(IVertexSource control, IVertexSource test, double maxError = .0001)
        {
            control.Rewind(0);
            double controlX;
            double controlY;
            FlagsAndCommand controlFlagsAndCommand = control.Vertex(out controlX, out controlY);

            int index = 0;
            foreach (VertexData vertexData in test.Vertices())
            {
                if (controlFlagsAndCommand != vertexData.Command
                    || controlX < vertexData.Position.X - maxError || controlX > vertexData.Position.X + maxError
                    || controlY < vertexData.Position.Y - maxError || controlY > vertexData.Position.Y + maxError)
                {
                    return false;
                }
                controlFlagsAndCommand = control.Vertex(out controlX, out controlY);
                index++;
            }

            if (controlFlagsAndCommand == FlagsAndCommand.Stop)
            {
                return true;
            }

            return false;
        }

        public void RemoveAt(int index)
        {
            // find out what type of point we are deleting
            var command = vertexDataManager.Command(index);
            var hint = this.GetCommandHint(index);

            switch(command)
            {
                case FlagsAndCommand.Curve3:
                    switch (hint)
                    {
                        case CommandHint.C3ControlFromPrev:
                            throw new Exception("Not implemented yet");
                            break;
                        
                        case CommandHint.C3Point:
                            throw new Exception("Not implemented yet");
                            break;

                        default:
                            throw new NotImplementedException("This sholud not happen for curve3");
                    }
                    break;

                case FlagsAndCommand.Curve4:
                    switch (hint)
                    {
                        case CommandHint.C4ControlFromPrev:
                            throw new Exception("Not implemented yet");
                            break;

                        case CommandHint.C4ControlToPoint:
                            throw new Exception("Not implemented yet");
                            break;

                        case CommandHint.C4Point:
                            throw new Exception("Not implemented yet");
                            break;

                        default:
                            throw new NotImplementedException("This sholud not happen for curve4");
                    }
                    break;

                case FlagsAndCommand.LineTo:
                    // delete the vertex
                    vertexDataManager.RemoveAt(index);
                    break;

                case FlagsAndCommand.MoveTo:
                    vertexDataManager.RemoveAt(index);
                    break;

                case FlagsAndCommand.EndPoly:
                    throw new Exception("Not implemented yet");
                    break;

                case FlagsAndCommand.FlagClose:
                case FlagsAndCommand.FlagClose | FlagsAndCommand.CommandsMask:
                    vertexDataManager.RemoveAt(index);
                    break;

                default:
                    throw new NotImplementedException("Add this case and test it");
            }
        }

        public static bool OldEqualsOldStyle(IVertexSource control, IVertexSource test, double maxError = .0001)
        {
            control.Rewind(0);
            double controlX;
            double controlY;
            FlagsAndCommand controlFlagsAndCommand = control.Vertex(out controlX, out controlY);

            test.Rewind(0);
            double testX;
            double testY;
            FlagsAndCommand otherFlagsAndCommand = test.Vertex(out testX, out testY);

            int index = 1;
            if (controlFlagsAndCommand == otherFlagsAndCommand && controlX == testX && Util.is_equal_eps(controlY, testY, .000000001))
            {
                while (controlFlagsAndCommand != FlagsAndCommand.Stop)
                {
                    controlFlagsAndCommand = control.Vertex(out controlX, out controlY);
                    otherFlagsAndCommand = test.Vertex(out testX, out testY);
                    if (controlFlagsAndCommand != otherFlagsAndCommand
                        || controlX < testX - maxError || controlX > testX + maxError
                        || controlY < testY - maxError || controlY > testY + maxError)
                    {
                        return false;
                    }

                    index++;
                }

                return true;
            }

            return false;
        }

        public void Add(Vector2 vertex)
        {
            throw new System.NotImplementedException();
        }

        public void Add(double x, double y, FlagsAndCommand flagsAndCommand, CommandHint hint = CommandHint.None)
        {
            vertexDataManager.AddVertex(x, y, flagsAndCommand, hint);
        }

        public int ArrangeOrientations(int start, FlagsAndCommand orientation)
        {
            if (orientation != FlagsAndCommand.FlagNone)
            {
                while (start < vertexDataManager.TotalVertices())
                {
                    start = ArrangePolygonOrientation(start, orientation);
                    if (ShapePath.IsStop(vertexDataManager.Command(start)))
                    {
                        ++start;
                        break;
                    }
                }
            }

            return start;
        }

        public void ArrangeOrientationsAllPaths(FlagsAndCommand orientation)
        {
            if (orientation != FlagsAndCommand.FlagNone)
            {
                int start = 0;
                while (start < vertexDataManager.TotalVertices())
                {
                    start = ArrangeOrientations(start, orientation);
                }
            }
        }

        // Arrange the orientation of a polygon, all polygons in a path,
        // or in all paths. After calling arrange_orientations() or
        // arrange_orientations_all_paths(), all the polygons will have
        // the same orientation, i.e. path_flags_cw or path_flags_ccw
        //--------------------------------------------------------------------
        public int ArrangePolygonOrientation(int start, FlagsAndCommand orientation)
        {
            if (orientation == FlagsAndCommand.FlagNone) return start;

            // Skip all non-vertices at the beginning
            while (start < vertexDataManager.TotalVertices() &&
                  !ShapePath.IsVertex(vertexDataManager.Command(start))) ++start;

            // Skip all insignificant move_to
            while (start + 1 < vertexDataManager.TotalVertices() &&
                  ShapePath.IsMoveTo(vertexDataManager.Command(start)) &&
                  ShapePath.IsMoveTo(vertexDataManager.Command(start + 1))) ++start;

            // Find the last vertex
            int end = start + 1;
            while (end < vertexDataManager.TotalVertices() &&
                  !ShapePath.IsNextPoly(vertexDataManager.Command(end))) ++end;

            if (end - start > 2)
            {
                if (PerceivePolygonOrientation(start, end) != orientation)
                {
                    // Invert polygon, set orientation flag, and skip all end_poly
                    InvertPolygon(start, end);
                    FlagsAndCommand PathAndFlags;
                    while (end < vertexDataManager.TotalVertices() &&
                          ShapePath.is_end_poly(PathAndFlags = vertexDataManager.Command(end)))
                    {
                        vertexDataManager.ModifyCommand(end++, PathAndFlags | orientation);// Path.set_orientation(cmd, orientation));
                    }
                }
            }

            return end;
        }

        public void ClosePolygon(FlagsAndCommand flags)
        {
            EndPoly(FlagsAndCommand.FlagClose | flags);
        }

        public void ClosePolygon()
        {
            ClosePolygon(FlagsAndCommand.FlagNone);
        }

        public FlagsAndCommand Command(int index)
        {
            return vertexDataManager.Command(index);
        }

        // Concatenate path. The path is added as is.
        public void ConcatPath(IVertexSource vs)
        {
            ConcatPath(vs, 0);
        }

        public void ConcatPath(IVertexSource vs, int path_id)
        {
            double x, y;
            FlagsAndCommand PathAndFlags;
            vs.Rewind(path_id);
            while (!ShapePath.IsStop(PathAndFlags = vs.Vertex(out x, out y)))
            {
                vertexDataManager.AddVertex(x, y, PathAndFlags);
            }
        }

        /// <summary>
        /// Draws a quadratic Bzier curve from the current point to the target point using the supplied control point.
        /// </summary>
        /// <param name="controlPoint">The control point</param>
        /// <param name="point">The new target point</param>
        public void Curve3(Vector2 controlPoint, Vector2 point)
        {
            Curve3(controlPoint.X, controlPoint.Y, point.X, point.Y);
        }

        /// <summary>
        /// Draws a quadratic Bzier curve from the current point to (x,y) using (xControl,yControl) as the control point.
        /// </summary>
        /// <param name="xControl"></param>
        /// <param name="yControl"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        public void Curve3(double xControl, double yControl, double x, double y)
        {
            vertexDataManager.AddVertex(xControl, yControl, FlagsAndCommand.Curve3);
            vertexDataManager.AddVertex(x, y, FlagsAndCommand.Curve3);
        }

        /// <summary>
        /// <para>Draws a quadratic Bzier curve from the current point to (x,y).</para>
        /// <para>The control point is assumed to be the reflection of the control point on the previous command relative to the current point.</para>
        /// <para>(If there is no previous command or if the previous command was not a curve, assume the control point is coincident with the current point.)</para>
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        public void Curve3(double x, double y)
        {
            double x0;
            double y0;
            if (ShapePath.IsVertex(vertexDataManager.LastVertex(out x0, out y0)))
            {
                double x_ctrl;
                double y_ctrl;
                FlagsAndCommand cmd = vertexDataManager.PrevVertex(out x_ctrl, out y_ctrl);
                if (ShapePath.IsCurve(cmd))
                {
                    x_ctrl = x0 + x0 - x_ctrl;
                    y_ctrl = y0 + y0 - y_ctrl;
                }
                else
                {
                    x_ctrl = x0;
                    y_ctrl = y0;
                }
                Curve3(x_ctrl, y_ctrl, x, y);
            }
        }

        /// <summary>
        /// Draws a quadratic Bzier curve from the current point to (x,y) using (xControl,yControl) as the control point.
        /// </summary>
        /// <param name="xControl"></param>
        /// <param name="yControl"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        public void Curve3Rel(double dx_ctrl, double dy_ctrl, double dx_to, double dy_to)
        {
            RelToAbs(ref dx_ctrl, ref dy_ctrl);
            RelToAbs(ref dx_to, ref dy_to);
            vertexDataManager.AddVertex(dx_ctrl, dy_ctrl, FlagsAndCommand.Curve3);
            vertexDataManager.AddVertex(dx_to, dy_to, FlagsAndCommand.Curve3);
        }

        /// <summary>
        /// <para>Draws a quadratic Bzier curve from the current point to (x,y).</para>
        /// <para>The control point is assumed to be the reflection of the control point on the previous command relative to the current point.</para>
        /// <para>(If there is no previous command or if the previous command was not a curve, assume the control point is coincident with the current point.)</para>
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        public void Curve3Rel(double dx_to, double dy_to)
        {
            RelToAbs(ref dx_to, ref dy_to);
            Curve3(dx_to, dy_to);
        }

        public void Curve4(double controlFromPrevX, double controlFromPrevY,
                                   double controlToPointX, double controlToPointY,
                                   double pointX, double pointY)
        {
            vertexDataManager.AddVertex(controlFromPrevX, controlFromPrevY, FlagsAndCommand.Curve4, CommandHint.C4ControlFromPrev);
            vertexDataManager.AddVertex(controlToPointX, controlToPointY, FlagsAndCommand.Curve4, CommandHint.C4ControlToPoint);
            vertexDataManager.AddVertex(pointX, pointY, FlagsAndCommand.Curve4, CommandHint.C4Point);
        }

        public void Curve4(Vector2 controlFromPrev, Vector2 controlToPoint, Vector2 point)
        {
            Curve4(controlFromPrev.X, controlFromPrev.Y, controlToPoint.X, controlToPoint.Y, point.X, point.Y);
        }

        public void Curve4(double controlToPointX, double controlToPointY, double pointX, double pointY)
        {
            double lastX;
            double lastY;
            if (ShapePath.IsVertex(LastVertex(out lastX, out lastY)))
            {
                double controlFromPrevX;
                double controlFromPrevY;
                FlagsAndCommand prevVertex = PrevVertex(out controlFromPrevX, out controlFromPrevY);
                if (ShapePath.IsCurve(prevVertex))
                {
                    controlFromPrevX = lastX + lastX - controlFromPrevX;
                    controlFromPrevY = lastY + lastY - controlFromPrevY;
                }
                else
                {
                    controlFromPrevX = lastX;
                    controlFromPrevY = lastY;
                }
                Curve4(controlFromPrevX, controlFromPrevY, controlToPointX, controlToPointY, pointX, pointY);
            }
        }

        public void Curve4(Vector2 controlToPoint, Vector2 point)
        {
            Curve4(controlToPoint.X, controlToPoint.Y, point.X, point.Y);
        }

        public void Curve4Rel(double dx_ctrl1, double dy_ctrl1,
                                       double dx_ctrl2, double dy_ctrl2,
                                       double dx_to, double dy_to)
        {
            RelToAbs(ref dx_ctrl1, ref dy_ctrl1);
            RelToAbs(ref dx_ctrl2, ref dy_ctrl2);
            RelToAbs(ref dx_to, ref dy_to);
            vertexDataManager.AddVertex(dx_ctrl1, dy_ctrl1, FlagsAndCommand.Curve4);
            vertexDataManager.AddVertex(dx_ctrl2, dy_ctrl2, FlagsAndCommand.Curve4);
            vertexDataManager.AddVertex(dx_to, dy_to, FlagsAndCommand.Curve4);
        }

        public void Curve4Rel(double dx_ctrl2, double dy_ctrl2,
                                       double dx_to, double dy_to)
        {
            RelToAbs(ref dx_ctrl2, ref dy_ctrl2);
            RelToAbs(ref dx_to, ref dy_to);
            Curve4(dx_ctrl2, dy_ctrl2, dx_to, dy_to);
        }

        public void EndPoly()
        {
            ClosePolygon(FlagsAndCommand.FlagClose);
        }

        public void EndPoly(FlagsAndCommand flags)
        {
            if (ShapePath.IsVertex(vertexDataManager.LastCommand()))
            {
                vertexDataManager.AddVertex(0.0, 0.0, FlagsAndCommand.EndPoly | flags);
            }
        }

        public bool Equals(IVertexSource other, double maxError = .0001, bool oldStyle = true)
        {
            if (oldStyle)
            {
                return OldEqualsOldStyle(this, other, maxError);
            }
            else
            {
                return OldEqualsNewStyle(this, other, maxError);
            }
        }

        // Flip all vertices horizontally or vertically,
        // between x1 and x2, or between y1 and y2 respectively
        //--------------------------------------------------------------------
        public void FlipX(double x1, double x2)
        {
            for (int i = 0; i < vertexDataManager.TotalVertices(); i++)
            {
                FlagsAndCommand PathAndFlags = vertexDataManager.Vertex(i, out double x, out double y);
                if (ShapePath.IsVertex(PathAndFlags))
                {
                    vertexDataManager.ModifyVertex(i, x2 - x + x1, y);
                }
            }
        }

        public void FlipY(double y1, double y2)
        {
            for (int i = 0; i < vertexDataManager.TotalVertices(); i++)
            {
                FlagsAndCommand PathAndFlags = vertexDataManager.Vertex(i, out double x, out double y);
                if (ShapePath.IsVertex(PathAndFlags))
                {
                    vertexDataManager.ModifyVertex(i, x, y2 - y + y1);
                }
            }
        }

        public void FreeAll()
        {
            vertexDataManager.free_all(); iteratorIndex = 0;
        }

        public double GetLastX()
        {
            return vertexDataManager.last_x();
        }

        public double GetLastY()
        {
            return vertexDataManager.LastY();
        }

        public void HorizontalLineTo(double x)
        {
            vertexDataManager.AddVertex(x, GetLastY(), FlagsAndCommand.LineTo);
        }

        public void InvertPolygon(int start)
        {
            // Skip all non-vertices at the beginning
            while (start < vertexDataManager.TotalVertices() &&
                  !ShapePath.IsVertex(vertexDataManager.Command(start))) ++start;

            // Skip all insignificant move_to
            while (start + 1 < vertexDataManager.TotalVertices() &&
                  ShapePath.IsMoveTo(vertexDataManager.Command(start)) &&
                  ShapePath.IsMoveTo(vertexDataManager.Command(start + 1))) ++start;

            // Find the last vertex
            int end = start + 1;
            while (end < vertexDataManager.TotalVertices() &&
                  !ShapePath.IsNextPoly(vertexDataManager.Command(end))) ++end;

            InvertPolygon(start, end);
        }

        //--------------------------------------------------------------------
        // Join path. The path is joined with the existing one, that is,
        // it behaves as if the pen of a plotter was always down (drawing)
        //template<class VertexSource>
        public void JoinPath(VertexStorage vs)
        {
            JoinPath(vs, 0);
        }

        public void JoinPath(VertexStorage vs, int path_id)
        {
            double x, y;
            vs.Rewind(path_id);
            FlagsAndCommand PathAndFlags = vs.Vertex(out x, out y);
            if (!ShapePath.IsStop(PathAndFlags))
            {
                if (ShapePath.IsVertex(PathAndFlags))
                {
                    double x0, y0;
                    FlagsAndCommand PathAndFlags0 = LastVertex(out x0, out y0);
                    if (ShapePath.IsVertex(PathAndFlags0))
                    {
                        if (agg_math.CalcDistance(x, y, x0, y0) > agg_math.vertex_dist_epsilon)
                        {
                            if (ShapePath.IsMoveTo(PathAndFlags)) PathAndFlags = FlagsAndCommand.LineTo;
                            vertexDataManager.AddVertex(x, y, PathAndFlags);
                        }
                    }
                    else
                    {
                        if (ShapePath.IsStop(PathAndFlags0))
                        {
                            PathAndFlags = FlagsAndCommand.MoveTo;
                        }
                        else
                        {
                            if (ShapePath.IsMoveTo(PathAndFlags)) PathAndFlags = FlagsAndCommand.LineTo;
                        }
                        vertexDataManager.AddVertex(x, y, PathAndFlags);
                    }
                }
                while (!ShapePath.IsStop(PathAndFlags = vs.Vertex(out x, out y)))
                {
                    vertexDataManager.AddVertex(x, y, ShapePath.IsMoveTo(PathAndFlags) ?
                                                    FlagsAndCommand.LineTo :
                                                    PathAndFlags);
                }
            }
        }

        public FlagsAndCommand LastVertex(out double x, out double y)
        {
            return vertexDataManager.LastVertex(out x, out y);
        }

        public void LineTo(Point2D position)
        {
            LineTo(position.x, position.y);
        }

        public void LineTo(Vector2 position)
        {
            LineTo(position.X, position.Y);
        }

        public void LineTo(double x, double y)
        {
            vertexDataManager.AddVertex(x, y, FlagsAndCommand.LineTo);
        }

        public void ModifyCommand(int index, FlagsAndCommand PathAndFlags)
        {
            vertexDataManager.ModifyCommand(index, PathAndFlags);
        }

        public void ModifyVertex(int index, double x, double y)
        {
            vertexDataManager.ModifyVertex(index, x, y);
        }

        public void ModifyVertex(int index, double x, double y, FlagsAndCommand PathAndFlags)
        {
            vertexDataManager.ModifyVertex(index, x, y, PathAndFlags);
        }

        public void MoveTo(Vector2 position)
        {
            MoveTo(position.X, position.Y);
        }

        public void MoveTo(double x, double y)
        {
            vertexDataManager.AddVertex(x, y, FlagsAndCommand.MoveTo);
        }

        public string SvgDString
        {
            get
            {
                return this.SvgDString();
            }

            set
            {
                this.ParseSvgDString(value);
            }
        }

        public FlagsAndCommand PrevVertex(out double x, out double y)
        {
            return vertexDataManager.PrevVertex(out x, out y);
        }

        public void RelToAbs(ref double x, ref double y)
        {
            if (vertexDataManager.TotalVertices() != 0)
            {
                double x2;
                double y2;
                if (ShapePath.IsVertex(vertexDataManager.LastVertex(out x2, out y2)))
                {
                    x += x2;
                    y += y2;
                }
            }
        }

        public void Clear()
        {
            vertexDataManager.Clear();
            iteratorIndex = 0;
        }

        public virtual void Rewind(int pathId)
        {
            iteratorIndex = pathId;
        }

        public void ShareVertexData(VertexStorage pathStorageToShareFrom)
        {
            vertexDataManager = pathStorageToShareFrom.vertexDataManager;
        }

        // Make path functions
        //--------------------------------------------------------------------
        public int StartNewPath()
        {
            if (!ShapePath.IsStop(vertexDataManager.LastCommand()))
            {
                vertexDataManager.AddVertex(0.0, 0.0, FlagsAndCommand.Stop);
            }
            return vertexDataManager.TotalVertices();
        }

        public int TotalVertices()
        {
            return vertexDataManager.TotalVertices();
        }

        //--------------------------------------------------------------------
        public void Transform(Transform.Affine trans)
        {
            Transform(trans, 0);
        }

        public void Transform(Transform.Affine trans, int path_id)
        {
            int num_ver = vertexDataManager.TotalVertices();
            for (; path_id < num_ver; path_id++)
            {
                double x, y;
                FlagsAndCommand PathAndFlags = vertexDataManager.Vertex(path_id, out x, out y);
                if (ShapePath.IsStop(PathAndFlags)) break;
                if (ShapePath.IsVertex(PathAndFlags))
                {
                    trans.Transform(ref x, ref y);
                    vertexDataManager.ModifyVertex(path_id, x, y);
                }
            }
        }

        //--------------------------------------------------------------------
        public void TransformAllPaths(Transform.Affine trans)
        {
            int index;
            int num_ver = vertexDataManager.TotalVertices();
            for (index = 0; index < num_ver; index++)
            {
                double x, y;
                if (ShapePath.IsVertex(vertexDataManager.Vertex(index, out x, out y)))
                {
                    trans.Transform(ref x, ref y);
                    vertexDataManager.ModifyVertex(index, x, y);
                }
            }
        }

        //--------------------------------------------------------------------
        public void Translate(double dx, double dy)
        {
            Translate(dx, dy, 0);
        }

        public void Translate(double dx, double dy, int path_id)
        {
            int num_ver = vertexDataManager.TotalVertices();
            for (; path_id < num_ver; path_id++)
            {
                double x, y;
                FlagsAndCommand PathAndFlags = vertexDataManager.Vertex(path_id, out x, out y);
                if (ShapePath.IsStop(PathAndFlags)) break;
                if (ShapePath.IsVertex(PathAndFlags))
                {
                    x += dx;
                    y += dy;
                    vertexDataManager.ModifyVertex(path_id, x, y);
                }
            }
        }

        public void TranslateAllPaths(double dx, double dy)
        {
            int index;
            int num_ver = vertexDataManager.TotalVertices();
            for (index = 0; index < num_ver; index++)
            {
                double x, y;
                if (ShapePath.IsVertex(vertexDataManager.Vertex(index, out x, out y)))
                {
                    x += dx;
                    y += dy;
                    vertexDataManager.ModifyVertex(index, x, y);
                }
            }
        }

        public VertexData this[int index]
        {
            get => vertexDataManager[index];
            set => vertexDataManager[index] = value;
        }

        public FlagsAndCommand Vertex(int index, out double x, out double y)
        {
            return vertexDataManager.Vertex(index, out x, out y);
        }

        public FlagsAndCommand Vertex(out double x, out double y)
        {
            if (iteratorIndex >= vertexDataManager.TotalVertices())
            {
                x = 0;
                y = 0;
                return FlagsAndCommand.Stop;
            }

            return vertexDataManager.Vertex(iteratorIndex++, out x, out y);
        }

        public void VerticalLineTo(double y)
        {
            vertexDataManager.AddVertex(GetLastX(), y, FlagsAndCommand.LineTo);
        }

        public IEnumerable<VertexData> Vertices()
        {
            int count = vertexDataManager.TotalVertices();
            for (int i = 0; i < count; i++)
            {
                yield return vertexDataManager[i];
            }

            yield return new VertexData(FlagsAndCommand.Stop, new Vector2(0, 0));
        }

        private void InvertPolygon(int start, int end)
        {
            int i;
            FlagsAndCommand tmp_PathAndFlags = vertexDataManager.Command(start);

            --end; // Make "end" inclusive

            // Shift all commands to one position
            for (i = start; i < end; i++)
            {
                vertexDataManager.ModifyCommand(i, vertexDataManager.Command(i + 1));
            }

            // Assign starting command to the ending command
            vertexDataManager.ModifyCommand(end, tmp_PathAndFlags);

            // Reverse the polygon
            while (end > start)
            {
                vertexDataManager.SwapVertices(start++, end--);
            }
        }

        private FlagsAndCommand PerceivePolygonOrientation(int start, int end)
        {
            // Calculate signed area (double area to be exact)
            //---------------------
            int np = end - start;
            double area = 0.0;
            int i;
            for (i = 0; i < np; i++)
            {
                double x1, y1, x2, y2;
                vertexDataManager.Vertex(start + i, out x1, out y1);
                vertexDataManager.Vertex(start + (i + 1) % np, out x2, out y2);
                area += x1 * y2 - y1 * x2;
            }
            return (area < 0.0) ? FlagsAndCommand.FlagCW : FlagsAndCommand.FlagCCW;
        }
    }
}

